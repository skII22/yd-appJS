(window.webpackJsonp = window.webpackJsonp || []).push([[0], []]);
!function(n) {
    function e(e) {
        for (var a, o, l = e[0], s = e[1], c = e[2], u = 0, m = []; u < l.length; u++)
            o = l[u],
            Object.prototype.hasOwnProperty.call(i, o) && i[o] && m.push(i[o][0]),
            i[o] = 0;
        for (a in s)
            Object.prototype.hasOwnProperty.call(s, a) && (n[a] = s[a]);
        for (d && d(e); m.length; )
            m.shift()();
        return r.push.apply(r, c || []),
        t()
    }
    function t() {
        for (var n, e = 0; e < r.length; e++) {
            for (var t = r[e], a = !0, l = 1; l < t.length; l++) {
                var s = t[l];
                0 !== i[s] && (a = !1)
            }
            a && (r.splice(e--, 1),
            n = o(o.s = t[0]))
        }
        return n
    }
    var a = {}
      , i = {
        1: 0
    }
      , r = [];
    function o(e) {
        if (a[e])
            return a[e].exports;
        var t = a[e] = {
            i: e,
            l: !1,
            exports: {}
        };
        return n[e].call(t.exports, t, t.exports, o),
        t.l = !0,
        t.exports
    }
    o.e = function(n) {
        var e = []
          , t = i[n];
        if (0 !== t)
            if (t)
                e.push(t[2]);
            else {
                var a = new Promise((function(e, a) {
                    t = i[n] = [e, a]
                }
                ));
                e.push(t[2] = a);
                var r, l = document.createElement("script");
                l.charset = "utf-8",
                l.timeout = 120,
                o.nc && l.setAttribute("nonce", o.nc),
                l.src = function(n) {
                    return o.p + "assets/js/" + ({}[n] || n) + "." + {
                        2: "063dd65b",
                        3: "156cb25c",
                        4: "6173b67f",
                        5: "d8756f31",
                        6: "7c978b15",
                        7: "62256554",
                        8: "2a73e5cc",
                        9: "f6246539",
                        10: "353f6006",
                        11: "b83f8368",
                        12: "7734e8cb",
                        13: "173094fc",
                        14: "16305e8c",
                        15: "49f6cc6b",
                        16: "a23edb21",
                        17: "5bebf640",
                        18: "215c0419",
                        19: "5b243455",
                        20: "123e5659",
                        21: "14247e76",
                        22: "97f55206",
                        23: "7512c371",
                        24: "d6aeaa14",
                        25: "c1097644",
                        26: "7bc0e9cf",
                        27: "94ac3127",
                        28: "330af1c9",
                        29: "1deb0834",
                        30: "15a703c4",
                        31: "f9ba7ed4",
                        32: "4e2b2419",
                        33: "baee8535",
                        34: "102807b0",
                        35: "518d28c0",
                        36: "9d55d0fb",
                        37: "7498424f",
                        38: "6ce9b839",
                        39: "2e4b4c60",
                        40: "18303eea",
                        41: "45095a26",
                        42: "0303b9f3",
                        43: "2490a3bc",
                        44: "6c5956d2",
                        45: "d6ceebc8",
                        46: "d9738980",
                        47: "d244d86d",
                        48: "c07c0f26",
                        49: "c93d3c24",
                        50: "a2a05de6",
                        51: "da549076",
                        52: "c5c0be6b",
                        53: "e939b42e",
                        54: "f822c517",
                        55: "c130dd42",
                        56: "a7a4c829",
                        57: "9a460a9a",
                        58: "866f8a18",
                        59: "156c3882",
                        60: "7b53c08c",
                        61: "b23b5c20",
                        62: "bbe68590",
                        63: "cc244fbd",
                        64: "86bc76b9",
                        65: "9ebd7446",
                        66: "998e79d5",
                        67: "65adbad2",
                        68: "f50f4f8e",
                        69: "68dfd959",
                        70: "8ebe43a0",
                        71: "33a46330",
                        72: "79740ce0",
                        73: "416ef7fd",
                        74: "ddbf66fa",
                        75: "fc00041b",
                        76: "c939ca27",
                        77: "e59f95f4",
                        78: "362822fc",
                        79: "fd2977d1",
                        80: "6309e95d",
                        81: "799b5863",
                        82: "0dab236b",
                        83: "2b2e4931",
                        84: "28f1c2ad",
                        85: "311dadb0",
                        86: "896250d2",
                        87: "72be5675",
                        88: "34b1dfd5",
                        89: "f1eb08b9",
                        90: "d3ed2c1f",
                        91: "30a0fe51",
                        92: "658f524c",
                        93: "598f2aca",
                        94: "7b4f0418",
                        95: "9b4c1c9b",
                        96: "03ead8d7",
                        97: "aba0288d",
                        98: "efa1b443",
                        99: "9be31f97",
                        100: "5a6fd11c",
                        101: "90f69426",
                        102: "cf0463c1",
                        103: "78088ded",
                        104: "60588556",
                        105: "bd54eda1",
                        106: "eb74ea67",
                        107: "27659aa5",
                        108: "552dd4ba",
                        109: "166618ee",
                        110: "7e48a20c",
                        111: "56803d60",
                        112: "52ff5880",
                        113: "68642aa3",
                        114: "7861751e",
                        115: "229eb961",
                        116: "3d46df80",
                        117: "ba2924d8",
                        118: "15aefea7",
                        119: "154ddd8c",
                        120: "03e2827f",
                        121: "a9d73112",
                        122: "bc2d6905",
                        123: "ecea6ee5",
                        124: "2247956d",
                        125: "c200f9bc",
                        126: "2e7bbd02",
                        127: "745bf2c7",
                        128: "bef6ecdf",
                        129: "a24555c8",
                        130: "8631eac0",
                        131: "dd308788",
                        132: "da67473d",
                        133: "ae8710d8",
                        134: "ec894df7",
                        135: "20a2f32c",
                        136: "9841f6c5",
                        137: "37c41a19",
                        138: "40b9e902",
                        139: "4b252e0a",
                        140: "c5c59c98",
                        141: "681905c9",
                        142: "e197c2a2",
                        143: "dd01d8b7",
                        144: "1c17557b",
                        145: "67136d9d",
                        146: "f2b150ec",
                        147: "fa9734d8",
                        148: "900d1d90",
                        149: "3bbb66fc",
                        150: "81a5152c",
                        151: "43e0ffe9",
                        152: "a4f91fdd",
                        153: "4ea448ea",
                        154: "bec33aa8",
                        155: "e0d8567d",
                        156: "1bc2e3f4",
                        157: "2ac99e2f",
                        158: "2bc532a1",
                        159: "141c6f3a",
                        160: "c0eba962",
                        161: "682added",
                        162: "0f25a214",
                        163: "4e6b49b0",
                        164: "b33af772",
                        165: "cc79f118",
                        166: "eccd53be",
                        167: "42dd88b1",
                        168: "3c6cc0e4",
                        169: "501ef51e",
                        170: "238e7f2a",
                        171: "46002180",
                        172: "9f41a40b",
                        173: "ca18eb95",
                        174: "d4424725",
                        175: "61e220e6",
                        176: "d3a7009e",
                        177: "3026e99d",
                        178: "13867310",
                        179: "869b3e25",
                        180: "73cd0553",
                        181: "cf34c4d7",
                        182: "e4e558f1",
                        183: "bd46069b",
                        184: "08596b3d",
                        185: "27464abc",
                        186: "dc3d7a05",
                        187: "4611d31f",
                        188: "295b7f85",
                        189: "5f47e928",
                        190: "2e65f60f",
                        191: "3f73edf6",
                        192: "390182c1",
                        193: "be0d9a6c",
                        194: "4512dc86",
                        195: "2090cd85",
                        196: "fa4e40ec",
                        197: "ac45f6bc",
                        198: "368fd9e4",
                        199: "f894ce36",
                        200: "dd3c5908",
                        201: "b947a447",
                        202: "f784f291",
                        203: "0aa187ba",
                        204: "a7e3e082",
                        205: "b5ccdc60",
                        206: "6c7ece65",
                        207: "28981fd6",
                        208: "ddfcb3b2",
                        209: "4e197b2a",
                        210: "d31c26f1",
                        211: "22e5846b",
                        212: "5ccff31e",
                        213: "d765b693",
                        214: "2ab763b3",
                        215: "b4011d9e",
                        216: "b238309b",
                        217: "a8fc596c",
                        218: "05babade",
                        219: "1a5ad568",
                        220: "be072abb",
                        221: "3254e95d",
                        222: "96fefe6e",
                        223: "c3211716",
                        224: "917cda3f",
                        225: "517f5aa3",
                        226: "b244210c",
                        227: "d5c831d9",
                        228: "6cfa53c0",
                        229: "1dde6e8f",
                        230: "e7189e94",
                        231: "eb9ff63c",
                        232: "5265bb11",
                        233: "0b5227c5",
                        234: "6408dace",
                        235: "53d4956d"
                    }[n] + ".js"
                }(n);
                var s = new Error;
                r = function(e) {
                    l.onerror = l.onload = null,
                    clearTimeout(c);
                    var t = i[n];
                    if (0 !== t) {
                        if (t) {
                            var a = e && ("load" === e.type ? "missing" : e.type)
                              , r = e && e.target && e.target.src;
                            s.message = "Loading chunk " + n + " failed.\n(" + a + ": " + r + ")",
                            s.name = "ChunkLoadError",
                            s.type = a,
                            s.request = r,
                            t[1](s)
                        }
                        i[n] = void 0
                    }
                }
                ;
                var c = setTimeout((function() {
                    r({
                        type: "timeout",
                        target: l
                    })
                }
                ), 12e4);
                l.onerror = l.onload = r,
                document.head.appendChild(l)
            }
        return Promise.all(e)
    }
    ,
    o.m = n,
    o.c = a,
    o.d = function(n, e, t) {
        o.o(n, e) || Object.defineProperty(n, e, {
            enumerable: !0,
            get: t
        })
    }
    ,
    o.r = function(n) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(n, Symbol.toStringTag, {
            value: "Module"
        }),
        Object.defineProperty(n, "__esModule", {
            value: !0
        })
    }
    ,
    o.t = function(n, e) {
        if (1 & e && (n = o(n)),
        8 & e)
            return n;
        if (4 & e && "object" == typeof n && n && n.__esModule)
            return n;
        var t = Object.create(null);
        if (o.r(t),
        Object.defineProperty(t, "default", {
            enumerable: !0,
            value: n
        }),
        2 & e && "string" != typeof n)
            for (var a in n)
                o.d(t, a, function(e) {
                    return n[e]
                }
                .bind(null, a));
        return t
    }
    ,
    o.n = function(n) {
        var e = n && n.__esModule ? function() {
            return n.default
        }
        : function() {
            return n
        }
        ;
        return o.d(e, "a", e),
        e
    }
    ,
    o.o = function(n, e) {
        return Object.prototype.hasOwnProperty.call(n, e)
    }
    ,
    o.p = "/",
    o.oe = function(n) {
        throw console.error(n),
        n
    }
    ;
    var l = window.webpackJsonp = window.webpackJsonp || []
      , s = l.push.bind(l);
    l.push = e,
    l = l.slice();
    for (var c = 0; c < l.length; c++)
        e(l[c]);
    var d = s;
    r.push([105, 0]),
    t()
}([function(n, e, t) {
    "use strict";
    var a = t(55)
      , i = a.all;
    n.exports = a.IS_HTMLDDA ? function(n) {
        return "function" == typeof n || n === i
    }
    : function(n) {
        return "function" == typeof n
    }
}
, function(n, e, t) {
    "use strict";
    var a = function(n) {
        return n && n.Math === Math && n
    };
    n.exports = a("object" == typeof globalThis && globalThis) || a("object" == typeof window && window) || a("object" == typeof self && self) || a("object" == typeof global && global) || function() {
        return this
    }() || this || Function("return this")()
}
, function(n, e, t) {
    "use strict";
    var a = t(27)
      , i = Function.prototype
      , r = i.call
      , o = a && i.bind.bind(r, r);
    n.exports = a ? o : function(n) {
        return function() {
            return r.apply(n, arguments)
        }
    }
}
, function(n, e, t) {
    "use strict";
    n.exports = function(n) {
        try {
            return !!n()
        } catch (n) {
            return !0
        }
    }
}
, function(n, e, t) {
    "use strict";
    var a = t(3);
    n.exports = !a((function() {
        return 7 !== Object.defineProperty({}, 1, {
            get: function() {
                return 7
            }
        })[1]
    }
    ))
}
, function(n, e) {
    var t = Array.isArray;
    n.exports = t
}
, function(n, e, t) {
    var a = t(69)
      , i = "object" == typeof self && self && self.Object === Object && self
      , r = a || i || Function("return this")();
    n.exports = r
}
, function(n, e, t) {
    "use strict";
    function a(n, e, t, a, i, r, o, l) {
        var s, c = "function" == typeof n ? n.options : n;
        if (e && (c.render = e,
        c.staticRenderFns = t,
        c._compiled = !0),
        a && (c.functional = !0),
        r && (c._scopeId = "data-v-" + r),
        o ? (s = function(n) {
            (n = n || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) || "undefined" == typeof __VUE_SSR_CONTEXT__ || (n = __VUE_SSR_CONTEXT__),
            i && i.call(this, n),
            n && n._registeredComponents && n._registeredComponents.add(o)
        }
        ,
        c._ssrRegister = s) : i && (s = l ? function() {
            i.call(this, (c.functional ? this.parent : this).$root.$options.shadowRoot)
        }
        : i),
        s)
            if (c.functional) {
                c._injectStyles = s;
                var d = c.render;
                c.render = function(n, e) {
                    return s.call(e),
                    d(n, e)
                }
            } else {
                var u = c.beforeCreate;
                c.beforeCreate = u ? [].concat(u, s) : [s]
            }
        return {
            exports: n,
            options: c
        }
    }
    t.d(e, "a", (function() {
        return a
    }
    ))
}
, function(n, e, t) {
    "use strict";
    var a = t(2)
      , i = t(32)
      , r = a({}.hasOwnProperty);
    n.exports = Object.hasOwn || function(n, e) {
        return r(i(n), e)
    }
}
, function(n, e, t) {
    "use strict";
    var a = t(0)
      , i = t(55)
      , r = i.all;
    n.exports = i.IS_HTMLDDA ? function(n) {
        return "object" == typeof n ? null !== n : a(n) || n === r
    }
    : function(n) {
        return "object" == typeof n ? null !== n : a(n)
    }
}
, function(n, e, t) {
    var a = t(163)
      , i = t(166);
    n.exports = function(n, e) {
        var t = i(n, e);
        return a(t) ? t : void 0
    }
}
, function(n, e, t) {
    "use strict";
    t.d(e, "e", (function() {
        return a
    }
    )),
    t.d(e, "b", (function() {
        return r
    }
    )),
    t.d(e, "j", (function() {
        return o
    }
    )),
    t.d(e, "g", (function() {
        return s
    }
    )),
    t.d(e, "h", (function() {
        return c
    }
    )),
    t.d(e, "i", (function() {
        return d
    }
    )),
    t.d(e, "c", (function() {
        return u
    }
    )),
    t.d(e, "f", (function() {
        return m
    }
    )),
    t.d(e, "l", (function() {
        return p
    }
    )),
    t.d(e, "m", (function() {
        return h
    }
    )),
    t.d(e, "d", (function() {
        return _
    }
    )),
    t.d(e, "k", (function() {
        return v
    }
    )),
    t.d(e, "n", (function() {
        return b
    }
    )),
    t.d(e, "a", (function() {
        return E
    }
    ));
    t(16);
    const a = /#.*$/
      , i = /\.(md|html)$/
      , r = /\/$/
      , o = /^[a-z]+:/i;
    function l(n) {
        return decodeURI(n).replace(a, "").replace(i, "")
    }
    function s(n) {
        return o.test(n)
    }
    function c(n) {
        return /^mailto:/.test(n)
    }
    function d(n) {
        return /^tel:/.test(n)
    }
    function u(n) {
        if (s(n))
            return n;
        if (!n)
            return "404";
        const e = n.match(a)
          , t = e ? e[0] : ""
          , i = l(n);
        return r.test(i) ? n : i + ".html" + t
    }
    function m(n, e) {
        const t = n.hash
          , i = function(n) {
            const e = n && n.match(a);
            if (e)
                return e[0]
        }(e);
        if (i && t !== i)
            return !1;
        return l(n.path) === l(e)
    }
    function p(n, e, t) {
        if (s(e))
            return {
                type: "external",
                path: e
            };
        t && (e = function(n, e, t) {
            const a = n.charAt(0);
            if ("/" === a)
                return n;
            if ("?" === a || "#" === a)
                return e + n;
            const i = e.split("/");
            t && i[i.length - 1] || i.pop();
            const r = n.replace(/^\//, "").split("/");
            for (let n = 0; n < r.length; n++) {
                const e = r[n];
                ".." === e ? i.pop() : "." !== e && i.push(e)
            }
            "" !== i[0] && i.unshift("");
            return i.join("/")
        }(e, t));
        const a = l(e);
        for (let e = 0; e < n.length; e++)
            if (l(n[e].regularPath) === a)
                return Object.assign({}, n[e], {
                    type: "page",
                    path: u(n[e].path)
                });
        return console.error(`[vuepress] No matching page found for sidebar item "${e}"`),
        {}
    }
    function h(n, e, t, a) {
        const {pages: i, themeConfig: r} = t
          , o = a && r.locales && r.locales[a] || r;
        if ("auto" === (n.frontmatter.sidebar || o.sidebar || r.sidebar))
            return g(n);
        const l = o.sidebar || r.sidebar;
        if (l) {
            const {base: t, config: a} = function(n, e) {
                if (Array.isArray(e))
                    return {
                        base: "/",
                        config: e
                    };
                for (const a in e)
                    if (0 === (t = n,
                    /(\.html|\/)$/.test(t) ? t : t + "/").indexOf(encodeURI(a)))
                        return {
                            base: a,
                            config: e[a]
                        };
                var t;
                return {}
            }(e, l);
            return "auto" === a ? g(n) : a ? a.map(n => function n(e, t, a, i=1) {
                if ("string" == typeof e)
                    return p(t, e, a);
                if (Array.isArray(e))
                    return Object.assign(p(t, e[0], a), {
                        title: e[1]
                    });
                {
                    i > 3 && console.error("[vuepress] detected a too deep nested sidebar group.");
                    const r = e.children || [];
                    return 0 === r.length && e.path ? Object.assign(p(t, e.path, a), {
                        title: e.title
                    }) : {
                        type: "group",
                        path: e.path,
                        title: e.title,
                        sidebarDepth: e.sidebarDepth,
                        initialOpenGroupIndex: e.initialOpenGroupIndex,
                        children: r.map(e => n(e, t, a, i + 1)),
                        collapsable: !1 !== e.collapsable
                    }
                }
            }(n, i, t)) : []
        }
        return []
    }
    function g(n) {
        const e = _(n.headers || []);
        return [{
            type: "group",
            collapsable: !1,
            title: n.title,
            path: null,
            children: e.map(e => ({
                type: "auto",
                title: e.title,
                basePath: n.path,
                path: n.path + "#" + e.slug,
                children: e.children || []
            }))
        }]
    }
    function _(n) {
        let e;
        return (n = n.map(n => Object.assign({}, n))).forEach(n => {
            2 === n.level ? e = n : e && (e.children || (e.children = [])).push(n)
        }
        ),
        n.filter(n => 2 === n.level)
    }
    function v(n) {
        return Object.assign(n, {
            type: n.items && n.items.length ? "links" : "link"
        })
    }
    function b(n) {
        return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()
    }
    function f(n) {
        let e = n.frontmatter.date || n.lastUpdated || new Date
          , t = new Date(e);
        return "Invalid Date" == t && e && (t = new Date(e.replace(/-/g, "/"))),
        t.getTime()
    }
    function E(n, e) {
        return f(e) - f(n)
    }
}
, function(n, e) {
    n.exports = function(n) {
        return null != n && "object" == typeof n
    }
}
, function(n, e, t) {
    var a = t(15)
      , i = t(148)
      , r = t(149)
      , o = a ? a.toStringTag : void 0;
    n.exports = function(n) {
        return null == n ? void 0 === n ? "[object Undefined]" : "[object Null]" : o && o in Object(n) ? i(n) : r(n)
    }
}
, function(n, e, t) {
    "use strict";
    var a = t(4)
      , i = t(17)
      , r = t(35);
    n.exports = a ? function(n, e, t) {
        return i.f(n, e, r(1, t))
    }
    : function(n, e, t) {
        return n[e] = t,
        n
    }
}
, function(n, e, t) {
    var a = t(6).Symbol;
    n.exports = a
}
, function(n, e, t) {
    "use strict";
    var a = t(26)
      , i = t(32)
      , r = t(33)
      , o = t(128)
      , l = t(130);
    a({
        target: "Array",
        proto: !0,
        arity: 1,
        forced: t(3)((function() {
            return 4294967297 !== [].push.call({
                length: 4294967296
            }, 1)
        }
        )) || !function() {
            try {
                Object.defineProperty([], "length", {
                    writable: !1
                }).push()
            } catch (n) {
                return n instanceof TypeError
            }
        }()
    }, {
        push: function(n) {
            var e = i(this)
              , t = r(e)
              , a = arguments.length;
            l(t + a);
            for (var s = 0; s < a; s++)
                e[t] = arguments[s],
                t++;
            return o(e, t),
            t
        }
    })
}
, function(n, e, t) {
    "use strict";
    var a = t(4)
      , i = t(64)
      , r = t(100)
      , o = t(25)
      , l = t(54)
      , s = TypeError
      , c = Object.defineProperty
      , d = Object.getOwnPropertyDescriptor;
    e.f = a ? r ? function(n, e, t) {
        if (o(n),
        e = l(e),
        o(t),
        "function" == typeof n && "prototype" === e && "value"in t && "writable"in t && !t.writable) {
            var a = d(n, e);
            a && a.writable && (n[e] = t.value,
            t = {
                configurable: "configurable"in t ? t.configurable : a.configurable,
                enumerable: "enumerable"in t ? t.enumerable : a.enumerable,
                writable: !1
            })
        }
        return c(n, e, t)
    }
    : c : function(n, e, t) {
        if (o(n),
        e = l(e),
        o(t),
        i)
            try {
                return c(n, e, t)
            } catch (n) {}
        if ("get"in t || "set"in t)
            throw new s("Accessors not supported");
        return "value"in t && (n[e] = t.value),
        n
    }
}
, function(n, e, t) {
    "use strict";
    var a = t(2)
      , i = a({}.toString)
      , r = a("".slice);
    n.exports = function(n) {
        return r(i(n), 8, -1)
    }
}
, function(n, e, t) {
    var a = t(153)
      , i = t(154)
      , r = t(155)
      , o = t(156)
      , l = t(157);
    function s(n) {
        var e = -1
          , t = null == n ? 0 : n.length;
        for (this.clear(); ++e < t; ) {
            var a = n[e];
            this.set(a[0], a[1])
        }
    }
    s.prototype.clear = a,
    s.prototype.delete = i,
    s.prototype.get = r,
    s.prototype.has = o,
    s.prototype.set = l,
    n.exports = s
}
, function(n, e, t) {
    var a = t(71);
    n.exports = function(n, e) {
        for (var t = n.length; t--; )
            if (a(n[t][0], e))
                return t;
        return -1
    }
}
, function(n, e, t) {
    var a = t(10)(Object, "create");
    n.exports = a
}
, function(n, e, t) {
    var a = t(175);
    n.exports = function(n, e) {
        var t = n.__data__;
        return a(e) ? t["string" == typeof e ? "string" : "hash"] : t.map
    }
}
, function(n, e, t) {
    var a = t(45);
    n.exports = function(n) {
        if ("string" == typeof n || a(n))
            return n;
        var e = n + "";
        return "0" == e && 1 / n == -1 / 0 ? "-0" : e
    }
}
, function(n, e, t) {
    var a, i;
    /* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */
    void 0 === (i = "function" == typeof (a = function() {
        var n, e, t = {
            version: "0.2.0"
        }, a = t.settings = {
            minimum: .08,
            easing: "ease",
            positionUsing: "",
            speed: 200,
            trickle: !0,
            trickleRate: .02,
            trickleSpeed: 800,
            showSpinner: !0,
            barSelector: '[role="bar"]',
            spinnerSelector: '[role="spinner"]',
            parent: "body",
            template: '<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'
        };
        function i(n, e, t) {
            return n < e ? e : n > t ? t : n
        }
        function r(n) {
            return 100 * (-1 + n)
        }
        t.configure = function(n) {
            var e, t;
            for (e in n)
                void 0 !== (t = n[e]) && n.hasOwnProperty(e) && (a[e] = t);
            return this
        }
        ,
        t.status = null,
        t.set = function(n) {
            var e = t.isStarted();
            n = i(n, a.minimum, 1),
            t.status = 1 === n ? null : n;
            var s = t.render(!e)
              , c = s.querySelector(a.barSelector)
              , d = a.speed
              , u = a.easing;
            return s.offsetWidth,
            o((function(e) {
                "" === a.positionUsing && (a.positionUsing = t.getPositioningCSS()),
                l(c, function(n, e, t) {
                    var i;
                    return (i = "translate3d" === a.positionUsing ? {
                        transform: "translate3d(" + r(n) + "%,0,0)"
                    } : "translate" === a.positionUsing ? {
                        transform: "translate(" + r(n) + "%,0)"
                    } : {
                        "margin-left": r(n) + "%"
                    }).transition = "all " + e + "ms " + t,
                    i
                }(n, d, u)),
                1 === n ? (l(s, {
                    transition: "none",
                    opacity: 1
                }),
                s.offsetWidth,
                setTimeout((function() {
                    l(s, {
                        transition: "all " + d + "ms linear",
                        opacity: 0
                    }),
                    setTimeout((function() {
                        t.remove(),
                        e()
                    }
                    ), d)
                }
                ), d)) : setTimeout(e, d)
            }
            )),
            this
        }
        ,
        t.isStarted = function() {
            return "number" == typeof t.status
        }
        ,
        t.start = function() {
            t.status || t.set(0);
            var n = function() {
                setTimeout((function() {
                    t.status && (t.trickle(),
                    n())
                }
                ), a.trickleSpeed)
            };
            return a.trickle && n(),
            this
        }
        ,
        t.done = function(n) {
            return n || t.status ? t.inc(.3 + .5 * Math.random()).set(1) : this
        }
        ,
        t.inc = function(n) {
            var e = t.status;
            return e ? ("number" != typeof n && (n = (1 - e) * i(Math.random() * e, .1, .95)),
            e = i(e + n, 0, .994),
            t.set(e)) : t.start()
        }
        ,
        t.trickle = function() {
            return t.inc(Math.random() * a.trickleRate)
        }
        ,
        n = 0,
        e = 0,
        t.promise = function(a) {
            return a && "resolved" !== a.state() ? (0 === e && t.start(),
            n++,
            e++,
            a.always((function() {
                0 == --e ? (n = 0,
                t.done()) : t.set((n - e) / n)
            }
            )),
            this) : this
        }
        ,
        t.render = function(n) {
            if (t.isRendered())
                return document.getElementById("nprogress");
            c(document.documentElement, "nprogress-busy");
            var e = document.createElement("div");
            e.id = "nprogress",
            e.innerHTML = a.template;
            var i, o = e.querySelector(a.barSelector), s = n ? "-100" : r(t.status || 0), d = document.querySelector(a.parent);
            return l(o, {
                transition: "all 0 linear",
                transform: "translate3d(" + s + "%,0,0)"
            }),
            a.showSpinner || (i = e.querySelector(a.spinnerSelector)) && m(i),
            d != document.body && c(d, "nprogress-custom-parent"),
            d.appendChild(e),
            e
        }
        ,
        t.remove = function() {
            d(document.documentElement, "nprogress-busy"),
            d(document.querySelector(a.parent), "nprogress-custom-parent");
            var n = document.getElementById("nprogress");
            n && m(n)
        }
        ,
        t.isRendered = function() {
            return !!document.getElementById("nprogress")
        }
        ,
        t.getPositioningCSS = function() {
            var n = document.body.style
              , e = "WebkitTransform"in n ? "Webkit" : "MozTransform"in n ? "Moz" : "msTransform"in n ? "ms" : "OTransform"in n ? "O" : "";
            return e + "Perspective"in n ? "translate3d" : e + "Transform"in n ? "translate" : "margin"
        }
        ;
        var o = function() {
            var n = [];
            function e() {
                var t = n.shift();
                t && t(e)
            }
            return function(t) {
                n.push(t),
                1 == n.length && e()
            }
        }()
          , l = function() {
            var n = ["Webkit", "O", "Moz", "ms"]
              , e = {};
            function t(t) {
                return t = t.replace(/^-ms-/, "ms-").replace(/-([\da-z])/gi, (function(n, e) {
                    return e.toUpperCase()
                }
                )),
                e[t] || (e[t] = function(e) {
                    var t = document.body.style;
                    if (e in t)
                        return e;
                    for (var a, i = n.length, r = e.charAt(0).toUpperCase() + e.slice(1); i--; )
                        if ((a = n[i] + r)in t)
                            return a;
                    return e
                }(t))
            }
            function a(n, e, a) {
                e = t(e),
                n.style[e] = a
            }
            return function(n, e) {
                var t, i, r = arguments;
                if (2 == r.length)
                    for (t in e)
                        void 0 !== (i = e[t]) && e.hasOwnProperty(t) && a(n, t, i);
                else
                    a(n, r[1], r[2])
            }
        }();
        function s(n, e) {
            return ("string" == typeof n ? n : u(n)).indexOf(" " + e + " ") >= 0
        }
        function c(n, e) {
            var t = u(n)
              , a = t + e;
            s(t, e) || (n.className = a.substring(1))
        }
        function d(n, e) {
            var t, a = u(n);
            s(n, e) && (t = a.replace(" " + e + " ", " "),
            n.className = t.substring(1, t.length - 1))
        }
        function u(n) {
            return (" " + (n.className || "") + " ").replace(/\s+/gi, " ")
        }
        function m(n) {
            n && n.parentNode && n.parentNode.removeChild(n)
        }
        return t
    }
    ) ? a.call(e, t, e, n) : a) || (n.exports = i)
}
, function(n, e, t) {
    "use strict";
    var a = t(9)
      , i = String
      , r = TypeError;
    n.exports = function(n) {
        if (a(n))
            return n;
        throw new r(i(n) + " is not an object")
    }
}
, function(n, e, t) {
    "use strict";
    var a = t(1)
      , i = t(51).f
      , r = t(14)
      , o = t(96)
      , l = t(37)
      , s = t(65)
      , c = t(124);
    n.exports = function(n, e) {
        var t, d, u, m, p, h = n.target, g = n.global, _ = n.stat;
        if (t = g ? a : _ ? a[h] || l(h, {}) : (a[h] || {}).prototype)
            for (d in e) {
                if (m = e[d],
                u = n.dontCallGetSet ? (p = i(t, d)) && p.value : t[d],
                !c(g ? d : h + (_ ? "." : "#") + d, n.forced) && void 0 !== u) {
                    if (typeof m == typeof u)
                        continue;
                    s(m, u)
                }
                (n.sham || u && u.sham) && r(m, "sham", !0),
                o(t, d, m, n)
            }
    }
}
, function(n, e, t) {
    "use strict";
    var a = t(3);
    n.exports = !a((function() {
        var n = function() {}
        .bind();
        return "function" != typeof n || n.hasOwnProperty("prototype")
    }
    ))
}
, function(n, e, t) {
    "use strict";
    var a = t(47)
      , i = t(52);
    n.exports = function(n) {
        return a(i(n))
    }
}
, function(n, e, t) {
    "use strict";
    var a = t(1)
      , i = t(0)
      , r = function(n) {
        return i(n) ? n : void 0
    };
    n.exports = function(n, e) {
        return arguments.length < 2 ? r(a[n]) : a[n] && a[n][e]
    }
}
, function(n, e, t) {
    "use strict";
    var a = t(0)
      , i = t(111)
      , r = TypeError;
    n.exports = function(n) {
        if (a(n))
            return n;
        throw new r(i(n) + " is not a function")
    }
}
, function(n, e, t) {
    "use strict";
    var a = t(1)
      , i = t(61)
      , r = t(8)
      , o = t(63)
      , l = t(59)
      , s = t(58)
      , c = a.Symbol
      , d = i("wks")
      , u = s ? c.for || c : c && c.withoutSetter || o;
    n.exports = function(n) {
        return r(d, n) || (d[n] = l && r(c, n) ? c[n] : u("Symbol." + n)),
        d[n]
    }
}
, function(n, e, t) {
    "use strict";
    var a = t(52)
      , i = Object;
    n.exports = function(n) {
        return i(a(n))
    }
}
, function(n, e, t) {
    "use strict";
    var a = t(122);
    n.exports = function(n) {
        return a(n.length)
    }
}
, function(n, e, t) {
    "use strict";
    var a = t(27)
      , i = Function.prototype.call;
    n.exports = a ? i.bind(i) : function() {
        return i.apply(i, arguments)
    }
}
, function(n, e, t) {
    "use strict";
    n.exports = function(n, e) {
        return {
            enumerable: !(1 & n),
            configurable: !(2 & n),
            writable: !(4 & n),
            value: e
        }
    }
}
, function(n, e, t) {
    "use strict";
    var a = t(1)
      , i = t(37)
      , r = a["__core-js_shared__"] || i("__core-js_shared__", {});
    n.exports = r
}
, function(n, e, t) {
    "use strict";
    var a = t(1)
      , i = Object.defineProperty;
    n.exports = function(n, e) {
        try {
            i(a, n, {
                value: e,
                configurable: !0,
                writable: !0
            })
        } catch (t) {
            a[n] = e
        }
        return e
    }
}
, function(n, e, t) {
    var a = t(147)
      , i = t(12)
      , r = Object.prototype
      , o = r.hasOwnProperty
      , l = r.propertyIsEnumerable
      , s = a(function() {
        return arguments
    }()) ? a : function(n) {
        return i(n) && o.call(n, "callee") && !l.call(n, "callee")
    }
    ;
    n.exports = s
}
, function(n, e, t) {
    var a = t(10)(t(6), "Map");
    n.exports = a
}
, function(n, e) {
    n.exports = function(n) {
        var e = typeof n;
        return null != n && ("object" == e || "function" == e)
    }
}
, function(n, e, t) {
    var a = t(167)
      , i = t(174)
      , r = t(176)
      , o = t(177)
      , l = t(178);
    function s(n) {
        var e = -1
          , t = null == n ? 0 : n.length;
        for (this.clear(); ++e < t; ) {
            var a = n[e];
            this.set(a[0], a[1])
        }
    }
    s.prototype.clear = a,
    s.prototype.delete = i,
    s.prototype.get = r,
    s.prototype.has = o,
    s.prototype.set = l,
    n.exports = s
}
, function(n, e) {
    n.exports = function(n) {
        var e = -1
          , t = Array(n.size);
        return n.forEach((function(n) {
            t[++e] = n
        }
        )),
        t
    }
}
, function(n, e) {
    n.exports = function(n) {
        return "number" == typeof n && n > -1 && n % 1 == 0 && n <= 9007199254740991
    }
}
, function(n, e, t) {
    var a = t(5)
      , i = t(45)
      , r = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/
      , o = /^\w*$/;
    n.exports = function(n, e) {
        if (a(n))
            return !1;
        var t = typeof n;
        return !("number" != t && "symbol" != t && "boolean" != t && null != n && !i(n)) || (o.test(n) || !r.test(n) || null != e && n in Object(e))
    }
}
, function(n, e, t) {
    var a = t(13)
      , i = t(12);
    n.exports = function(n) {
        return "symbol" == typeof n || i(n) && "[object Symbol]" == a(n)
    }
}
, function(n, e) {
    n.exports = function(n) {
        return n
    }
}
, function(n, e, t) {
    "use strict";
    var a = t(2)
      , i = t(3)
      , r = t(18)
      , o = Object
      , l = a("".split);
    n.exports = i((function() {
        return !o("z").propertyIsEnumerable(0)
    }
    )) ? function(n) {
        return "String" === r(n) ? l(n, "") : o(n)
    }
    : o
}
, function(n, e, t) {
    "use strict";
    n.exports = {}
}
, function(n, e) {
    n.exports = function(n) {
        return n.webpackPolyfill || (n.deprecate = function() {}
        ,
        n.paths = [],
        n.children || (n.children = []),
        Object.defineProperty(n, "loaded", {
            enumerable: !0,
            get: function() {
                return n.l
            }
        }),
        Object.defineProperty(n, "id", {
            enumerable: !0,
            get: function() {
                return n.i
            }
        }),
        n.webpackPolyfill = 1),
        n
    }
}
, function(n, e) {
    var t = /^\s+|\s+$/g
      , a = /^[-+]0x[0-9a-f]+$/i
      , i = /^0b[01]+$/i
      , r = /^0o[0-7]+$/i
      , o = parseInt
      , l = "object" == typeof global && global && global.Object === Object && global
      , s = "object" == typeof self && self && self.Object === Object && self
      , c = l || s || Function("return this")()
      , d = Object.prototype.toString
      , u = Math.max
      , m = Math.min
      , p = function() {
        return c.Date.now()
    };
    function h(n) {
        var e = typeof n;
        return !!n && ("object" == e || "function" == e)
    }
    function g(n) {
        if ("number" == typeof n)
            return n;
        if (function(n) {
            return "symbol" == typeof n || function(n) {
                return !!n && "object" == typeof n
            }(n) && "[object Symbol]" == d.call(n)
        }(n))
            return NaN;
        if (h(n)) {
            var e = "function" == typeof n.valueOf ? n.valueOf() : n;
            n = h(e) ? e + "" : e
        }
        if ("string" != typeof n)
            return 0 === n ? n : +n;
        n = n.replace(t, "");
        var l = i.test(n);
        return l || r.test(n) ? o(n.slice(2), l ? 2 : 8) : a.test(n) ? NaN : +n
    }
    n.exports = function(n, e, t) {
        var a, i, r, o, l, s, c = 0, d = !1, _ = !1, v = !0;
        if ("function" != typeof n)
            throw new TypeError("Expected a function");
        function b(e) {
            var t = a
              , r = i;
            return a = i = void 0,
            c = e,
            o = n.apply(r, t)
        }
        function f(n) {
            return c = n,
            l = setTimeout(y, e),
            d ? b(n) : o
        }
        function E(n) {
            var t = n - s;
            return void 0 === s || t >= e || t < 0 || _ && n - c >= r
        }
        function y() {
            var n = p();
            if (E(n))
                return T(n);
            l = setTimeout(y, function(n) {
                var t = e - (n - s);
                return _ ? m(t, r - (n - c)) : t
            }(n))
        }
        function T(n) {
            return l = void 0,
            v && a ? b(n) : (a = i = void 0,
            o)
        }
        function A() {
            var n = p()
              , t = E(n);
            if (a = arguments,
            i = this,
            s = n,
            t) {
                if (void 0 === l)
                    return f(s);
                if (_)
                    return l = setTimeout(y, e),
                    b(s)
            }
            return void 0 === l && (l = setTimeout(y, e)),
            o
        }
        return e = g(e) || 0,
        h(t) && (d = !!t.leading,
        r = (_ = "maxWait"in t) ? u(g(t.maxWait) || 0, e) : r,
        v = "trailing"in t ? !!t.trailing : v),
        A.cancel = function() {
            void 0 !== l && clearTimeout(l),
            c = 0,
            a = s = i = l = void 0
        }
        ,
        A.flush = function() {
            return void 0 === l ? o : T(p())
        }
        ,
        A
    }
}
, function(n, e, t) {
    "use strict";
    var a = t(4)
      , i = t(34)
      , r = t(107)
      , o = t(35)
      , l = t(28)
      , s = t(54)
      , c = t(8)
      , d = t(64)
      , u = Object.getOwnPropertyDescriptor;
    e.f = a ? u : function(n, e) {
        if (n = l(n),
        e = s(e),
        d)
            try {
                return u(n, e)
            } catch (n) {}
        if (c(n, e))
            return o(!i(r.f, n, e), n[e])
    }
}
, function(n, e, t) {
    "use strict";
    var a = t(53)
      , i = TypeError;
    n.exports = function(n) {
        if (a(n))
            throw new i("Can't call method on " + n);
        return n
    }
}
, function(n, e, t) {
    "use strict";
    n.exports = function(n) {
        return null == n
    }
}
, function(n, e, t) {
    "use strict";
    var a = t(108)
      , i = t(56);
    n.exports = function(n) {
        var e = a(n, "string");
        return i(e) ? e : e + ""
    }
}
, function(n, e, t) {
    "use strict";
    var a = "object" == typeof document && document.all
      , i = void 0 === a && void 0 !== a;
    n.exports = {
        all: a,
        IS_HTMLDDA: i
    }
}
, function(n, e, t) {
    "use strict";
    var a = t(29)
      , i = t(0)
      , r = t(57)
      , o = t(58)
      , l = Object;
    n.exports = o ? function(n) {
        return "symbol" == typeof n
    }
    : function(n) {
        var e = a("Symbol");
        return i(e) && r(e.prototype, l(n))
    }
}
, function(n, e, t) {
    "use strict";
    var a = t(2);
    n.exports = a({}.isPrototypeOf)
}
, function(n, e, t) {
    "use strict";
    var a = t(59);
    n.exports = a && !Symbol.sham && "symbol" == typeof Symbol.iterator
}
, function(n, e, t) {
    "use strict";
    var a = t(60)
      , i = t(3)
      , r = t(1).String;
    n.exports = !!Object.getOwnPropertySymbols && !i((function() {
        var n = Symbol("symbol detection");
        return !r(n) || !(Object(n)instanceof Symbol) || !Symbol.sham && a && a < 41
    }
    ))
}
, function(n, e, t) {
    "use strict";
    var a, i, r = t(1), o = t(109), l = r.process, s = r.Deno, c = l && l.versions || s && s.version, d = c && c.v8;
    d && (i = (a = d.split("."))[0] > 0 && a[0] < 4 ? 1 : +(a[0] + a[1])),
    !i && o && (!(a = o.match(/Edge\/(\d+)/)) || a[1] >= 74) && (a = o.match(/Chrome\/(\d+)/)) && (i = +a[1]),
    n.exports = i
}
, function(n, e, t) {
    "use strict";
    var a = t(62)
      , i = t(36);
    (n.exports = function(n, e) {
        return i[n] || (i[n] = void 0 !== e ? e : {})
    }
    )("versions", []).push({
        version: "3.33.0",
        mode: a ? "pure" : "global",
        copyright: "© 2014-2023 Denis Pushkarev (zloirock.ru)",
        license: "https://github.com/zloirock/core-js/blob/v3.33.0/LICENSE",
        source: "https://github.com/zloirock/core-js"
    })
}
, function(n, e, t) {
    "use strict";
    n.exports = !1
}
, function(n, e, t) {
    "use strict";
    var a = t(2)
      , i = 0
      , r = Math.random()
      , o = a(1..toString);
    n.exports = function(n) {
        return "Symbol(" + (void 0 === n ? "" : n) + ")_" + o(++i + r, 36)
    }
}
, function(n, e, t) {
    "use strict";
    var a = t(4)
      , i = t(3)
      , r = t(99);
    n.exports = !a && !i((function() {
        return 7 !== Object.defineProperty(r("div"), "a", {
            get: function() {
                return 7
            }
        }).a
    }
    ))
}
, function(n, e, t) {
    "use strict";
    var a = t(8)
      , i = t(117)
      , r = t(51)
      , o = t(17);
    n.exports = function(n, e, t) {
        for (var l = i(e), s = o.f, c = r.f, d = 0; d < l.length; d++) {
            var u = l[d];
            a(n, u) || t && a(t, u) || s(n, u, c(e, u))
        }
    }
}
, function(n, e, t) {
    "use strict";
    var a = t(121);
    n.exports = function(n) {
        var e = +n;
        return e != e || 0 === e ? 0 : a(e)
    }
}
, function(n, e, t) {
    "use strict";
    var a = t(134)
      , i = t(25)
      , r = t(135);
    n.exports = Object.setPrototypeOf || ("__proto__"in {} ? function() {
        var n, e = !1, t = {};
        try {
            (n = a(Object.prototype, "__proto__", "set"))(t, []),
            e = t instanceof Array
        } catch (n) {}
        return function(t, a) {
            return i(t),
            r(a),
            e ? n(t, a) : t.__proto__ = a,
            t
        }
    }() : void 0)
}
, function(n, e) {
    n.exports = function(n, e) {
        for (var t = -1, a = e.length, i = n.length; ++t < a; )
            n[i + t] = e[t];
        return n
    }
}
, function(n, e) {
    var t = "object" == typeof global && global && global.Object === Object && global;
    n.exports = t
}
, function(n, e, t) {
    var a = t(19)
      , i = t(158)
      , r = t(159)
      , o = t(160)
      , l = t(161)
      , s = t(162);
    function c(n) {
        var e = this.__data__ = new a(n);
        this.size = e.size
    }
    c.prototype.clear = i,
    c.prototype.delete = r,
    c.prototype.get = o,
    c.prototype.has = l,
    c.prototype.set = s,
    n.exports = c
}
, function(n, e) {
    n.exports = function(n, e) {
        return n === e || n != n && e != e
    }
}
, function(n, e, t) {
    var a = t(13)
      , i = t(40);
    n.exports = function(n) {
        if (!i(n))
            return !1;
        var e = a(n);
        return "[object Function]" == e || "[object GeneratorFunction]" == e || "[object AsyncFunction]" == e || "[object Proxy]" == e
    }
}
, function(n, e) {
    var t = Function.prototype.toString;
    n.exports = function(n) {
        if (null != n) {
            try {
                return t.call(n)
            } catch (n) {}
            try {
                return n + ""
            } catch (n) {}
        }
        return ""
    }
}
, function(n, e, t) {
    var a = t(179)
      , i = t(12);
    n.exports = function n(e, t, r, o, l) {
        return e === t || (null == e || null == t || !i(e) && !i(t) ? e != e && t != t : a(e, t, r, o, n, l))
    }
}
, function(n, e, t) {
    var a = t(76)
      , i = t(182)
      , r = t(77);
    n.exports = function(n, e, t, o, l, s) {
        var c = 1 & t
          , d = n.length
          , u = e.length;
        if (d != u && !(c && u > d))
            return !1;
        var m = s.get(n)
          , p = s.get(e);
        if (m && p)
            return m == e && p == n;
        var h = -1
          , g = !0
          , _ = 2 & t ? new a : void 0;
        for (s.set(n, e),
        s.set(e, n); ++h < d; ) {
            var v = n[h]
              , b = e[h];
            if (o)
                var f = c ? o(b, v, h, e, n, s) : o(v, b, h, n, e, s);
            if (void 0 !== f) {
                if (f)
                    continue;
                g = !1;
                break
            }
            if (_) {
                if (!i(e, (function(n, e) {
                    if (!r(_, e) && (v === n || l(v, n, t, o, s)))
                        return _.push(e)
                }
                ))) {
                    g = !1;
                    break
                }
            } else if (v !== b && !l(v, b, t, o, s)) {
                g = !1;
                break
            }
        }
        return s.delete(n),
        s.delete(e),
        g
    }
}
, function(n, e, t) {
    var a = t(41)
      , i = t(180)
      , r = t(181);
    function o(n) {
        var e = -1
          , t = null == n ? 0 : n.length;
        for (this.__data__ = new a; ++e < t; )
            this.add(n[e])
    }
    o.prototype.add = o.prototype.push = i,
    o.prototype.has = r,
    n.exports = o
}
, function(n, e) {
    n.exports = function(n, e) {
        return n.has(e)
    }
}
, function(n, e, t) {
    var a = t(192)
      , i = t(198)
      , r = t(82);
    n.exports = function(n) {
        return r(n) ? a(n) : i(n)
    }
}
, function(n, e, t) {
    (function(n) {
        var a = t(6)
          , i = t(194)
          , r = e && !e.nodeType && e
          , o = r && "object" == typeof n && n && !n.nodeType && n
          , l = o && o.exports === r ? a.Buffer : void 0
          , s = (l ? l.isBuffer : void 0) || i;
        n.exports = s
    }
    ).call(this, t(49)(n))
}
, function(n, e) {
    var t = /^(?:0|[1-9]\d*)$/;
    n.exports = function(n, e) {
        var a = typeof n;
        return !!(e = null == e ? 9007199254740991 : e) && ("number" == a || "symbol" != a && t.test(n)) && n > -1 && n % 1 == 0 && n < e
    }
}
, function(n, e, t) {
    var a = t(195)
      , i = t(196)
      , r = t(197)
      , o = r && r.isTypedArray
      , l = o ? i(o) : a;
    n.exports = l
}
, function(n, e, t) {
    var a = t(72)
      , i = t(43);
    n.exports = function(n) {
        return null != n && i(n.length) && !a(n)
    }
}
, function(n, e, t) {
    var a = t(10)(t(6), "Set");
    n.exports = a
}
, function(n, e, t) {
    var a = t(40);
    n.exports = function(n) {
        return n == n && !a(n)
    }
}
, function(n, e) {
    n.exports = function(n, e) {
        return function(t) {
            return null != t && (t[n] === e && (void 0 !== e || n in Object(t)))
        }
    }
}
, function(n, e, t) {
    var a = t(87)
      , i = t(23);
    n.exports = function(n, e) {
        for (var t = 0, r = (e = a(e, n)).length; null != n && t < r; )
            n = n[i(e[t++])];
        return t && t == r ? n : void 0
    }
}
, function(n, e, t) {
    var a = t(5)
      , i = t(44)
      , r = t(209)
      , o = t(212);
    n.exports = function(n, e) {
        return a(n) ? n : i(n, e) ? [n] : r(o(n))
    }
}
, function(n, e, t) {}
, function(n, e, t) {}
, function(n, e, t) {}
, function(n, e, t) {}
, function(n, e, t) {
    var a = t(145)
      , i = t(150)
      , r = t(221)
      , o = t(229)
      , l = t(238)
      , s = t(104)
      , c = r((function(n) {
        var e = s(n);
        return l(e) && (e = void 0),
        o(a(n, 1, l, !0), i(e, 2))
    }
    ));
    n.exports = c
}
, function(n, e, t) {
    "use strict";
    /*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */
    var a = /["'&<>]/;
    n.exports = function(n) {
        var e, t = "" + n, i = a.exec(t);
        if (!i)
            return t;
        var r = ""
          , o = 0
          , l = 0;
        for (o = i.index; o < t.length; o++) {
            switch (t.charCodeAt(o)) {
            case 34:
                e = "&quot;";
                break;
            case 38:
                e = "&amp;";
                break;
            case 39:
                e = "&#39;";
                break;
            case 60:
                e = "&lt;";
                break;
            case 62:
                e = "&gt;";
                break;
            default:
                continue
            }
            l !== o && (r += t.substring(l, o)),
            l = o + 1,
            r += e
        }
        return l !== o ? r + t.substring(l, o) : r
    }
}
, function(n, e, t) {
    "use strict";
    t.r(e);
    var a = {
        name: "CodeBlock",
        props: {
            title: {
                type: String,
                required: !0
            },
            active: {
                type: Boolean,
                default: !1
            }
        }
    }
      , i = (t(241),
    t(7))
      , r = Object(i.a)(a, (function() {
        return (0,
        this._self._c)("div", {
            staticClass: "theme-code-block",
            class: {
                "theme-code-block__active": this.active
            }
        }, [this._t("default")], 2)
    }
    ), [], !1, null, "4f1e9d0c", null);
    e.default = r.exports
}
, function(n, e, t) {
    "use strict";
    t.r(e);
    var a = {
        name: "CodeGroup",
        data: () => ({
            codeTabs: [],
            activeCodeTabIndex: -1
        }),
        watch: {
            activeCodeTabIndex(n) {
                this.codeTabs.forEach(n => {
                    n.elm.classList.remove("theme-code-block__active")
                }
                ),
                this.codeTabs[n].elm.classList.add("theme-code-block__active")
            }
        },
        mounted() {
            this.codeTabs = (this.$slots.default || []).filter(n => Boolean(n.componentOptions)).map( (n, e) => ("" === n.componentOptions.propsData.active && (this.activeCodeTabIndex = e),
            {
                title: n.componentOptions.propsData.title,
                elm: n.elm
            })),
            -1 === this.activeCodeTabIndex && this.codeTabs.length > 0 && (this.activeCodeTabIndex = 0)
        },
        methods: {
            changeCodeTab(n) {
                this.activeCodeTabIndex = n
            }
        }
    }
      , i = (t(242),
    t(7))
      , r = Object(i.a)(a, (function() {
        var n = this
          , e = n._self._c;
        return e("div", {
            staticClass: "theme-code-group"
        }, [e("div", {
            staticClass: "theme-code-group__nav"
        }, [e("ul", {
            staticClass: "theme-code-group__ul"
        }, n._l(n.codeTabs, (function(t, a) {
            return e("li", {
                key: t.title,
                staticClass: "theme-code-group__li"
            }, [e("button", {
                staticClass: "theme-code-group__nav-tab",
                class: {
                    "theme-code-group__nav-tab-active": a === n.activeCodeTabIndex
                },
                on: {
                    click: function(e) {
                        return n.changeCodeTab(a)
                    }
                }
            }, [n._v("\n            " + n._s(t.title) + "\n          ")])])
        }
        )), 0)]), n._v(" "), n._t("default"), n._v(" "), n.codeTabs.length < 1 ? e("pre", {
            staticClass: "pre-blank"
        }, [n._v("// Make sure to add code blocks to your code group")]) : n._e()], 2)
    }
    ), [], !1, null, "2f5f1757", null);
    e.default = r.exports
}
, function(n, e, t) {
    "use strict";
    var a = t(0)
      , i = t(17)
      , r = t(101)
      , o = t(37);
    n.exports = function(n, e, t, l) {
        l || (l = {});
        var s = l.enumerable
          , c = void 0 !== l.name ? l.name : e;
        if (a(t) && r(t, c, l),
        l.global)
            s ? n[e] = t : o(e, t);
        else {
            try {
                l.unsafe ? n[e] && (s = !0) : delete n[e]
            } catch (n) {}
            s ? n[e] = t : i.f(n, e, {
                value: t,
                enumerable: !1,
                configurable: !l.nonConfigurable,
                writable: !l.nonWritable
            })
        }
        return n
    }
}
, function(n, e, t) {
    "use strict";
    n.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"]
}
, function(n, e, t) {
    "use strict";
    var a = t(139)
      , i = String;
    n.exports = function(n) {
        if ("Symbol" === a(n))
            throw new TypeError("Cannot convert a Symbol value to a string");
        return i(n)
    }
}
, function(n, e, t) {
    "use strict";
    var a = t(1)
      , i = t(9)
      , r = a.document
      , o = i(r) && i(r.createElement);
    n.exports = function(n) {
        return o ? r.createElement(n) : {}
    }
}
, function(n, e, t) {
    "use strict";
    var a = t(4)
      , i = t(3);
    n.exports = a && i((function() {
        return 42 !== Object.defineProperty((function() {}
        ), "prototype", {
            value: 42,
            writable: !1
        }).prototype
    }
    ))
}
, function(n, e, t) {
    "use strict";
    var a = t(2)
      , i = t(3)
      , r = t(0)
      , o = t(8)
      , l = t(4)
      , s = t(113).CONFIGURABLE
      , c = t(114)
      , d = t(115)
      , u = d.enforce
      , m = d.get
      , p = String
      , h = Object.defineProperty
      , g = a("".slice)
      , _ = a("".replace)
      , v = a([].join)
      , b = l && !i((function() {
        return 8 !== h((function() {}
        ), "length", {
            value: 8
        }).length
    }
    ))
      , f = String(String).split("String")
      , E = n.exports = function(n, e, t) {
        "Symbol(" === g(p(e), 0, 7) && (e = "[" + _(p(e), /^Symbol\(([^)]*)\)/, "$1") + "]"),
        t && t.getter && (e = "get " + e),
        t && t.setter && (e = "set " + e),
        (!o(n, "name") || s && n.name !== e) && (l ? h(n, "name", {
            value: e,
            configurable: !0
        }) : n.name = e),
        b && t && o(t, "arity") && n.length !== t.arity && h(n, "length", {
            value: t.arity
        });
        try {
            t && o(t, "constructor") && t.constructor ? l && h(n, "prototype", {
                writable: !1
            }) : n.prototype && (n.prototype = void 0)
        } catch (n) {}
        var a = u(n);
        return o(a, "source") || (a.source = v(f, "string" == typeof e ? e : "")),
        n
    }
    ;
    Function.prototype.toString = E((function() {
        return r(this) && m(this).source || c(this)
    }
    ), "toString")
}
, function(n, e, t) {
    "use strict";
    var a = t(61)
      , i = t(63)
      , r = a("keys");
    n.exports = function(n) {
        return r[n] || (r[n] = i(n))
    }
}
, function(n, e, t) {
    "use strict";
    var a = t(2)
      , i = t(8)
      , r = t(28)
      , o = t(119).indexOf
      , l = t(48)
      , s = a([].push);
    n.exports = function(n, e) {
        var t, a = r(n), c = 0, d = [];
        for (t in a)
            !i(l, t) && i(a, t) && s(d, t);
        for (; e.length > c; )
            i(a, t = e[c++]) && (~o(d, t) || s(d, t));
        return d
    }
}
, function(n, e) {
    n.exports = function(n) {
        var e = null == n ? 0 : n.length;
        return e ? n[e - 1] : void 0
    }
}
, function(n, e, t) {
    n.exports = t(247)
}
, function(n, e, t) {
    "use strict";
    var a = t(26)
      , i = t(125).left
      , r = t(126)
      , o = t(60);
    a({
        target: "Array",
        proto: !0,
        forced: !t(127) && o > 79 && o < 83 || !r("reduce")
    }, {
        reduce: function(n) {
            var e = arguments.length;
            return i(this, n, e, e > 1 ? arguments[1] : void 0)
        }
    })
}
, function(n, e, t) {
    "use strict";
    var a = {}.propertyIsEnumerable
      , i = Object.getOwnPropertyDescriptor
      , r = i && !a.call({
        1: 2
    }, 1);
    e.f = r ? function(n) {
        var e = i(this, n);
        return !!e && e.enumerable
    }
    : a
}
, function(n, e, t) {
    "use strict";
    var a = t(34)
      , i = t(9)
      , r = t(56)
      , o = t(110)
      , l = t(112)
      , s = t(31)
      , c = TypeError
      , d = s("toPrimitive");
    n.exports = function(n, e) {
        if (!i(n) || r(n))
            return n;
        var t, s = o(n, d);
        if (s) {
            if (void 0 === e && (e = "default"),
            t = a(s, n, e),
            !i(t) || r(t))
                return t;
            throw new c("Can't convert object to primitive value")
        }
        return void 0 === e && (e = "number"),
        l(n, e)
    }
}
, function(n, e, t) {
    "use strict";
    n.exports = "undefined" != typeof navigator && String(navigator.userAgent) || ""
}
, function(n, e, t) {
    "use strict";
    var a = t(30)
      , i = t(53);
    n.exports = function(n, e) {
        var t = n[e];
        return i(t) ? void 0 : a(t)
    }
}
, function(n, e, t) {
    "use strict";
    var a = String;
    n.exports = function(n) {
        try {
            return a(n)
        } catch (n) {
            return "Object"
        }
    }
}
, function(n, e, t) {
    "use strict";
    var a = t(34)
      , i = t(0)
      , r = t(9)
      , o = TypeError;
    n.exports = function(n, e) {
        var t, l;
        if ("string" === e && i(t = n.toString) && !r(l = a(t, n)))
            return l;
        if (i(t = n.valueOf) && !r(l = a(t, n)))
            return l;
        if ("string" !== e && i(t = n.toString) && !r(l = a(t, n)))
            return l;
        throw new o("Can't convert object to primitive value")
    }
}
, function(n, e, t) {
    "use strict";
    var a = t(4)
      , i = t(8)
      , r = Function.prototype
      , o = a && Object.getOwnPropertyDescriptor
      , l = i(r, "name")
      , s = l && "something" === function() {}
    .name
      , c = l && (!a || a && o(r, "name").configurable);
    n.exports = {
        EXISTS: l,
        PROPER: s,
        CONFIGURABLE: c
    }
}
, function(n, e, t) {
    "use strict";
    var a = t(2)
      , i = t(0)
      , r = t(36)
      , o = a(Function.toString);
    i(r.inspectSource) || (r.inspectSource = function(n) {
        return o(n)
    }
    ),
    n.exports = r.inspectSource
}
, function(n, e, t) {
    "use strict";
    var a, i, r, o = t(116), l = t(1), s = t(9), c = t(14), d = t(8), u = t(36), m = t(102), p = t(48), h = l.TypeError, g = l.WeakMap;
    if (o || u.state) {
        var _ = u.state || (u.state = new g);
        _.get = _.get,
        _.has = _.has,
        _.set = _.set,
        a = function(n, e) {
            if (_.has(n))
                throw new h("Object already initialized");
            return e.facade = n,
            _.set(n, e),
            e
        }
        ,
        i = function(n) {
            return _.get(n) || {}
        }
        ,
        r = function(n) {
            return _.has(n)
        }
    } else {
        var v = m("state");
        p[v] = !0,
        a = function(n, e) {
            if (d(n, v))
                throw new h("Object already initialized");
            return e.facade = n,
            c(n, v, e),
            e
        }
        ,
        i = function(n) {
            return d(n, v) ? n[v] : {}
        }
        ,
        r = function(n) {
            return d(n, v)
        }
    }
    n.exports = {
        set: a,
        get: i,
        has: r,
        enforce: function(n) {
            return r(n) ? i(n) : a(n, {})
        },
        getterFor: function(n) {
            return function(e) {
                var t;
                if (!s(e) || (t = i(e)).type !== n)
                    throw new h("Incompatible receiver, " + n + " required");
                return t
            }
        }
    }
}
, function(n, e, t) {
    "use strict";
    var a = t(1)
      , i = t(0)
      , r = a.WeakMap;
    n.exports = i(r) && /native code/.test(String(r))
}
, function(n, e, t) {
    "use strict";
    var a = t(29)
      , i = t(2)
      , r = t(118)
      , o = t(123)
      , l = t(25)
      , s = i([].concat);
    n.exports = a("Reflect", "ownKeys") || function(n) {
        var e = r.f(l(n))
          , t = o.f;
        return t ? s(e, t(n)) : e
    }
}
, function(n, e, t) {
    "use strict";
    var a = t(103)
      , i = t(97).concat("length", "prototype");
    e.f = Object.getOwnPropertyNames || function(n) {
        return a(n, i)
    }
}
, function(n, e, t) {
    "use strict";
    var a = t(28)
      , i = t(120)
      , r = t(33)
      , o = function(n) {
        return function(e, t, o) {
            var l, s = a(e), c = r(s), d = i(o, c);
            if (n && t != t) {
                for (; c > d; )
                    if ((l = s[d++]) != l)
                        return !0
            } else
                for (; c > d; d++)
                    if ((n || d in s) && s[d] === t)
                        return n || d || 0;
            return !n && -1
        }
    };
    n.exports = {
        includes: o(!0),
        indexOf: o(!1)
    }
}
, function(n, e, t) {
    "use strict";
    var a = t(66)
      , i = Math.max
      , r = Math.min;
    n.exports = function(n, e) {
        var t = a(n);
        return t < 0 ? i(t + e, 0) : r(t, e)
    }
}
, function(n, e, t) {
    "use strict";
    var a = Math.ceil
      , i = Math.floor;
    n.exports = Math.trunc || function(n) {
        var e = +n;
        return (e > 0 ? i : a)(e)
    }
}
, function(n, e, t) {
    "use strict";
    var a = t(66)
      , i = Math.min;
    n.exports = function(n) {
        return n > 0 ? i(a(n), 9007199254740991) : 0
    }
}
, function(n, e, t) {
    "use strict";
    e.f = Object.getOwnPropertySymbols
}
, function(n, e, t) {
    "use strict";
    var a = t(3)
      , i = t(0)
      , r = /#|\.prototype\./
      , o = function(n, e) {
        var t = s[l(n)];
        return t === d || t !== c && (i(e) ? a(e) : !!e)
    }
      , l = o.normalize = function(n) {
        return String(n).replace(r, ".").toLowerCase()
    }
      , s = o.data = {}
      , c = o.NATIVE = "N"
      , d = o.POLYFILL = "P";
    n.exports = o
}
, function(n, e, t) {
    "use strict";
    var a = t(30)
      , i = t(32)
      , r = t(47)
      , o = t(33)
      , l = TypeError
      , s = function(n) {
        return function(e, t, s, c) {
            a(t);
            var d = i(e)
              , u = r(d)
              , m = o(d)
              , p = n ? m - 1 : 0
              , h = n ? -1 : 1;
            if (s < 2)
                for (; ; ) {
                    if (p in u) {
                        c = u[p],
                        p += h;
                        break
                    }
                    if (p += h,
                    n ? p < 0 : m <= p)
                        throw new l("Reduce of empty array with no initial value")
                }
            for (; n ? p >= 0 : m > p; p += h)
                p in u && (c = t(c, u[p], p, d));
            return c
        }
    };
    n.exports = {
        left: s(!1),
        right: s(!0)
    }
}
, function(n, e, t) {
    "use strict";
    var a = t(3);
    n.exports = function(n, e) {
        var t = [][n];
        return !!t && a((function() {
            t.call(null, e || function() {
                return 1
            }
            , 1)
        }
        ))
    }
}
, function(n, e, t) {
    "use strict";
    var a = t(1)
      , i = t(18);
    n.exports = "process" === i(a.process)
}
, function(n, e, t) {
    "use strict";
    var a = t(4)
      , i = t(129)
      , r = TypeError
      , o = Object.getOwnPropertyDescriptor
      , l = a && !function() {
        if (void 0 !== this)
            return !0;
        try {
            Object.defineProperty([], "length", {
                writable: !1
            }).length = 1
        } catch (n) {
            return n instanceof TypeError
        }
    }();
    n.exports = l ? function(n, e) {
        if (i(n) && !o(n, "length").writable)
            throw new r("Cannot set read only .length");
        return n.length = e
    }
    : function(n, e) {
        return n.length = e
    }
}
, function(n, e, t) {
    "use strict";
    var a = t(18);
    n.exports = Array.isArray || function(n) {
        return "Array" === a(n)
    }
}
, function(n, e, t) {
    "use strict";
    var a = TypeError;
    n.exports = function(n) {
        if (n > 9007199254740991)
            throw a("Maximum allowed index exceeded");
        return n
    }
}
, function(n, e, t) {
    "use strict";
    var a = t(26)
      , i = t(1)
      , r = t(132)
      , o = t(133)
      , l = i.WebAssembly
      , s = 7 !== new Error("e",{
        cause: 7
    }).cause
      , c = function(n, e) {
        var t = {};
        t[n] = o(n, e, s),
        a({
            global: !0,
            constructor: !0,
            arity: 1,
            forced: s
        }, t)
    }
      , d = function(n, e) {
        if (l && l[n]) {
            var t = {};
            t[n] = o("WebAssembly." + n, e, s),
            a({
                target: "WebAssembly",
                stat: !0,
                constructor: !0,
                arity: 1,
                forced: s
            }, t)
        }
    };
    c("Error", (function(n) {
        return function(e) {
            return r(n, this, arguments)
        }
    }
    )),
    c("EvalError", (function(n) {
        return function(e) {
            return r(n, this, arguments)
        }
    }
    )),
    c("RangeError", (function(n) {
        return function(e) {
            return r(n, this, arguments)
        }
    }
    )),
    c("ReferenceError", (function(n) {
        return function(e) {
            return r(n, this, arguments)
        }
    }
    )),
    c("SyntaxError", (function(n) {
        return function(e) {
            return r(n, this, arguments)
        }
    }
    )),
    c("TypeError", (function(n) {
        return function(e) {
            return r(n, this, arguments)
        }
    }
    )),
    c("URIError", (function(n) {
        return function(e) {
            return r(n, this, arguments)
        }
    }
    )),
    d("CompileError", (function(n) {
        return function(e) {
            return r(n, this, arguments)
        }
    }
    )),
    d("LinkError", (function(n) {
        return function(e) {
            return r(n, this, arguments)
        }
    }
    )),
    d("RuntimeError", (function(n) {
        return function(e) {
            return r(n, this, arguments)
        }
    }
    ))
}
, function(n, e, t) {
    "use strict";
    var a = t(27)
      , i = Function.prototype
      , r = i.apply
      , o = i.call;
    n.exports = "object" == typeof Reflect && Reflect.apply || (a ? o.bind(r) : function() {
        return o.apply(r, arguments)
    }
    )
}
, function(n, e, t) {
    "use strict";
    var a = t(29)
      , i = t(8)
      , r = t(14)
      , o = t(57)
      , l = t(67)
      , s = t(65)
      , c = t(136)
      , d = t(137)
      , u = t(138)
      , m = t(141)
      , p = t(142)
      , h = t(4)
      , g = t(62);
    n.exports = function(n, e, t, _) {
        var v = _ ? 2 : 1
          , b = n.split(".")
          , f = b[b.length - 1]
          , E = a.apply(null, b);
        if (E) {
            var y = E.prototype;
            if (!g && i(y, "cause") && delete y.cause,
            !t)
                return E;
            var T = a("Error")
              , A = e((function(n, e) {
                var t = u(_ ? e : n, void 0)
                  , a = _ ? new E(n) : new E;
                return void 0 !== t && r(a, "message", t),
                p(a, A, a.stack, 2),
                this && o(y, this) && d(a, this, A),
                arguments.length > v && m(a, arguments[v]),
                a
            }
            ));
            if (A.prototype = y,
            "Error" !== f ? l ? l(A, T) : s(A, T, {
                name: !0
            }) : h && "stackTraceLimit"in E && (c(A, E, "stackTraceLimit"),
            c(A, E, "prepareStackTrace")),
            s(A, E),
            !g)
                try {
                    y.name !== f && r(y, "name", f),
                    y.constructor = A
                } catch (n) {}
            return A
        }
    }
}
, function(n, e, t) {
    "use strict";
    var a = t(2)
      , i = t(30);
    n.exports = function(n, e, t) {
        try {
            return a(i(Object.getOwnPropertyDescriptor(n, e)[t]))
        } catch (n) {}
    }
}
, function(n, e, t) {
    "use strict";
    var a = t(0)
      , i = String
      , r = TypeError;
    n.exports = function(n) {
        if ("object" == typeof n || a(n))
            return n;
        throw new r("Can't set " + i(n) + " as a prototype")
    }
}
, function(n, e, t) {
    "use strict";
    var a = t(17).f;
    n.exports = function(n, e, t) {
        t in n || a(n, t, {
            configurable: !0,
            get: function() {
                return e[t]
            },
            set: function(n) {
                e[t] = n
            }
        })
    }
}
, function(n, e, t) {
    "use strict";
    var a = t(0)
      , i = t(9)
      , r = t(67);
    n.exports = function(n, e, t) {
        var o, l;
        return r && a(o = e.constructor) && o !== t && i(l = o.prototype) && l !== t.prototype && r(n, l),
        n
    }
}
, function(n, e, t) {
    "use strict";
    var a = t(98);
    n.exports = function(n, e) {
        return void 0 === n ? arguments.length < 2 ? "" : e : a(n)
    }
}
, function(n, e, t) {
    "use strict";
    var a = t(140)
      , i = t(0)
      , r = t(18)
      , o = t(31)("toStringTag")
      , l = Object
      , s = "Arguments" === r(function() {
        return arguments
    }());
    n.exports = a ? r : function(n) {
        var e, t, a;
        return void 0 === n ? "Undefined" : null === n ? "Null" : "string" == typeof (t = function(n, e) {
            try {
                return n[e]
            } catch (n) {}
        }(e = l(n), o)) ? t : s ? r(e) : "Object" === (a = r(e)) && i(e.callee) ? "Arguments" : a
    }
}
, function(n, e, t) {
    "use strict";
    var a = {};
    a[t(31)("toStringTag")] = "z",
    n.exports = "[object z]" === String(a)
}
, function(n, e, t) {
    "use strict";
    var a = t(9)
      , i = t(14);
    n.exports = function(n, e) {
        a(e) && "cause"in e && i(n, "cause", e.cause)
    }
}
, function(n, e, t) {
    "use strict";
    var a = t(14)
      , i = t(143)
      , r = t(144)
      , o = Error.captureStackTrace;
    n.exports = function(n, e, t, l) {
        r && (o ? o(n, e) : a(n, "stack", i(t, l)))
    }
}
, function(n, e, t) {
    "use strict";
    var a = t(2)
      , i = Error
      , r = a("".replace)
      , o = String(new i("zxcasd").stack)
      , l = /\n\s*at [^:]*:[^\n]*/
      , s = l.test(o);
    n.exports = function(n, e) {
        if (s && "string" == typeof n && !i.prepareStackTrace)
            for (; e--; )
                n = r(n, l, "");
        return n
    }
}
, function(n, e, t) {
    "use strict";
    var a = t(3)
      , i = t(35);
    n.exports = !a((function() {
        var n = new Error("a");
        return !("stack"in n) || (Object.defineProperty(n, "stack", i(1, 7)),
        7 !== n.stack)
    }
    ))
}
, function(n, e, t) {
    var a = t(68)
      , i = t(146);
    n.exports = function n(e, t, r, o, l) {
        var s = -1
          , c = e.length;
        for (r || (r = i),
        l || (l = []); ++s < c; ) {
            var d = e[s];
            t > 0 && r(d) ? t > 1 ? n(d, t - 1, r, o, l) : a(l, d) : o || (l[l.length] = d)
        }
        return l
    }
}
, function(n, e, t) {
    var a = t(15)
      , i = t(38)
      , r = t(5)
      , o = a ? a.isConcatSpreadable : void 0;
    n.exports = function(n) {
        return r(n) || i(n) || !!(o && n && n[o])
    }
}
, function(n, e, t) {
    var a = t(13)
      , i = t(12);
    n.exports = function(n) {
        return i(n) && "[object Arguments]" == a(n)
    }
}
, function(n, e, t) {
    var a = t(15)
      , i = Object.prototype
      , r = i.hasOwnProperty
      , o = i.toString
      , l = a ? a.toStringTag : void 0;
    n.exports = function(n) {
        var e = r.call(n, l)
          , t = n[l];
        try {
            n[l] = void 0;
            var a = !0
        } catch (n) {}
        var i = o.call(n);
        return a && (e ? n[l] = t : delete n[l]),
        i
    }
}
, function(n, e) {
    var t = Object.prototype.toString;
    n.exports = function(n) {
        return t.call(n)
    }
}
, function(n, e, t) {
    var a = t(151)
      , i = t(207)
      , r = t(46)
      , o = t(5)
      , l = t(218);
    n.exports = function(n) {
        return "function" == typeof n ? n : null == n ? r : "object" == typeof n ? o(n) ? i(n[0], n[1]) : a(n) : l(n)
    }
}
, function(n, e, t) {
    var a = t(152)
      , i = t(206)
      , r = t(85);
    n.exports = function(n) {
        var e = i(n);
        return 1 == e.length && e[0][2] ? r(e[0][0], e[0][1]) : function(t) {
            return t === n || a(t, n, e)
        }
    }
}
, function(n, e, t) {
    var a = t(70)
      , i = t(74);
    n.exports = function(n, e, t, r) {
        var o = t.length
          , l = o
          , s = !r;
        if (null == n)
            return !l;
        for (n = Object(n); o--; ) {
            var c = t[o];
            if (s && c[2] ? c[1] !== n[c[0]] : !(c[0]in n))
                return !1
        }
        for (; ++o < l; ) {
            var d = (c = t[o])[0]
              , u = n[d]
              , m = c[1];
            if (s && c[2]) {
                if (void 0 === u && !(d in n))
                    return !1
            } else {
                var p = new a;
                if (r)
                    var h = r(u, m, d, n, e, p);
                if (!(void 0 === h ? i(m, u, 3, r, p) : h))
                    return !1
            }
        }
        return !0
    }
}
, function(n, e) {
    n.exports = function() {
        this.__data__ = [],
        this.size = 0
    }
}
, function(n, e, t) {
    var a = t(20)
      , i = Array.prototype.splice;
    n.exports = function(n) {
        var e = this.__data__
          , t = a(e, n);
        return !(t < 0) && (t == e.length - 1 ? e.pop() : i.call(e, t, 1),
        --this.size,
        !0)
    }
}
, function(n, e, t) {
    var a = t(20);
    n.exports = function(n) {
        var e = this.__data__
          , t = a(e, n);
        return t < 0 ? void 0 : e[t][1]
    }
}
, function(n, e, t) {
    var a = t(20);
    n.exports = function(n) {
        return a(this.__data__, n) > -1
    }
}
, function(n, e, t) {
    var a = t(20);
    n.exports = function(n, e) {
        var t = this.__data__
          , i = a(t, n);
        return i < 0 ? (++this.size,
        t.push([n, e])) : t[i][1] = e,
        this
    }
}
, function(n, e, t) {
    var a = t(19);
    n.exports = function() {
        this.__data__ = new a,
        this.size = 0
    }
}
, function(n, e) {
    n.exports = function(n) {
        var e = this.__data__
          , t = e.delete(n);
        return this.size = e.size,
        t
    }
}
, function(n, e) {
    n.exports = function(n) {
        return this.__data__.get(n)
    }
}
, function(n, e) {
    n.exports = function(n) {
        return this.__data__.has(n)
    }
}
, function(n, e, t) {
    var a = t(19)
      , i = t(39)
      , r = t(41);
    n.exports = function(n, e) {
        var t = this.__data__;
        if (t instanceof a) {
            var o = t.__data__;
            if (!i || o.length < 199)
                return o.push([n, e]),
                this.size = ++t.size,
                this;
            t = this.__data__ = new r(o)
        }
        return t.set(n, e),
        this.size = t.size,
        this
    }
}
, function(n, e, t) {
    var a = t(72)
      , i = t(164)
      , r = t(40)
      , o = t(73)
      , l = /^\[object .+?Constructor\]$/
      , s = Function.prototype
      , c = Object.prototype
      , d = s.toString
      , u = c.hasOwnProperty
      , m = RegExp("^" + d.call(u).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    n.exports = function(n) {
        return !(!r(n) || i(n)) && (a(n) ? m : l).test(o(n))
    }
}
, function(n, e, t) {
    var a, i = t(165), r = (a = /[^.]+$/.exec(i && i.keys && i.keys.IE_PROTO || "")) ? "Symbol(src)_1." + a : "";
    n.exports = function(n) {
        return !!r && r in n
    }
}
, function(n, e, t) {
    var a = t(6)["__core-js_shared__"];
    n.exports = a
}
, function(n, e) {
    n.exports = function(n, e) {
        return null == n ? void 0 : n[e]
    }
}
, function(n, e, t) {
    var a = t(168)
      , i = t(19)
      , r = t(39);
    n.exports = function() {
        this.size = 0,
        this.__data__ = {
            hash: new a,
            map: new (r || i),
            string: new a
        }
    }
}
, function(n, e, t) {
    var a = t(169)
      , i = t(170)
      , r = t(171)
      , o = t(172)
      , l = t(173);
    function s(n) {
        var e = -1
          , t = null == n ? 0 : n.length;
        for (this.clear(); ++e < t; ) {
            var a = n[e];
            this.set(a[0], a[1])
        }
    }
    s.prototype.clear = a,
    s.prototype.delete = i,
    s.prototype.get = r,
    s.prototype.has = o,
    s.prototype.set = l,
    n.exports = s
}
, function(n, e, t) {
    var a = t(21);
    n.exports = function() {
        this.__data__ = a ? a(null) : {},
        this.size = 0
    }
}
, function(n, e) {
    n.exports = function(n) {
        var e = this.has(n) && delete this.__data__[n];
        return this.size -= e ? 1 : 0,
        e
    }
}
, function(n, e, t) {
    var a = t(21)
      , i = Object.prototype.hasOwnProperty;
    n.exports = function(n) {
        var e = this.__data__;
        if (a) {
            var t = e[n];
            return "__lodash_hash_undefined__" === t ? void 0 : t
        }
        return i.call(e, n) ? e[n] : void 0
    }
}
, function(n, e, t) {
    var a = t(21)
      , i = Object.prototype.hasOwnProperty;
    n.exports = function(n) {
        var e = this.__data__;
        return a ? void 0 !== e[n] : i.call(e, n)
    }
}
, function(n, e, t) {
    var a = t(21);
    n.exports = function(n, e) {
        var t = this.__data__;
        return this.size += this.has(n) ? 0 : 1,
        t[n] = a && void 0 === e ? "__lodash_hash_undefined__" : e,
        this
    }
}
, function(n, e, t) {
    var a = t(22);
    n.exports = function(n) {
        var e = a(this, n).delete(n);
        return this.size -= e ? 1 : 0,
        e
    }
}
, function(n, e) {
    n.exports = function(n) {
        var e = typeof n;
        return "string" == e || "number" == e || "symbol" == e || "boolean" == e ? "__proto__" !== n : null === n
    }
}
, function(n, e, t) {
    var a = t(22);
    n.exports = function(n) {
        return a(this, n).get(n)
    }
}
, function(n, e, t) {
    var a = t(22);
    n.exports = function(n) {
        return a(this, n).has(n)
    }
}
, function(n, e, t) {
    var a = t(22);
    n.exports = function(n, e) {
        var t = a(this, n)
          , i = t.size;
        return t.set(n, e),
        this.size += t.size == i ? 0 : 1,
        this
    }
}
, function(n, e, t) {
    var a = t(70)
      , i = t(75)
      , r = t(183)
      , o = t(186)
      , l = t(202)
      , s = t(5)
      , c = t(79)
      , d = t(81)
      , u = "[object Object]"
      , m = Object.prototype.hasOwnProperty;
    n.exports = function(n, e, t, p, h, g) {
        var _ = s(n)
          , v = s(e)
          , b = _ ? "[object Array]" : l(n)
          , f = v ? "[object Array]" : l(e)
          , E = (b = "[object Arguments]" == b ? u : b) == u
          , y = (f = "[object Arguments]" == f ? u : f) == u
          , T = b == f;
        if (T && c(n)) {
            if (!c(e))
                return !1;
            _ = !0,
            E = !1
        }
        if (T && !E)
            return g || (g = new a),
            _ || d(n) ? i(n, e, t, p, h, g) : r(n, e, b, t, p, h, g);
        if (!(1 & t)) {
            var A = E && m.call(n, "__wrapped__")
              , x = y && m.call(e, "__wrapped__");
            if (A || x) {
                var C = A ? n.value() : n
                  , L = x ? e.value() : e;
                return g || (g = new a),
                h(C, L, t, p, g)
            }
        }
        return !!T && (g || (g = new a),
        o(n, e, t, p, h, g))
    }
}
, function(n, e) {
    n.exports = function(n) {
        return this.__data__.set(n, "__lodash_hash_undefined__"),
        this
    }
}
, function(n, e) {
    n.exports = function(n) {
        return this.__data__.has(n)
    }
}
, function(n, e) {
    n.exports = function(n, e) {
        for (var t = -1, a = null == n ? 0 : n.length; ++t < a; )
            if (e(n[t], t, n))
                return !0;
        return !1
    }
}
, function(n, e, t) {
    var a = t(15)
      , i = t(184)
      , r = t(71)
      , o = t(75)
      , l = t(185)
      , s = t(42)
      , c = a ? a.prototype : void 0
      , d = c ? c.valueOf : void 0;
    n.exports = function(n, e, t, a, c, u, m) {
        switch (t) {
        case "[object DataView]":
            if (n.byteLength != e.byteLength || n.byteOffset != e.byteOffset)
                return !1;
            n = n.buffer,
            e = e.buffer;
        case "[object ArrayBuffer]":
            return !(n.byteLength != e.byteLength || !u(new i(n), new i(e)));
        case "[object Boolean]":
        case "[object Date]":
        case "[object Number]":
            return r(+n, +e);
        case "[object Error]":
            return n.name == e.name && n.message == e.message;
        case "[object RegExp]":
        case "[object String]":
            return n == e + "";
        case "[object Map]":
            var p = l;
        case "[object Set]":
            var h = 1 & a;
            if (p || (p = s),
            n.size != e.size && !h)
                return !1;
            var g = m.get(n);
            if (g)
                return g == e;
            a |= 2,
            m.set(n, e);
            var _ = o(p(n), p(e), a, c, u, m);
            return m.delete(n),
            _;
        case "[object Symbol]":
            if (d)
                return d.call(n) == d.call(e)
        }
        return !1
    }
}
, function(n, e, t) {
    var a = t(6).Uint8Array;
    n.exports = a
}
, function(n, e) {
    n.exports = function(n) {
        var e = -1
          , t = Array(n.size);
        return n.forEach((function(n, a) {
            t[++e] = [a, n]
        }
        )),
        t
    }
}
, function(n, e, t) {
    var a = t(187)
      , i = Object.prototype.hasOwnProperty;
    n.exports = function(n, e, t, r, o, l) {
        var s = 1 & t
          , c = a(n)
          , d = c.length;
        if (d != a(e).length && !s)
            return !1;
        for (var u = d; u--; ) {
            var m = c[u];
            if (!(s ? m in e : i.call(e, m)))
                return !1
        }
        var p = l.get(n)
          , h = l.get(e);
        if (p && h)
            return p == e && h == n;
        var g = !0;
        l.set(n, e),
        l.set(e, n);
        for (var _ = s; ++u < d; ) {
            var v = n[m = c[u]]
              , b = e[m];
            if (r)
                var f = s ? r(b, v, m, e, n, l) : r(v, b, m, n, e, l);
            if (!(void 0 === f ? v === b || o(v, b, t, r, l) : f)) {
                g = !1;
                break
            }
            _ || (_ = "constructor" == m)
        }
        if (g && !_) {
            var E = n.constructor
              , y = e.constructor;
            E == y || !("constructor"in n) || !("constructor"in e) || "function" == typeof E && E instanceof E && "function" == typeof y && y instanceof y || (g = !1)
        }
        return l.delete(n),
        l.delete(e),
        g
    }
}
, function(n, e, t) {
    var a = t(188)
      , i = t(189)
      , r = t(78);
    n.exports = function(n) {
        return a(n, r, i)
    }
}
, function(n, e, t) {
    var a = t(68)
      , i = t(5);
    n.exports = function(n, e, t) {
        var r = e(n);
        return i(n) ? r : a(r, t(n))
    }
}
, function(n, e, t) {
    var a = t(190)
      , i = t(191)
      , r = Object.prototype.propertyIsEnumerable
      , o = Object.getOwnPropertySymbols
      , l = o ? function(n) {
        return null == n ? [] : (n = Object(n),
        a(o(n), (function(e) {
            return r.call(n, e)
        }
        )))
    }
    : i;
    n.exports = l
}
, function(n, e) {
    n.exports = function(n, e) {
        for (var t = -1, a = null == n ? 0 : n.length, i = 0, r = []; ++t < a; ) {
            var o = n[t];
            e(o, t, n) && (r[i++] = o)
        }
        return r
    }
}
, function(n, e) {
    n.exports = function() {
        return []
    }
}
, function(n, e, t) {
    var a = t(193)
      , i = t(38)
      , r = t(5)
      , o = t(79)
      , l = t(80)
      , s = t(81)
      , c = Object.prototype.hasOwnProperty;
    n.exports = function(n, e) {
        var t = r(n)
          , d = !t && i(n)
          , u = !t && !d && o(n)
          , m = !t && !d && !u && s(n)
          , p = t || d || u || m
          , h = p ? a(n.length, String) : []
          , g = h.length;
        for (var _ in n)
            !e && !c.call(n, _) || p && ("length" == _ || u && ("offset" == _ || "parent" == _) || m && ("buffer" == _ || "byteLength" == _ || "byteOffset" == _) || l(_, g)) || h.push(_);
        return h
    }
}
, function(n, e) {
    n.exports = function(n, e) {
        for (var t = -1, a = Array(n); ++t < n; )
            a[t] = e(t);
        return a
    }
}
, function(n, e) {
    n.exports = function() {
        return !1
    }
}
, function(n, e, t) {
    var a = t(13)
      , i = t(43)
      , r = t(12)
      , o = {};
    o["[object Float32Array]"] = o["[object Float64Array]"] = o["[object Int8Array]"] = o["[object Int16Array]"] = o["[object Int32Array]"] = o["[object Uint8Array]"] = o["[object Uint8ClampedArray]"] = o["[object Uint16Array]"] = o["[object Uint32Array]"] = !0,
    o["[object Arguments]"] = o["[object Array]"] = o["[object ArrayBuffer]"] = o["[object Boolean]"] = o["[object DataView]"] = o["[object Date]"] = o["[object Error]"] = o["[object Function]"] = o["[object Map]"] = o["[object Number]"] = o["[object Object]"] = o["[object RegExp]"] = o["[object Set]"] = o["[object String]"] = o["[object WeakMap]"] = !1,
    n.exports = function(n) {
        return r(n) && i(n.length) && !!o[a(n)]
    }
}
, function(n, e) {
    n.exports = function(n) {
        return function(e) {
            return n(e)
        }
    }
}
, function(n, e, t) {
    (function(n) {
        var a = t(69)
          , i = e && !e.nodeType && e
          , r = i && "object" == typeof n && n && !n.nodeType && n
          , o = r && r.exports === i && a.process
          , l = function() {
            try {
                var n = r && r.require && r.require("util").types;
                return n || o && o.binding && o.binding("util")
            } catch (n) {}
        }();
        n.exports = l
    }
    ).call(this, t(49)(n))
}
, function(n, e, t) {
    var a = t(199)
      , i = t(200)
      , r = Object.prototype.hasOwnProperty;
    n.exports = function(n) {
        if (!a(n))
            return i(n);
        var e = [];
        for (var t in Object(n))
            r.call(n, t) && "constructor" != t && e.push(t);
        return e
    }
}
, function(n, e) {
    var t = Object.prototype;
    n.exports = function(n) {
        var e = n && n.constructor;
        return n === ("function" == typeof e && e.prototype || t)
    }
}
, function(n, e, t) {
    var a = t(201)(Object.keys, Object);
    n.exports = a
}
, function(n, e) {
    n.exports = function(n, e) {
        return function(t) {
            return n(e(t))
        }
    }
}
, function(n, e, t) {
    var a = t(203)
      , i = t(39)
      , r = t(204)
      , o = t(83)
      , l = t(205)
      , s = t(13)
      , c = t(73)
      , d = c(a)
      , u = c(i)
      , m = c(r)
      , p = c(o)
      , h = c(l)
      , g = s;
    (a && "[object DataView]" != g(new a(new ArrayBuffer(1))) || i && "[object Map]" != g(new i) || r && "[object Promise]" != g(r.resolve()) || o && "[object Set]" != g(new o) || l && "[object WeakMap]" != g(new l)) && (g = function(n) {
        var e = s(n)
          , t = "[object Object]" == e ? n.constructor : void 0
          , a = t ? c(t) : "";
        if (a)
            switch (a) {
            case d:
                return "[object DataView]";
            case u:
                return "[object Map]";
            case m:
                return "[object Promise]";
            case p:
                return "[object Set]";
            case h:
                return "[object WeakMap]"
            }
        return e
    }
    ),
    n.exports = g
}
, function(n, e, t) {
    var a = t(10)(t(6), "DataView");
    n.exports = a
}
, function(n, e, t) {
    var a = t(10)(t(6), "Promise");
    n.exports = a
}
, function(n, e, t) {
    var a = t(10)(t(6), "WeakMap");
    n.exports = a
}
, function(n, e, t) {
    var a = t(84)
      , i = t(78);
    n.exports = function(n) {
        for (var e = i(n), t = e.length; t--; ) {
            var r = e[t]
              , o = n[r];
            e[t] = [r, o, a(o)]
        }
        return e
    }
}
, function(n, e, t) {
    var a = t(74)
      , i = t(208)
      , r = t(215)
      , o = t(44)
      , l = t(84)
      , s = t(85)
      , c = t(23);
    n.exports = function(n, e) {
        return o(n) && l(e) ? s(c(n), e) : function(t) {
            var o = i(t, n);
            return void 0 === o && o === e ? r(t, n) : a(e, o, 3)
        }
    }
}
, function(n, e, t) {
    var a = t(86);
    n.exports = function(n, e, t) {
        var i = null == n ? void 0 : a(n, e);
        return void 0 === i ? t : i
    }
}
, function(n, e, t) {
    var a = t(210)
      , i = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g
      , r = /\\(\\)?/g
      , o = a((function(n) {
        var e = [];
        return 46 === n.charCodeAt(0) && e.push(""),
        n.replace(i, (function(n, t, a, i) {
            e.push(a ? i.replace(r, "$1") : t || n)
        }
        )),
        e
    }
    ));
    n.exports = o
}
, function(n, e, t) {
    var a = t(211);
    n.exports = function(n) {
        var e = a(n, (function(n) {
            return 500 === t.size && t.clear(),
            n
        }
        ))
          , t = e.cache;
        return e
    }
}
, function(n, e, t) {
    var a = t(41);
    function i(n, e) {
        if ("function" != typeof n || null != e && "function" != typeof e)
            throw new TypeError("Expected a function");
        var t = function() {
            var a = arguments
              , i = e ? e.apply(this, a) : a[0]
              , r = t.cache;
            if (r.has(i))
                return r.get(i);
            var o = n.apply(this, a);
            return t.cache = r.set(i, o) || r,
            o
        };
        return t.cache = new (i.Cache || a),
        t
    }
    i.Cache = a,
    n.exports = i
}
, function(n, e, t) {
    var a = t(213);
    n.exports = function(n) {
        return null == n ? "" : a(n)
    }
}
, function(n, e, t) {
    var a = t(15)
      , i = t(214)
      , r = t(5)
      , o = t(45)
      , l = a ? a.prototype : void 0
      , s = l ? l.toString : void 0;
    n.exports = function n(e) {
        if ("string" == typeof e)
            return e;
        if (r(e))
            return i(e, n) + "";
        if (o(e))
            return s ? s.call(e) : "";
        var t = e + "";
        return "0" == t && 1 / e == -1 / 0 ? "-0" : t
    }
}
, function(n, e) {
    n.exports = function(n, e) {
        for (var t = -1, a = null == n ? 0 : n.length, i = Array(a); ++t < a; )
            i[t] = e(n[t], t, n);
        return i
    }
}
, function(n, e, t) {
    var a = t(216)
      , i = t(217);
    n.exports = function(n, e) {
        return null != n && i(n, e, a)
    }
}
, function(n, e) {
    n.exports = function(n, e) {
        return null != n && e in Object(n)
    }
}
, function(n, e, t) {
    var a = t(87)
      , i = t(38)
      , r = t(5)
      , o = t(80)
      , l = t(43)
      , s = t(23);
    n.exports = function(n, e, t) {
        for (var c = -1, d = (e = a(e, n)).length, u = !1; ++c < d; ) {
            var m = s(e[c]);
            if (!(u = null != n && t(n, m)))
                break;
            n = n[m]
        }
        return u || ++c != d ? u : !!(d = null == n ? 0 : n.length) && l(d) && o(m, d) && (r(n) || i(n))
    }
}
, function(n, e, t) {
    var a = t(219)
      , i = t(220)
      , r = t(44)
      , o = t(23);
    n.exports = function(n) {
        return r(n) ? a(o(n)) : i(n)
    }
}
, function(n, e) {
    n.exports = function(n) {
        return function(e) {
            return null == e ? void 0 : e[n]
        }
    }
}
, function(n, e, t) {
    var a = t(86);
    n.exports = function(n) {
        return function(e) {
            return a(e, n)
        }
    }
}
, function(n, e, t) {
    var a = t(46)
      , i = t(222)
      , r = t(224);
    n.exports = function(n, e) {
        return r(i(n, e, a), n + "")
    }
}
, function(n, e, t) {
    var a = t(223)
      , i = Math.max;
    n.exports = function(n, e, t) {
        return e = i(void 0 === e ? n.length - 1 : e, 0),
        function() {
            for (var r = arguments, o = -1, l = i(r.length - e, 0), s = Array(l); ++o < l; )
                s[o] = r[e + o];
            o = -1;
            for (var c = Array(e + 1); ++o < e; )
                c[o] = r[o];
            return c[e] = t(s),
            a(n, this, c)
        }
    }
}
, function(n, e) {
    n.exports = function(n, e, t) {
        switch (t.length) {
        case 0:
            return n.call(e);
        case 1:
            return n.call(e, t[0]);
        case 2:
            return n.call(e, t[0], t[1]);
        case 3:
            return n.call(e, t[0], t[1], t[2])
        }
        return n.apply(e, t)
    }
}
, function(n, e, t) {
    var a = t(225)
      , i = t(228)(a);
    n.exports = i
}
, function(n, e, t) {
    var a = t(226)
      , i = t(227)
      , r = t(46)
      , o = i ? function(n, e) {
        return i(n, "toString", {
            configurable: !0,
            enumerable: !1,
            value: a(e),
            writable: !0
        })
    }
    : r;
    n.exports = o
}
, function(n, e) {
    n.exports = function(n) {
        return function() {
            return n
        }
    }
}
, function(n, e, t) {
    var a = t(10)
      , i = function() {
        try {
            var n = a(Object, "defineProperty");
            return n({}, "", {}),
            n
        } catch (n) {}
    }();
    n.exports = i
}
, function(n, e) {
    var t = Date.now;
    n.exports = function(n) {
        var e = 0
          , a = 0;
        return function() {
            var i = t()
              , r = 16 - (i - a);
            if (a = i,
            r > 0) {
                if (++e >= 800)
                    return arguments[0]
            } else
                e = 0;
            return n.apply(void 0, arguments)
        }
    }
}
, function(n, e, t) {
    var a = t(76)
      , i = t(230)
      , r = t(235)
      , o = t(77)
      , l = t(236)
      , s = t(42);
    n.exports = function(n, e, t) {
        var c = -1
          , d = i
          , u = n.length
          , m = !0
          , p = []
          , h = p;
        if (t)
            m = !1,
            d = r;
        else if (u >= 200) {
            var g = e ? null : l(n);
            if (g)
                return s(g);
            m = !1,
            d = o,
            h = new a
        } else
            h = e ? [] : p;
        n: for (; ++c < u; ) {
            var _ = n[c]
              , v = e ? e(_) : _;
            if (_ = t || 0 !== _ ? _ : 0,
            m && v == v) {
                for (var b = h.length; b--; )
                    if (h[b] === v)
                        continue n;
                e && h.push(v),
                p.push(_)
            } else
                d(h, v, t) || (h !== p && h.push(v),
                p.push(_))
        }
        return p
    }
}
, function(n, e, t) {
    var a = t(231);
    n.exports = function(n, e) {
        return !!(null == n ? 0 : n.length) && a(n, e, 0) > -1
    }
}
, function(n, e, t) {
    var a = t(232)
      , i = t(233)
      , r = t(234);
    n.exports = function(n, e, t) {
        return e == e ? r(n, e, t) : a(n, i, t)
    }
}
, function(n, e) {
    n.exports = function(n, e, t, a) {
        for (var i = n.length, r = t + (a ? 1 : -1); a ? r-- : ++r < i; )
            if (e(n[r], r, n))
                return r;
        return -1
    }
}
, function(n, e) {
    n.exports = function(n) {
        return n != n
    }
}
, function(n, e) {
    n.exports = function(n, e, t) {
        for (var a = t - 1, i = n.length; ++a < i; )
            if (n[a] === e)
                return a;
        return -1
    }
}
, function(n, e) {
    n.exports = function(n, e, t) {
        for (var a = -1, i = null == n ? 0 : n.length; ++a < i; )
            if (t(e, n[a]))
                return !0;
        return !1
    }
}
, function(n, e, t) {
    var a = t(83)
      , i = t(237)
      , r = t(42)
      , o = a && 1 / r(new a([, -0]))[1] == 1 / 0 ? function(n) {
        return new a(n)
    }
    : i;
    n.exports = o
}
, function(n, e) {
    n.exports = function() {}
}
, function(n, e, t) {
    var a = t(82)
      , i = t(12);
    n.exports = function(n) {
        return i(n) && a(n)
    }
}
, function(n, e, t) {}
, function(n, e, t) {}
, function(n, e, t) {
    "use strict";
    t(88)
}
, function(n, e, t) {
    "use strict";
    t(89)
}
, function(n, e, t) {}
, function(n, e, t) {}
, function(n, e, t) {
    "use strict";
    t(90)
}
, function(n, e, t) {
    "use strict";
    t(91)
}
, function(n, e, t) {
    "use strict";
    t.r(e);
    /*!
 * Vue.js v2.7.14
 * (c) 2014-2022 Evan You
 * Released under the MIT License.
 */
    var a = Object.freeze({})
      , i = Array.isArray;
    function r(n) {
        return null == n
    }
    function o(n) {
        return null != n
    }
    function l(n) {
        return !0 === n
    }
    function s(n) {
        return "string" == typeof n || "number" == typeof n || "symbol" == typeof n || "boolean" == typeof n
    }
    function c(n) {
        return "function" == typeof n
    }
    function d(n) {
        return null !== n && "object" == typeof n
    }
    var u = Object.prototype.toString;
    function m(n) {
        return "[object Object]" === u.call(n)
    }
    function p(n) {
        return "[object RegExp]" === u.call(n)
    }
    function h(n) {
        var e = parseFloat(String(n));
        return e >= 0 && Math.floor(e) === e && isFinite(n)
    }
    function g(n) {
        return o(n) && "function" == typeof n.then && "function" == typeof n.catch
    }
    function _(n) {
        return null == n ? "" : Array.isArray(n) || m(n) && n.toString === u ? JSON.stringify(n, null, 2) : String(n)
    }
    function v(n) {
        var e = parseFloat(n);
        return isNaN(e) ? n : e
    }
    function b(n, e) {
        for (var t = Object.create(null), a = n.split(","), i = 0; i < a.length; i++)
            t[a[i]] = !0;
        return e ? function(n) {
            return t[n.toLowerCase()]
        }
        : function(n) {
            return t[n]
        }
    }
    b("slot,component", !0);
    var f = b("key,ref,slot,slot-scope,is");
    function E(n, e) {
        var t = n.length;
        if (t) {
            if (e === n[t - 1])
                return void (n.length = t - 1);
            var a = n.indexOf(e);
            if (a > -1)
                return n.splice(a, 1)
        }
    }
    var y = Object.prototype.hasOwnProperty;
    function T(n, e) {
        return y.call(n, e)
    }
    function A(n) {
        var e = Object.create(null);
        return function(t) {
            return e[t] || (e[t] = n(t))
        }
    }
    var x = /-(\w)/g
      , C = A((function(n) {
        return n.replace(x, (function(n, e) {
            return e ? e.toUpperCase() : ""
        }
        ))
    }
    ))
      , L = A((function(n) {
        return n.charAt(0).toUpperCase() + n.slice(1)
    }
    ))
      , N = /\B([A-Z])/g
      , M = A((function(n) {
        return n.replace(N, "-$1").toLowerCase()
    }
    ));
    var k = Function.prototype.bind ? function(n, e) {
        return n.bind(e)
    }
    : function(n, e) {
        function t(t) {
            var a = arguments.length;
            return a ? a > 1 ? n.apply(e, arguments) : n.call(e, t) : n.call(e)
        }
        return t._length = n.length,
        t
    }
    ;
    function O(n, e) {
        e = e || 0;
        for (var t = n.length - e, a = new Array(t); t--; )
            a[t] = n[t + e];
        return a
    }
    function I(n, e) {
        for (var t in e)
            n[t] = e[t];
        return n
    }
    function S(n) {
        for (var e = {}, t = 0; t < n.length; t++)
            n[t] && I(e, n[t]);
        return e
    }
    function R(n, e, t) {}
    var w = function(n, e, t) {
        return !1
    }
      , U = function(n) {
        return n
    };
    function z(n, e) {
        if (n === e)
            return !0;
        var t = d(n)
          , a = d(e);
        if (!t || !a)
            return !t && !a && String(n) === String(e);
        try {
            var i = Array.isArray(n)
              , r = Array.isArray(e);
            if (i && r)
                return n.length === e.length && n.every((function(n, t) {
                    return z(n, e[t])
                }
                ));
            if (n instanceof Date && e instanceof Date)
                return n.getTime() === e.getTime();
            if (i || r)
                return !1;
            var o = Object.keys(n)
              , l = Object.keys(e);
            return o.length === l.length && o.every((function(t) {
                return z(n[t], e[t])
            }
            ))
        } catch (n) {
            return !1
        }
    }
    function P(n, e) {
        for (var t = 0; t < n.length; t++)
            if (z(n[t], e))
                return t;
        return -1
    }
    function D(n) {
        var e = !1;
        return function() {
            e || (e = !0,
            n.apply(this, arguments))
        }
    }
    function B(n, e) {
        return n === e ? 0 === n && 1 / n != 1 / e : n == n || e == e
    }
    var j = ["component", "directive", "filter"]
      , F = ["beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeDestroy", "destroyed", "activated", "deactivated", "errorCaptured", "serverPrefetch", "renderTracked", "renderTriggered"]
      , q = {
        optionMergeStrategies: Object.create(null),
        silent: !1,
        productionTip: !1,
        devtools: !1,
        performance: !1,
        errorHandler: null,
        warnHandler: null,
        ignoredElements: [],
        keyCodes: Object.create(null),
        isReservedTag: w,
        isReservedAttr: w,
        isUnknownElement: w,
        getTagNamespace: R,
        parsePlatformTagName: U,
        mustUseProp: w,
        async: !0,
        _lifecycleHooks: F
    }
      , V = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;
    function H(n) {
        var e = (n + "").charCodeAt(0);
        return 36 === e || 95 === e
    }
    function K(n, e, t, a) {
        Object.defineProperty(n, e, {
            value: t,
            enumerable: !!a,
            writable: !0,
            configurable: !0
        })
    }
    var G = new RegExp("[^".concat(V.source, ".$_\\d]"));
    var Y = "__proto__"in {}
      , J = "undefined" != typeof window
      , W = J && window.navigator.userAgent.toLowerCase()
      , Q = W && /msie|trident/.test(W)
      , Z = W && W.indexOf("msie 9.0") > 0
      , X = W && W.indexOf("edge/") > 0;
    W && W.indexOf("android");
    var nn = W && /iphone|ipad|ipod|ios/.test(W);
    W && /chrome\/\d+/.test(W),
    W && /phantomjs/.test(W);
    var en, tn = W && W.match(/firefox\/(\d+)/), an = {}.watch, rn = !1;
    if (J)
        try {
            var on = {};
            Object.defineProperty(on, "passive", {
                get: function() {
                    rn = !0
                }
            }),
            window.addEventListener("test-passive", null, on)
        } catch (n) {}
    var ln = function() {
        return void 0 === en && (en = !J && "undefined" != typeof global && (global.process && "server" === global.process.env.VUE_ENV)),
        en
    }
      , sn = J && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
    function cn(n) {
        return "function" == typeof n && /native code/.test(n.toString())
    }
    var dn, un = "undefined" != typeof Symbol && cn(Symbol) && "undefined" != typeof Reflect && cn(Reflect.ownKeys);
    dn = "undefined" != typeof Set && cn(Set) ? Set : function() {
        function n() {
            this.set = Object.create(null)
        }
        return n.prototype.has = function(n) {
            return !0 === this.set[n]
        }
        ,
        n.prototype.add = function(n) {
            this.set[n] = !0
        }
        ,
        n.prototype.clear = function() {
            this.set = Object.create(null)
        }
        ,
        n
    }();
    var mn = null;
    function pn(n) {
        void 0 === n && (n = null),
        n || mn && mn._scope.off(),
        mn = n,
        n && n._scope.on()
    }
    var hn = function() {
        function n(n, e, t, a, i, r, o, l) {
            this.tag = n,
            this.data = e,
            this.children = t,
            this.text = a,
            this.elm = i,
            this.ns = void 0,
            this.context = r,
            this.fnContext = void 0,
            this.fnOptions = void 0,
            this.fnScopeId = void 0,
            this.key = e && e.key,
            this.componentOptions = o,
            this.componentInstance = void 0,
            this.parent = void 0,
            this.raw = !1,
            this.isStatic = !1,
            this.isRootInsert = !0,
            this.isComment = !1,
            this.isCloned = !1,
            this.isOnce = !1,
            this.asyncFactory = l,
            this.asyncMeta = void 0,
            this.isAsyncPlaceholder = !1
        }
        return Object.defineProperty(n.prototype, "child", {
            get: function() {
                return this.componentInstance
            },
            enumerable: !1,
            configurable: !0
        }),
        n
    }()
      , gn = function(n) {
        void 0 === n && (n = "");
        var e = new hn;
        return e.text = n,
        e.isComment = !0,
        e
    };
    function _n(n) {
        return new hn(void 0,void 0,void 0,String(n))
    }
    function vn(n) {
        var e = new hn(n.tag,n.data,n.children && n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);
        return e.ns = n.ns,
        e.isStatic = n.isStatic,
        e.key = n.key,
        e.isComment = n.isComment,
        e.fnContext = n.fnContext,
        e.fnOptions = n.fnOptions,
        e.fnScopeId = n.fnScopeId,
        e.asyncMeta = n.asyncMeta,
        e.isCloned = !0,
        e
    }
    var bn = 0
      , fn = []
      , En = function() {
        function n() {
            this._pending = !1,
            this.id = bn++,
            this.subs = []
        }
        return n.prototype.addSub = function(n) {
            this.subs.push(n)
        }
        ,
        n.prototype.removeSub = function(n) {
            this.subs[this.subs.indexOf(n)] = null,
            this._pending || (this._pending = !0,
            fn.push(this))
        }
        ,
        n.prototype.depend = function(e) {
            n.target && n.target.addDep(this)
        }
        ,
        n.prototype.notify = function(n) {
            var e = this.subs.filter((function(n) {
                return n
            }
            ));
            for (var t = 0, a = e.length; t < a; t++) {
                0,
                e[t].update()
            }
        }
        ,
        n
    }();
    En.target = null;
    var yn = [];
    function Tn(n) {
        yn.push(n),
        En.target = n
    }
    function An() {
        yn.pop(),
        En.target = yn[yn.length - 1]
    }
    var xn = Array.prototype
      , Cn = Object.create(xn);
    ["push", "pop", "shift", "unshift", "splice", "sort", "reverse"].forEach((function(n) {
        var e = xn[n];
        K(Cn, n, (function() {
            for (var t = [], a = 0; a < arguments.length; a++)
                t[a] = arguments[a];
            var i, r = e.apply(this, t), o = this.__ob__;
            switch (n) {
            case "push":
            case "unshift":
                i = t;
                break;
            case "splice":
                i = t.slice(2)
            }
            return i && o.observeArray(i),
            o.dep.notify(),
            r
        }
        ))
    }
    ));
    var Ln = Object.getOwnPropertyNames(Cn)
      , Nn = {}
      , Mn = !0;
    function kn(n) {
        Mn = n
    }
    var On = {
        notify: R,
        depend: R,
        addSub: R,
        removeSub: R
    }
      , In = function() {
        function n(n, e, t) {
            if (void 0 === e && (e = !1),
            void 0 === t && (t = !1),
            this.value = n,
            this.shallow = e,
            this.mock = t,
            this.dep = t ? On : new En,
            this.vmCount = 0,
            K(n, "__ob__", this),
            i(n)) {
                if (!t)
                    if (Y)
                        n.__proto__ = Cn;
                    else
                        for (var a = 0, r = Ln.length; a < r; a++) {
                            K(n, l = Ln[a], Cn[l])
                        }
                e || this.observeArray(n)
            } else {
                var o = Object.keys(n);
                for (a = 0; a < o.length; a++) {
                    var l;
                    Rn(n, l = o[a], Nn, void 0, e, t)
                }
            }
        }
        return n.prototype.observeArray = function(n) {
            for (var e = 0, t = n.length; e < t; e++)
                Sn(n[e], !1, this.mock)
        }
        ,
        n
    }();
    function Sn(n, e, t) {
        return n && T(n, "__ob__") && n.__ob__ instanceof In ? n.__ob__ : !Mn || !t && ln() || !i(n) && !m(n) || !Object.isExtensible(n) || n.__v_skip || jn(n) || n instanceof hn ? void 0 : new In(n,e,t)
    }
    function Rn(n, e, t, a, r, o) {
        var l = new En
          , s = Object.getOwnPropertyDescriptor(n, e);
        if (!s || !1 !== s.configurable) {
            var c = s && s.get
              , d = s && s.set;
            c && !d || t !== Nn && 2 !== arguments.length || (t = n[e]);
            var u = !r && Sn(t, !1, o);
            return Object.defineProperty(n, e, {
                enumerable: !0,
                configurable: !0,
                get: function() {
                    var e = c ? c.call(n) : t;
                    return En.target && (l.depend(),
                    u && (u.dep.depend(),
                    i(e) && zn(e))),
                    jn(e) && !r ? e.value : e
                },
                set: function(e) {
                    var a = c ? c.call(n) : t;
                    if (B(a, e)) {
                        if (d)
                            d.call(n, e);
                        else {
                            if (c)
                                return;
                            if (!r && jn(a) && !jn(e))
                                return void (a.value = e);
                            t = e
                        }
                        u = !r && Sn(e, !1, o),
                        l.notify()
                    }
                }
            }),
            l
        }
    }
    function wn(n, e, t) {
        if (!Bn(n)) {
            var a = n.__ob__;
            return i(n) && h(e) ? (n.length = Math.max(n.length, e),
            n.splice(e, 1, t),
            a && !a.shallow && a.mock && Sn(t, !1, !0),
            t) : e in n && !(e in Object.prototype) ? (n[e] = t,
            t) : n._isVue || a && a.vmCount ? t : a ? (Rn(a.value, e, t, void 0, a.shallow, a.mock),
            a.dep.notify(),
            t) : (n[e] = t,
            t)
        }
    }
    function Un(n, e) {
        if (i(n) && h(e))
            n.splice(e, 1);
        else {
            var t = n.__ob__;
            n._isVue || t && t.vmCount || Bn(n) || T(n, e) && (delete n[e],
            t && t.dep.notify())
        }
    }
    function zn(n) {
        for (var e = void 0, t = 0, a = n.length; t < a; t++)
            (e = n[t]) && e.__ob__ && e.__ob__.dep.depend(),
            i(e) && zn(e)
    }
    function Pn(n) {
        return Dn(n, !0),
        K(n, "__v_isShallow", !0),
        n
    }
    function Dn(n, e) {
        if (!Bn(n)) {
            Sn(n, e, ln());
            0
        }
    }
    function Bn(n) {
        return !(!n || !n.__v_isReadonly)
    }
    function jn(n) {
        return !(!n || !0 !== n.__v_isRef)
    }
    function Fn(n, e, t) {
        Object.defineProperty(n, t, {
            enumerable: !0,
            configurable: !0,
            get: function() {
                var n = e[t];
                if (jn(n))
                    return n.value;
                var a = n && n.__ob__;
                return a && a.dep.depend(),
                n
            },
            set: function(n) {
                var a = e[t];
                jn(a) && !jn(n) ? a.value = n : e[t] = n
            }
        })
    }
    "".concat("watcher", " callback"),
    "".concat("watcher", " getter"),
    "".concat("watcher", " cleanup");
    var qn;
    var Vn = function() {
        function n(n) {
            void 0 === n && (n = !1),
            this.detached = n,
            this.active = !0,
            this.effects = [],
            this.cleanups = [],
            this.parent = qn,
            !n && qn && (this.index = (qn.scopes || (qn.scopes = [])).push(this) - 1)
        }
        return n.prototype.run = function(n) {
            if (this.active) {
                var e = qn;
                try {
                    return qn = this,
                    n()
                } finally {
                    qn = e
                }
            } else
                0
        }
        ,
        n.prototype.on = function() {
            qn = this
        }
        ,
        n.prototype.off = function() {
            qn = this.parent
        }
        ,
        n.prototype.stop = function(n) {
            if (this.active) {
                var e = void 0
                  , t = void 0;
                for (e = 0,
                t = this.effects.length; e < t; e++)
                    this.effects[e].teardown();
                for (e = 0,
                t = this.cleanups.length; e < t; e++)
                    this.cleanups[e]();
                if (this.scopes)
                    for (e = 0,
                    t = this.scopes.length; e < t; e++)
                        this.scopes[e].stop(!0);
                if (!this.detached && this.parent && !n) {
                    var a = this.parent.scopes.pop();
                    a && a !== this && (this.parent.scopes[this.index] = a,
                    a.index = this.index)
                }
                this.parent = void 0,
                this.active = !1
            }
        }
        ,
        n
    }();
    function Hn(n) {
        var e = n._provided
          , t = n.$parent && n.$parent._provided;
        return t === e ? n._provided = Object.create(t) : e
    }
    var $n = A((function(n) {
        var e = "&" === n.charAt(0)
          , t = "~" === (n = e ? n.slice(1) : n).charAt(0)
          , a = "!" === (n = t ? n.slice(1) : n).charAt(0);
        return {
            name: n = a ? n.slice(1) : n,
            once: t,
            capture: a,
            passive: e
        }
    }
    ));
    function Kn(n, e) {
        function t() {
            var n = t.fns;
            if (!i(n))
                return Me(n, null, arguments, e, "v-on handler");
            for (var a = n.slice(), r = 0; r < a.length; r++)
                Me(a[r], null, arguments, e, "v-on handler")
        }
        return t.fns = n,
        t
    }
    function Gn(n, e, t, a, i, o) {
        var s, c, d, u;
        for (s in n)
            c = n[s],
            d = e[s],
            u = $n(s),
            r(c) || (r(d) ? (r(c.fns) && (c = n[s] = Kn(c, o)),
            l(u.once) && (c = n[s] = i(u.name, c, u.capture)),
            t(u.name, c, u.capture, u.passive, u.params)) : c !== d && (d.fns = c,
            n[s] = d));
        for (s in e)
            r(n[s]) && a((u = $n(s)).name, e[s], u.capture)
    }
    function Yn(n, e, t) {
        var a;
        n instanceof hn && (n = n.data.hook || (n.data.hook = {}));
        var i = n[e];
        function s() {
            t.apply(this, arguments),
            E(a.fns, s)
        }
        r(i) ? a = Kn([s]) : o(i.fns) && l(i.merged) ? (a = i).fns.push(s) : a = Kn([i, s]),
        a.merged = !0,
        n[e] = a
    }
    function Jn(n, e, t, a, i) {
        if (o(e)) {
            if (T(e, t))
                return n[t] = e[t],
                i || delete e[t],
                !0;
            if (T(e, a))
                return n[t] = e[a],
                i || delete e[a],
                !0
        }
        return !1
    }
    function Wn(n) {
        return s(n) ? [_n(n)] : i(n) ? function n(e, t) {
            var a, c, d, u, m = [];
            for (a = 0; a < e.length; a++)
                r(c = e[a]) || "boolean" == typeof c || (d = m.length - 1,
                u = m[d],
                i(c) ? c.length > 0 && (Qn((c = n(c, "".concat(t || "", "_").concat(a)))[0]) && Qn(u) && (m[d] = _n(u.text + c[0].text),
                c.shift()),
                m.push.apply(m, c)) : s(c) ? Qn(u) ? m[d] = _n(u.text + c) : "" !== c && m.push(_n(c)) : Qn(c) && Qn(u) ? m[d] = _n(u.text + c.text) : (l(e._isVList) && o(c.tag) && r(c.key) && o(t) && (c.key = "__vlist".concat(t, "_").concat(a, "__")),
                m.push(c)));
            return m
        }(n) : void 0
    }
    function Qn(n) {
        return o(n) && o(n.text) && !1 === n.isComment
    }
    function Zn(n, e) {
        var t, a, r, l, s = null;
        if (i(n) || "string" == typeof n)
            for (s = new Array(n.length),
            t = 0,
            a = n.length; t < a; t++)
                s[t] = e(n[t], t);
        else if ("number" == typeof n)
            for (s = new Array(n),
            t = 0; t < n; t++)
                s[t] = e(t + 1, t);
        else if (d(n))
            if (un && n[Symbol.iterator]) {
                s = [];
                for (var c = n[Symbol.iterator](), u = c.next(); !u.done; )
                    s.push(e(u.value, s.length)),
                    u = c.next()
            } else
                for (r = Object.keys(n),
                s = new Array(r.length),
                t = 0,
                a = r.length; t < a; t++)
                    l = r[t],
                    s[t] = e(n[l], l, t);
        return o(s) || (s = []),
        s._isVList = !0,
        s
    }
    function Xn(n, e, t, a) {
        var i, r = this.$scopedSlots[n];
        r ? (t = t || {},
        a && (t = I(I({}, a), t)),
        i = r(t) || (c(e) ? e() : e)) : i = this.$slots[n] || (c(e) ? e() : e);
        var o = t && t.slot;
        return o ? this.$createElement("template", {
            slot: o
        }, i) : i
    }
    function ne(n) {
        return It(this.$options, "filters", n, !0) || U
    }
    function ee(n, e) {
        return i(n) ? -1 === n.indexOf(e) : n !== e
    }
    function te(n, e, t, a, i) {
        var r = q.keyCodes[e] || t;
        return i && a && !q.keyCodes[e] ? ee(i, a) : r ? ee(r, n) : a ? M(a) !== e : void 0 === n
    }
    function ae(n, e, t, a, r) {
        if (t)
            if (d(t)) {
                i(t) && (t = S(t));
                var o = void 0
                  , l = function(i) {
                    if ("class" === i || "style" === i || f(i))
                        o = n;
                    else {
                        var l = n.attrs && n.attrs.type;
                        o = a || q.mustUseProp(e, l, i) ? n.domProps || (n.domProps = {}) : n.attrs || (n.attrs = {})
                    }
                    var s = C(i)
                      , c = M(i);
                    s in o || c in o || (o[i] = t[i],
                    r && ((n.on || (n.on = {}))["update:".concat(i)] = function(n) {
                        t[i] = n
                    }
                    ))
                };
                for (var s in t)
                    l(s)
            } else
                ;return n
    }
    function ie(n, e) {
        var t = this._staticTrees || (this._staticTrees = [])
          , a = t[n];
        return a && !e || oe(a = t[n] = this.$options.staticRenderFns[n].call(this._renderProxy, this._c, this), "__static__".concat(n), !1),
        a
    }
    function re(n, e, t) {
        return oe(n, "__once__".concat(e).concat(t ? "_".concat(t) : ""), !0),
        n
    }
    function oe(n, e, t) {
        if (i(n))
            for (var a = 0; a < n.length; a++)
                n[a] && "string" != typeof n[a] && le(n[a], "".concat(e, "_").concat(a), t);
        else
            le(n, e, t)
    }
    function le(n, e, t) {
        n.isStatic = !0,
        n.key = e,
        n.isOnce = t
    }
    function se(n, e) {
        if (e)
            if (m(e)) {
                var t = n.on = n.on ? I({}, n.on) : {};
                for (var a in e) {
                    var i = t[a]
                      , r = e[a];
                    t[a] = i ? [].concat(i, r) : r
                }
            } else
                ;return n
    }
    function ce(n, e, t, a) {
        e = e || {
            $stable: !t
        };
        for (var r = 0; r < n.length; r++) {
            var o = n[r];
            i(o) ? ce(o, e, t) : o && (o.proxy && (o.fn.proxy = !0),
            e[o.key] = o.fn)
        }
        return a && (e.$key = a),
        e
    }
    function de(n, e) {
        for (var t = 0; t < e.length; t += 2) {
            var a = e[t];
            "string" == typeof a && a && (n[e[t]] = e[t + 1])
        }
        return n
    }
    function ue(n, e) {
        return "string" == typeof n ? e + n : n
    }
    function me(n) {
        n._o = re,
        n._n = v,
        n._s = _,
        n._l = Zn,
        n._t = Xn,
        n._q = z,
        n._i = P,
        n._m = ie,
        n._f = ne,
        n._k = te,
        n._b = ae,
        n._v = _n,
        n._e = gn,
        n._u = ce,
        n._g = se,
        n._d = de,
        n._p = ue
    }
    function pe(n, e) {
        if (!n || !n.length)
            return {};
        for (var t = {}, a = 0, i = n.length; a < i; a++) {
            var r = n[a]
              , o = r.data;
            if (o && o.attrs && o.attrs.slot && delete o.attrs.slot,
            r.context !== e && r.fnContext !== e || !o || null == o.slot)
                (t.default || (t.default = [])).push(r);
            else {
                var l = o.slot
                  , s = t[l] || (t[l] = []);
                "template" === r.tag ? s.push.apply(s, r.children || []) : s.push(r)
            }
        }
        for (var c in t)
            t[c].every(he) && delete t[c];
        return t
    }
    function he(n) {
        return n.isComment && !n.asyncFactory || " " === n.text
    }
    function ge(n) {
        return n.isComment && n.asyncFactory
    }
    function _e(n, e, t, i) {
        var r, o = Object.keys(t).length > 0, l = e ? !!e.$stable : !o, s = e && e.$key;
        if (e) {
            if (e._normalized)
                return e._normalized;
            if (l && i && i !== a && s === i.$key && !o && !i.$hasNormal)
                return i;
            for (var c in r = {},
            e)
                e[c] && "$" !== c[0] && (r[c] = ve(n, t, c, e[c]))
        } else
            r = {};
        for (var d in t)
            d in r || (r[d] = be(t, d));
        return e && Object.isExtensible(e) && (e._normalized = r),
        K(r, "$stable", l),
        K(r, "$key", s),
        K(r, "$hasNormal", o),
        r
    }
    function ve(n, e, t, a) {
        var r = function() {
            var e = mn;
            pn(n);
            var t = arguments.length ? a.apply(null, arguments) : a({})
              , r = (t = t && "object" == typeof t && !i(t) ? [t] : Wn(t)) && t[0];
            return pn(e),
            t && (!r || 1 === t.length && r.isComment && !ge(r)) ? void 0 : t
        };
        return a.proxy && Object.defineProperty(e, t, {
            get: r,
            enumerable: !0,
            configurable: !0
        }),
        r
    }
    function be(n, e) {
        return function() {
            return n[e]
        }
    }
    function fe(n) {
        return {
            get attrs() {
                if (!n._attrsProxy) {
                    var e = n._attrsProxy = {};
                    K(e, "_v_attr_proxy", !0),
                    Ee(e, n.$attrs, a, n, "$attrs")
                }
                return n._attrsProxy
            },
            get listeners() {
                n._listenersProxy || Ee(n._listenersProxy = {}, n.$listeners, a, n, "$listeners");
                return n._listenersProxy
            },
            get slots() {
                return function(n) {
                    n._slotsProxy || Te(n._slotsProxy = {}, n.$scopedSlots);
                    return n._slotsProxy
                }(n)
            },
            emit: k(n.$emit, n),
            expose: function(e) {
                e && Object.keys(e).forEach((function(t) {
                    return Fn(n, e, t)
                }
                ))
            }
        }
    }
    function Ee(n, e, t, a, i) {
        var r = !1;
        for (var o in e)
            o in n ? e[o] !== t[o] && (r = !0) : (r = !0,
            ye(n, o, a, i));
        for (var o in n)
            o in e || (r = !0,
            delete n[o]);
        return r
    }
    function ye(n, e, t, a) {
        Object.defineProperty(n, e, {
            enumerable: !0,
            configurable: !0,
            get: function() {
                return t[a][e]
            }
        })
    }
    function Te(n, e) {
        for (var t in e)
            n[t] = e[t];
        for (var t in n)
            t in e || delete n[t]
    }
    var Ae = null;
    function xe(n, e) {
        return (n.__esModule || un && "Module" === n[Symbol.toStringTag]) && (n = n.default),
        d(n) ? e.extend(n) : n
    }
    function Ce(n) {
        if (i(n))
            for (var e = 0; e < n.length; e++) {
                var t = n[e];
                if (o(t) && (o(t.componentOptions) || ge(t)))
                    return t
            }
    }
    function Le(n, e, t, a, u, m) {
        return (i(t) || s(t)) && (u = a,
        a = t,
        t = void 0),
        l(m) && (u = 2),
        function(n, e, t, a, s) {
            if (o(t) && o(t.__ob__))
                return gn();
            o(t) && o(t.is) && (e = t.is);
            if (!e)
                return gn();
            0;
            i(a) && c(a[0]) && ((t = t || {}).scopedSlots = {
                default: a[0]
            },
            a.length = 0);
            2 === s ? a = Wn(a) : 1 === s && (a = function(n) {
                for (var e = 0; e < n.length; e++)
                    if (i(n[e]))
                        return Array.prototype.concat.apply([], n);
                return n
            }(a));
            var u, m;
            if ("string" == typeof e) {
                var p = void 0;
                m = n.$vnode && n.$vnode.ns || q.getTagNamespace(e),
                u = q.isReservedTag(e) ? new hn(q.parsePlatformTagName(e),t,a,void 0,void 0,n) : t && t.pre || !o(p = It(n.$options, "components", e)) ? new hn(e,t,a,void 0,void 0,n) : yt(p, t, n, a, e)
            } else
                u = yt(e, t, n, a);
            return i(u) ? u : o(u) ? (o(m) && function n(e, t, a) {
                e.ns = t,
                "foreignObject" === e.tag && (t = void 0,
                a = !0);
                if (o(e.children))
                    for (var i = 0, s = e.children.length; i < s; i++) {
                        var c = e.children[i];
                        o(c.tag) && (r(c.ns) || l(a) && "svg" !== c.tag) && n(c, t, a)
                    }
            }(u, m),
            o(t) && function(n) {
                d(n.style) && Ve(n.style);
                d(n.class) && Ve(n.class)
            }(t),
            u) : gn()
        }(n, e, t, a, u)
    }
    function Ne(n, e, t) {
        Tn();
        try {
            if (e)
                for (var a = e; a = a.$parent; ) {
                    var i = a.$options.errorCaptured;
                    if (i)
                        for (var r = 0; r < i.length; r++)
                            try {
                                if (!1 === i[r].call(a, n, e, t))
                                    return
                            } catch (n) {
                                ke(n, a, "errorCaptured hook")
                            }
                }
            ke(n, e, t)
        } finally {
            An()
        }
    }
    function Me(n, e, t, a, i) {
        var r;
        try {
            (r = t ? n.apply(e, t) : n.call(e)) && !r._isVue && g(r) && !r._handled && (r.catch((function(n) {
                return Ne(n, a, i + " (Promise/async)")
            }
            )),
            r._handled = !0)
        } catch (n) {
            Ne(n, a, i)
        }
        return r
    }
    function ke(n, e, t) {
        if (q.errorHandler)
            try {
                return q.errorHandler.call(null, n, e, t)
            } catch (e) {
                e !== n && Oe(e, null, "config.errorHandler")
            }
        Oe(n, e, t)
    }
    function Oe(n, e, t) {
        if (!J || "undefined" == typeof console)
            throw n;
        console.error(n)
    }
    var Ie, Se = !1, Re = [], we = !1;
    function Ue() {
        we = !1;
        var n = Re.slice(0);
        Re.length = 0;
        for (var e = 0; e < n.length; e++)
            n[e]()
    }
    if ("undefined" != typeof Promise && cn(Promise)) {
        var ze = Promise.resolve();
        Ie = function() {
            ze.then(Ue),
            nn && setTimeout(R)
        }
        ,
        Se = !0
    } else if (Q || "undefined" == typeof MutationObserver || !cn(MutationObserver) && "[object MutationObserverConstructor]" !== MutationObserver.toString())
        Ie = "undefined" != typeof setImmediate && cn(setImmediate) ? function() {
            setImmediate(Ue)
        }
        : function() {
            setTimeout(Ue, 0)
        }
        ;
    else {
        var Pe = 1
          , De = new MutationObserver(Ue)
          , Be = document.createTextNode(String(Pe));
        De.observe(Be, {
            characterData: !0
        }),
        Ie = function() {
            Pe = (Pe + 1) % 2,
            Be.data = String(Pe)
        }
        ,
        Se = !0
    }
    function je(n, e) {
        var t;
        if (Re.push((function() {
            if (n)
                try {
                    n.call(e)
                } catch (n) {
                    Ne(n, e, "nextTick")
                }
            else
                t && t(e)
        }
        )),
        we || (we = !0,
        Ie()),
        !n && "undefined" != typeof Promise)
            return new Promise((function(n) {
                t = n
            }
            ))
    }
    function Fe(n) {
        return function(e, t) {
            if (void 0 === t && (t = mn),
            t)
                return function(n, e, t) {
                    var a = n.$options;
                    a[e] = Nt(a[e], t)
                }(t, n, e)
        }
    }
    Fe("beforeMount"),
    Fe("mounted"),
    Fe("beforeUpdate"),
    Fe("updated"),
    Fe("beforeDestroy"),
    Fe("destroyed"),
    Fe("activated"),
    Fe("deactivated"),
    Fe("serverPrefetch"),
    Fe("renderTracked"),
    Fe("renderTriggered"),
    Fe("errorCaptured");
    var qe = new dn;
    function Ve(n) {
        return function n(e, t) {
            var a, r, o = i(e);
            if (!o && !d(e) || e.__v_skip || Object.isFrozen(e) || e instanceof hn)
                return;
            if (e.__ob__) {
                var l = e.__ob__.dep.id;
                if (t.has(l))
                    return;
                t.add(l)
            }
            if (o)
                for (a = e.length; a--; )
                    n(e[a], t);
            else if (jn(e))
                n(e.value, t);
            else
                for (r = Object.keys(e),
                a = r.length; a--; )
                    n(e[r[a]], t)
        }(n, qe),
        qe.clear(),
        n
    }
    var He, $e = 0, Ke = function() {
        function n(n, e, t, a, i) {
            var r, o;
            r = this,
            void 0 === (o = qn && !qn._vm ? qn : n ? n._scope : void 0) && (o = qn),
            o && o.active && o.effects.push(r),
            (this.vm = n) && i && (n._watcher = this),
            a ? (this.deep = !!a.deep,
            this.user = !!a.user,
            this.lazy = !!a.lazy,
            this.sync = !!a.sync,
            this.before = a.before) : this.deep = this.user = this.lazy = this.sync = !1,
            this.cb = t,
            this.id = ++$e,
            this.active = !0,
            this.post = !1,
            this.dirty = this.lazy,
            this.deps = [],
            this.newDeps = [],
            this.depIds = new dn,
            this.newDepIds = new dn,
            this.expression = "",
            c(e) ? this.getter = e : (this.getter = function(n) {
                if (!G.test(n)) {
                    var e = n.split(".");
                    return function(n) {
                        for (var t = 0; t < e.length; t++) {
                            if (!n)
                                return;
                            n = n[e[t]]
                        }
                        return n
                    }
                }
            }(e),
            this.getter || (this.getter = R)),
            this.value = this.lazy ? void 0 : this.get()
        }
        return n.prototype.get = function() {
            var n;
            Tn(this);
            var e = this.vm;
            try {
                n = this.getter.call(e, e)
            } catch (n) {
                if (!this.user)
                    throw n;
                Ne(n, e, 'getter for watcher "'.concat(this.expression, '"'))
            } finally {
                this.deep && Ve(n),
                An(),
                this.cleanupDeps()
            }
            return n
        }
        ,
        n.prototype.addDep = function(n) {
            var e = n.id;
            this.newDepIds.has(e) || (this.newDepIds.add(e),
            this.newDeps.push(n),
            this.depIds.has(e) || n.addSub(this))
        }
        ,
        n.prototype.cleanupDeps = function() {
            for (var n = this.deps.length; n--; ) {
                var e = this.deps[n];
                this.newDepIds.has(e.id) || e.removeSub(this)
            }
            var t = this.depIds;
            this.depIds = this.newDepIds,
            this.newDepIds = t,
            this.newDepIds.clear(),
            t = this.deps,
            this.deps = this.newDeps,
            this.newDeps = t,
            this.newDeps.length = 0
        }
        ,
        n.prototype.update = function() {
            this.lazy ? this.dirty = !0 : this.sync ? this.run() : pt(this)
        }
        ,
        n.prototype.run = function() {
            if (this.active) {
                var n = this.get();
                if (n !== this.value || d(n) || this.deep) {
                    var e = this.value;
                    if (this.value = n,
                    this.user) {
                        var t = 'callback for watcher "'.concat(this.expression, '"');
                        Me(this.cb, this.vm, [n, e], this.vm, t)
                    } else
                        this.cb.call(this.vm, n, e)
                }
            }
        }
        ,
        n.prototype.evaluate = function() {
            this.value = this.get(),
            this.dirty = !1
        }
        ,
        n.prototype.depend = function() {
            for (var n = this.deps.length; n--; )
                this.deps[n].depend()
        }
        ,
        n.prototype.teardown = function() {
            if (this.vm && !this.vm._isBeingDestroyed && E(this.vm._scope.effects, this),
            this.active) {
                for (var n = this.deps.length; n--; )
                    this.deps[n].removeSub(this);
                this.active = !1,
                this.onStop && this.onStop()
            }
        }
        ,
        n
    }();
    function Ge(n, e) {
        He.$on(n, e)
    }
    function Ye(n, e) {
        He.$off(n, e)
    }
    function Je(n, e) {
        var t = He;
        return function a() {
            var i = e.apply(null, arguments);
            null !== i && t.$off(n, a)
        }
    }
    function We(n, e, t) {
        He = n,
        Gn(e, t || {}, Ge, Ye, Je, n),
        He = void 0
    }
    var Qe = null;
    function Ze(n) {
        var e = Qe;
        return Qe = n,
        function() {
            Qe = e
        }
    }
    function Xe(n) {
        for (; n && (n = n.$parent); )
            if (n._inactive)
                return !0;
        return !1
    }
    function nt(n, e) {
        if (e) {
            if (n._directInactive = !1,
            Xe(n))
                return
        } else if (n._directInactive)
            return;
        if (n._inactive || null === n._inactive) {
            n._inactive = !1;
            for (var t = 0; t < n.$children.length; t++)
                nt(n.$children[t]);
            et(n, "activated")
        }
    }
    function et(n, e, t, a) {
        void 0 === a && (a = !0),
        Tn();
        var i = mn;
        a && pn(n);
        var r = n.$options[e]
          , o = "".concat(e, " hook");
        if (r)
            for (var l = 0, s = r.length; l < s; l++)
                Me(r[l], n, t || null, n, o);
        n._hasHookEvent && n.$emit("hook:" + e),
        a && pn(i),
        An()
    }
    var tt = []
      , at = []
      , it = {}
      , rt = !1
      , ot = !1
      , lt = 0;
    var st = 0
      , ct = Date.now;
    if (J && !Q) {
        var dt = window.performance;
        dt && "function" == typeof dt.now && ct() > document.createEvent("Event").timeStamp && (ct = function() {
            return dt.now()
        }
        )
    }
    var ut = function(n, e) {
        if (n.post) {
            if (!e.post)
                return 1
        } else if (e.post)
            return -1;
        return n.id - e.id
    };
    function mt() {
        var n, e;
        for (st = ct(),
        ot = !0,
        tt.sort(ut),
        lt = 0; lt < tt.length; lt++)
            (n = tt[lt]).before && n.before(),
            e = n.id,
            it[e] = null,
            n.run();
        var t = at.slice()
          , a = tt.slice();
        lt = tt.length = at.length = 0,
        it = {},
        rt = ot = !1,
        function(n) {
            for (var e = 0; e < n.length; e++)
                n[e]._inactive = !0,
                nt(n[e], !0)
        }(t),
        function(n) {
            var e = n.length;
            for (; e--; ) {
                var t = n[e]
                  , a = t.vm;
                a && a._watcher === t && a._isMounted && !a._isDestroyed && et(a, "updated")
            }
        }(a),
        function() {
            for (var n = 0; n < fn.length; n++) {
                var e = fn[n];
                e.subs = e.subs.filter((function(n) {
                    return n
                }
                )),
                e._pending = !1
            }
            fn.length = 0
        }(),
        sn && q.devtools && sn.emit("flush")
    }
    function pt(n) {
        var e = n.id;
        if (null == it[e] && (n !== En.target || !n.noRecurse)) {
            if (it[e] = !0,
            ot) {
                for (var t = tt.length - 1; t > lt && tt[t].id > n.id; )
                    t--;
                tt.splice(t + 1, 0, n)
            } else
                tt.push(n);
            rt || (rt = !0,
            je(mt))
        }
    }
    function ht(n, e) {
        if (n) {
            for (var t = Object.create(null), a = un ? Reflect.ownKeys(n) : Object.keys(n), i = 0; i < a.length; i++) {
                var r = a[i];
                if ("__ob__" !== r) {
                    var o = n[r].from;
                    if (o in e._provided)
                        t[r] = e._provided[o];
                    else if ("default"in n[r]) {
                        var l = n[r].default;
                        t[r] = c(l) ? l.call(e) : l
                    } else
                        0
                }
            }
            return t
        }
    }
    function gt(n, e, t, r, o) {
        var s, c = this, d = o.options;
        T(r, "_uid") ? (s = Object.create(r))._original = r : (s = r,
        r = r._original);
        var u = l(d._compiled)
          , m = !u;
        this.data = n,
        this.props = e,
        this.children = t,
        this.parent = r,
        this.listeners = n.on || a,
        this.injections = ht(d.inject, r),
        this.slots = function() {
            return c.$slots || _e(r, n.scopedSlots, c.$slots = pe(t, r)),
            c.$slots
        }
        ,
        Object.defineProperty(this, "scopedSlots", {
            enumerable: !0,
            get: function() {
                return _e(r, n.scopedSlots, this.slots())
            }
        }),
        u && (this.$options = d,
        this.$slots = this.slots(),
        this.$scopedSlots = _e(r, n.scopedSlots, this.$slots)),
        d._scopeId ? this._c = function(n, e, t, a) {
            var o = Le(s, n, e, t, a, m);
            return o && !i(o) && (o.fnScopeId = d._scopeId,
            o.fnContext = r),
            o
        }
        : this._c = function(n, e, t, a) {
            return Le(s, n, e, t, a, m)
        }
    }
    function _t(n, e, t, a, i) {
        var r = vn(n);
        return r.fnContext = t,
        r.fnOptions = a,
        e.slot && ((r.data || (r.data = {})).slot = e.slot),
        r
    }
    function vt(n, e) {
        for (var t in e)
            n[C(t)] = e[t]
    }
    function bt(n) {
        return n.name || n.__name || n._componentTag
    }
    me(gt.prototype);
    var ft = {
        init: function(n, e) {
            if (n.componentInstance && !n.componentInstance._isDestroyed && n.data.keepAlive) {
                var t = n;
                ft.prepatch(t, t)
            } else {
                (n.componentInstance = function(n, e) {
                    var t = {
                        _isComponent: !0,
                        _parentVnode: n,
                        parent: e
                    }
                      , a = n.data.inlineTemplate;
                    o(a) && (t.render = a.render,
                    t.staticRenderFns = a.staticRenderFns);
                    return new n.componentOptions.Ctor(t)
                }(n, Qe)).$mount(e ? n.elm : void 0, e)
            }
        },
        prepatch: function(n, e) {
            var t = e.componentOptions;
            !function(n, e, t, i, r) {
                var o = i.data.scopedSlots
                  , l = n.$scopedSlots
                  , s = !!(o && !o.$stable || l !== a && !l.$stable || o && n.$scopedSlots.$key !== o.$key || !o && n.$scopedSlots.$key)
                  , c = !!(r || n.$options._renderChildren || s)
                  , d = n.$vnode;
                n.$options._parentVnode = i,
                n.$vnode = i,
                n._vnode && (n._vnode.parent = i),
                n.$options._renderChildren = r;
                var u = i.data.attrs || a;
                n._attrsProxy && Ee(n._attrsProxy, u, d.data && d.data.attrs || a, n, "$attrs") && (c = !0),
                n.$attrs = u,
                t = t || a;
                var m = n.$options._parentListeners;
                if (n._listenersProxy && Ee(n._listenersProxy, t, m || a, n, "$listeners"),
                n.$listeners = n.$options._parentListeners = t,
                We(n, t, m),
                e && n.$options.props) {
                    kn(!1);
                    for (var p = n._props, h = n.$options._propKeys || [], g = 0; g < h.length; g++) {
                        var _ = h[g]
                          , v = n.$options.props;
                        p[_] = St(_, v, e, n)
                    }
                    kn(!0),
                    n.$options.propsData = e
                }
                c && (n.$slots = pe(r, i.context),
                n.$forceUpdate())
            }(e.componentInstance = n.componentInstance, t.propsData, t.listeners, e, t.children)
        },
        insert: function(n) {
            var e, t = n.context, a = n.componentInstance;
            a._isMounted || (a._isMounted = !0,
            et(a, "mounted")),
            n.data.keepAlive && (t._isMounted ? ((e = a)._inactive = !1,
            at.push(e)) : nt(a, !0))
        },
        destroy: function(n) {
            var e = n.componentInstance;
            e._isDestroyed || (n.data.keepAlive ? function n(e, t) {
                if (!(t && (e._directInactive = !0,
                Xe(e)) || e._inactive)) {
                    e._inactive = !0;
                    for (var a = 0; a < e.$children.length; a++)
                        n(e.$children[a]);
                    et(e, "deactivated")
                }
            }(e, !0) : e.$destroy())
        }
    }
      , Et = Object.keys(ft);
    function yt(n, e, t, s, c) {
        if (!r(n)) {
            var u = t.$options._base;
            if (d(n) && (n = u.extend(n)),
            "function" == typeof n) {
                var m;
                if (r(n.cid) && void 0 === (n = function(n, e) {
                    if (l(n.error) && o(n.errorComp))
                        return n.errorComp;
                    if (o(n.resolved))
                        return n.resolved;
                    var t = Ae;
                    if (t && o(n.owners) && -1 === n.owners.indexOf(t) && n.owners.push(t),
                    l(n.loading) && o(n.loadingComp))
                        return n.loadingComp;
                    if (t && !o(n.owners)) {
                        var a = n.owners = [t]
                          , i = !0
                          , s = null
                          , c = null;
                        t.$on("hook:destroyed", (function() {
                            return E(a, t)
                        }
                        ));
                        var u = function(n) {
                            for (var e = 0, t = a.length; e < t; e++)
                                a[e].$forceUpdate();
                            n && (a.length = 0,
                            null !== s && (clearTimeout(s),
                            s = null),
                            null !== c && (clearTimeout(c),
                            c = null))
                        }
                          , m = D((function(t) {
                            n.resolved = xe(t, e),
                            i ? a.length = 0 : u(!0)
                        }
                        ))
                          , p = D((function(e) {
                            o(n.errorComp) && (n.error = !0,
                            u(!0))
                        }
                        ))
                          , h = n(m, p);
                        return d(h) && (g(h) ? r(n.resolved) && h.then(m, p) : g(h.component) && (h.component.then(m, p),
                        o(h.error) && (n.errorComp = xe(h.error, e)),
                        o(h.loading) && (n.loadingComp = xe(h.loading, e),
                        0 === h.delay ? n.loading = !0 : s = setTimeout((function() {
                            s = null,
                            r(n.resolved) && r(n.error) && (n.loading = !0,
                            u(!1))
                        }
                        ), h.delay || 200)),
                        o(h.timeout) && (c = setTimeout((function() {
                            c = null,
                            r(n.resolved) && p(null)
                        }
                        ), h.timeout)))),
                        i = !1,
                        n.loading ? n.loadingComp : n.resolved
                    }
                }(m = n, u)))
                    return function(n, e, t, a, i) {
                        var r = gn();
                        return r.asyncFactory = n,
                        r.asyncMeta = {
                            data: e,
                            context: t,
                            children: a,
                            tag: i
                        },
                        r
                    }(m, e, t, s, c);
                e = e || {},
                Kt(n),
                o(e.model) && function(n, e) {
                    var t = n.model && n.model.prop || "value"
                      , a = n.model && n.model.event || "input";
                    (e.attrs || (e.attrs = {}))[t] = e.model.value;
                    var r = e.on || (e.on = {})
                      , l = r[a]
                      , s = e.model.callback;
                    o(l) ? (i(l) ? -1 === l.indexOf(s) : l !== s) && (r[a] = [s].concat(l)) : r[a] = s
                }(n.options, e);
                var p = function(n, e, t) {
                    var a = e.options.props;
                    if (!r(a)) {
                        var i = {}
                          , l = n.attrs
                          , s = n.props;
                        if (o(l) || o(s))
                            for (var c in a) {
                                var d = M(c);
                                Jn(i, s, c, d, !0) || Jn(i, l, c, d, !1)
                            }
                        return i
                    }
                }(e, n);
                if (l(n.options.functional))
                    return function(n, e, t, r, l) {
                        var s = n.options
                          , c = {}
                          , d = s.props;
                        if (o(d))
                            for (var u in d)
                                c[u] = St(u, d, e || a);
                        else
                            o(t.attrs) && vt(c, t.attrs),
                            o(t.props) && vt(c, t.props);
                        var m = new gt(t,c,l,r,n)
                          , p = s.render.call(null, m._c, m);
                        if (p instanceof hn)
                            return _t(p, t, m.parent, s, m);
                        if (i(p)) {
                            for (var h = Wn(p) || [], g = new Array(h.length), _ = 0; _ < h.length; _++)
                                g[_] = _t(h[_], t, m.parent, s, m);
                            return g
                        }
                    }(n, p, e, t, s);
                var h = e.on;
                if (e.on = e.nativeOn,
                l(n.options.abstract)) {
                    var _ = e.slot;
                    e = {},
                    _ && (e.slot = _)
                }
                !function(n) {
                    for (var e = n.hook || (n.hook = {}), t = 0; t < Et.length; t++) {
                        var a = Et[t]
                          , i = e[a]
                          , r = ft[a];
                        i === r || i && i._merged || (e[a] = i ? Tt(r, i) : r)
                    }
                }(e);
                var v = bt(n.options) || c;
                return new hn("vue-component-".concat(n.cid).concat(v ? "-".concat(v) : ""),e,void 0,void 0,void 0,t,{
                    Ctor: n,
                    propsData: p,
                    listeners: h,
                    tag: c,
                    children: s
                },m)
            }
        }
    }
    function Tt(n, e) {
        var t = function(t, a) {
            n(t, a),
            e(t, a)
        };
        return t._merged = !0,
        t
    }
    var At = R
      , xt = q.optionMergeStrategies;
    function Ct(n, e, t) {
        if (void 0 === t && (t = !0),
        !e)
            return n;
        for (var a, i, r, o = un ? Reflect.ownKeys(e) : Object.keys(e), l = 0; l < o.length; l++)
            "__ob__" !== (a = o[l]) && (i = n[a],
            r = e[a],
            t && T(n, a) ? i !== r && m(i) && m(r) && Ct(i, r) : wn(n, a, r));
        return n
    }
    function Lt(n, e, t) {
        return t ? function() {
            var a = c(e) ? e.call(t, t) : e
              , i = c(n) ? n.call(t, t) : n;
            return a ? Ct(a, i) : i
        }
        : e ? n ? function() {
            return Ct(c(e) ? e.call(this, this) : e, c(n) ? n.call(this, this) : n)
        }
        : e : n
    }
    function Nt(n, e) {
        var t = e ? n ? n.concat(e) : i(e) ? e : [e] : n;
        return t ? function(n) {
            for (var e = [], t = 0; t < n.length; t++)
                -1 === e.indexOf(n[t]) && e.push(n[t]);
            return e
        }(t) : t
    }
    function Mt(n, e, t, a) {
        var i = Object.create(n || null);
        return e ? I(i, e) : i
    }
    xt.data = function(n, e, t) {
        return t ? Lt(n, e, t) : e && "function" != typeof e ? n : Lt(n, e)
    }
    ,
    F.forEach((function(n) {
        xt[n] = Nt
    }
    )),
    j.forEach((function(n) {
        xt[n + "s"] = Mt
    }
    )),
    xt.watch = function(n, e, t, a) {
        if (n === an && (n = void 0),
        e === an && (e = void 0),
        !e)
            return Object.create(n || null);
        if (!n)
            return e;
        var r = {};
        for (var o in I(r, n),
        e) {
            var l = r[o]
              , s = e[o];
            l && !i(l) && (l = [l]),
            r[o] = l ? l.concat(s) : i(s) ? s : [s]
        }
        return r
    }
    ,
    xt.props = xt.methods = xt.inject = xt.computed = function(n, e, t, a) {
        if (!n)
            return e;
        var i = Object.create(null);
        return I(i, n),
        e && I(i, e),
        i
    }
    ,
    xt.provide = function(n, e) {
        return n ? function() {
            var t = Object.create(null);
            return Ct(t, c(n) ? n.call(this) : n),
            e && Ct(t, c(e) ? e.call(this) : e, !1),
            t
        }
        : e
    }
    ;
    var kt = function(n, e) {
        return void 0 === e ? n : e
    };
    function Ot(n, e, t) {
        if (c(e) && (e = e.options),
        function(n, e) {
            var t = n.props;
            if (t) {
                var a, r, o = {};
                if (i(t))
                    for (a = t.length; a--; )
                        "string" == typeof (r = t[a]) && (o[C(r)] = {
                            type: null
                        });
                else if (m(t))
                    for (var l in t)
                        r = t[l],
                        o[C(l)] = m(r) ? r : {
                            type: r
                        };
                else
                    0;
                n.props = o
            }
        }(e),
        function(n, e) {
            var t = n.inject;
            if (t) {
                var a = n.inject = {};
                if (i(t))
                    for (var r = 0; r < t.length; r++)
                        a[t[r]] = {
                            from: t[r]
                        };
                else if (m(t))
                    for (var o in t) {
                        var l = t[o];
                        a[o] = m(l) ? I({
                            from: o
                        }, l) : {
                            from: l
                        }
                    }
                else
                    0
            }
        }(e),
        function(n) {
            var e = n.directives;
            if (e)
                for (var t in e) {
                    var a = e[t];
                    c(a) && (e[t] = {
                        bind: a,
                        update: a
                    })
                }
        }(e),
        !e._base && (e.extends && (n = Ot(n, e.extends, t)),
        e.mixins))
            for (var a = 0, r = e.mixins.length; a < r; a++)
                n = Ot(n, e.mixins[a], t);
        var o, l = {};
        for (o in n)
            s(o);
        for (o in e)
            T(n, o) || s(o);
        function s(a) {
            var i = xt[a] || kt;
            l[a] = i(n[a], e[a], t, a)
        }
        return l
    }
    function It(n, e, t, a) {
        if ("string" == typeof t) {
            var i = n[e];
            if (T(i, t))
                return i[t];
            var r = C(t);
            if (T(i, r))
                return i[r];
            var o = L(r);
            return T(i, o) ? i[o] : i[t] || i[r] || i[o]
        }
    }
    function St(n, e, t, a) {
        var i = e[n]
          , r = !T(t, n)
          , o = t[n]
          , l = zt(Boolean, i.type);
        if (l > -1)
            if (r && !T(i, "default"))
                o = !1;
            else if ("" === o || o === M(n)) {
                var s = zt(String, i.type);
                (s < 0 || l < s) && (o = !0)
            }
        if (void 0 === o) {
            o = function(n, e, t) {
                if (!T(e, "default"))
                    return;
                var a = e.default;
                0;
                if (n && n.$options.propsData && void 0 === n.$options.propsData[t] && void 0 !== n._props[t])
                    return n._props[t];
                return c(a) && "Function" !== wt(e.type) ? a.call(n) : a
            }(a, i, n);
            var d = Mn;
            kn(!0),
            Sn(o),
            kn(d)
        }
        return o
    }
    var Rt = /^\s*function (\w+)/;
    function wt(n) {
        var e = n && n.toString().match(Rt);
        return e ? e[1] : ""
    }
    function Ut(n, e) {
        return wt(n) === wt(e)
    }
    function zt(n, e) {
        if (!i(e))
            return Ut(e, n) ? 0 : -1;
        for (var t = 0, a = e.length; t < a; t++)
            if (Ut(e[t], n))
                return t;
        return -1
    }
    var Pt = {
        enumerable: !0,
        configurable: !0,
        get: R,
        set: R
    };
    function Dt(n, e, t) {
        Pt.get = function() {
            return this[e][t]
        }
        ,
        Pt.set = function(n) {
            this[e][t] = n
        }
        ,
        Object.defineProperty(n, t, Pt)
    }
    function Bt(n) {
        var e = n.$options;
        if (e.props && function(n, e) {
            var t = n.$options.propsData || {}
              , a = n._props = Pn({})
              , i = n.$options._propKeys = [];
            n.$parent && kn(!1);
            var r = function(r) {
                i.push(r);
                var o = St(r, e, t, n);
                Rn(a, r, o),
                r in n || Dt(n, "_props", r)
            };
            for (var o in e)
                r(o);
            kn(!0)
        }(n, e.props),
        function(n) {
            var e = n.$options
              , t = e.setup;
            if (t) {
                var a = n._setupContext = fe(n);
                pn(n),
                Tn();
                var i = Me(t, null, [n._props || Pn({}), a], n, "setup");
                if (An(),
                pn(),
                c(i))
                    e.render = i;
                else if (d(i))
                    if (n._setupState = i,
                    i.__sfc) {
                        var r = n._setupProxy = {};
                        for (var o in i)
                            "__sfc" !== o && Fn(r, i, o)
                    } else
                        for (var o in i)
                            H(o) || Fn(n, i, o);
                else
                    0
            }
        }(n),
        e.methods && function(n, e) {
            n.$options.props;
            for (var t in e)
                n[t] = "function" != typeof e[t] ? R : k(e[t], n)
        }(n, e.methods),
        e.data)
            !function(n) {
                var e = n.$options.data;
                m(e = n._data = c(e) ? function(n, e) {
                    Tn();
                    try {
                        return n.call(e, e)
                    } catch (n) {
                        return Ne(n, e, "data()"),
                        {}
                    } finally {
                        An()
                    }
                }(e, n) : e || {}) || (e = {});
                var t = Object.keys(e)
                  , a = n.$options.props
                  , i = (n.$options.methods,
                t.length);
                for (; i--; ) {
                    var r = t[i];
                    0,
                    a && T(a, r) || H(r) || Dt(n, "_data", r)
                }
                var o = Sn(e);
                o && o.vmCount++
            }(n);
        else {
            var t = Sn(n._data = {});
            t && t.vmCount++
        }
        e.computed && function(n, e) {
            var t = n._computedWatchers = Object.create(null)
              , a = ln();
            for (var i in e) {
                var r = e[i]
                  , o = c(r) ? r : r.get;
                0,
                a || (t[i] = new Ke(n,o || R,R,jt)),
                i in n || Ft(n, i, r)
            }
        }(n, e.computed),
        e.watch && e.watch !== an && function(n, e) {
            for (var t in e) {
                var a = e[t];
                if (i(a))
                    for (var r = 0; r < a.length; r++)
                        Ht(n, t, a[r]);
                else
                    Ht(n, t, a)
            }
        }(n, e.watch)
    }
    var jt = {
        lazy: !0
    };
    function Ft(n, e, t) {
        var a = !ln();
        c(t) ? (Pt.get = a ? qt(e) : Vt(t),
        Pt.set = R) : (Pt.get = t.get ? a && !1 !== t.cache ? qt(e) : Vt(t.get) : R,
        Pt.set = t.set || R),
        Object.defineProperty(n, e, Pt)
    }
    function qt(n) {
        return function() {
            var e = this._computedWatchers && this._computedWatchers[n];
            if (e)
                return e.dirty && e.evaluate(),
                En.target && e.depend(),
                e.value
        }
    }
    function Vt(n) {
        return function() {
            return n.call(this, this)
        }
    }
    function Ht(n, e, t, a) {
        return m(t) && (a = t,
        t = t.handler),
        "string" == typeof t && (t = n[t]),
        n.$watch(e, t, a)
    }
    var $t = 0;
    function Kt(n) {
        var e = n.options;
        if (n.super) {
            var t = Kt(n.super);
            if (t !== n.superOptions) {
                n.superOptions = t;
                var a = function(n) {
                    var e, t = n.options, a = n.sealedOptions;
                    for (var i in t)
                        t[i] !== a[i] && (e || (e = {}),
                        e[i] = t[i]);
                    return e
                }(n);
                a && I(n.extendOptions, a),
                (e = n.options = Ot(t, n.extendOptions)).name && (e.components[e.name] = n)
            }
        }
        return e
    }
    function Gt(n) {
        this._init(n)
    }
    function Yt(n) {
        n.cid = 0;
        var e = 1;
        n.extend = function(n) {
            n = n || {};
            var t = this
              , a = t.cid
              , i = n._Ctor || (n._Ctor = {});
            if (i[a])
                return i[a];
            var r = bt(n) || bt(t.options);
            var o = function(n) {
                this._init(n)
            };
            return (o.prototype = Object.create(t.prototype)).constructor = o,
            o.cid = e++,
            o.options = Ot(t.options, n),
            o.super = t,
            o.options.props && function(n) {
                var e = n.options.props;
                for (var t in e)
                    Dt(n.prototype, "_props", t)
            }(o),
            o.options.computed && function(n) {
                var e = n.options.computed;
                for (var t in e)
                    Ft(n.prototype, t, e[t])
            }(o),
            o.extend = t.extend,
            o.mixin = t.mixin,
            o.use = t.use,
            j.forEach((function(n) {
                o[n] = t[n]
            }
            )),
            r && (o.options.components[r] = o),
            o.superOptions = t.options,
            o.extendOptions = n,
            o.sealedOptions = I({}, o.options),
            i[a] = o,
            o
        }
    }
    function Jt(n) {
        return n && (bt(n.Ctor.options) || n.tag)
    }
    function Wt(n, e) {
        return i(n) ? n.indexOf(e) > -1 : "string" == typeof n ? n.split(",").indexOf(e) > -1 : !!p(n) && n.test(e)
    }
    function Qt(n, e) {
        var t = n.cache
          , a = n.keys
          , i = n._vnode;
        for (var r in t) {
            var o = t[r];
            if (o) {
                var l = o.name;
                l && !e(l) && Zt(t, r, a, i)
            }
        }
    }
    function Zt(n, e, t, a) {
        var i = n[e];
        !i || a && i.tag === a.tag || i.componentInstance.$destroy(),
        n[e] = null,
        E(t, e)
    }
    !function(n) {
        n.prototype._init = function(n) {
            var e = this;
            e._uid = $t++,
            e._isVue = !0,
            e.__v_skip = !0,
            e._scope = new Vn(!0),
            e._scope._vm = !0,
            n && n._isComponent ? function(n, e) {
                var t = n.$options = Object.create(n.constructor.options)
                  , a = e._parentVnode;
                t.parent = e.parent,
                t._parentVnode = a;
                var i = a.componentOptions;
                t.propsData = i.propsData,
                t._parentListeners = i.listeners,
                t._renderChildren = i.children,
                t._componentTag = i.tag,
                e.render && (t.render = e.render,
                t.staticRenderFns = e.staticRenderFns)
            }(e, n) : e.$options = Ot(Kt(e.constructor), n || {}, e),
            e._renderProxy = e,
            e._self = e,
            function(n) {
                var e = n.$options
                  , t = e.parent;
                if (t && !e.abstract) {
                    for (; t.$options.abstract && t.$parent; )
                        t = t.$parent;
                    t.$children.push(n)
                }
                n.$parent = t,
                n.$root = t ? t.$root : n,
                n.$children = [],
                n.$refs = {},
                n._provided = t ? t._provided : Object.create(null),
                n._watcher = null,
                n._inactive = null,
                n._directInactive = !1,
                n._isMounted = !1,
                n._isDestroyed = !1,
                n._isBeingDestroyed = !1
            }(e),
            function(n) {
                n._events = Object.create(null),
                n._hasHookEvent = !1;
                var e = n.$options._parentListeners;
                e && We(n, e)
            }(e),
            function(n) {
                n._vnode = null,
                n._staticTrees = null;
                var e = n.$options
                  , t = n.$vnode = e._parentVnode
                  , i = t && t.context;
                n.$slots = pe(e._renderChildren, i),
                n.$scopedSlots = t ? _e(n.$parent, t.data.scopedSlots, n.$slots) : a,
                n._c = function(e, t, a, i) {
                    return Le(n, e, t, a, i, !1)
                }
                ,
                n.$createElement = function(e, t, a, i) {
                    return Le(n, e, t, a, i, !0)
                }
                ;
                var r = t && t.data;
                Rn(n, "$attrs", r && r.attrs || a, null, !0),
                Rn(n, "$listeners", e._parentListeners || a, null, !0)
            }(e),
            et(e, "beforeCreate", void 0, !1),
            function(n) {
                var e = ht(n.$options.inject, n);
                e && (kn(!1),
                Object.keys(e).forEach((function(t) {
                    Rn(n, t, e[t])
                }
                )),
                kn(!0))
            }(e),
            Bt(e),
            function(n) {
                var e = n.$options.provide;
                if (e) {
                    var t = c(e) ? e.call(n) : e;
                    if (!d(t))
                        return;
                    for (var a = Hn(n), i = un ? Reflect.ownKeys(t) : Object.keys(t), r = 0; r < i.length; r++) {
                        var o = i[r];
                        Object.defineProperty(a, o, Object.getOwnPropertyDescriptor(t, o))
                    }
                }
            }(e),
            et(e, "created"),
            e.$options.el && e.$mount(e.$options.el)
        }
    }(Gt),
    function(n) {
        var e = {
            get: function() {
                return this._data
            }
        }
          , t = {
            get: function() {
                return this._props
            }
        };
        Object.defineProperty(n.prototype, "$data", e),
        Object.defineProperty(n.prototype, "$props", t),
        n.prototype.$set = wn,
        n.prototype.$delete = Un,
        n.prototype.$watch = function(n, e, t) {
            if (m(e))
                return Ht(this, n, e, t);
            (t = t || {}).user = !0;
            var a = new Ke(this,n,e,t);
            if (t.immediate) {
                var i = 'callback for immediate watcher "'.concat(a.expression, '"');
                Tn(),
                Me(e, this, [a.value], this, i),
                An()
            }
            return function() {
                a.teardown()
            }
        }
    }(Gt),
    function(n) {
        var e = /^hook:/;
        n.prototype.$on = function(n, t) {
            var a = this;
            if (i(n))
                for (var r = 0, o = n.length; r < o; r++)
                    a.$on(n[r], t);
            else
                (a._events[n] || (a._events[n] = [])).push(t),
                e.test(n) && (a._hasHookEvent = !0);
            return a
        }
        ,
        n.prototype.$once = function(n, e) {
            var t = this;
            function a() {
                t.$off(n, a),
                e.apply(t, arguments)
            }
            return a.fn = e,
            t.$on(n, a),
            t
        }
        ,
        n.prototype.$off = function(n, e) {
            var t = this;
            if (!arguments.length)
                return t._events = Object.create(null),
                t;
            if (i(n)) {
                for (var a = 0, r = n.length; a < r; a++)
                    t.$off(n[a], e);
                return t
            }
            var o, l = t._events[n];
            if (!l)
                return t;
            if (!e)
                return t._events[n] = null,
                t;
            for (var s = l.length; s--; )
                if ((o = l[s]) === e || o.fn === e) {
                    l.splice(s, 1);
                    break
                }
            return t
        }
        ,
        n.prototype.$emit = function(n) {
            var e = this
              , t = e._events[n];
            if (t) {
                t = t.length > 1 ? O(t) : t;
                for (var a = O(arguments, 1), i = 'event handler for "'.concat(n, '"'), r = 0, o = t.length; r < o; r++)
                    Me(t[r], e, a, e, i)
            }
            return e
        }
    }(Gt),
    function(n) {
        n.prototype._update = function(n, e) {
            var t = this
              , a = t.$el
              , i = t._vnode
              , r = Ze(t);
            t._vnode = n,
            t.$el = i ? t.__patch__(i, n) : t.__patch__(t.$el, n, e, !1),
            r(),
            a && (a.__vue__ = null),
            t.$el && (t.$el.__vue__ = t);
            for (var o = t; o && o.$vnode && o.$parent && o.$vnode === o.$parent._vnode; )
                o.$parent.$el = o.$el,
                o = o.$parent
        }
        ,
        n.prototype.$forceUpdate = function() {
            this._watcher && this._watcher.update()
        }
        ,
        n.prototype.$destroy = function() {
            var n = this;
            if (!n._isBeingDestroyed) {
                et(n, "beforeDestroy"),
                n._isBeingDestroyed = !0;
                var e = n.$parent;
                !e || e._isBeingDestroyed || n.$options.abstract || E(e.$children, n),
                n._scope.stop(),
                n._data.__ob__ && n._data.__ob__.vmCount--,
                n._isDestroyed = !0,
                n.__patch__(n._vnode, null),
                et(n, "destroyed"),
                n.$off(),
                n.$el && (n.$el.__vue__ = null),
                n.$vnode && (n.$vnode.parent = null)
            }
        }
    }(Gt),
    function(n) {
        me(n.prototype),
        n.prototype.$nextTick = function(n) {
            return je(n, this)
        }
        ,
        n.prototype._render = function() {
            var n, e = this, t = e.$options, a = t.render, r = t._parentVnode;
            r && e._isMounted && (e.$scopedSlots = _e(e.$parent, r.data.scopedSlots, e.$slots, e.$scopedSlots),
            e._slotsProxy && Te(e._slotsProxy, e.$scopedSlots)),
            e.$vnode = r;
            try {
                pn(e),
                Ae = e,
                n = a.call(e._renderProxy, e.$createElement)
            } catch (t) {
                Ne(t, e, "render"),
                n = e._vnode
            } finally {
                Ae = null,
                pn()
            }
            return i(n) && 1 === n.length && (n = n[0]),
            n instanceof hn || (n = gn()),
            n.parent = r,
            n
        }
    }(Gt);
    var Xt = [String, RegExp, Array]
      , na = {
        KeepAlive: {
            name: "keep-alive",
            abstract: !0,
            props: {
                include: Xt,
                exclude: Xt,
                max: [String, Number]
            },
            methods: {
                cacheVNode: function() {
                    var n = this.cache
                      , e = this.keys
                      , t = this.vnodeToCache
                      , a = this.keyToCache;
                    if (t) {
                        var i = t.tag
                          , r = t.componentInstance
                          , o = t.componentOptions;
                        n[a] = {
                            name: Jt(o),
                            tag: i,
                            componentInstance: r
                        },
                        e.push(a),
                        this.max && e.length > parseInt(this.max) && Zt(n, e[0], e, this._vnode),
                        this.vnodeToCache = null
                    }
                }
            },
            created: function() {
                this.cache = Object.create(null),
                this.keys = []
            },
            destroyed: function() {
                for (var n in this.cache)
                    Zt(this.cache, n, this.keys)
            },
            mounted: function() {
                var n = this;
                this.cacheVNode(),
                this.$watch("include", (function(e) {
                    Qt(n, (function(n) {
                        return Wt(e, n)
                    }
                    ))
                }
                )),
                this.$watch("exclude", (function(e) {
                    Qt(n, (function(n) {
                        return !Wt(e, n)
                    }
                    ))
                }
                ))
            },
            updated: function() {
                this.cacheVNode()
            },
            render: function() {
                var n = this.$slots.default
                  , e = Ce(n)
                  , t = e && e.componentOptions;
                if (t) {
                    var a = Jt(t)
                      , i = this.include
                      , r = this.exclude;
                    if (i && (!a || !Wt(i, a)) || r && a && Wt(r, a))
                        return e;
                    var o = this.cache
                      , l = this.keys
                      , s = null == e.key ? t.Ctor.cid + (t.tag ? "::".concat(t.tag) : "") : e.key;
                    o[s] ? (e.componentInstance = o[s].componentInstance,
                    E(l, s),
                    l.push(s)) : (this.vnodeToCache = e,
                    this.keyToCache = s),
                    e.data.keepAlive = !0
                }
                return e || n && n[0]
            }
        }
    };
    !function(n) {
        var e = {
            get: function() {
                return q
            }
        };
        Object.defineProperty(n, "config", e),
        n.util = {
            warn: At,
            extend: I,
            mergeOptions: Ot,
            defineReactive: Rn
        },
        n.set = wn,
        n.delete = Un,
        n.nextTick = je,
        n.observable = function(n) {
            return Sn(n),
            n
        }
        ,
        n.options = Object.create(null),
        j.forEach((function(e) {
            n.options[e + "s"] = Object.create(null)
        }
        )),
        n.options._base = n,
        I(n.options.components, na),
        function(n) {
            n.use = function(n) {
                var e = this._installedPlugins || (this._installedPlugins = []);
                if (e.indexOf(n) > -1)
                    return this;
                var t = O(arguments, 1);
                return t.unshift(this),
                c(n.install) ? n.install.apply(n, t) : c(n) && n.apply(null, t),
                e.push(n),
                this
            }
        }(n),
        function(n) {
            n.mixin = function(n) {
                return this.options = Ot(this.options, n),
                this
            }
        }(n),
        Yt(n),
        function(n) {
            j.forEach((function(e) {
                n[e] = function(n, t) {
                    return t ? ("component" === e && m(t) && (t.name = t.name || n,
                    t = this.options._base.extend(t)),
                    "directive" === e && c(t) && (t = {
                        bind: t,
                        update: t
                    }),
                    this.options[e + "s"][n] = t,
                    t) : this.options[e + "s"][n]
                }
            }
            ))
        }(n)
    }(Gt),
    Object.defineProperty(Gt.prototype, "$isServer", {
        get: ln
    }),
    Object.defineProperty(Gt.prototype, "$ssrContext", {
        get: function() {
            return this.$vnode && this.$vnode.ssrContext
        }
    }),
    Object.defineProperty(Gt, "FunctionalRenderContext", {
        value: gt
    }),
    Gt.version = "2.7.14";
    var ea = b("style,class")
      , ta = b("input,textarea,option,select,progress")
      , aa = b("contenteditable,draggable,spellcheck")
      , ia = b("events,caret,typing,plaintext-only")
      , ra = b("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible")
      , oa = "http://www.w3.org/1999/xlink"
      , la = function(n) {
        return ":" === n.charAt(5) && "xlink" === n.slice(0, 5)
    }
      , sa = function(n) {
        return la(n) ? n.slice(6, n.length) : ""
    }
      , ca = function(n) {
        return null == n || !1 === n
    };
    function da(n) {
        for (var e = n.data, t = n, a = n; o(a.componentInstance); )
            (a = a.componentInstance._vnode) && a.data && (e = ua(a.data, e));
        for (; o(t = t.parent); )
            t && t.data && (e = ua(e, t.data));
        return function(n, e) {
            if (o(n) || o(e))
                return ma(n, pa(e));
            return ""
        }(e.staticClass, e.class)
    }
    function ua(n, e) {
        return {
            staticClass: ma(n.staticClass, e.staticClass),
            class: o(n.class) ? [n.class, e.class] : e.class
        }
    }
    function ma(n, e) {
        return n ? e ? n + " " + e : n : e || ""
    }
    function pa(n) {
        return Array.isArray(n) ? function(n) {
            for (var e, t = "", a = 0, i = n.length; a < i; a++)
                o(e = pa(n[a])) && "" !== e && (t && (t += " "),
                t += e);
            return t
        }(n) : d(n) ? function(n) {
            var e = "";
            for (var t in n)
                n[t] && (e && (e += " "),
                e += t);
            return e
        }(n) : "string" == typeof n ? n : ""
    }
    var ha = {
        svg: "http://www.w3.org/2000/svg",
        math: "http://www.w3.org/1998/Math/MathML"
    }
      , ga = b("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot")
      , _a = b("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view", !0)
      , va = function(n) {
        return ga(n) || _a(n)
    };
    var ba = Object.create(null);
    var fa = b("text,number,password,search,email,tel,url");
    var Ea = Object.freeze({
        __proto__: null,
        createElement: function(n, e) {
            var t = document.createElement(n);
            return "select" !== n || e.data && e.data.attrs && void 0 !== e.data.attrs.multiple && t.setAttribute("multiple", "multiple"),
            t
        },
        createElementNS: function(n, e) {
            return document.createElementNS(ha[n], e)
        },
        createTextNode: function(n) {
            return document.createTextNode(n)
        },
        createComment: function(n) {
            return document.createComment(n)
        },
        insertBefore: function(n, e, t) {
            n.insertBefore(e, t)
        },
        removeChild: function(n, e) {
            n.removeChild(e)
        },
        appendChild: function(n, e) {
            n.appendChild(e)
        },
        parentNode: function(n) {
            return n.parentNode
        },
        nextSibling: function(n) {
            return n.nextSibling
        },
        tagName: function(n) {
            return n.tagName
        },
        setTextContent: function(n, e) {
            n.textContent = e
        },
        setStyleScope: function(n, e) {
            n.setAttribute(e, "")
        }
    })
      , ya = {
        create: function(n, e) {
            Ta(e)
        },
        update: function(n, e) {
            n.data.ref !== e.data.ref && (Ta(n, !0),
            Ta(e))
        },
        destroy: function(n) {
            Ta(n, !0)
        }
    };
    function Ta(n, e) {
        var t = n.data.ref;
        if (o(t)) {
            var a = n.context
              , r = n.componentInstance || n.elm
              , l = e ? null : r
              , s = e ? void 0 : r;
            if (c(t))
                Me(t, a, [l], a, "template ref function");
            else {
                var d = n.data.refInFor
                  , u = "string" == typeof t || "number" == typeof t
                  , m = jn(t)
                  , p = a.$refs;
                if (u || m)
                    if (d) {
                        var h = u ? p[t] : t.value;
                        e ? i(h) && E(h, r) : i(h) ? h.includes(r) || h.push(r) : u ? (p[t] = [r],
                        Aa(a, t, p[t])) : t.value = [r]
                    } else if (u) {
                        if (e && p[t] !== r)
                            return;
                        p[t] = s,
                        Aa(a, t, l)
                    } else if (m) {
                        if (e && t.value !== r)
                            return;
                        t.value = l
                    } else
                        0
            }
        }
    }
    function Aa(n, e, t) {
        var a = n._setupState;
        a && T(a, e) && (jn(a[e]) ? a[e].value = t : a[e] = t)
    }
    var xa = new hn("",{},[])
      , Ca = ["create", "activate", "update", "remove", "destroy"];
    function La(n, e) {
        return n.key === e.key && n.asyncFactory === e.asyncFactory && (n.tag === e.tag && n.isComment === e.isComment && o(n.data) === o(e.data) && function(n, e) {
            if ("input" !== n.tag)
                return !0;
            var t, a = o(t = n.data) && o(t = t.attrs) && t.type, i = o(t = e.data) && o(t = t.attrs) && t.type;
            return a === i || fa(a) && fa(i)
        }(n, e) || l(n.isAsyncPlaceholder) && r(e.asyncFactory.error))
    }
    function Na(n, e, t) {
        var a, i, r = {};
        for (a = e; a <= t; ++a)
            o(i = n[a].key) && (r[i] = a);
        return r
    }
    var Ma = {
        create: ka,
        update: ka,
        destroy: function(n) {
            ka(n, xa)
        }
    };
    function ka(n, e) {
        (n.data.directives || e.data.directives) && function(n, e) {
            var t, a, i, r = n === xa, o = e === xa, l = Ia(n.data.directives, n.context), s = Ia(e.data.directives, e.context), c = [], d = [];
            for (t in s)
                a = l[t],
                i = s[t],
                a ? (i.oldValue = a.value,
                i.oldArg = a.arg,
                Ra(i, "update", e, n),
                i.def && i.def.componentUpdated && d.push(i)) : (Ra(i, "bind", e, n),
                i.def && i.def.inserted && c.push(i));
            if (c.length) {
                var u = function() {
                    for (var t = 0; t < c.length; t++)
                        Ra(c[t], "inserted", e, n)
                };
                r ? Yn(e, "insert", u) : u()
            }
            d.length && Yn(e, "postpatch", (function() {
                for (var t = 0; t < d.length; t++)
                    Ra(d[t], "componentUpdated", e, n)
            }
            ));
            if (!r)
                for (t in l)
                    s[t] || Ra(l[t], "unbind", n, n, o)
        }(n, e)
    }
    var Oa = Object.create(null);
    function Ia(n, e) {
        var t, a, i = Object.create(null);
        if (!n)
            return i;
        for (t = 0; t < n.length; t++) {
            if ((a = n[t]).modifiers || (a.modifiers = Oa),
            i[Sa(a)] = a,
            e._setupState && e._setupState.__sfc) {
                var r = a.def || It(e, "_setupState", "v-" + a.name);
                a.def = "function" == typeof r ? {
                    bind: r,
                    update: r
                } : r
            }
            a.def = a.def || It(e.$options, "directives", a.name)
        }
        return i
    }
    function Sa(n) {
        return n.rawName || "".concat(n.name, ".").concat(Object.keys(n.modifiers || {}).join("."))
    }
    function Ra(n, e, t, a, i) {
        var r = n.def && n.def[e];
        if (r)
            try {
                r(t.elm, n, t, a, i)
            } catch (a) {
                Ne(a, t.context, "directive ".concat(n.name, " ").concat(e, " hook"))
            }
    }
    var wa = [ya, Ma];
    function Ua(n, e) {
        var t = e.componentOptions;
        if (!(o(t) && !1 === t.Ctor.options.inheritAttrs || r(n.data.attrs) && r(e.data.attrs))) {
            var a, i, s = e.elm, c = n.data.attrs || {}, d = e.data.attrs || {};
            for (a in (o(d.__ob__) || l(d._v_attr_proxy)) && (d = e.data.attrs = I({}, d)),
            d)
                i = d[a],
                c[a] !== i && za(s, a, i, e.data.pre);
            for (a in (Q || X) && d.value !== c.value && za(s, "value", d.value),
            c)
                r(d[a]) && (la(a) ? s.removeAttributeNS(oa, sa(a)) : aa(a) || s.removeAttribute(a))
        }
    }
    function za(n, e, t, a) {
        a || n.tagName.indexOf("-") > -1 ? Pa(n, e, t) : ra(e) ? ca(t) ? n.removeAttribute(e) : (t = "allowfullscreen" === e && "EMBED" === n.tagName ? "true" : e,
        n.setAttribute(e, t)) : aa(e) ? n.setAttribute(e, function(n, e) {
            return ca(e) || "false" === e ? "false" : "contenteditable" === n && ia(e) ? e : "true"
        }(e, t)) : la(e) ? ca(t) ? n.removeAttributeNS(oa, sa(e)) : n.setAttributeNS(oa, e, t) : Pa(n, e, t)
    }
    function Pa(n, e, t) {
        if (ca(t))
            n.removeAttribute(e);
        else {
            if (Q && !Z && "TEXTAREA" === n.tagName && "placeholder" === e && "" !== t && !n.__ieph) {
                var a = function(e) {
                    e.stopImmediatePropagation(),
                    n.removeEventListener("input", a)
                };
                n.addEventListener("input", a),
                n.__ieph = !0
            }
            n.setAttribute(e, t)
        }
    }
    var Da = {
        create: Ua,
        update: Ua
    };
    function Ba(n, e) {
        var t = e.elm
          , a = e.data
          , i = n.data;
        if (!(r(a.staticClass) && r(a.class) && (r(i) || r(i.staticClass) && r(i.class)))) {
            var l = da(e)
              , s = t._transitionClasses;
            o(s) && (l = ma(l, pa(s))),
            l !== t._prevClass && (t.setAttribute("class", l),
            t._prevClass = l)
        }
    }
    var ja, Fa = {
        create: Ba,
        update: Ba
    };
    function qa(n, e, t) {
        var a = ja;
        return function i() {
            var r = e.apply(null, arguments);
            null !== r && $a(n, i, t, a)
        }
    }
    var Va = Se && !(tn && Number(tn[1]) <= 53);
    function Ha(n, e, t, a) {
        if (Va) {
            var i = st
              , r = e;
            e = r._wrapper = function(n) {
                if (n.target === n.currentTarget || n.timeStamp >= i || n.timeStamp <= 0 || n.target.ownerDocument !== document)
                    return r.apply(this, arguments)
            }
        }
        ja.addEventListener(n, e, rn ? {
            capture: t,
            passive: a
        } : t)
    }
    function $a(n, e, t, a) {
        (a || ja).removeEventListener(n, e._wrapper || e, t)
    }
    function Ka(n, e) {
        if (!r(n.data.on) || !r(e.data.on)) {
            var t = e.data.on || {}
              , a = n.data.on || {};
            ja = e.elm || n.elm,
            function(n) {
                if (o(n.__r)) {
                    var e = Q ? "change" : "input";
                    n[e] = [].concat(n.__r, n[e] || []),
                    delete n.__r
                }
                o(n.__c) && (n.change = [].concat(n.__c, n.change || []),
                delete n.__c)
            }(t),
            Gn(t, a, Ha, $a, qa, e.context),
            ja = void 0
        }
    }
    var Ga, Ya = {
        create: Ka,
        update: Ka,
        destroy: function(n) {
            return Ka(n, xa)
        }
    };
    function Ja(n, e) {
        if (!r(n.data.domProps) || !r(e.data.domProps)) {
            var t, a, i = e.elm, s = n.data.domProps || {}, c = e.data.domProps || {};
            for (t in (o(c.__ob__) || l(c._v_attr_proxy)) && (c = e.data.domProps = I({}, c)),
            s)
                t in c || (i[t] = "");
            for (t in c) {
                if (a = c[t],
                "textContent" === t || "innerHTML" === t) {
                    if (e.children && (e.children.length = 0),
                    a === s[t])
                        continue;
                    1 === i.childNodes.length && i.removeChild(i.childNodes[0])
                }
                if ("value" === t && "PROGRESS" !== i.tagName) {
                    i._value = a;
                    var d = r(a) ? "" : String(a);
                    Wa(i, d) && (i.value = d)
                } else if ("innerHTML" === t && _a(i.tagName) && r(i.innerHTML)) {
                    (Ga = Ga || document.createElement("div")).innerHTML = "<svg>".concat(a, "</svg>");
                    for (var u = Ga.firstChild; i.firstChild; )
                        i.removeChild(i.firstChild);
                    for (; u.firstChild; )
                        i.appendChild(u.firstChild)
                } else if (a !== s[t])
                    try {
                        i[t] = a
                    } catch (n) {}
            }
        }
    }
    function Wa(n, e) {
        return !n.composing && ("OPTION" === n.tagName || function(n, e) {
            var t = !0;
            try {
                t = document.activeElement !== n
            } catch (n) {}
            return t && n.value !== e
        }(n, e) || function(n, e) {
            var t = n.value
              , a = n._vModifiers;
            if (o(a)) {
                if (a.number)
                    return v(t) !== v(e);
                if (a.trim)
                    return t.trim() !== e.trim()
            }
            return t !== e
        }(n, e))
    }
    var Qa = {
        create: Ja,
        update: Ja
    }
      , Za = A((function(n) {
        var e = {}
          , t = /:(.+)/;
        return n.split(/;(?![^(]*\))/g).forEach((function(n) {
            if (n) {
                var a = n.split(t);
                a.length > 1 && (e[a[0].trim()] = a[1].trim())
            }
        }
        )),
        e
    }
    ));
    function Xa(n) {
        var e = ni(n.style);
        return n.staticStyle ? I(n.staticStyle, e) : e
    }
    function ni(n) {
        return Array.isArray(n) ? S(n) : "string" == typeof n ? Za(n) : n
    }
    var ei, ti = /^--/, ai = /\s*!important$/, ii = function(n, e, t) {
        if (ti.test(e))
            n.style.setProperty(e, t);
        else if (ai.test(t))
            n.style.setProperty(M(e), t.replace(ai, ""), "important");
        else {
            var a = oi(e);
            if (Array.isArray(t))
                for (var i = 0, r = t.length; i < r; i++)
                    n.style[a] = t[i];
            else
                n.style[a] = t
        }
    }, ri = ["Webkit", "Moz", "ms"], oi = A((function(n) {
        if (ei = ei || document.createElement("div").style,
        "filter" !== (n = C(n)) && n in ei)
            return n;
        for (var e = n.charAt(0).toUpperCase() + n.slice(1), t = 0; t < ri.length; t++) {
            var a = ri[t] + e;
            if (a in ei)
                return a
        }
    }
    ));
    function li(n, e) {
        var t = e.data
          , a = n.data;
        if (!(r(t.staticStyle) && r(t.style) && r(a.staticStyle) && r(a.style))) {
            var i, l, s = e.elm, c = a.staticStyle, d = a.normalizedStyle || a.style || {}, u = c || d, m = ni(e.data.style) || {};
            e.data.normalizedStyle = o(m.__ob__) ? I({}, m) : m;
            var p = function(n, e) {
                var t, a = {};
                if (e)
                    for (var i = n; i.componentInstance; )
                        (i = i.componentInstance._vnode) && i.data && (t = Xa(i.data)) && I(a, t);
                (t = Xa(n.data)) && I(a, t);
                for (var r = n; r = r.parent; )
                    r.data && (t = Xa(r.data)) && I(a, t);
                return a
            }(e, !0);
            for (l in u)
                r(p[l]) && ii(s, l, "");
            for (l in p)
                (i = p[l]) !== u[l] && ii(s, l, null == i ? "" : i)
        }
    }
    var si = {
        create: li,
        update: li
    }
      , ci = /\s+/;
    function di(n, e) {
        if (e && (e = e.trim()))
            if (n.classList)
                e.indexOf(" ") > -1 ? e.split(ci).forEach((function(e) {
                    return n.classList.add(e)
                }
                )) : n.classList.add(e);
            else {
                var t = " ".concat(n.getAttribute("class") || "", " ");
                t.indexOf(" " + e + " ") < 0 && n.setAttribute("class", (t + e).trim())
            }
    }
    function ui(n, e) {
        if (e && (e = e.trim()))
            if (n.classList)
                e.indexOf(" ") > -1 ? e.split(ci).forEach((function(e) {
                    return n.classList.remove(e)
                }
                )) : n.classList.remove(e),
                n.classList.length || n.removeAttribute("class");
            else {
                for (var t = " ".concat(n.getAttribute("class") || "", " "), a = " " + e + " "; t.indexOf(a) >= 0; )
                    t = t.replace(a, " ");
                (t = t.trim()) ? n.setAttribute("class", t) : n.removeAttribute("class")
            }
    }
    function mi(n) {
        if (n) {
            if ("object" == typeof n) {
                var e = {};
                return !1 !== n.css && I(e, pi(n.name || "v")),
                I(e, n),
                e
            }
            return "string" == typeof n ? pi(n) : void 0
        }
    }
    var pi = A((function(n) {
        return {
            enterClass: "".concat(n, "-enter"),
            enterToClass: "".concat(n, "-enter-to"),
            enterActiveClass: "".concat(n, "-enter-active"),
            leaveClass: "".concat(n, "-leave"),
            leaveToClass: "".concat(n, "-leave-to"),
            leaveActiveClass: "".concat(n, "-leave-active")
        }
    }
    ))
      , hi = J && !Z
      , gi = "transition"
      , _i = "transitionend"
      , vi = "animation"
      , bi = "animationend";
    hi && (void 0 === window.ontransitionend && void 0 !== window.onwebkittransitionend && (gi = "WebkitTransition",
    _i = "webkitTransitionEnd"),
    void 0 === window.onanimationend && void 0 !== window.onwebkitanimationend && (vi = "WebkitAnimation",
    bi = "webkitAnimationEnd"));
    var fi = J ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout : function(n) {
        return n()
    }
    ;
    function Ei(n) {
        fi((function() {
            fi(n)
        }
        ))
    }
    function yi(n, e) {
        var t = n._transitionClasses || (n._transitionClasses = []);
        t.indexOf(e) < 0 && (t.push(e),
        di(n, e))
    }
    function Ti(n, e) {
        n._transitionClasses && E(n._transitionClasses, e),
        ui(n, e)
    }
    function Ai(n, e, t) {
        var a = Ci(n, e)
          , i = a.type
          , r = a.timeout
          , o = a.propCount;
        if (!i)
            return t();
        var l = "transition" === i ? _i : bi
          , s = 0
          , c = function() {
            n.removeEventListener(l, d),
            t()
        }
          , d = function(e) {
            e.target === n && ++s >= o && c()
        };
        setTimeout((function() {
            s < o && c()
        }
        ), r + 1),
        n.addEventListener(l, d)
    }
    var xi = /\b(transform|all)(,|$)/;
    function Ci(n, e) {
        var t, a = window.getComputedStyle(n), i = (a[gi + "Delay"] || "").split(", "), r = (a[gi + "Duration"] || "").split(", "), o = Li(i, r), l = (a[vi + "Delay"] || "").split(", "), s = (a[vi + "Duration"] || "").split(", "), c = Li(l, s), d = 0, u = 0;
        return "transition" === e ? o > 0 && (t = "transition",
        d = o,
        u = r.length) : "animation" === e ? c > 0 && (t = "animation",
        d = c,
        u = s.length) : u = (t = (d = Math.max(o, c)) > 0 ? o > c ? "transition" : "animation" : null) ? "transition" === t ? r.length : s.length : 0,
        {
            type: t,
            timeout: d,
            propCount: u,
            hasTransform: "transition" === t && xi.test(a[gi + "Property"])
        }
    }
    function Li(n, e) {
        for (; n.length < e.length; )
            n = n.concat(n);
        return Math.max.apply(null, e.map((function(e, t) {
            return Ni(e) + Ni(n[t])
        }
        )))
    }
    function Ni(n) {
        return 1e3 * Number(n.slice(0, -1).replace(",", "."))
    }
    function Mi(n, e) {
        var t = n.elm;
        o(t._leaveCb) && (t._leaveCb.cancelled = !0,
        t._leaveCb());
        var a = mi(n.data.transition);
        if (!r(a) && !o(t._enterCb) && 1 === t.nodeType) {
            for (var i = a.css, l = a.type, s = a.enterClass, u = a.enterToClass, m = a.enterActiveClass, p = a.appearClass, h = a.appearToClass, g = a.appearActiveClass, _ = a.beforeEnter, b = a.enter, f = a.afterEnter, E = a.enterCancelled, y = a.beforeAppear, T = a.appear, A = a.afterAppear, x = a.appearCancelled, C = a.duration, L = Qe, N = Qe.$vnode; N && N.parent; )
                L = N.context,
                N = N.parent;
            var M = !L._isMounted || !n.isRootInsert;
            if (!M || T || "" === T) {
                var k = M && p ? p : s
                  , O = M && g ? g : m
                  , I = M && h ? h : u
                  , S = M && y || _
                  , R = M && c(T) ? T : b
                  , w = M && A || f
                  , U = M && x || E
                  , z = v(d(C) ? C.enter : C);
                0;
                var P = !1 !== i && !Z
                  , B = Ii(R)
                  , j = t._enterCb = D((function() {
                    P && (Ti(t, I),
                    Ti(t, O)),
                    j.cancelled ? (P && Ti(t, k),
                    U && U(t)) : w && w(t),
                    t._enterCb = null
                }
                ));
                n.data.show || Yn(n, "insert", (function() {
                    var e = t.parentNode
                      , a = e && e._pending && e._pending[n.key];
                    a && a.tag === n.tag && a.elm._leaveCb && a.elm._leaveCb(),
                    R && R(t, j)
                }
                )),
                S && S(t),
                P && (yi(t, k),
                yi(t, O),
                Ei((function() {
                    Ti(t, k),
                    j.cancelled || (yi(t, I),
                    B || (Oi(z) ? setTimeout(j, z) : Ai(t, l, j)))
                }
                ))),
                n.data.show && (e && e(),
                R && R(t, j)),
                P || B || j()
            }
        }
    }
    function ki(n, e) {
        var t = n.elm;
        o(t._enterCb) && (t._enterCb.cancelled = !0,
        t._enterCb());
        var a = mi(n.data.transition);
        if (r(a) || 1 !== t.nodeType)
            return e();
        if (!o(t._leaveCb)) {
            var i = a.css
              , l = a.type
              , s = a.leaveClass
              , c = a.leaveToClass
              , u = a.leaveActiveClass
              , m = a.beforeLeave
              , p = a.leave
              , h = a.afterLeave
              , g = a.leaveCancelled
              , _ = a.delayLeave
              , b = a.duration
              , f = !1 !== i && !Z
              , E = Ii(p)
              , y = v(d(b) ? b.leave : b);
            0;
            var T = t._leaveCb = D((function() {
                t.parentNode && t.parentNode._pending && (t.parentNode._pending[n.key] = null),
                f && (Ti(t, c),
                Ti(t, u)),
                T.cancelled ? (f && Ti(t, s),
                g && g(t)) : (e(),
                h && h(t)),
                t._leaveCb = null
            }
            ));
            _ ? _(A) : A()
        }
        function A() {
            T.cancelled || (!n.data.show && t.parentNode && ((t.parentNode._pending || (t.parentNode._pending = {}))[n.key] = n),
            m && m(t),
            f && (yi(t, s),
            yi(t, u),
            Ei((function() {
                Ti(t, s),
                T.cancelled || (yi(t, c),
                E || (Oi(y) ? setTimeout(T, y) : Ai(t, l, T)))
            }
            ))),
            p && p(t, T),
            f || E || T())
        }
    }
    function Oi(n) {
        return "number" == typeof n && !isNaN(n)
    }
    function Ii(n) {
        if (r(n))
            return !1;
        var e = n.fns;
        return o(e) ? Ii(Array.isArray(e) ? e[0] : e) : (n._length || n.length) > 1
    }
    function Si(n, e) {
        !0 !== e.data.show && Mi(e)
    }
    var Ri = function(n) {
        var e, t, a = {}, c = n.modules, d = n.nodeOps;
        for (e = 0; e < Ca.length; ++e)
            for (a[Ca[e]] = [],
            t = 0; t < c.length; ++t)
                o(c[t][Ca[e]]) && a[Ca[e]].push(c[t][Ca[e]]);
        function u(n) {
            var e = d.parentNode(n);
            o(e) && d.removeChild(e, n)
        }
        function m(n, e, t, i, r, s, c) {
            if (o(n.elm) && o(s) && (n = s[c] = vn(n)),
            n.isRootInsert = !r,
            !function(n, e, t, i) {
                var r = n.data;
                if (o(r)) {
                    var s = o(n.componentInstance) && r.keepAlive;
                    if (o(r = r.hook) && o(r = r.init) && r(n, !1),
                    o(n.componentInstance))
                        return p(n, e),
                        h(t, n.elm, i),
                        l(s) && function(n, e, t, i) {
                            var r, l = n;
                            for (; l.componentInstance; )
                                if (l = l.componentInstance._vnode,
                                o(r = l.data) && o(r = r.transition)) {
                                    for (r = 0; r < a.activate.length; ++r)
                                        a.activate[r](xa, l);
                                    e.push(l);
                                    break
                                }
                            h(t, n.elm, i)
                        }(n, e, t, i),
                        !0
                }
            }(n, e, t, i)) {
                var u = n.data
                  , m = n.children
                  , _ = n.tag;
                o(_) ? (n.elm = n.ns ? d.createElementNS(n.ns, _) : d.createElement(_, n),
                f(n),
                g(n, m, e),
                o(u) && v(n, e),
                h(t, n.elm, i)) : l(n.isComment) ? (n.elm = d.createComment(n.text),
                h(t, n.elm, i)) : (n.elm = d.createTextNode(n.text),
                h(t, n.elm, i))
            }
        }
        function p(n, e) {
            o(n.data.pendingInsert) && (e.push.apply(e, n.data.pendingInsert),
            n.data.pendingInsert = null),
            n.elm = n.componentInstance.$el,
            _(n) ? (v(n, e),
            f(n)) : (Ta(n),
            e.push(n))
        }
        function h(n, e, t) {
            o(n) && (o(t) ? d.parentNode(t) === n && d.insertBefore(n, e, t) : d.appendChild(n, e))
        }
        function g(n, e, t) {
            if (i(e)) {
                0;
                for (var a = 0; a < e.length; ++a)
                    m(e[a], t, n.elm, null, !0, e, a)
            } else
                s(n.text) && d.appendChild(n.elm, d.createTextNode(String(n.text)))
        }
        function _(n) {
            for (; n.componentInstance; )
                n = n.componentInstance._vnode;
            return o(n.tag)
        }
        function v(n, t) {
            for (var i = 0; i < a.create.length; ++i)
                a.create[i](xa, n);
            o(e = n.data.hook) && (o(e.create) && e.create(xa, n),
            o(e.insert) && t.push(n))
        }
        function f(n) {
            var e;
            if (o(e = n.fnScopeId))
                d.setStyleScope(n.elm, e);
            else
                for (var t = n; t; )
                    o(e = t.context) && o(e = e.$options._scopeId) && d.setStyleScope(n.elm, e),
                    t = t.parent;
            o(e = Qe) && e !== n.context && e !== n.fnContext && o(e = e.$options._scopeId) && d.setStyleScope(n.elm, e)
        }
        function E(n, e, t, a, i, r) {
            for (; a <= i; ++a)
                m(t[a], r, n, e, !1, t, a)
        }
        function y(n) {
            var e, t, i = n.data;
            if (o(i))
                for (o(e = i.hook) && o(e = e.destroy) && e(n),
                e = 0; e < a.destroy.length; ++e)
                    a.destroy[e](n);
            if (o(e = n.children))
                for (t = 0; t < n.children.length; ++t)
                    y(n.children[t])
        }
        function T(n, e, t) {
            for (; e <= t; ++e) {
                var a = n[e];
                o(a) && (o(a.tag) ? (A(a),
                y(a)) : u(a.elm))
            }
        }
        function A(n, e) {
            if (o(e) || o(n.data)) {
                var t, i = a.remove.length + 1;
                for (o(e) ? e.listeners += i : e = function(n, e) {
                    function t() {
                        0 == --t.listeners && u(n)
                    }
                    return t.listeners = e,
                    t
                }(n.elm, i),
                o(t = n.componentInstance) && o(t = t._vnode) && o(t.data) && A(t, e),
                t = 0; t < a.remove.length; ++t)
                    a.remove[t](n, e);
                o(t = n.data.hook) && o(t = t.remove) ? t(n, e) : e()
            } else
                u(n.elm)
        }
        function x(n, e, t, a) {
            for (var i = t; i < a; i++) {
                var r = e[i];
                if (o(r) && La(n, r))
                    return i
            }
        }
        function C(n, e, t, i, s, c) {
            if (n !== e) {
                o(e.elm) && o(i) && (e = i[s] = vn(e));
                var u = e.elm = n.elm;
                if (l(n.isAsyncPlaceholder))
                    o(e.asyncFactory.resolved) ? M(n.elm, e, t) : e.isAsyncPlaceholder = !0;
                else if (l(e.isStatic) && l(n.isStatic) && e.key === n.key && (l(e.isCloned) || l(e.isOnce)))
                    e.componentInstance = n.componentInstance;
                else {
                    var p, h = e.data;
                    o(h) && o(p = h.hook) && o(p = p.prepatch) && p(n, e);
                    var g = n.children
                      , v = e.children;
                    if (o(h) && _(e)) {
                        for (p = 0; p < a.update.length; ++p)
                            a.update[p](n, e);
                        o(p = h.hook) && o(p = p.update) && p(n, e)
                    }
                    r(e.text) ? o(g) && o(v) ? g !== v && function(n, e, t, a, i) {
                        var l, s, c, u = 0, p = 0, h = e.length - 1, g = e[0], _ = e[h], v = t.length - 1, b = t[0], f = t[v], y = !i;
                        for (0; u <= h && p <= v; )
                            r(g) ? g = e[++u] : r(_) ? _ = e[--h] : La(g, b) ? (C(g, b, a, t, p),
                            g = e[++u],
                            b = t[++p]) : La(_, f) ? (C(_, f, a, t, v),
                            _ = e[--h],
                            f = t[--v]) : La(g, f) ? (C(g, f, a, t, v),
                            y && d.insertBefore(n, g.elm, d.nextSibling(_.elm)),
                            g = e[++u],
                            f = t[--v]) : La(_, b) ? (C(_, b, a, t, p),
                            y && d.insertBefore(n, _.elm, g.elm),
                            _ = e[--h],
                            b = t[++p]) : (r(l) && (l = Na(e, u, h)),
                            r(s = o(b.key) ? l[b.key] : x(b, e, u, h)) ? m(b, a, n, g.elm, !1, t, p) : La(c = e[s], b) ? (C(c, b, a, t, p),
                            e[s] = void 0,
                            y && d.insertBefore(n, c.elm, g.elm)) : m(b, a, n, g.elm, !1, t, p),
                            b = t[++p]);
                        u > h ? E(n, r(t[v + 1]) ? null : t[v + 1].elm, t, p, v, a) : p > v && T(e, u, h)
                    }(u, g, v, t, c) : o(v) ? (o(n.text) && d.setTextContent(u, ""),
                    E(u, null, v, 0, v.length - 1, t)) : o(g) ? T(g, 0, g.length - 1) : o(n.text) && d.setTextContent(u, "") : n.text !== e.text && d.setTextContent(u, e.text),
                    o(h) && o(p = h.hook) && o(p = p.postpatch) && p(n, e)
                }
            }
        }
        function L(n, e, t) {
            if (l(t) && o(n.parent))
                n.parent.data.pendingInsert = e;
            else
                for (var a = 0; a < e.length; ++a)
                    e[a].data.hook.insert(e[a])
        }
        var N = b("attrs,class,staticClass,staticStyle,key");
        function M(n, e, t, a) {
            var i, r = e.tag, s = e.data, c = e.children;
            if (a = a || s && s.pre,
            e.elm = n,
            l(e.isComment) && o(e.asyncFactory))
                return e.isAsyncPlaceholder = !0,
                !0;
            if (o(s) && (o(i = s.hook) && o(i = i.init) && i(e, !0),
            o(i = e.componentInstance)))
                return p(e, t),
                !0;
            if (o(r)) {
                if (o(c))
                    if (n.hasChildNodes())
                        if (o(i = s) && o(i = i.domProps) && o(i = i.innerHTML)) {
                            if (i !== n.innerHTML)
                                return !1
                        } else {
                            for (var d = !0, u = n.firstChild, m = 0; m < c.length; m++) {
                                if (!u || !M(u, c[m], t, a)) {
                                    d = !1;
                                    break
                                }
                                u = u.nextSibling
                            }
                            if (!d || u)
                                return !1
                        }
                    else
                        g(e, c, t);
                if (o(s)) {
                    var h = !1;
                    for (var _ in s)
                        if (!N(_)) {
                            h = !0,
                            v(e, t);
                            break
                        }
                    !h && s.class && Ve(s.class)
                }
            } else
                n.data !== e.text && (n.data = e.text);
            return !0
        }
        return function(n, e, t, i) {
            if (!r(e)) {
                var s, c = !1, u = [];
                if (r(n))
                    c = !0,
                    m(e, u);
                else {
                    var p = o(n.nodeType);
                    if (!p && La(n, e))
                        C(n, e, u, null, null, i);
                    else {
                        if (p) {
                            if (1 === n.nodeType && n.hasAttribute("data-server-rendered") && (n.removeAttribute("data-server-rendered"),
                            t = !0),
                            l(t) && M(n, e, u))
                                return L(e, u, !0),
                                n;
                            s = n,
                            n = new hn(d.tagName(s).toLowerCase(),{},[],void 0,s)
                        }
                        var h = n.elm
                          , g = d.parentNode(h);
                        if (m(e, u, h._leaveCb ? null : g, d.nextSibling(h)),
                        o(e.parent))
                            for (var v = e.parent, b = _(e); v; ) {
                                for (var f = 0; f < a.destroy.length; ++f)
                                    a.destroy[f](v);
                                if (v.elm = e.elm,
                                b) {
                                    for (var E = 0; E < a.create.length; ++E)
                                        a.create[E](xa, v);
                                    var A = v.data.hook.insert;
                                    if (A.merged)
                                        for (var x = 1; x < A.fns.length; x++)
                                            A.fns[x]()
                                } else
                                    Ta(v);
                                v = v.parent
                            }
                        o(g) ? T([n], 0, 0) : o(n.tag) && y(n)
                    }
                }
                return L(e, u, c),
                e.elm
            }
            o(n) && y(n)
        }
    }({
        nodeOps: Ea,
        modules: [Da, Fa, Ya, Qa, si, J ? {
            create: Si,
            activate: Si,
            remove: function(n, e) {
                !0 !== n.data.show ? ki(n, e) : e()
            }
        } : {}].concat(wa)
    });
    Z && document.addEventListener("selectionchange", (function() {
        var n = document.activeElement;
        n && n.vmodel && Fi(n, "input")
    }
    ));
    var wi = {
        inserted: function(n, e, t, a) {
            "select" === t.tag ? (a.elm && !a.elm._vOptions ? Yn(t, "postpatch", (function() {
                wi.componentUpdated(n, e, t)
            }
            )) : Ui(n, e, t.context),
            n._vOptions = [].map.call(n.options, Di)) : ("textarea" === t.tag || fa(n.type)) && (n._vModifiers = e.modifiers,
            e.modifiers.lazy || (n.addEventListener("compositionstart", Bi),
            n.addEventListener("compositionend", ji),
            n.addEventListener("change", ji),
            Z && (n.vmodel = !0)))
        },
        componentUpdated: function(n, e, t) {
            if ("select" === t.tag) {
                Ui(n, e, t.context);
                var a = n._vOptions
                  , i = n._vOptions = [].map.call(n.options, Di);
                if (i.some((function(n, e) {
                    return !z(n, a[e])
                }
                )))
                    (n.multiple ? e.value.some((function(n) {
                        return Pi(n, i)
                    }
                    )) : e.value !== e.oldValue && Pi(e.value, i)) && Fi(n, "change")
            }
        }
    };
    function Ui(n, e, t) {
        zi(n, e, t),
        (Q || X) && setTimeout((function() {
            zi(n, e, t)
        }
        ), 0)
    }
    function zi(n, e, t) {
        var a = e.value
          , i = n.multiple;
        if (!i || Array.isArray(a)) {
            for (var r, o, l = 0, s = n.options.length; l < s; l++)
                if (o = n.options[l],
                i)
                    r = P(a, Di(o)) > -1,
                    o.selected !== r && (o.selected = r);
                else if (z(Di(o), a))
                    return void (n.selectedIndex !== l && (n.selectedIndex = l));
            i || (n.selectedIndex = -1)
        }
    }
    function Pi(n, e) {
        return e.every((function(e) {
            return !z(e, n)
        }
        ))
    }
    function Di(n) {
        return "_value"in n ? n._value : n.value
    }
    function Bi(n) {
        n.target.composing = !0
    }
    function ji(n) {
        n.target.composing && (n.target.composing = !1,
        Fi(n.target, "input"))
    }
    function Fi(n, e) {
        var t = document.createEvent("HTMLEvents");
        t.initEvent(e, !0, !0),
        n.dispatchEvent(t)
    }
    function qi(n) {
        return !n.componentInstance || n.data && n.data.transition ? n : qi(n.componentInstance._vnode)
    }
    var Vi = {
        model: wi,
        show: {
            bind: function(n, e, t) {
                var a = e.value
                  , i = (t = qi(t)).data && t.data.transition
                  , r = n.__vOriginalDisplay = "none" === n.style.display ? "" : n.style.display;
                a && i ? (t.data.show = !0,
                Mi(t, (function() {
                    n.style.display = r
                }
                ))) : n.style.display = a ? r : "none"
            },
            update: function(n, e, t) {
                var a = e.value;
                !a != !e.oldValue && ((t = qi(t)).data && t.data.transition ? (t.data.show = !0,
                a ? Mi(t, (function() {
                    n.style.display = n.__vOriginalDisplay
                }
                )) : ki(t, (function() {
                    n.style.display = "none"
                }
                ))) : n.style.display = a ? n.__vOriginalDisplay : "none")
            },
            unbind: function(n, e, t, a, i) {
                i || (n.style.display = n.__vOriginalDisplay)
            }
        }
    }
      , Hi = {
        name: String,
        appear: Boolean,
        css: Boolean,
        mode: String,
        type: String,
        enterClass: String,
        leaveClass: String,
        enterToClass: String,
        leaveToClass: String,
        enterActiveClass: String,
        leaveActiveClass: String,
        appearClass: String,
        appearActiveClass: String,
        appearToClass: String,
        duration: [Number, String, Object]
    };
    function $i(n) {
        var e = n && n.componentOptions;
        return e && e.Ctor.options.abstract ? $i(Ce(e.children)) : n
    }
    function Ki(n) {
        var e = {}
          , t = n.$options;
        for (var a in t.propsData)
            e[a] = n[a];
        var i = t._parentListeners;
        for (var a in i)
            e[C(a)] = i[a];
        return e
    }
    function Gi(n, e) {
        if (/\d-keep-alive$/.test(e.tag))
            return n("keep-alive", {
                props: e.componentOptions.propsData
            })
    }
    var Yi = function(n) {
        return n.tag || ge(n)
    }
      , Ji = function(n) {
        return "show" === n.name
    }
      , Wi = {
        name: "transition",
        props: Hi,
        abstract: !0,
        render: function(n) {
            var e = this
              , t = this.$slots.default;
            if (t && (t = t.filter(Yi)).length) {
                0;
                var a = this.mode;
                0;
                var i = t[0];
                if (function(n) {
                    for (; n = n.parent; )
                        if (n.data.transition)
                            return !0
                }(this.$vnode))
                    return i;
                var r = $i(i);
                if (!r)
                    return i;
                if (this._leaving)
                    return Gi(n, i);
                var o = "__transition-".concat(this._uid, "-");
                r.key = null == r.key ? r.isComment ? o + "comment" : o + r.tag : s(r.key) ? 0 === String(r.key).indexOf(o) ? r.key : o + r.key : r.key;
                var l = (r.data || (r.data = {})).transition = Ki(this)
                  , c = this._vnode
                  , d = $i(c);
                if (r.data.directives && r.data.directives.some(Ji) && (r.data.show = !0),
                d && d.data && !function(n, e) {
                    return e.key === n.key && e.tag === n.tag
                }(r, d) && !ge(d) && (!d.componentInstance || !d.componentInstance._vnode.isComment)) {
                    var u = d.data.transition = I({}, l);
                    if ("out-in" === a)
                        return this._leaving = !0,
                        Yn(u, "afterLeave", (function() {
                            e._leaving = !1,
                            e.$forceUpdate()
                        }
                        )),
                        Gi(n, i);
                    if ("in-out" === a) {
                        if (ge(r))
                            return c;
                        var m, p = function() {
                            m()
                        };
                        Yn(l, "afterEnter", p),
                        Yn(l, "enterCancelled", p),
                        Yn(u, "delayLeave", (function(n) {
                            m = n
                        }
                        ))
                    }
                }
                return i
            }
        }
    }
      , Qi = I({
        tag: String,
        moveClass: String
    }, Hi);
    function Zi(n) {
        n.elm._moveCb && n.elm._moveCb(),
        n.elm._enterCb && n.elm._enterCb()
    }
    function Xi(n) {
        n.data.newPos = n.elm.getBoundingClientRect()
    }
    function nr(n) {
        var e = n.data.pos
          , t = n.data.newPos
          , a = e.left - t.left
          , i = e.top - t.top;
        if (a || i) {
            n.data.moved = !0;
            var r = n.elm.style;
            r.transform = r.WebkitTransform = "translate(".concat(a, "px,").concat(i, "px)"),
            r.transitionDuration = "0s"
        }
    }
    delete Qi.mode;
    var er = {
        Transition: Wi,
        TransitionGroup: {
            props: Qi,
            beforeMount: function() {
                var n = this
                  , e = this._update;
                this._update = function(t, a) {
                    var i = Ze(n);
                    n.__patch__(n._vnode, n.kept, !1, !0),
                    n._vnode = n.kept,
                    i(),
                    e.call(n, t, a)
                }
            },
            render: function(n) {
                for (var e = this.tag || this.$vnode.data.tag || "span", t = Object.create(null), a = this.prevChildren = this.children, i = this.$slots.default || [], r = this.children = [], o = Ki(this), l = 0; l < i.length; l++) {
                    if ((d = i[l]).tag)
                        if (null != d.key && 0 !== String(d.key).indexOf("__vlist"))
                            r.push(d),
                            t[d.key] = d,
                            (d.data || (d.data = {})).transition = o;
                        else
                            ;
                }
                if (a) {
                    var s = []
                      , c = [];
                    for (l = 0; l < a.length; l++) {
                        var d;
                        (d = a[l]).data.transition = o,
                        d.data.pos = d.elm.getBoundingClientRect(),
                        t[d.key] ? s.push(d) : c.push(d)
                    }
                    this.kept = n(e, null, s),
                    this.removed = c
                }
                return n(e, null, r)
            },
            updated: function() {
                var n = this.prevChildren
                  , e = this.moveClass || (this.name || "v") + "-move";
                n.length && this.hasMove(n[0].elm, e) && (n.forEach(Zi),
                n.forEach(Xi),
                n.forEach(nr),
                this._reflow = document.body.offsetHeight,
                n.forEach((function(n) {
                    if (n.data.moved) {
                        var t = n.elm
                          , a = t.style;
                        yi(t, e),
                        a.transform = a.WebkitTransform = a.transitionDuration = "",
                        t.addEventListener(_i, t._moveCb = function n(a) {
                            a && a.target !== t || a && !/transform$/.test(a.propertyName) || (t.removeEventListener(_i, n),
                            t._moveCb = null,
                            Ti(t, e))
                        }
                        )
                    }
                }
                )))
            },
            methods: {
                hasMove: function(n, e) {
                    if (!hi)
                        return !1;
                    if (this._hasMove)
                        return this._hasMove;
                    var t = n.cloneNode();
                    n._transitionClasses && n._transitionClasses.forEach((function(n) {
                        ui(t, n)
                    }
                    )),
                    di(t, e),
                    t.style.display = "none",
                    this.$el.appendChild(t);
                    var a = Ci(t);
                    return this.$el.removeChild(t),
                    this._hasMove = a.hasTransform
                }
            }
        }
    };
    function tr(n, e) {
        for (var t in e)
            n[t] = e[t];
        return n
    }
    Gt.config.mustUseProp = function(n, e, t) {
        return "value" === t && ta(n) && "button" !== e || "selected" === t && "option" === n || "checked" === t && "input" === n || "muted" === t && "video" === n
    }
    ,
    Gt.config.isReservedTag = va,
    Gt.config.isReservedAttr = ea,
    Gt.config.getTagNamespace = function(n) {
        return _a(n) ? "svg" : "math" === n ? "math" : void 0
    }
    ,
    Gt.config.isUnknownElement = function(n) {
        if (!J)
            return !0;
        if (va(n))
            return !1;
        if (n = n.toLowerCase(),
        null != ba[n])
            return ba[n];
        var e = document.createElement(n);
        return n.indexOf("-") > -1 ? ba[n] = e.constructor === window.HTMLUnknownElement || e.constructor === window.HTMLElement : ba[n] = /HTMLUnknownElement/.test(e.toString())
    }
    ,
    I(Gt.options.directives, Vi),
    I(Gt.options.components, er),
    Gt.prototype.__patch__ = J ? Ri : R,
    Gt.prototype.$mount = function(n, e) {
        return function(n, e, t) {
            var a;
            n.$el = e,
            n.$options.render || (n.$options.render = gn),
            et(n, "beforeMount"),
            a = function() {
                n._update(n._render(), t)
            }
            ,
            new Ke(n,a,R,{
                before: function() {
                    n._isMounted && !n._isDestroyed && et(n, "beforeUpdate")
                }
            },!0),
            t = !1;
            var i = n._preWatchers;
            if (i)
                for (var r = 0; r < i.length; r++)
                    i[r].run();
            return null == n.$vnode && (n._isMounted = !0,
            et(n, "mounted")),
            n
        }(this, n = n && J ? function(n) {
            if ("string" == typeof n) {
                var e = document.querySelector(n);
                return e || document.createElement("div")
            }
            return n
        }(n) : void 0, e)
    }
    ,
    J && setTimeout((function() {
        q.devtools && sn && sn.emit("init", Gt)
    }
    ), 0);
    var ar = /[!'()*]/g
      , ir = function(n) {
        return "%" + n.charCodeAt(0).toString(16)
    }
      , rr = /%2C/g
      , or = function(n) {
        return encodeURIComponent(n).replace(ar, ir).replace(rr, ",")
    };
    function lr(n) {
        try {
            return decodeURIComponent(n)
        } catch (n) {
            0
        }
        return n
    }
    var sr = function(n) {
        return null == n || "object" == typeof n ? n : String(n)
    };
    function cr(n) {
        var e = {};
        return (n = n.trim().replace(/^(\?|#|&)/, "")) ? (n.split("&").forEach((function(n) {
            var t = n.replace(/\+/g, " ").split("=")
              , a = lr(t.shift())
              , i = t.length > 0 ? lr(t.join("=")) : null;
            void 0 === e[a] ? e[a] = i : Array.isArray(e[a]) ? e[a].push(i) : e[a] = [e[a], i]
        }
        )),
        e) : e
    }
    function dr(n) {
        var e = n ? Object.keys(n).map((function(e) {
            var t = n[e];
            if (void 0 === t)
                return "";
            if (null === t)
                return or(e);
            if (Array.isArray(t)) {
                var a = [];
                return t.forEach((function(n) {
                    void 0 !== n && (null === n ? a.push(or(e)) : a.push(or(e) + "=" + or(n)))
                }
                )),
                a.join("&")
            }
            return or(e) + "=" + or(t)
        }
        )).filter((function(n) {
            return n.length > 0
        }
        )).join("&") : null;
        return e ? "?" + e : ""
    }
    var ur = /\/?$/;
    function mr(n, e, t, a) {
        var i = a && a.options.stringifyQuery
          , r = e.query || {};
        try {
            r = pr(r)
        } catch (n) {}
        var o = {
            name: e.name || n && n.name,
            meta: n && n.meta || {},
            path: e.path || "/",
            hash: e.hash || "",
            query: r,
            params: e.params || {},
            fullPath: _r(e, i),
            matched: n ? gr(n) : []
        };
        return t && (o.redirectedFrom = _r(t, i)),
        Object.freeze(o)
    }
    function pr(n) {
        if (Array.isArray(n))
            return n.map(pr);
        if (n && "object" == typeof n) {
            var e = {};
            for (var t in n)
                e[t] = pr(n[t]);
            return e
        }
        return n
    }
    var hr = mr(null, {
        path: "/"
    });
    function gr(n) {
        for (var e = []; n; )
            e.unshift(n),
            n = n.parent;
        return e
    }
    function _r(n, e) {
        var t = n.path
          , a = n.query;
        void 0 === a && (a = {});
        var i = n.hash;
        return void 0 === i && (i = ""),
        (t || "/") + (e || dr)(a) + i
    }
    function vr(n, e, t) {
        return e === hr ? n === e : !!e && (n.path && e.path ? n.path.replace(ur, "") === e.path.replace(ur, "") && (t || n.hash === e.hash && br(n.query, e.query)) : !(!n.name || !e.name) && (n.name === e.name && (t || n.hash === e.hash && br(n.query, e.query) && br(n.params, e.params))))
    }
    function br(n, e) {
        if (void 0 === n && (n = {}),
        void 0 === e && (e = {}),
        !n || !e)
            return n === e;
        var t = Object.keys(n).sort()
          , a = Object.keys(e).sort();
        return t.length === a.length && t.every((function(t, i) {
            var r = n[t];
            if (a[i] !== t)
                return !1;
            var o = e[t];
            return null == r || null == o ? r === o : "object" == typeof r && "object" == typeof o ? br(r, o) : String(r) === String(o)
        }
        ))
    }
    function fr(n) {
        for (var e = 0; e < n.matched.length; e++) {
            var t = n.matched[e];
            for (var a in t.instances) {
                var i = t.instances[a]
                  , r = t.enteredCbs[a];
                if (i && r) {
                    delete t.enteredCbs[a];
                    for (var o = 0; o < r.length; o++)
                        i._isBeingDestroyed || r[o](i)
                }
            }
        }
    }
    var Er = {
        name: "RouterView",
        functional: !0,
        props: {
            name: {
                type: String,
                default: "default"
            }
        },
        render: function(n, e) {
            var t = e.props
              , a = e.children
              , i = e.parent
              , r = e.data;
            r.routerView = !0;
            for (var o = i.$createElement, l = t.name, s = i.$route, c = i._routerViewCache || (i._routerViewCache = {}), d = 0, u = !1; i && i._routerRoot !== i; ) {
                var m = i.$vnode ? i.$vnode.data : {};
                m.routerView && d++,
                m.keepAlive && i._directInactive && i._inactive && (u = !0),
                i = i.$parent
            }
            if (r.routerViewDepth = d,
            u) {
                var p = c[l]
                  , h = p && p.component;
                return h ? (p.configProps && yr(h, r, p.route, p.configProps),
                o(h, r, a)) : o()
            }
            var g = s.matched[d]
              , _ = g && g.components[l];
            if (!g || !_)
                return c[l] = null,
                o();
            c[l] = {
                component: _
            },
            r.registerRouteInstance = function(n, e) {
                var t = g.instances[l];
                (e && t !== n || !e && t === n) && (g.instances[l] = e)
            }
            ,
            (r.hook || (r.hook = {})).prepatch = function(n, e) {
                g.instances[l] = e.componentInstance
            }
            ,
            r.hook.init = function(n) {
                n.data.keepAlive && n.componentInstance && n.componentInstance !== g.instances[l] && (g.instances[l] = n.componentInstance),
                fr(s)
            }
            ;
            var v = g.props && g.props[l];
            return v && (tr(c[l], {
                route: s,
                configProps: v
            }),
            yr(_, r, s, v)),
            o(_, r, a)
        }
    };
    function yr(n, e, t, a) {
        var i = e.props = function(n, e) {
            switch (typeof e) {
            case "undefined":
                return;
            case "object":
                return e;
            case "function":
                return e(n);
            case "boolean":
                return e ? n.params : void 0;
            default:
                0
            }
        }(t, a);
        if (i) {
            i = e.props = tr({}, i);
            var r = e.attrs = e.attrs || {};
            for (var o in i)
                n.props && o in n.props || (r[o] = i[o],
                delete i[o])
        }
    }
    function Tr(n, e, t) {
        var a = n.charAt(0);
        if ("/" === a)
            return n;
        if ("?" === a || "#" === a)
            return e + n;
        var i = e.split("/");
        t && i[i.length - 1] || i.pop();
        for (var r = n.replace(/^\//, "").split("/"), o = 0; o < r.length; o++) {
            var l = r[o];
            ".." === l ? i.pop() : "." !== l && i.push(l)
        }
        return "" !== i[0] && i.unshift(""),
        i.join("/")
    }
    function Ar(n) {
        return n.replace(/\/(?:\s*\/)+/g, "/")
    }
    var xr = Array.isArray || function(n) {
        return "[object Array]" == Object.prototype.toString.call(n)
    }
      , Cr = Br
      , Lr = Ir
      , Nr = function(n, e) {
        return Rr(Ir(n, e), e)
    }
      , Mr = Rr
      , kr = Dr
      , Or = new RegExp(["(\\\\.)", "([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");
    function Ir(n, e) {
        for (var t, a = [], i = 0, r = 0, o = "", l = e && e.delimiter || "/"; null != (t = Or.exec(n)); ) {
            var s = t[0]
              , c = t[1]
              , d = t.index;
            if (o += n.slice(r, d),
            r = d + s.length,
            c)
                o += c[1];
            else {
                var u = n[r]
                  , m = t[2]
                  , p = t[3]
                  , h = t[4]
                  , g = t[5]
                  , _ = t[6]
                  , v = t[7];
                o && (a.push(o),
                o = "");
                var b = null != m && null != u && u !== m
                  , f = "+" === _ || "*" === _
                  , E = "?" === _ || "*" === _
                  , y = t[2] || l
                  , T = h || g;
                a.push({
                    name: p || i++,
                    prefix: m || "",
                    delimiter: y,
                    optional: E,
                    repeat: f,
                    partial: b,
                    asterisk: !!v,
                    pattern: T ? Ur(T) : v ? ".*" : "[^" + wr(y) + "]+?"
                })
            }
        }
        return r < n.length && (o += n.substr(r)),
        o && a.push(o),
        a
    }
    function Sr(n) {
        return encodeURI(n).replace(/[\/?#]/g, (function(n) {
            return "%" + n.charCodeAt(0).toString(16).toUpperCase()
        }
        ))
    }
    function Rr(n, e) {
        for (var t = new Array(n.length), a = 0; a < n.length; a++)
            "object" == typeof n[a] && (t[a] = new RegExp("^(?:" + n[a].pattern + ")$",Pr(e)));
        return function(e, a) {
            for (var i = "", r = e || {}, o = (a || {}).pretty ? Sr : encodeURIComponent, l = 0; l < n.length; l++) {
                var s = n[l];
                if ("string" != typeof s) {
                    var c, d = r[s.name];
                    if (null == d) {
                        if (s.optional) {
                            s.partial && (i += s.prefix);
                            continue
                        }
                        throw new TypeError('Expected "' + s.name + '" to be defined')
                    }
                    if (xr(d)) {
                        if (!s.repeat)
                            throw new TypeError('Expected "' + s.name + '" to not repeat, but received `' + JSON.stringify(d) + "`");
                        if (0 === d.length) {
                            if (s.optional)
                                continue;
                            throw new TypeError('Expected "' + s.name + '" to not be empty')
                        }
                        for (var u = 0; u < d.length; u++) {
                            if (c = o(d[u]),
                            !t[l].test(c))
                                throw new TypeError('Expected all "' + s.name + '" to match "' + s.pattern + '", but received `' + JSON.stringify(c) + "`");
                            i += (0 === u ? s.prefix : s.delimiter) + c
                        }
                    } else {
                        if (c = s.asterisk ? encodeURI(d).replace(/[?#]/g, (function(n) {
                            return "%" + n.charCodeAt(0).toString(16).toUpperCase()
                        }
                        )) : o(d),
                        !t[l].test(c))
                            throw new TypeError('Expected "' + s.name + '" to match "' + s.pattern + '", but received "' + c + '"');
                        i += s.prefix + c
                    }
                } else
                    i += s
            }
            return i
        }
    }
    function wr(n) {
        return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g, "\\$1")
    }
    function Ur(n) {
        return n.replace(/([=!:$\/()])/g, "\\$1")
    }
    function zr(n, e) {
        return n.keys = e,
        n
    }
    function Pr(n) {
        return n && n.sensitive ? "" : "i"
    }
    function Dr(n, e, t) {
        xr(e) || (t = e || t,
        e = []);
        for (var a = (t = t || {}).strict, i = !1 !== t.end, r = "", o = 0; o < n.length; o++) {
            var l = n[o];
            if ("string" == typeof l)
                r += wr(l);
            else {
                var s = wr(l.prefix)
                  , c = "(?:" + l.pattern + ")";
                e.push(l),
                l.repeat && (c += "(?:" + s + c + ")*"),
                r += c = l.optional ? l.partial ? s + "(" + c + ")?" : "(?:" + s + "(" + c + "))?" : s + "(" + c + ")"
            }
        }
        var d = wr(t.delimiter || "/")
          , u = r.slice(-d.length) === d;
        return a || (r = (u ? r.slice(0, -d.length) : r) + "(?:" + d + "(?=$))?"),
        r += i ? "$" : a && u ? "" : "(?=" + d + "|$)",
        zr(new RegExp("^" + r,Pr(t)), e)
    }
    function Br(n, e, t) {
        return xr(e) || (t = e || t,
        e = []),
        t = t || {},
        n instanceof RegExp ? function(n, e) {
            var t = n.source.match(/\((?!\?)/g);
            if (t)
                for (var a = 0; a < t.length; a++)
                    e.push({
                        name: a,
                        prefix: null,
                        delimiter: null,
                        optional: !1,
                        repeat: !1,
                        partial: !1,
                        asterisk: !1,
                        pattern: null
                    });
            return zr(n, e)
        }(n, e) : xr(n) ? function(n, e, t) {
            for (var a = [], i = 0; i < n.length; i++)
                a.push(Br(n[i], e, t).source);
            return zr(new RegExp("(?:" + a.join("|") + ")",Pr(t)), e)
        }(n, e, t) : function(n, e, t) {
            return Dr(Ir(n, t), e, t)
        }(n, e, t)
    }
    Cr.parse = Lr,
    Cr.compile = Nr,
    Cr.tokensToFunction = Mr,
    Cr.tokensToRegExp = kr;
    var jr = Object.create(null);
    function Fr(n, e, t) {
        e = e || {};
        try {
            var a = jr[n] || (jr[n] = Cr.compile(n));
            return "string" == typeof e.pathMatch && (e[0] = e.pathMatch),
            a(e, {
                pretty: !0
            })
        } catch (n) {
            return ""
        } finally {
            delete e[0]
        }
    }
    function qr(n, e, t, a) {
        var i = "string" == typeof n ? {
            path: n
        } : n;
        if (i._normalized)
            return i;
        if (i.name) {
            var r = (i = tr({}, n)).params;
            return r && "object" == typeof r && (i.params = tr({}, r)),
            i
        }
        if (!i.path && i.params && e) {
            (i = tr({}, i))._normalized = !0;
            var o = tr(tr({}, e.params), i.params);
            if (e.name)
                i.name = e.name,
                i.params = o;
            else if (e.matched.length) {
                var l = e.matched[e.matched.length - 1].path;
                i.path = Fr(l, o, e.path)
            } else
                0;
            return i
        }
        var s = function(n) {
            var e = ""
              , t = ""
              , a = n.indexOf("#");
            a >= 0 && (e = n.slice(a),
            n = n.slice(0, a));
            var i = n.indexOf("?");
            return i >= 0 && (t = n.slice(i + 1),
            n = n.slice(0, i)),
            {
                path: n,
                query: t,
                hash: e
            }
        }(i.path || "")
          , c = e && e.path || "/"
          , d = s.path ? Tr(s.path, c, t || i.append) : c
          , u = function(n, e, t) {
            void 0 === e && (e = {});
            var a, i = t || cr;
            try {
                a = i(n || "")
            } catch (n) {
                a = {}
            }
            for (var r in e) {
                var o = e[r];
                a[r] = Array.isArray(o) ? o.map(sr) : sr(o)
            }
            return a
        }(s.query, i.query, a && a.options.parseQuery)
          , m = i.hash || s.hash;
        return m && "#" !== m.charAt(0) && (m = "#" + m),
        {
            _normalized: !0,
            path: d,
            query: u,
            hash: m
        }
    }
    var Vr, Hr = function() {}, $r = {
        name: "RouterLink",
        props: {
            to: {
                type: [String, Object],
                required: !0
            },
            tag: {
                type: String,
                default: "a"
            },
            custom: Boolean,
            exact: Boolean,
            exactPath: Boolean,
            append: Boolean,
            replace: Boolean,
            activeClass: String,
            exactActiveClass: String,
            ariaCurrentValue: {
                type: String,
                default: "page"
            },
            event: {
                type: [String, Array],
                default: "click"
            }
        },
        render: function(n) {
            var e = this
              , t = this.$router
              , a = this.$route
              , i = t.resolve(this.to, a, this.append)
              , r = i.location
              , o = i.route
              , l = i.href
              , s = {}
              , c = t.options.linkActiveClass
              , d = t.options.linkExactActiveClass
              , u = null == c ? "router-link-active" : c
              , m = null == d ? "router-link-exact-active" : d
              , p = null == this.activeClass ? u : this.activeClass
              , h = null == this.exactActiveClass ? m : this.exactActiveClass
              , g = o.redirectedFrom ? mr(null, qr(o.redirectedFrom), null, t) : o;
            s[h] = vr(a, g, this.exactPath),
            s[p] = this.exact || this.exactPath ? s[h] : function(n, e) {
                return 0 === n.path.replace(ur, "/").indexOf(e.path.replace(ur, "/")) && (!e.hash || n.hash === e.hash) && function(n, e) {
                    for (var t in e)
                        if (!(t in n))
                            return !1;
                    return !0
                }(n.query, e.query)
            }(a, g);
            var _ = s[h] ? this.ariaCurrentValue : null
              , v = function(n) {
                Kr(n) && (e.replace ? t.replace(r, Hr) : t.push(r, Hr))
            }
              , b = {
                click: Kr
            };
            Array.isArray(this.event) ? this.event.forEach((function(n) {
                b[n] = v
            }
            )) : b[this.event] = v;
            var f = {
                class: s
            }
              , E = !this.$scopedSlots.$hasNormal && this.$scopedSlots.default && this.$scopedSlots.default({
                href: l,
                route: o,
                navigate: v,
                isActive: s[p],
                isExactActive: s[h]
            });
            if (E) {
                if (1 === E.length)
                    return E[0];
                if (E.length > 1 || !E.length)
                    return 0 === E.length ? n() : n("span", {}, E)
            }
            if ("a" === this.tag)
                f.on = b,
                f.attrs = {
                    href: l,
                    "aria-current": _
                };
            else {
                var y = function n(e) {
                    var t;
                    if (e)
                        for (var a = 0; a < e.length; a++) {
                            if ("a" === (t = e[a]).tag)
                                return t;
                            if (t.children && (t = n(t.children)))
                                return t
                        }
                }(this.$slots.default);
                if (y) {
                    y.isStatic = !1;
                    var T = y.data = tr({}, y.data);
                    for (var A in T.on = T.on || {},
                    T.on) {
                        var x = T.on[A];
                        A in b && (T.on[A] = Array.isArray(x) ? x : [x])
                    }
                    for (var C in b)
                        C in T.on ? T.on[C].push(b[C]) : T.on[C] = v;
                    var L = y.data.attrs = tr({}, y.data.attrs);
                    L.href = l,
                    L["aria-current"] = _
                } else
                    f.on = b
            }
            return n(this.tag, f, this.$slots.default)
        }
    };
    function Kr(n) {
        if (!(n.metaKey || n.altKey || n.ctrlKey || n.shiftKey || n.defaultPrevented || void 0 !== n.button && 0 !== n.button)) {
            if (n.currentTarget && n.currentTarget.getAttribute) {
                var e = n.currentTarget.getAttribute("target");
                if (/\b_blank\b/i.test(e))
                    return
            }
            return n.preventDefault && n.preventDefault(),
            !0
        }
    }
    var Gr = "undefined" != typeof window;
    function Yr(n, e, t, a, i) {
        var r = e || []
          , o = t || Object.create(null)
          , l = a || Object.create(null);
        n.forEach((function(n) {
            !function n(e, t, a, i, r, o) {
                var l = i.path
                  , s = i.name;
                0;
                var c = i.pathToRegexpOptions || {}
                  , d = function(n, e, t) {
                    t || (n = n.replace(/\/$/, ""));
                    if ("/" === n[0])
                        return n;
                    if (null == e)
                        return n;
                    return Ar(e.path + "/" + n)
                }(l, r, c.strict);
                "boolean" == typeof i.caseSensitive && (c.sensitive = i.caseSensitive);
                var u = {
                    path: d,
                    regex: Jr(d, c),
                    components: i.components || {
                        default: i.component
                    },
                    alias: i.alias ? "string" == typeof i.alias ? [i.alias] : i.alias : [],
                    instances: {},
                    enteredCbs: {},
                    name: s,
                    parent: r,
                    matchAs: o,
                    redirect: i.redirect,
                    beforeEnter: i.beforeEnter,
                    meta: i.meta || {},
                    props: null == i.props ? {} : i.components ? i.props : {
                        default: i.props
                    }
                };
                i.children && i.children.forEach((function(i) {
                    var r = o ? Ar(o + "/" + i.path) : void 0;
                    n(e, t, a, i, u, r)
                }
                ));
                t[u.path] || (e.push(u.path),
                t[u.path] = u);
                if (void 0 !== i.alias)
                    for (var m = Array.isArray(i.alias) ? i.alias : [i.alias], p = 0; p < m.length; ++p) {
                        0;
                        var h = {
                            path: m[p],
                            children: i.children
                        };
                        n(e, t, a, h, r, u.path || "/")
                    }
                s && (a[s] || (a[s] = u))
            }(r, o, l, n, i)
        }
        ));
        for (var s = 0, c = r.length; s < c; s++)
            "*" === r[s] && (r.push(r.splice(s, 1)[0]),
            c--,
            s--);
        return {
            pathList: r,
            pathMap: o,
            nameMap: l
        }
    }
    function Jr(n, e) {
        return Cr(n, [], e)
    }
    function Wr(n, e) {
        var t = Yr(n)
          , a = t.pathList
          , i = t.pathMap
          , r = t.nameMap;
        function o(n, t, o) {
            var l = qr(n, t, !1, e)
              , c = l.name;
            if (c) {
                var d = r[c];
                if (!d)
                    return s(null, l);
                var u = d.regex.keys.filter((function(n) {
                    return !n.optional
                }
                )).map((function(n) {
                    return n.name
                }
                ));
                if ("object" != typeof l.params && (l.params = {}),
                t && "object" == typeof t.params)
                    for (var m in t.params)
                        !(m in l.params) && u.indexOf(m) > -1 && (l.params[m] = t.params[m]);
                return l.path = Fr(d.path, l.params),
                s(d, l, o)
            }
            if (l.path) {
                l.params = {};
                for (var p = 0; p < a.length; p++) {
                    var h = a[p]
                      , g = i[h];
                    if (Qr(g.regex, l.path, l.params))
                        return s(g, l, o)
                }
            }
            return s(null, l)
        }
        function l(n, t) {
            var a = n.redirect
              , i = "function" == typeof a ? a(mr(n, t, null, e)) : a;
            if ("string" == typeof i && (i = {
                path: i
            }),
            !i || "object" != typeof i)
                return s(null, t);
            var l = i
              , c = l.name
              , d = l.path
              , u = t.query
              , m = t.hash
              , p = t.params;
            if (u = l.hasOwnProperty("query") ? l.query : u,
            m = l.hasOwnProperty("hash") ? l.hash : m,
            p = l.hasOwnProperty("params") ? l.params : p,
            c) {
                r[c];
                return o({
                    _normalized: !0,
                    name: c,
                    query: u,
                    hash: m,
                    params: p
                }, void 0, t)
            }
            if (d) {
                var h = function(n, e) {
                    return Tr(n, e.parent ? e.parent.path : "/", !0)
                }(d, n);
                return o({
                    _normalized: !0,
                    path: Fr(h, p),
                    query: u,
                    hash: m
                }, void 0, t)
            }
            return s(null, t)
        }
        function s(n, t, a) {
            return n && n.redirect ? l(n, a || t) : n && n.matchAs ? function(n, e, t) {
                var a = o({
                    _normalized: !0,
                    path: Fr(t, e.params)
                });
                if (a) {
                    var i = a.matched
                      , r = i[i.length - 1];
                    return e.params = a.params,
                    s(r, e)
                }
                return s(null, e)
            }(0, t, n.matchAs) : mr(n, t, a, e)
        }
        return {
            match: o,
            addRoute: function(n, e) {
                var t = "object" != typeof n ? r[n] : void 0;
                Yr([e || n], a, i, r, t),
                t && t.alias.length && Yr(t.alias.map((function(n) {
                    return {
                        path: n,
                        children: [e]
                    }
                }
                )), a, i, r, t)
            },
            getRoutes: function() {
                return a.map((function(n) {
                    return i[n]
                }
                ))
            },
            addRoutes: function(n) {
                Yr(n, a, i, r)
            }
        }
    }
    function Qr(n, e, t) {
        var a = e.match(n);
        if (!a)
            return !1;
        if (!t)
            return !0;
        for (var i = 1, r = a.length; i < r; ++i) {
            var o = n.keys[i - 1];
            o && (t[o.name || "pathMatch"] = "string" == typeof a[i] ? lr(a[i]) : a[i])
        }
        return !0
    }
    var Zr = Gr && window.performance && window.performance.now ? window.performance : Date;
    function Xr() {
        return Zr.now().toFixed(3)
    }
    var no = Xr();
    function eo() {
        return no
    }
    function to(n) {
        return no = n
    }
    var ao = Object.create(null);
    function io() {
        "scrollRestoration"in window.history && (window.history.scrollRestoration = "manual");
        var n = window.location.protocol + "//" + window.location.host
          , e = window.location.href.replace(n, "")
          , t = tr({}, window.history.state);
        return t.key = eo(),
        window.history.replaceState(t, "", e),
        window.addEventListener("popstate", lo),
        function() {
            window.removeEventListener("popstate", lo)
        }
    }
    function ro(n, e, t, a) {
        if (n.app) {
            var i = n.options.scrollBehavior;
            i && n.app.$nextTick((function() {
                var r = function() {
                    var n = eo();
                    if (n)
                        return ao[n]
                }()
                  , o = i.call(n, e, t, a ? r : null);
                o && ("function" == typeof o.then ? o.then((function(n) {
                    po(n, r)
                }
                )).catch((function(n) {
                    0
                }
                )) : po(o, r))
            }
            ))
        }
    }
    function oo() {
        var n = eo();
        n && (ao[n] = {
            x: window.pageXOffset,
            y: window.pageYOffset
        })
    }
    function lo(n) {
        oo(),
        n.state && n.state.key && to(n.state.key)
    }
    function so(n) {
        return uo(n.x) || uo(n.y)
    }
    function co(n) {
        return {
            x: uo(n.x) ? n.x : window.pageXOffset,
            y: uo(n.y) ? n.y : window.pageYOffset
        }
    }
    function uo(n) {
        return "number" == typeof n
    }
    var mo = /^#\d/;
    function po(n, e) {
        var t, a = "object" == typeof n;
        if (a && "string" == typeof n.selector) {
            var i = mo.test(n.selector) ? document.getElementById(n.selector.slice(1)) : document.querySelector(n.selector);
            if (i) {
                var r = n.offset && "object" == typeof n.offset ? n.offset : {};
                e = function(n, e) {
                    var t = document.documentElement.getBoundingClientRect()
                      , a = n.getBoundingClientRect();
                    return {
                        x: a.left - t.left - e.x,
                        y: a.top - t.top - e.y
                    }
                }(i, r = {
                    x: uo((t = r).x) ? t.x : 0,
                    y: uo(t.y) ? t.y : 0
                })
            } else
                so(n) && (e = co(n))
        } else
            a && so(n) && (e = co(n));
        e && ("scrollBehavior"in document.documentElement.style ? window.scrollTo({
            left: e.x,
            top: e.y,
            behavior: n.behavior
        }) : window.scrollTo(e.x, e.y))
    }
    var ho, go = Gr && ((-1 === (ho = window.navigator.userAgent).indexOf("Android 2.") && -1 === ho.indexOf("Android 4.0") || -1 === ho.indexOf("Mobile Safari") || -1 !== ho.indexOf("Chrome") || -1 !== ho.indexOf("Windows Phone")) && window.history && "function" == typeof window.history.pushState);
    function _o(n, e) {
        oo();
        var t = window.history;
        try {
            if (e) {
                var a = tr({}, t.state);
                a.key = eo(),
                t.replaceState(a, "", n)
            } else
                t.pushState({
                    key: to(Xr())
                }, "", n)
        } catch (t) {
            window.location[e ? "replace" : "assign"](n)
        }
    }
    function vo(n) {
        _o(n, !0)
    }
    var bo = {
        redirected: 2,
        aborted: 4,
        cancelled: 8,
        duplicated: 16
    };
    function fo(n, e) {
        return yo(n, e, bo.redirected, 'Redirected when going from "' + n.fullPath + '" to "' + function(n) {
            if ("string" == typeof n)
                return n;
            if ("path"in n)
                return n.path;
            var e = {};
            return To.forEach((function(t) {
                t in n && (e[t] = n[t])
            }
            )),
            JSON.stringify(e, null, 2)
        }(e) + '" via a navigation guard.')
    }
    function Eo(n, e) {
        return yo(n, e, bo.cancelled, 'Navigation cancelled from "' + n.fullPath + '" to "' + e.fullPath + '" with a new navigation.')
    }
    function yo(n, e, t, a) {
        var i = new Error(a);
        return i._isRouter = !0,
        i.from = n,
        i.to = e,
        i.type = t,
        i
    }
    var To = ["params", "query", "hash"];
    function Ao(n) {
        return Object.prototype.toString.call(n).indexOf("Error") > -1
    }
    function xo(n, e) {
        return Ao(n) && n._isRouter && (null == e || n.type === e)
    }
    function Co(n, e, t) {
        var a = function(i) {
            i >= n.length ? t() : n[i] ? e(n[i], (function() {
                a(i + 1)
            }
            )) : a(i + 1)
        };
        a(0)
    }
    function Lo(n) {
        return function(e, t, a) {
            var i = !1
              , r = 0
              , o = null;
            No(n, (function(n, e, t, l) {
                if ("function" == typeof n && void 0 === n.cid) {
                    i = !0,
                    r++;
                    var s, c = Oo((function(e) {
                        var i;
                        ((i = e).__esModule || ko && "Module" === i[Symbol.toStringTag]) && (e = e.default),
                        n.resolved = "function" == typeof e ? e : Vr.extend(e),
                        t.components[l] = e,
                        --r <= 0 && a()
                    }
                    )), d = Oo((function(n) {
                        var e = "Failed to resolve async component " + l + ": " + n;
                        o || (o = Ao(n) ? n : new Error(e),
                        a(o))
                    }
                    ));
                    try {
                        s = n(c, d)
                    } catch (n) {
                        d(n)
                    }
                    if (s)
                        if ("function" == typeof s.then)
                            s.then(c, d);
                        else {
                            var u = s.component;
                            u && "function" == typeof u.then && u.then(c, d)
                        }
                }
            }
            )),
            i || a()
        }
    }
    function No(n, e) {
        return Mo(n.map((function(n) {
            return Object.keys(n.components).map((function(t) {
                return e(n.components[t], n.instances[t], n, t)
            }
            ))
        }
        )))
    }
    function Mo(n) {
        return Array.prototype.concat.apply([], n)
    }
    var ko = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag;
    function Oo(n) {
        var e = !1;
        return function() {
            for (var t = [], a = arguments.length; a--; )
                t[a] = arguments[a];
            if (!e)
                return e = !0,
                n.apply(this, t)
        }
    }
    var Io = function(n, e) {
        this.router = n,
        this.base = function(n) {
            if (!n)
                if (Gr) {
                    var e = document.querySelector("base");
                    n = (n = e && e.getAttribute("href") || "/").replace(/^https?:\/\/[^\/]+/, "")
                } else
                    n = "/";
            "/" !== n.charAt(0) && (n = "/" + n);
            return n.replace(/\/$/, "")
        }(e),
        this.current = hr,
        this.pending = null,
        this.ready = !1,
        this.readyCbs = [],
        this.readyErrorCbs = [],
        this.errorCbs = [],
        this.listeners = []
    };
    function So(n, e, t, a) {
        var i = No(n, (function(n, a, i, r) {
            var o = function(n, e) {
                "function" != typeof n && (n = Vr.extend(n));
                return n.options[e]
            }(n, e);
            if (o)
                return Array.isArray(o) ? o.map((function(n) {
                    return t(n, a, i, r)
                }
                )) : t(o, a, i, r)
        }
        ));
        return Mo(a ? i.reverse() : i)
    }
    function Ro(n, e) {
        if (e)
            return function() {
                return n.apply(e, arguments)
            }
    }
    Io.prototype.listen = function(n) {
        this.cb = n
    }
    ,
    Io.prototype.onReady = function(n, e) {
        this.ready ? n() : (this.readyCbs.push(n),
        e && this.readyErrorCbs.push(e))
    }
    ,
    Io.prototype.onError = function(n) {
        this.errorCbs.push(n)
    }
    ,
    Io.prototype.transitionTo = function(n, e, t) {
        var a, i = this;
        try {
            a = this.router.match(n, this.current)
        } catch (n) {
            throw this.errorCbs.forEach((function(e) {
                e(n)
            }
            )),
            n
        }
        var r = this.current;
        this.confirmTransition(a, (function() {
            i.updateRoute(a),
            e && e(a),
            i.ensureURL(),
            i.router.afterHooks.forEach((function(n) {
                n && n(a, r)
            }
            )),
            i.ready || (i.ready = !0,
            i.readyCbs.forEach((function(n) {
                n(a)
            }
            )))
        }
        ), (function(n) {
            t && t(n),
            n && !i.ready && (xo(n, bo.redirected) && r === hr || (i.ready = !0,
            i.readyErrorCbs.forEach((function(e) {
                e(n)
            }
            ))))
        }
        ))
    }
    ,
    Io.prototype.confirmTransition = function(n, e, t) {
        var a = this
          , i = this.current;
        this.pending = n;
        var r, o, l = function(n) {
            !xo(n) && Ao(n) && (a.errorCbs.length ? a.errorCbs.forEach((function(e) {
                e(n)
            }
            )) : console.error(n)),
            t && t(n)
        }, s = n.matched.length - 1, c = i.matched.length - 1;
        if (vr(n, i) && s === c && n.matched[s] === i.matched[c])
            return this.ensureURL(),
            n.hash && ro(this.router, i, n, !1),
            l(((o = yo(r = i, n, bo.duplicated, 'Avoided redundant navigation to current location: "' + r.fullPath + '".')).name = "NavigationDuplicated",
            o));
        var d = function(n, e) {
            var t, a = Math.max(n.length, e.length);
            for (t = 0; t < a && n[t] === e[t]; t++)
                ;
            return {
                updated: e.slice(0, t),
                activated: e.slice(t),
                deactivated: n.slice(t)
            }
        }(this.current.matched, n.matched)
          , u = d.updated
          , m = d.deactivated
          , p = d.activated
          , h = [].concat(function(n) {
            return So(n, "beforeRouteLeave", Ro, !0)
        }(m), this.router.beforeHooks, function(n) {
            return So(n, "beforeRouteUpdate", Ro)
        }(u), p.map((function(n) {
            return n.beforeEnter
        }
        )), Lo(p))
          , g = function(e, t) {
            if (a.pending !== n)
                return l(Eo(i, n));
            try {
                e(n, i, (function(e) {
                    !1 === e ? (a.ensureURL(!0),
                    l(function(n, e) {
                        return yo(n, e, bo.aborted, 'Navigation aborted from "' + n.fullPath + '" to "' + e.fullPath + '" via a navigation guard.')
                    }(i, n))) : Ao(e) ? (a.ensureURL(!0),
                    l(e)) : "string" == typeof e || "object" == typeof e && ("string" == typeof e.path || "string" == typeof e.name) ? (l(fo(i, n)),
                    "object" == typeof e && e.replace ? a.replace(e) : a.push(e)) : t(e)
                }
                ))
            } catch (n) {
                l(n)
            }
        };
        Co(h, g, (function() {
            Co(function(n) {
                return So(n, "beforeRouteEnter", (function(n, e, t, a) {
                    return function(n, e, t) {
                        return function(a, i, r) {
                            return n(a, i, (function(n) {
                                "function" == typeof n && (e.enteredCbs[t] || (e.enteredCbs[t] = []),
                                e.enteredCbs[t].push(n)),
                                r(n)
                            }
                            ))
                        }
                    }(n, t, a)
                }
                ))
            }(p).concat(a.router.resolveHooks), g, (function() {
                if (a.pending !== n)
                    return l(Eo(i, n));
                a.pending = null,
                e(n),
                a.router.app && a.router.app.$nextTick((function() {
                    fr(n)
                }
                ))
            }
            ))
        }
        ))
    }
    ,
    Io.prototype.updateRoute = function(n) {
        this.current = n,
        this.cb && this.cb(n)
    }
    ,
    Io.prototype.setupListeners = function() {}
    ,
    Io.prototype.teardown = function() {
        this.listeners.forEach((function(n) {
            n()
        }
        )),
        this.listeners = [],
        this.current = hr,
        this.pending = null
    }
    ;
    var wo = function(n) {
        function e(e, t) {
            n.call(this, e, t),
            this._startLocation = Uo(this.base)
        }
        return n && (e.__proto__ = n),
        e.prototype = Object.create(n && n.prototype),
        e.prototype.constructor = e,
        e.prototype.setupListeners = function() {
            var n = this;
            if (!(this.listeners.length > 0)) {
                var e = this.router
                  , t = e.options.scrollBehavior
                  , a = go && t;
                a && this.listeners.push(io());
                var i = function() {
                    var t = n.current
                      , i = Uo(n.base);
                    n.current === hr && i === n._startLocation || n.transitionTo(i, (function(n) {
                        a && ro(e, n, t, !0)
                    }
                    ))
                };
                window.addEventListener("popstate", i),
                this.listeners.push((function() {
                    window.removeEventListener("popstate", i)
                }
                ))
            }
        }
        ,
        e.prototype.go = function(n) {
            window.history.go(n)
        }
        ,
        e.prototype.push = function(n, e, t) {
            var a = this
              , i = this.current;
            this.transitionTo(n, (function(n) {
                _o(Ar(a.base + n.fullPath)),
                ro(a.router, n, i, !1),
                e && e(n)
            }
            ), t)
        }
        ,
        e.prototype.replace = function(n, e, t) {
            var a = this
              , i = this.current;
            this.transitionTo(n, (function(n) {
                vo(Ar(a.base + n.fullPath)),
                ro(a.router, n, i, !1),
                e && e(n)
            }
            ), t)
        }
        ,
        e.prototype.ensureURL = function(n) {
            if (Uo(this.base) !== this.current.fullPath) {
                var e = Ar(this.base + this.current.fullPath);
                n ? _o(e) : vo(e)
            }
        }
        ,
        e.prototype.getCurrentLocation = function() {
            return Uo(this.base)
        }
        ,
        e
    }(Io);
    function Uo(n) {
        var e = window.location.pathname
          , t = e.toLowerCase()
          , a = n.toLowerCase();
        return !n || t !== a && 0 !== t.indexOf(Ar(a + "/")) || (e = e.slice(n.length)),
        (e || "/") + window.location.search + window.location.hash
    }
    var zo = function(n) {
        function e(e, t, a) {
            n.call(this, e, t),
            a && function(n) {
                var e = Uo(n);
                if (!/^\/#/.test(e))
                    return window.location.replace(Ar(n + "/#" + e)),
                    !0
            }(this.base) || Po()
        }
        return n && (e.__proto__ = n),
        e.prototype = Object.create(n && n.prototype),
        e.prototype.constructor = e,
        e.prototype.setupListeners = function() {
            var n = this;
            if (!(this.listeners.length > 0)) {
                var e = this.router.options.scrollBehavior
                  , t = go && e;
                t && this.listeners.push(io());
                var a = function() {
                    var e = n.current;
                    Po() && n.transitionTo(Do(), (function(a) {
                        t && ro(n.router, a, e, !0),
                        go || Fo(a.fullPath)
                    }
                    ))
                }
                  , i = go ? "popstate" : "hashchange";
                window.addEventListener(i, a),
                this.listeners.push((function() {
                    window.removeEventListener(i, a)
                }
                ))
            }
        }
        ,
        e.prototype.push = function(n, e, t) {
            var a = this
              , i = this.current;
            this.transitionTo(n, (function(n) {
                jo(n.fullPath),
                ro(a.router, n, i, !1),
                e && e(n)
            }
            ), t)
        }
        ,
        e.prototype.replace = function(n, e, t) {
            var a = this
              , i = this.current;
            this.transitionTo(n, (function(n) {
                Fo(n.fullPath),
                ro(a.router, n, i, !1),
                e && e(n)
            }
            ), t)
        }
        ,
        e.prototype.go = function(n) {
            window.history.go(n)
        }
        ,
        e.prototype.ensureURL = function(n) {
            var e = this.current.fullPath;
            Do() !== e && (n ? jo(e) : Fo(e))
        }
        ,
        e.prototype.getCurrentLocation = function() {
            return Do()
        }
        ,
        e
    }(Io);
    function Po() {
        var n = Do();
        return "/" === n.charAt(0) || (Fo("/" + n),
        !1)
    }
    function Do() {
        var n = window.location.href
          , e = n.indexOf("#");
        return e < 0 ? "" : n = n.slice(e + 1)
    }
    function Bo(n) {
        var e = window.location.href
          , t = e.indexOf("#");
        return (t >= 0 ? e.slice(0, t) : e) + "#" + n
    }
    function jo(n) {
        go ? _o(Bo(n)) : window.location.hash = n
    }
    function Fo(n) {
        go ? vo(Bo(n)) : window.location.replace(Bo(n))
    }
    var qo = function(n) {
        function e(e, t) {
            n.call(this, e, t),
            this.stack = [],
            this.index = -1
        }
        return n && (e.__proto__ = n),
        e.prototype = Object.create(n && n.prototype),
        e.prototype.constructor = e,
        e.prototype.push = function(n, e, t) {
            var a = this;
            this.transitionTo(n, (function(n) {
                a.stack = a.stack.slice(0, a.index + 1).concat(n),
                a.index++,
                e && e(n)
            }
            ), t)
        }
        ,
        e.prototype.replace = function(n, e, t) {
            var a = this;
            this.transitionTo(n, (function(n) {
                a.stack = a.stack.slice(0, a.index).concat(n),
                e && e(n)
            }
            ), t)
        }
        ,
        e.prototype.go = function(n) {
            var e = this
              , t = this.index + n;
            if (!(t < 0 || t >= this.stack.length)) {
                var a = this.stack[t];
                this.confirmTransition(a, (function() {
                    var n = e.current;
                    e.index = t,
                    e.updateRoute(a),
                    e.router.afterHooks.forEach((function(e) {
                        e && e(a, n)
                    }
                    ))
                }
                ), (function(n) {
                    xo(n, bo.duplicated) && (e.index = t)
                }
                ))
            }
        }
        ,
        e.prototype.getCurrentLocation = function() {
            var n = this.stack[this.stack.length - 1];
            return n ? n.fullPath : "/"
        }
        ,
        e.prototype.ensureURL = function() {}
        ,
        e
    }(Io)
      , Vo = function(n) {
        void 0 === n && (n = {}),
        this.app = null,
        this.apps = [],
        this.options = n,
        this.beforeHooks = [],
        this.resolveHooks = [],
        this.afterHooks = [],
        this.matcher = Wr(n.routes || [], this);
        var e = n.mode || "hash";
        switch (this.fallback = "history" === e && !go && !1 !== n.fallback,
        this.fallback && (e = "hash"),
        Gr || (e = "abstract"),
        this.mode = e,
        e) {
        case "history":
            this.history = new wo(this,n.base);
            break;
        case "hash":
            this.history = new zo(this,n.base,this.fallback);
            break;
        case "abstract":
            this.history = new qo(this,n.base);
            break;
        default:
            0
        }
    }
      , Ho = {
        currentRoute: {
            configurable: !0
        }
    };
    Vo.prototype.match = function(n, e, t) {
        return this.matcher.match(n, e, t)
    }
    ,
    Ho.currentRoute.get = function() {
        return this.history && this.history.current
    }
    ,
    Vo.prototype.init = function(n) {
        var e = this;
        if (this.apps.push(n),
        n.$once("hook:destroyed", (function() {
            var t = e.apps.indexOf(n);
            t > -1 && e.apps.splice(t, 1),
            e.app === n && (e.app = e.apps[0] || null),
            e.app || e.history.teardown()
        }
        )),
        !this.app) {
            this.app = n;
            var t = this.history;
            if (t instanceof wo || t instanceof zo) {
                var a = function(n) {
                    t.setupListeners(),
                    function(n) {
                        var a = t.current
                          , i = e.options.scrollBehavior;
                        go && i && "fullPath"in n && ro(e, n, a, !1)
                    }(n)
                };
                t.transitionTo(t.getCurrentLocation(), a, a)
            }
            t.listen((function(n) {
                e.apps.forEach((function(e) {
                    e._route = n
                }
                ))
            }
            ))
        }
    }
    ,
    Vo.prototype.beforeEach = function(n) {
        return Ko(this.beforeHooks, n)
    }
    ,
    Vo.prototype.beforeResolve = function(n) {
        return Ko(this.resolveHooks, n)
    }
    ,
    Vo.prototype.afterEach = function(n) {
        return Ko(this.afterHooks, n)
    }
    ,
    Vo.prototype.onReady = function(n, e) {
        this.history.onReady(n, e)
    }
    ,
    Vo.prototype.onError = function(n) {
        this.history.onError(n)
    }
    ,
    Vo.prototype.push = function(n, e, t) {
        var a = this;
        if (!e && !t && "undefined" != typeof Promise)
            return new Promise((function(e, t) {
                a.history.push(n, e, t)
            }
            ));
        this.history.push(n, e, t)
    }
    ,
    Vo.prototype.replace = function(n, e, t) {
        var a = this;
        if (!e && !t && "undefined" != typeof Promise)
            return new Promise((function(e, t) {
                a.history.replace(n, e, t)
            }
            ));
        this.history.replace(n, e, t)
    }
    ,
    Vo.prototype.go = function(n) {
        this.history.go(n)
    }
    ,
    Vo.prototype.back = function() {
        this.go(-1)
    }
    ,
    Vo.prototype.forward = function() {
        this.go(1)
    }
    ,
    Vo.prototype.getMatchedComponents = function(n) {
        var e = n ? n.matched ? n : this.resolve(n).route : this.currentRoute;
        return e ? [].concat.apply([], e.matched.map((function(n) {
            return Object.keys(n.components).map((function(e) {
                return n.components[e]
            }
            ))
        }
        ))) : []
    }
    ,
    Vo.prototype.resolve = function(n, e, t) {
        var a = qr(n, e = e || this.history.current, t, this)
          , i = this.match(a, e)
          , r = i.redirectedFrom || i.fullPath;
        return {
            location: a,
            route: i,
            href: function(n, e, t) {
                var a = "hash" === t ? "#" + e : e;
                return n ? Ar(n + "/" + a) : a
            }(this.history.base, r, this.mode),
            normalizedTo: a,
            resolved: i
        }
    }
    ,
    Vo.prototype.getRoutes = function() {
        return this.matcher.getRoutes()
    }
    ,
    Vo.prototype.addRoute = function(n, e) {
        this.matcher.addRoute(n, e),
        this.history.current !== hr && this.history.transitionTo(this.history.getCurrentLocation())
    }
    ,
    Vo.prototype.addRoutes = function(n) {
        this.matcher.addRoutes(n),
        this.history.current !== hr && this.history.transitionTo(this.history.getCurrentLocation())
    }
    ,
    Object.defineProperties(Vo.prototype, Ho);
    var $o = Vo;
    function Ko(n, e) {
        return n.push(e),
        function() {
            var t = n.indexOf(e);
            t > -1 && n.splice(t, 1)
        }
    }
    Vo.install = function n(e) {
        if (!n.installed || Vr !== e) {
            n.installed = !0,
            Vr = e;
            var t = function(n) {
                return void 0 !== n
            }
              , a = function(n, e) {
                var a = n.$options._parentVnode;
                t(a) && t(a = a.data) && t(a = a.registerRouteInstance) && a(n, e)
            };
            e.mixin({
                beforeCreate: function() {
                    t(this.$options.router) ? (this._routerRoot = this,
                    this._router = this.$options.router,
                    this._router.init(this),
                    e.util.defineReactive(this, "_route", this._router.history.current)) : this._routerRoot = this.$parent && this.$parent._routerRoot || this,
                    a(this, this)
                },
                destroyed: function() {
                    a(this)
                }
            }),
            Object.defineProperty(e.prototype, "$router", {
                get: function() {
                    return this._routerRoot._router
                }
            }),
            Object.defineProperty(e.prototype, "$route", {
                get: function() {
                    return this._routerRoot._route
                }
            }),
            e.component("RouterView", Er),
            e.component("RouterLink", $r);
            var i = e.config.optionMergeStrategies;
            i.beforeRouteEnter = i.beforeRouteLeave = i.beforeRouteUpdate = i.created
        }
    }
    ,
    Vo.version = "3.6.5",
    Vo.isNavigationFailure = xo,
    Vo.NavigationFailureType = bo,
    Vo.START_LOCATION = hr,
    Gr && window.Vue && window.Vue.use(Vo);
    t(106);
    t(16),
    t(131);
    var Go = {
        NotFound: () => Promise.all([t.e(0), t.e(4)]).then(t.bind(null, 333)),
        Layout: () => Promise.all([t.e(0), t.e(2)]).then(t.bind(null, 332))
    }
      , Yo = {
        "v-02b738c7": () => t.e(5).then(t.bind(null, 334)),
        "v-429ee8f1": () => t.e(6).then(t.bind(null, 335)),
        "v-2b88bf2c": () => t.e(8).then(t.bind(null, 336)),
        "v-2fd82d08": () => t.e(7).then(t.bind(null, 337)),
        "v-0f8a606f": () => t.e(9).then(t.bind(null, 338)),
        "v-abcf704e": () => t.e(10).then(t.bind(null, 339)),
        "v-06f1ade6": () => t.e(11).then(t.bind(null, 340)),
        "v-5c7d2de3": () => t.e(12).then(t.bind(null, 341)),
        "v-999f7d24": () => t.e(13).then(t.bind(null, 342)),
        "v-bc6df3f8": () => t.e(14).then(t.bind(null, 343)),
        "v-7389e108": () => t.e(15).then(t.bind(null, 344)),
        "v-44dfccd2": () => t.e(16).then(t.bind(null, 345)),
        "v-2bac80ba": () => t.e(17).then(t.bind(null, 346)),
        "v-5e94a2f2": () => t.e(18).then(t.bind(null, 347)),
        "v-6fd4058c": () => t.e(22).then(t.bind(null, 348)),
        "v-25ea4e32": () => t.e(19).then(t.bind(null, 349)),
        "v-1c8ff8ea": () => t.e(20).then(t.bind(null, 350)),
        "v-14de04f4": () => t.e(21).then(t.bind(null, 351)),
        "v-43c1547e": () => t.e(23).then(t.bind(null, 352)),
        "v-a1e90a8a": () => t.e(24).then(t.bind(null, 353)),
        "v-7eec88fb": () => t.e(25).then(t.bind(null, 354)),
        "v-8f5874c6": () => t.e(26).then(t.bind(null, 355)),
        "v-d03982c2": () => t.e(28).then(t.bind(null, 356)),
        "v-6bf342bf": () => t.e(27).then(t.bind(null, 357)),
        "v-29a135b6": () => t.e(30).then(t.bind(null, 358)),
        "v-06acd369": () => t.e(29).then(t.bind(null, 359)),
        "v-016743b8": () => t.e(31).then(t.bind(null, 360)),
        "v-72c78798": () => t.e(34).then(t.bind(null, 361)),
        "v-a715ae90": () => t.e(32).then(t.bind(null, 362)),
        "v-7c41859a": () => t.e(33).then(t.bind(null, 363)),
        "v-bee4c996": () => t.e(35).then(t.bind(null, 364)),
        "v-01a3c3ae": () => t.e(36).then(t.bind(null, 365)),
        "v-4e5e44e1": () => t.e(37).then(t.bind(null, 366)),
        "v-ea775c7e": () => t.e(38).then(t.bind(null, 367)),
        "v-0a50e53e": () => t.e(39).then(t.bind(null, 368)),
        "v-34c1d3ae": () => t.e(40).then(t.bind(null, 369)),
        "v-f31a1c8e": () => t.e(41).then(t.bind(null, 370)),
        "v-a9ac9b64": () => t.e(43).then(t.bind(null, 371)),
        "v-4a7d74a0": () => t.e(42).then(t.bind(null, 372)),
        "v-b3cf38b6": () => t.e(45).then(t.bind(null, 373)),
        "v-efcaad44": () => t.e(44).then(t.bind(null, 374)),
        "v-0ef32c3e": () => t.e(46).then(t.bind(null, 375)),
        "v-78635b68": () => t.e(47).then(t.bind(null, 376)),
        "v-cad135d2": () => t.e(48).then(t.bind(null, 377)),
        "v-4542a8f3": () => t.e(49).then(t.bind(null, 378)),
        "v-0e8d395b": () => t.e(50).then(t.bind(null, 379)),
        "v-53547eb1": () => t.e(51).then(t.bind(null, 380)),
        "v-1538c668": () => t.e(52).then(t.bind(null, 381)),
        "v-29cec904": () => t.e(55).then(t.bind(null, 382)),
        "v-083d3c72": () => t.e(54).then(t.bind(null, 383)),
        "v-68f656d5": () => t.e(57).then(t.bind(null, 384)),
        "v-10102f0d": () => t.e(56).then(t.bind(null, 385)),
        "v-c5941d2e": () => t.e(58).then(t.bind(null, 386)),
        "v-1d2b9a12": () => t.e(59).then(t.bind(null, 387)),
        "v-7e706b0d": () => t.e(60).then(t.bind(null, 388)),
        "v-c869afae": () => t.e(53).then(t.bind(null, 389)),
        "v-6af50b4a": () => t.e(61).then(t.bind(null, 390)),
        "v-bcabe830": () => t.e(63).then(t.bind(null, 391)),
        "v-7f482612": () => t.e(62).then(t.bind(null, 392)),
        "v-fc3ae356": () => t.e(65).then(t.bind(null, 393)),
        "v-062f85ec": () => t.e(64).then(t.bind(null, 394)),
        "v-cc2f8ada": () => t.e(66).then(t.bind(null, 395)),
        "v-1c97a241": () => t.e(68).then(t.bind(null, 396)),
        "v-66fc1dcc": () => t.e(67).then(t.bind(null, 397)),
        "v-b58f8daa": () => t.e(69).then(t.bind(null, 398)),
        "v-74ea7ea9": () => t.e(70).then(t.bind(null, 399)),
        "v-fd046d40": () => t.e(71).then(t.bind(null, 400)),
        "v-36616294": () => t.e(72).then(t.bind(null, 401)),
        "v-2ec9624a": () => t.e(74).then(t.bind(null, 402)),
        "v-206fa80a": () => t.e(75).then(t.bind(null, 403)),
        "v-7bcb8f4d": () => t.e(73).then(t.bind(null, 404)),
        "v-9101d9a2": () => t.e(77).then(t.bind(null, 405)),
        "v-ffb49796": () => t.e(76).then(t.bind(null, 406)),
        "v-15fe64f5": () => t.e(78).then(t.bind(null, 407)),
        "v-e09374cc": () => t.e(79).then(t.bind(null, 408)),
        "v-51ece8cc": () => t.e(80).then(t.bind(null, 409)),
        "v-387aeb79": () => t.e(82).then(t.bind(null, 410)),
        "v-90482726": () => t.e(83).then(t.bind(null, 411)),
        "v-4da5e558": () => t.e(84).then(t.bind(null, 412)),
        "v-3a3955ca": () => t.e(81).then(t.bind(null, 413)),
        "v-18b6abc1": () => t.e(85).then(t.bind(null, 414)),
        "v-5e7d42dd": () => t.e(87).then(t.bind(null, 415)),
        "v-74d1fe05": () => t.e(86).then(t.bind(null, 416)),
        "v-6807e4c0": () => t.e(89).then(t.bind(null, 417)),
        "v-17169eb9": () => t.e(91).then(t.bind(null, 418)),
        "v-579c34cc": () => t.e(88).then(t.bind(null, 419)),
        "v-4ee82b66": () => t.e(92).then(t.bind(null, 420)),
        "v-6462c10c": () => t.e(90).then(t.bind(null, 421)),
        "v-1561b62d": () => t.e(97).then(t.bind(null, 422)),
        "v-667d3c15": () => t.e(93).then(t.bind(null, 423)),
        "v-21105448": () => t.e(94).then(t.bind(null, 424)),
        "v-efc01664": () => t.e(95).then(t.bind(null, 425)),
        "v-6909fb9a": () => t.e(96).then(t.bind(null, 426)),
        "v-5f89bd8e": () => t.e(98).then(t.bind(null, 427)),
        "v-2961facf": () => t.e(99).then(t.bind(null, 428)),
        "v-2f67cc3d": () => t.e(100).then(t.bind(null, 429)),
        "v-05be4724": () => t.e(101).then(t.bind(null, 430)),
        "v-37a586a9": () => t.e(102).then(t.bind(null, 431)),
        "v-743e4ef6": () => t.e(103).then(t.bind(null, 432)),
        "v-d0f81f92": () => t.e(104).then(t.bind(null, 433)),
        "v-5dfa0e50": () => t.e(105).then(t.bind(null, 434)),
        "v-c0d3292c": () => t.e(106).then(t.bind(null, 435)),
        "v-139162e2": () => t.e(107).then(t.bind(null, 436)),
        "v-6077cf88": () => t.e(109).then(t.bind(null, 437)),
        "v-030ec89a": () => t.e(110).then(t.bind(null, 438)),
        "v-533a65b7": () => t.e(111).then(t.bind(null, 439)),
        "v-daa527f8": () => t.e(108).then(t.bind(null, 440)),
        "v-2c1efaa7": () => t.e(112).then(t.bind(null, 441)),
        "v-718a2694": () => t.e(113).then(t.bind(null, 442)),
        "v-6f357586": () => t.e(114).then(t.bind(null, 443)),
        "v-7b64b9ed": () => t.e(117).then(t.bind(null, 444)),
        "v-31a9a83c": () => t.e(118).then(t.bind(null, 445)),
        "v-c7b93916": () => t.e(119).then(t.bind(null, 446)),
        "v-3b32bf6e": () => t.e(121).then(t.bind(null, 447)),
        "v-35ca4e46": () => t.e(116).then(t.bind(null, 448)),
        "v-3dd7997c": () => t.e(115).then(t.bind(null, 449)),
        "v-2a7a8dba": () => t.e(120).then(t.bind(null, 450)),
        "v-72c968c8": () => t.e(123).then(t.bind(null, 451)),
        "v-281927db": () => t.e(124).then(t.bind(null, 452)),
        "v-481dc19e": () => t.e(122).then(t.bind(null, 453)),
        "v-7b9175cc": () => t.e(127).then(t.bind(null, 454)),
        "v-6a4d8916": () => t.e(125).then(t.bind(null, 455)),
        "v-5a202116": () => t.e(126).then(t.bind(null, 456)),
        "v-299d87aa": () => t.e(129).then(t.bind(null, 457)),
        "v-ffef209a": () => t.e(128).then(t.bind(null, 458)),
        "v-21141a8d": () => t.e(130).then(t.bind(null, 459)),
        "v-09e8ac9a": () => t.e(131).then(t.bind(null, 460)),
        "v-54f886d0": () => t.e(132).then(t.bind(null, 461)),
        "v-42013c00": () => t.e(133).then(t.bind(null, 462)),
        "v-41341d4b": () => t.e(135).then(t.bind(null, 463)),
        "v-343e687c": () => t.e(134).then(t.bind(null, 464)),
        "v-7c10611a": () => t.e(136).then(t.bind(null, 465)),
        "v-773f7e1e": () => t.e(137).then(t.bind(null, 466)),
        "v-7845bd88": () => t.e(139).then(t.bind(null, 467)),
        "v-062f207d": () => t.e(138).then(t.bind(null, 468)),
        "v-58fea08e": () => t.e(140).then(t.bind(null, 469)),
        "v-e6e74c38": () => t.e(143).then(t.bind(null, 470)),
        "v-70a39a82": () => t.e(141).then(t.bind(null, 471)),
        "v-176d8495": () => t.e(145).then(t.bind(null, 472)),
        "v-c13f42f0": () => t.e(142).then(t.bind(null, 473)),
        "v-43441f7a": () => t.e(144).then(t.bind(null, 474)),
        "v-25aac8de": () => t.e(146).then(t.bind(null, 475)),
        "v-fbfa8048": () => t.e(148).then(t.bind(null, 476)),
        "v-50756546": () => t.e(150).then(t.bind(null, 477)),
        "v-a46abea8": () => t.e(149).then(t.bind(null, 478)),
        "v-d71b1316": () => t.e(147).then(t.bind(null, 479)),
        "v-a07ad6d0": () => t.e(151).then(t.bind(null, 480)),
        "v-2487171a": () => t.e(155).then(t.bind(null, 481)),
        "v-cf80555e": () => t.e(153).then(t.bind(null, 482)),
        "v-eb35368e": () => t.e(152).then(t.bind(null, 483)),
        "v-11c4deaa": () => t.e(154).then(t.bind(null, 484)),
        "v-3203ab40": () => t.e(156).then(t.bind(null, 485)),
        "v-3a8738bf": () => t.e(159).then(t.bind(null, 486)),
        "v-8117d9da": () => t.e(158).then(t.bind(null, 487)),
        "v-5b0d6144": () => t.e(157).then(t.bind(null, 488)),
        "v-3d6744a0": () => t.e(160).then(t.bind(null, 489)),
        "v-bd370bb0": () => t.e(161).then(t.bind(null, 490)),
        "v-9cf724c4": () => t.e(164).then(t.bind(null, 491)),
        "v-6cfef11d": () => t.e(163).then(t.bind(null, 492)),
        "v-96bcf192": () => t.e(165).then(t.bind(null, 493)),
        "v-2718e9ea": () => t.e(162).then(t.bind(null, 494)),
        "v-33de6fc2": () => t.e(166).then(t.bind(null, 495)),
        "v-76a0b199": () => t.e(169).then(t.bind(null, 496)),
        "v-708f9059": () => t.e(167).then(t.bind(null, 497)),
        "v-217c7a2a": () => t.e(170).then(t.bind(null, 498)),
        "v-3e3c0a92": () => t.e(168).then(t.bind(null, 499)),
        "v-1d0606ec": () => t.e(174).then(t.bind(null, 500)),
        "v-59619c72": () => t.e(173).then(t.bind(null, 501)),
        "v-1f164a08": () => t.e(172).then(t.bind(null, 502)),
        "v-1573c0d7": () => t.e(175).then(t.bind(null, 503)),
        "v-7b1df228": () => t.e(171).then(t.bind(null, 504)),
        "v-5f199590": () => t.e(177).then(t.bind(null, 505)),
        "v-34a0a5ca": () => t.e(176).then(t.bind(null, 506)),
        "v-017c0fde": () => t.e(178).then(t.bind(null, 507)),
        "v-604907e0": () => t.e(179).then(t.bind(null, 508)),
        "v-41a4a526": () => t.e(180).then(t.bind(null, 509)),
        "v-455bbf33": () => t.e(183).then(t.bind(null, 510)),
        "v-5979c815": () => t.e(181).then(t.bind(null, 511)),
        "v-6fec2647": () => t.e(184).then(t.bind(null, 512)),
        "v-f698ea34": () => t.e(182).then(t.bind(null, 513)),
        "v-191f91c3": () => t.e(185).then(t.bind(null, 514)),
        "v-6f969d4f": () => t.e(188).then(t.bind(null, 515)),
        "v-6707f78a": () => t.e(186).then(t.bind(null, 516)),
        "v-63425dba": () => t.e(187).then(t.bind(null, 517)),
        "v-b7a0fe8c": () => t.e(189).then(t.bind(null, 518)),
        "v-f3732e0a": () => t.e(191).then(t.bind(null, 519)),
        "v-26f5609c": () => t.e(190).then(t.bind(null, 520)),
        "v-1ff35d63": () => t.e(193).then(t.bind(null, 521)),
        "v-1f7300c5": () => t.e(192).then(t.bind(null, 522)),
        "v-19b9a873": () => t.e(194).then(t.bind(null, 523)),
        "v-a2edb502": () => t.e(196).then(t.bind(null, 524)),
        "v-ba868b3a": () => t.e(198).then(t.bind(null, 525)),
        "v-444a0f87": () => t.e(195).then(t.bind(null, 526)),
        "v-be4c250a": () => t.e(197).then(t.bind(null, 527)),
        "v-43f4868f": () => t.e(199).then(t.bind(null, 528)),
        "v-788d69fa": () => t.e(200).then(t.bind(null, 529)),
        "v-4c301678": () => t.e(202).then(t.bind(null, 530)),
        "v-08720438": () => t.e(201).then(t.bind(null, 531)),
        "v-fa8c6850": () => t.e(203).then(t.bind(null, 532)),
        "v-23b6cc78": () => t.e(204).then(t.bind(null, 533)),
        "v-4abee190": () => t.e(205).then(t.bind(null, 534)),
        "v-c0868a50": () => t.e(207).then(t.bind(null, 535)),
        "v-5f5ee778": () => t.e(206).then(t.bind(null, 536)),
        "v-3f295e87": () => t.e(209).then(t.bind(null, 537)),
        "v-7e58c238": () => t.e(208).then(t.bind(null, 538)),
        "v-f21f67b2": () => t.e(210).then(t.bind(null, 539)),
        "v-aded8732": () => t.e(211).then(t.bind(null, 540)),
        "v-74173047": () => t.e(214).then(t.bind(null, 541)),
        "v-a77a1c72": () => t.e(212).then(t.bind(null, 542)),
        "v-4994ee47": () => t.e(216).then(t.bind(null, 543)),
        "v-41bc0e67": () => t.e(213).then(t.bind(null, 544)),
        "v-171fe3f2": () => t.e(217).then(t.bind(null, 545)),
        "v-816439f2": () => t.e(215).then(t.bind(null, 546)),
        "v-99637f32": () => t.e(219).then(t.bind(null, 547)),
        "v-0f85e067": () => t.e(220).then(t.bind(null, 548)),
        "v-10452a93": () => t.e(218).then(t.bind(null, 549)),
        "v-03a14a67": () => t.e(221).then(t.bind(null, 550)),
        "v-31567b87": () => t.e(223).then(t.bind(null, 551)),
        "v-79b60e27": () => t.e(222).then(t.bind(null, 552)),
        "v-790095a7": () => t.e(225).then(t.bind(null, 553)),
        "v-4ef2e2f2": () => t.e(224).then(t.bind(null, 554)),
        "v-2030a8a7": () => t.e(226).then(t.bind(null, 555)),
        "v-406aafe7": () => t.e(227).then(t.bind(null, 556)),
        "v-2c62e6c7": () => t.e(230).then(t.bind(null, 557)),
        "v-255d11e7": () => t.e(229).then(t.bind(null, 558)),
        "v-aa31bdf2": () => t.e(228).then(t.bind(null, 559)),
        "v-682dfe87": () => t.e(231).then(t.bind(null, 560)),
        "v-81a0e9b8": () => t.e(232).then(t.bind(null, 561)),
        "v-8f722e46": () => t.e(235).then(t.bind(null, 562)),
        "v-0d120b84": () => t.e(234).then(t.bind(null, 563)),
        "v-126d25a2": () => t.e(233).then(t.bind(null, 564))
    };
    function Jo(n) {
        const e = Object.create(null);
        return function(t) {
            return e[t] || (e[t] = n(t))
        }
    }
    const Wo = /-(\w)/g
      , Qo = Jo(n => n.replace(Wo, (n, e) => e ? e.toUpperCase() : ""))
      , Zo = /\B([A-Z])/g
      , Xo = Jo(n => n.replace(Zo, "-$1").toLowerCase())
      , nl = Jo(n => n.charAt(0).toUpperCase() + n.slice(1));
    function el(n, e) {
        if (!e)
            return;
        if (n(e))
            return n(e);
        return e.includes("-") ? n(nl(Qo(e))) : n(nl(e)) || n(Xo(e))
    }
    const tl = Object.assign({}, Go, Yo)
      , al = n => tl[n]
      , il = n => Yo[n]
      , rl = n => Go[n]
      , ol = n => Gt.component(n);
    function ll(n) {
        return el(il, n)
    }
    function sl(n) {
        return el(rl, n)
    }
    function cl(n) {
        return el(al, n)
    }
    function dl(n) {
        return el(ol, n)
    }
    function ul(...n) {
        return Promise.all(n.filter(n => n).map(async n => {
            if (!dl(n) && cl(n)) {
                const e = await cl(n)();
                Gt.component(n, e.default)
            }
        }
        ))
    }
    function ml(n, e) {
        "undefined" != typeof window && window.__VUEPRESS__ && (window.__VUEPRESS__[n] = e)
    }
    var pl = t(92)
      , hl = t.n(pl)
      , gl = t(93)
      , _l = t.n(gl)
      , vl = {
        created() {
            if (this.siteMeta = this.$site.headTags.filter( ([n]) => "meta" === n).map( ([n,e]) => e),
            this.$ssrContext) {
                const e = this.getMergedMetaTags();
                this.$ssrContext.title = this.$title,
                this.$ssrContext.lang = this.$lang,
                this.$ssrContext.pageMeta = (n = e) ? n.map(n => {
                    let e = "<meta";
                    return Object.keys(n).forEach(t => {
                        e += ` ${t}="${_l()(n[t])}"`
                    }
                    ),
                    e + ">"
                }
                ).join("\n    ") : "",
                this.$ssrContext.canonicalLink = fl(this.$canonicalUrl)
            }
            var n
        },
        mounted() {
            this.currentMetaTags = [...document.querySelectorAll("meta")],
            this.updateMeta(),
            this.updateCanonicalLink()
        },
        methods: {
            updateMeta() {
                document.title = this.$title,
                document.documentElement.lang = this.$lang;
                const n = this.getMergedMetaTags();
                this.currentMetaTags = El(n, this.currentMetaTags)
            },
            getMergedMetaTags() {
                const n = this.$page.frontmatter.meta || [];
                return hl()([{
                    name: "description",
                    content: this.$description
                }], n, this.siteMeta, yl)
            },
            updateCanonicalLink() {
                bl(),
                this.$canonicalUrl && document.head.insertAdjacentHTML("beforeend", fl(this.$canonicalUrl))
            }
        },
        watch: {
            $page() {
                this.updateMeta(),
                this.updateCanonicalLink()
            }
        },
        beforeDestroy() {
            El(null, this.currentMetaTags),
            bl()
        }
    };
    function bl() {
        const n = document.querySelector("link[rel='canonical']");
        n && n.remove()
    }
    function fl(n="") {
        return n ? `<link href="${n}" rel="canonical" />` : ""
    }
    function El(n, e) {
        if (e && [...e].filter(n => n.parentNode === document.head).forEach(n => document.head.removeChild(n)),
        n)
            return n.map(n => {
                const e = document.createElement("meta");
                return Object.keys(n).forEach(t => {
                    e.setAttribute(t, n[t])
                }
                ),
                document.head.appendChild(e),
                e
            }
            )
    }
    function yl(n) {
        for (const e of ["name", "property", "itemprop"])
            if (n.hasOwnProperty(e))
                return n[e] + e;
        return JSON.stringify(n)
    }
    var Tl = t(50)
      , Al = {
        mounted() {
            window.addEventListener("scroll", this.onScroll)
        },
        methods: {
            onScroll: t.n(Tl)()((function() {
                this.setActiveHash()
            }
            ), 300),
            setActiveHash() {
                const n = [].slice.call(document.querySelectorAll(".sidebar-link"))
                  , e = [].slice.call(document.querySelectorAll(".header-anchor")).filter(e => n.some(n => n.hash === e.hash))
                  , t = Math.max(window.pageYOffset, document.documentElement.scrollTop, document.body.scrollTop)
                  , a = Math.max(document.documentElement.scrollHeight, document.body.scrollHeight)
                  , i = window.innerHeight + t;
                for (let n = 0; n < e.length; n++) {
                    const r = e[n]
                      , o = e[n + 1]
                      , l = 0 === n && 0 === t || t >= r.parentElement.offsetTop + 10 && (!o || t < o.parentElement.offsetTop - 10)
                      , s = decodeURIComponent(this.$route.hash);
                    if (l && s !== decodeURIComponent(r.hash)) {
                        const t = r;
                        if (i === a)
                            for (let t = n + 1; t < e.length; t++)
                                if (s === decodeURIComponent(e[t].hash))
                                    return;
                        return this.$vuepress.$set("disableScrollBehavior", !0),
                        void this.$router.replace(decodeURIComponent(t.hash), () => {
                            this.$nextTick( () => {
                                this.$vuepress.$set("disableScrollBehavior", !1)
                            }
                            )
                        }
                        )
                    }
                }
            }
        },
        beforeDestroy() {
            window.removeEventListener("scroll", this.onScroll)
        }
    }
      , xl = t(24)
      , Cl = t.n(xl)
      , Ll = {
        mounted() {
            Cl.a.configure({
                showSpinner: !1
            }),
            this.$router.beforeEach( (n, e, t) => {
                n.path === e.path || Gt.component(n.name) || Cl.a.start(),
                t()
            }
            ),
            this.$router.afterEach( () => {
                Cl.a.done(),
                this.isSidebarOpen = !1
            }
            )
        }
    };
    t(239),
    t(240);
    class Nl {
        constructor() {
            this.containerEl = document.getElementById("message-container"),
            this.containerEl || (this.containerEl = document.createElement("div"),
            this.containerEl.id = "message-container",
            document.body.appendChild(this.containerEl))
        }
        show({text: n="", duration: e=3e3}) {
            let t = document.createElement("div");
            t.className = "message move-in",
            t.innerHTML = `\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">${n}</div>\n    `,
            this.containerEl.appendChild(t),
            e > 0 && setTimeout( () => {
                this.close(t)
            }
            , e)
        }
        close(n) {
            n.className = n.className.replace("move-in", ""),
            n.className += "move-out",
            n.addEventListener("animationend", () => {
                n.remove()
            }
            )
        }
    }
    var Ml = {
        mounted() {
            !!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || this.updateCopy()
        },
        updated() {
            !!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || this.updateCopy()
        },
        methods: {
            updateCopy() {
                setTimeout( () => {
                    (['div[class*="language-"] pre', 'div[class*="aside-code"] aside']instanceof Array || Array.isArray(['div[class*="language-"] pre', 'div[class*="aside-code"] aside'])) && ['div[class*="language-"] pre', 'div[class*="aside-code"] aside'].forEach(n => {
                        document.querySelectorAll(n).forEach(this.generateCopyButton)
                    }
                    )
                }
                , 1e3)
            },
            generateCopyButton(n) {
                if (n.classList.contains("codecopy-enabled"))
                    return;
                const e = document.createElement("i");
                e.className = "code-copy",
                e.innerHTML = '<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',
                e.title = "Copy to clipboard",
                e.addEventListener("click", () => {
                    this.copyToClipboard(n.innerText)
                }
                ),
                n.appendChild(e),
                n.classList.add("codecopy-enabled")
            },
            copyToClipboard(n) {
                const e = document.createElement("textarea");
                e.value = n,
                e.setAttribute("readonly", ""),
                e.style.position = "absolute",
                e.style.left = "-9999px",
                document.body.appendChild(e);
                const t = document.getSelection().rangeCount > 0 && document.getSelection().getRangeAt(0);
                e.select(),
                document.execCommand("copy");
                (new Nl).show({
                    text: "复制成功",
                    duration: 1e3
                }),
                document.body.removeChild(e),
                t && (document.getSelection().removeAllRanges(),
                document.getSelection().addRange(t))
            }
        }
    };
    !function(n, e) {
        void 0 === e && (e = {});
        var t = e.insertAt;
        if (n && "undefined" != typeof document) {
            var a = document.head || document.getElementsByTagName("head")[0]
              , i = document.createElement("style");
            i.type = "text/css",
            "top" === t && a.firstChild ? a.insertBefore(i, a.firstChild) : a.appendChild(i),
            i.styleSheet ? i.styleSheet.cssText = n : i.appendChild(document.createTextNode(n))
        }
    }("@media (max-width: 1000px) {\n  .vuepress-plugin-demo-block__h_code {\n    display: none;\n  }\n  .vuepress-plugin-demo-block__app {\n    margin-left: auto !important;\n    margin-right: auto !important;\n  }\n}\n.vuepress-plugin-demo-block__wrapper {\n  margin-top: 10px;\n  border: 1px solid #ebebeb;\n  border-radius: 4px;\n  transition: all 0.2s;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display {\n  height: 400px;\n  display: flex;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__app {\n  width: 300px;\n  border: 1px solid #ebebeb;\n  box-shadow: 1px 1px 3px #ebebeb;\n  margin-right: 5px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code {\n  flex: 1;\n  overflow: auto;\n  height: 100%;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code > pre {\n  overflow: visible;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  max-height: 400px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper div {\n  box-sizing: border-box;\n}\n.vuepress-plugin-demo-block__wrapper:hover {\n  box-shadow: 0 0 11px rgba(33, 33, 33, 0.2);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code {\n  overflow: hidden;\n  height: 0;\n  padding: 0 !important;\n  background-color: #282c34;\n  border-radius: 0 !important;\n  transition: height 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code pre {\n  margin: 0 !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  padding: 20px;\n  border-bottom: 1px solid #ebebeb;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer {\n  position: relative;\n  text-align: center;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__codepen {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__expand::before {\n  border-top: none;\n  border-right: 6px solid transparent;\n  border-bottom: 6px solid #ccc;\n  border-left: 6px solid transparent;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__codepen,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand span,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand::before {\n  border-top-color: #3eaf7c !important;\n  border-bottom-color: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover svg {\n  fill: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand-text {\n  transition: all 0.5s;\n  opacity: 0;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:nth-last-child(2) {\n  right: 50px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:last-child {\n  right: 10px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button {\n  border-color: transparent;\n  background-color: transparent;\n  font-size: 14px;\n  color: #3eaf7c;\n  cursor: pointer;\n  outline: none;\n  margin: 0;\n  width: 46px;\n  position: relative;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::before {\n  content: attr(data-tip);\n  white-space: nowrap;\n  position: absolute;\n  top: -30px;\n  left: 50%;\n  color: #eee;\n  line-height: 1;\n  z-index: 1000;\n  border-radius: 4px;\n  padding: 6px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  background-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::after {\n  content: '' !important;\n  display: block;\n  position: absolute;\n  left: 50%;\n  top: -5px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  border: 5px solid transparent;\n  border-top-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button svg {\n  width: 34px;\n  height: 20px;\n  fill: #ccc;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__codepen {\n  position: absolute;\n  top: 10px;\n  transition: all 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand {\n  position: relative;\n  width: 100px;\n  height: 40px;\n  margin: 0;\n  color: #3eaf7c;\n  font-size: 14px;\n  background-color: transparent;\n  border-color: transparent;\n  outline: none;\n  transition: all 0.5s;\n  cursor: pointer;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand::before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-top: 6px solid #ccc;\n  border-right: 6px solid transparent;\n  border-left: 6px solid transparent;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n}\n");
    var kl = {
        jsLib: [],
        cssLib: [],
        jsfiddle: !0,
        codepen: !0,
        codepenLayout: "left",
        codepenJsProcessor: "babel",
        codepenEditors: "101",
        horizontal: !1,
        vue: "https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js",
        react: "https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js",
        reactDOM: "https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"
    }
      , Ol = {}
      , Il = function(n) {
        return '<div id="app">\n'.concat(n, "\n</div>")
    }
      , Sl = function(n) {
        return window.$VUEPRESS_DEMO_BLOCK && void 0 !== window.$VUEPRESS_DEMO_BLOCK[n] ? window.$VUEPRESS_DEMO_BLOCK[n] : kl[n]
    }
      , Rl = function n(e, t, a) {
        var i = document.createElement(e);
        return t && Object.keys(t).forEach((function(n) {
            if (n.indexOf("data"))
                i[n] = t[n];
            else {
                var e = n.replace("data", "");
                i.dataset[e] = t[n]
            }
        }
        )),
        a && a.forEach((function(e) {
            var t = e.tag
              , a = e.attrs
              , r = e.children;
            i.appendChild(n(t, a, r))
        }
        )),
        i
    }
      , wl = function(n, e, t) {
        var a, i = (a = n.querySelectorAll(".".concat(e)),
        Array.prototype.slice.call(a));
        return 1 !== i.length || t ? i : i[0]
    }
      , Ul = function(n, e) {
        var t, a, i = n.match(/<style>([\s\S]+)<\/style>/), r = n.match(/<template>([\s\S]+)<\/template>/), o = n.match(/<script>([\s\S]+)<\/script>/), l = {
            css: i && i[1].replace(/^\n|\n$/g, ""),
            html: r && r[1].replace(/^\n|\n$/g, ""),
            js: o && o[1].replace(/^\n|\n$/g, ""),
            jsLib: e.jsLib || [],
            cssLib: e.cssLib || []
        };
        l.htmlTpl = Il(l.html),
        l.jsTpl = (t = l.js,
        a = t.replace(/export\s+default\s*?\{\n*/, "").replace(/\n*\}\s*$/, "").trim(),
        "new Vue({\n  el: '#app',\n  ".concat(a, "\n})")),
        l.script = function(n, e) {
            var t = n.split(/export\s+default/)
              , a = "(function() {".concat(t[0], " ; return ").concat(t[1], "})()")
              , i = window.Babel ? window.Babel.transform(a, {
                presets: ["es2015"]
            }).code : a
              , r = [eval][0](i);
            return r.template = e,
            r
        }(l.js, l.html);
        var s = Sl("vue");
        return l.jsLib.unshift(s),
        l
    }
      , zl = function(n, e) {
        var t, a = n.match(/<style>([\s\S]+)<\/style>/), i = n.match(/<html>([\s\S]+)<\/html>/), r = n.match(/<script>([\s\S]+)<\/script>/), o = {
            css: a && a[1].replace(/^\n|\n$/g, ""),
            html: i && i[1].replace(/^\n|\n$/g, ""),
            js: r && r[1].replace(/^\n|\n$/g, ""),
            jsLib: e.jsLib || [],
            cssLib: e.cssLib || []
        };
        return o.htmlTpl = o.html,
        o.jsTpl = o.js,
        o.script = (t = o.js,
        window.Babel ? window.Babel.transform(t, {
            presets: ["es2015"]
        }).code : t),
        o
    }
      , Pl = function(n) {
        return n = n.replace("export default ", "").replace(/App\.__style__(\s*)=(\s*)`([\s\S]*)?`/, ""),
        n += 'ReactDOM.render(React.createElement(App), document.getElementById("app"))'
    };
    function Dl() {
        var n = wl(document, "vuepress-plugin-demo-block__wrapper", !0);
        n.length ? n.forEach((function(n) {
            if ("true" !== n.dataset.created) {
                n.style.display = "block";
                var e = wl(n, "vuepress-plugin-demo-block__code")
                  , t = wl(n, "vuepress-plugin-demo-block__display")
                  , a = wl(n, "vuepress-plugin-demo-block__footer")
                  , i = wl(t, "vuepress-plugin-demo-block__app")
                  , r = decodeURIComponent(n.dataset.code)
                  , o = decodeURIComponent(n.dataset.config)
                  , l = decodeURIComponent(n.dataset.type);
                o = o ? JSON.parse(o) : {};
                var s = e.querySelector("div").clientHeight
                  , c = "react" === l ? function(n, e) {
                    var t = (0,
                    window.Babel.transform)(n, {
                        presets: ["es2015", "react"]
                    }).code
                      , a = "(function(exports){var module={};module.exports=exports;".concat(t, ";return module.exports.__esModule?module.exports.default:module.exports;})({})")
                      , i = new Function("return ".concat(a))()
                      , r = {
                        js: i,
                        css: i.__style__ || "",
                        jsLib: e.jsLib || [],
                        cssLib: e.cssLib || [],
                        jsTpl: Pl(n),
                        htmlTpl: Il("")
                    }
                      , o = Sl("react")
                      , l = Sl("reactDOM");
                    return r.jsLib.unshift(o, l),
                    r
                }(r, o) : "vanilla" === l ? zl(r, o) : Ul(r, o)
                  , d = Rl("button", {
                    className: "".concat("vuepress-plugin-demo-block__expand")
                });
                if (a.appendChild(d),
                d.addEventListener("click", Bl.bind(null, d, s, e, a)),
                Sl("jsfiddle") && a.appendChild(function(n) {
                    var e = n.css
                      , t = n.htmlTpl
                      , a = n.jsTpl
                      , i = n.jsLib
                      , r = n.cssLib
                      , o = i.concat(r).concat(Sl("cssLib")).concat(Sl("jsLib")).join(",");
                    return Rl("form", {
                        className: "vuepress-plugin-demo-block__jsfiddle",
                        target: "_blank",
                        action: "https://jsfiddle.net/api/post/library/pure/",
                        method: "post"
                    }, [{
                        tag: "input",
                        attrs: {
                            type: "hidden",
                            name: "css",
                            value: e
                        }
                    }, {
                        tag: "input",
                        attrs: {
                            type: "hidden",
                            name: "html",
                            value: t
                        }
                    }, {
                        tag: "input",
                        attrs: {
                            type: "hidden",
                            name: "js",
                            value: a
                        }
                    }, {
                        tag: "input",
                        attrs: {
                            type: "hidden",
                            name: "panel_js",
                            value: 3
                        }
                    }, {
                        tag: "input",
                        attrs: {
                            type: "hidden",
                            name: "wrap",
                            value: 1
                        }
                    }, {
                        tag: "input",
                        attrs: {
                            type: "hidden",
                            name: "resources",
                            value: o
                        }
                    }, {
                        tag: "button",
                        attrs: {
                            type: "submit",
                            className: "vuepress-plugin-demo-block__button",
                            innerHTML: '<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088289967" class="icon" style="" viewBox="0 0 1170 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1952" xmlns:xlink="http://www.w3.org/1999/xlink" width="228.515625" height="200"><defs><style type="text/css"></style></defs><path d="M1028.571429 441.142857q63.428571 26.285714 102.571428 83.142857T1170.285714 650.857143q0 93.714286-67.428571 160.285714T940 877.714286q-2.285714 0-6.571429-0.285715t-6-0.285714H232q-97.142857-5.714286-164.571429-71.714286T0 645.142857q0-62.857143 31.428571-116t84-84q-6.857143-22.285714-6.857142-46.857143 0-65.714286 46.857142-112t113.714286-46.285714q54.285714 0 98.285714 33.142857 42.857143-88 127.142858-141.714286t186.571428-53.714285q94.857143 0 174.857143 46T982.571429 248.571429t46.571428 172q0 3.428571-0.285714 10.285714t-0.285714 10.285714zM267.428571 593.142857q0 69.714286 48 110.285714t118.857143 40.571429q78.285714 0 137.142857-56.571429-9.142857-11.428571-27.142857-32.285714T519.428571 626.285714q-38.285714 37.142857-82.285714 37.142857-31.428571 0-53.428571-19.142857T361.714286 594.285714q0-30.285714 22-49.714285t52.285714-19.428572q25.142857 0 48.285714 12t41.714286 31.428572 37.142857 42.857142 39.428572 46.857143 44 42.857143 55.428571 31.428572 69.428571 12q69.142857 0 116.857143-40.857143T936 594.857143q0-69.142857-48-109.714286t-118.285714-40.571428q-81.714286 0-137.714286 55.428571l53.142857 61.714286q37.714286-36.571429 81.142857-36.571429 29.714286 0 52.571429 18.857143t22.857143 48q0 32.571429-21.142857 52.285714t-53.714286 19.714286q-24.571429 0-47.142857-12t-41.142857-31.428571-37.428572-42.857143-39.714286-46.857143-44.285714-42.857143-55.142857-31.428571T434.285714 444.571429q-69.714286 0-118.285714 40.285714T267.428571 593.142857z" p-id="1953"></path></svg>',
                            datatip: "JSFiddle"
                        }
                    }])
                }(c)),
                Sl("codepen") && a.appendChild(function(n) {
                    var e = n.css
                      , t = n.htmlTpl
                      , a = n.jsTpl
                      , i = n.jsLib
                      , r = n.cssLib
                      , o = JSON.stringify({
                        css: e,
                        html: t,
                        js: a,
                        js_external: i.concat(Sl("jsLib")).join(";"),
                        css_external: r.concat(Sl("cssLib")).join(";"),
                        layout: Sl("codepenLayout"),
                        js_pre_processor: Sl("codepenJsProcessor"),
                        editors: Sl("codepenEditors")
                    });
                    return Rl("form", {
                        className: "vuepress-plugin-demo-block__codepen",
                        target: "_blank",
                        action: "https://codepen.io/pen/define",
                        method: "post"
                    }, [{
                        tag: "input",
                        attrs: {
                            type: "hidden",
                            name: "data",
                            value: o
                        }
                    }, {
                        tag: "button",
                        attrs: {
                            type: "submit",
                            innerHTML: '<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088271207" class="icon" style="" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1737" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M123.428571 668l344.571429 229.714286v-205.142857L277.142857 565.142857z m-35.428571-82.285714l110.285714-73.714286-110.285714-73.714286v147.428572z m468 312l344.571429-229.714286-153.714286-102.857143-190.857143 127.428572v205.142857z m-44-281.714286l155.428571-104-155.428571-104-155.428571 104zM277.142857 458.857143l190.857143-127.428572V126.285714L123.428571 356z m548.571429 53.142857l110.285714 73.714286V438.285714z m-78.857143-53.142857l153.714286-102.857143-344.571429-229.714286v205.142857z m277.142857-102.857143v312q0 23.428571-19.428571 36.571429l-468 312q-12 7.428571-24.571429 7.428571t-24.571429-7.428571L19.428571 704.571429q-19.428571-13.142857-19.428571-36.571429V356q0-23.428571 19.428571-36.571429L487.428571 7.428571q12-7.428571 24.571429-7.428571t24.571429 7.428571l468 312q19.428571 13.142857 19.428571 36.571429z" p-id="1738"></path></svg>',
                            className: "vuepress-plugin-demo-block__button",
                            datatip: "Codepen"
                        }
                    }])
                }(c)),
                void 0 !== o.horizontal ? o.horizontal : Sl("horizontal")) {
                    n.classList.add("vuepress-plugin-demo-block__horizontal");
                    var u = e.firstChild.cloneNode(!0);
                    u.classList.add("vuepress-plugin-demo-block__h_code"),
                    t.appendChild(u)
                }
                if (c.css && function(n) {
                    if (!Ol[n]) {
                        var e = Rl("style", {
                            innerHTML: n
                        });
                        document.body.appendChild(e),
                        Ol[n] = !0
                    }
                }(c.css),
                "react" === l)
                    ReactDOM.render(React.createElement(c.js), i);
                else if ("vue" === l) {
                    var m = (new (Vue.extend(c.script))).$mount();
                    i.appendChild(m.$el)
                } else
                    "vanilla" === l && (i.innerHTML = c.html,
                    new Function("return (function(){".concat(c.script, "})()"))());
                n.dataset.created = "true"
            }
        }
        )) : setTimeout((function(n) {
            Dl()
        }
        ), 300)
    }
    function Bl(n, e, t, a) {
        var i = "1" !== n.dataset.isExpand;
        t.style.height = i ? "".concat(e, "px") : 0,
        i ? a.classList.add("vuepress-plugin-demo-block__show-link") : a.classList.remove("vuepress-plugin-demo-block__show-link"),
        n.dataset.isExpand = i ? "1" : "0"
    }
    var jl = {
        mounted: function() {
            window.$VUEPRESS_DEMO_BLOCK = {
                jsfiddle: !1,
                codepen: !0,
                horizontal: !1
            },
            Dl()
        },
        updated: function() {
            Dl()
        }
    }
      , Fl = "auto"
      , ql = "zoom-in"
      , Vl = "zoom-out"
      , Hl = "grab"
      , $l = "move";
    function Kl(n, e, t) {
        var a = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3]
          , i = {
            passive: !1
        };
        a ? n.addEventListener(e, t, i) : n.removeEventListener(e, t, i)
    }
    function Gl(n, e) {
        if (n) {
            var t = new Image;
            t.onload = function() {
                e && e(t)
            }
            ,
            t.src = n
        }
    }
    function Yl(n) {
        return n.dataset.original ? n.dataset.original : "A" === n.parentNode.tagName ? n.parentNode.getAttribute("href") : null
    }
    function Jl(n, e, t) {
        !function(n) {
            var e = Wl
              , t = Ql;
            if (n.transition) {
                var a = n.transition;
                delete n.transition,
                n[e] = a
            }
            if (n.transform) {
                var i = n.transform;
                delete n.transform,
                n[t] = i
            }
        }(e);
        var a = n.style
          , i = {};
        for (var r in e)
            t && (i[r] = a[r] || ""),
            a[r] = e[r];
        return i
    }
    var Wl = "transition"
      , Ql = "transform"
      , Zl = "transform"
      , Xl = "transitionend";
    var ns = function() {}
      , es = {
        enableGrab: !0,
        preloadImage: !1,
        closeOnWindowResize: !0,
        transitionDuration: .4,
        transitionTimingFunction: "cubic-bezier(0.4, 0, 0, 1)",
        bgColor: "rgb(255, 255, 255)",
        bgOpacity: 1,
        scaleBase: 1,
        scaleExtra: .5,
        scrollThreshold: 40,
        zIndex: 998,
        customSize: null,
        onOpen: ns,
        onClose: ns,
        onGrab: ns,
        onMove: ns,
        onRelease: ns,
        onBeforeOpen: ns,
        onBeforeClose: ns,
        onBeforeGrab: ns,
        onBeforeRelease: ns,
        onImageLoading: ns,
        onImageLoaded: ns
    }
      , ts = {
        init: function(n) {
            var e, t;
            e = this,
            t = n,
            Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n) {
                e[n] = e[n].bind(t)
            }
            ))
        },
        click: function(n) {
            if (n.preventDefault(),
            is(n))
                return window.open(this.target.srcOriginal || n.currentTarget.src, "_blank");
            this.shown ? this.released ? this.close() : this.release() : this.open(n.currentTarget)
        },
        scroll: function() {
            var n = document.documentElement || document.body.parentNode || document.body
              , e = window.pageXOffset || n.scrollLeft
              , t = window.pageYOffset || n.scrollTop;
            null === this.lastScrollPosition && (this.lastScrollPosition = {
                x: e,
                y: t
            });
            var a = this.lastScrollPosition.x - e
              , i = this.lastScrollPosition.y - t
              , r = this.options.scrollThreshold;
            (Math.abs(i) >= r || Math.abs(a) >= r) && (this.lastScrollPosition = null,
            this.close())
        },
        keydown: function(n) {
            (function(n) {
                return "Escape" === (n.key || n.code) || 27 === n.keyCode
            }
            )(n) && (this.released ? this.close() : this.release(this.close))
        },
        mousedown: function(n) {
            if (as(n) && !is(n)) {
                n.preventDefault();
                var e = n.clientX
                  , t = n.clientY;
                this.pressTimer = setTimeout(function() {
                    this.grab(e, t)
                }
                .bind(this), 200)
            }
        },
        mousemove: function(n) {
            this.released || this.move(n.clientX, n.clientY)
        },
        mouseup: function(n) {
            as(n) && !is(n) && (clearTimeout(this.pressTimer),
            this.released ? this.close() : this.release())
        },
        touchstart: function(n) {
            n.preventDefault();
            var e = n.touches[0]
              , t = e.clientX
              , a = e.clientY;
            this.pressTimer = setTimeout(function() {
                this.grab(t, a)
            }
            .bind(this), 200)
        },
        touchmove: function(n) {
            if (!this.released) {
                var e = n.touches[0]
                  , t = e.clientX
                  , a = e.clientY;
                this.move(t, a)
            }
        },
        touchend: function(n) {
            (function(n) {
                n.targetTouches.length
            }
            )(n) || (clearTimeout(this.pressTimer),
            this.released ? this.close() : this.release())
        },
        clickOverlay: function() {
            this.close()
        },
        resizeWindow: function() {
            this.close()
        }
    };
    function as(n) {
        return 0 === n.button
    }
    function is(n) {
        return n.metaKey || n.ctrlKey
    }
    var rs = {
        init: function(n) {
            this.el = document.createElement("div"),
            this.instance = n,
            this.parent = document.body,
            Jl(this.el, {
                position: "fixed",
                top: 0,
                left: 0,
                right: 0,
                bottom: 0,
                opacity: 0
            }),
            this.updateStyle(n.options),
            Kl(this.el, "click", n.handler.clickOverlay.bind(n))
        },
        updateStyle: function(n) {
            Jl(this.el, {
                zIndex: n.zIndex,
                backgroundColor: n.bgColor,
                transition: "opacity\n        " + n.transitionDuration + "s\n        " + n.transitionTimingFunction
            })
        },
        insert: function() {
            this.parent.appendChild(this.el)
        },
        remove: function() {
            this.parent.removeChild(this.el)
        },
        fadeIn: function() {
            this.el.offsetWidth,
            this.el.style.opacity = this.instance.options.bgOpacity
        },
        fadeOut: function() {
            this.el.style.opacity = 0
        }
    }
      , os = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(n) {
        return typeof n
    }
    : function(n) {
        return n && "function" == typeof Symbol && n.constructor === Symbol && n !== Symbol.prototype ? "symbol" : typeof n
    }
      , ls = function() {
        function n(n, e) {
            for (var t = 0; t < e.length; t++) {
                var a = e[t];
                a.enumerable = a.enumerable || !1,
                a.configurable = !0,
                "value"in a && (a.writable = !0),
                Object.defineProperty(n, a.key, a)
            }
        }
        return function(e, t, a) {
            return t && n(e.prototype, t),
            a && n(e, a),
            e
        }
    }()
      , ss = Object.assign || function(n) {
        for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var a in t)
                Object.prototype.hasOwnProperty.call(t, a) && (n[a] = t[a])
        }
        return n
    }
      , cs = {
        init: function(n, e) {
            this.el = n,
            this.instance = e,
            this.srcThumbnail = this.el.getAttribute("src"),
            this.srcset = this.el.getAttribute("srcset"),
            this.srcOriginal = Yl(this.el),
            this.rect = this.el.getBoundingClientRect(),
            this.translate = null,
            this.scale = null,
            this.styleOpen = null,
            this.styleClose = null
        },
        zoomIn: function() {
            var n = this.instance.options
              , e = n.zIndex
              , t = n.enableGrab
              , a = n.transitionDuration
              , i = n.transitionTimingFunction;
            this.translate = this.calculateTranslate(),
            this.scale = this.calculateScale(),
            this.styleOpen = {
                position: "relative",
                zIndex: e + 1,
                cursor: t ? Hl : Vl,
                transition: Zl + "\n        " + a + "s\n        " + i,
                transform: "translate3d(" + this.translate.x + "px, " + this.translate.y + "px, 0px)\n        scale(" + this.scale.x + "," + this.scale.y + ")",
                height: this.rect.height + "px",
                width: this.rect.width + "px"
            },
            this.el.offsetWidth,
            this.styleClose = Jl(this.el, this.styleOpen, !0)
        },
        zoomOut: function() {
            this.el.offsetWidth,
            Jl(this.el, {
                transform: "none"
            })
        },
        grab: function(n, e, t) {
            var a = ds()
              , i = a.x - n
              , r = a.y - e;
            Jl(this.el, {
                cursor: $l,
                transform: "translate3d(\n        " + (this.translate.x + i) + "px, " + (this.translate.y + r) + "px, 0px)\n        scale(" + (this.scale.x + t) + "," + (this.scale.y + t) + ")"
            })
        },
        move: function(n, e, t) {
            var a = ds()
              , i = a.x - n
              , r = a.y - e;
            Jl(this.el, {
                transition: Zl,
                transform: "translate3d(\n        " + (this.translate.x + i) + "px, " + (this.translate.y + r) + "px, 0px)\n        scale(" + (this.scale.x + t) + "," + (this.scale.y + t) + ")"
            })
        },
        restoreCloseStyle: function() {
            Jl(this.el, this.styleClose)
        },
        restoreOpenStyle: function() {
            Jl(this.el, this.styleOpen)
        },
        upgradeSource: function() {
            if (this.srcOriginal) {
                var n = this.el.parentNode;
                this.srcset && this.el.removeAttribute("srcset");
                var e = this.el.cloneNode(!1);
                e.setAttribute("src", this.srcOriginal),
                e.style.position = "fixed",
                e.style.visibility = "hidden",
                n.appendChild(e),
                setTimeout(function() {
                    this.el.setAttribute("src", this.srcOriginal),
                    n.removeChild(e)
                }
                .bind(this), 50)
            }
        },
        downgradeSource: function() {
            this.srcOriginal && (this.srcset && this.el.setAttribute("srcset", this.srcset),
            this.el.setAttribute("src", this.srcThumbnail))
        },
        calculateTranslate: function() {
            var n = ds()
              , e = this.rect.left + this.rect.width / 2
              , t = this.rect.top + this.rect.height / 2;
            return {
                x: n.x - e,
                y: n.y - t
            }
        },
        calculateScale: function() {
            var n = this.el.dataset
              , e = n.zoomingHeight
              , t = n.zoomingWidth
              , a = this.instance.options
              , i = a.customSize
              , r = a.scaleBase;
            if (!i && e && t)
                return {
                    x: t / this.rect.width,
                    y: e / this.rect.height
                };
            if (i && "object" === (void 0 === i ? "undefined" : os(i)))
                return {
                    x: i.width / this.rect.width,
                    y: i.height / this.rect.height
                };
            var o = this.rect.width / 2
              , l = this.rect.height / 2
              , s = ds()
              , c = {
                x: s.x - o,
                y: s.y - l
            }
              , d = c.x / o
              , u = c.y / l
              , m = r + Math.min(d, u);
            if (i && "string" == typeof i) {
                var p = t || this.el.naturalWidth
                  , h = e || this.el.naturalHeight
                  , g = parseFloat(i) * p / (100 * this.rect.width)
                  , _ = parseFloat(i) * h / (100 * this.rect.height);
                if (m > g || m > _)
                    return {
                        x: g,
                        y: _
                    }
            }
            return {
                x: m,
                y: m
            }
        }
    };
    function ds() {
        var n = document.documentElement;
        return {
            x: Math.min(n.clientWidth, window.innerWidth) / 2,
            y: Math.min(n.clientHeight, window.innerHeight) / 2
        }
    }
    function us(n, e, t) {
        ["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend"].forEach((function(a) {
            Kl(n, a, e[a], t)
        }
        ))
    }
    var ms = function() {
        function n(e) {
            !function(n, e) {
                if (!(n instanceof e))
                    throw new TypeError("Cannot call a class as a function")
            }(this, n),
            this.target = Object.create(cs),
            this.overlay = Object.create(rs),
            this.handler = Object.create(ts),
            this.body = document.body,
            this.shown = !1,
            this.lock = !1,
            this.released = !0,
            this.lastScrollPosition = null,
            this.pressTimer = null,
            this.options = ss({}, es, e),
            this.overlay.init(this),
            this.handler.init(this)
        }
        return ls(n, [{
            key: "listen",
            value: function(n) {
                if ("string" == typeof n)
                    for (var e = document.querySelectorAll(n), t = e.length; t--; )
                        this.listen(e[t]);
                else
                    "IMG" === n.tagName && (n.style.cursor = ql,
                    Kl(n, "click", this.handler.click),
                    this.options.preloadImage && Gl(Yl(n)));
                return this
            }
        }, {
            key: "config",
            value: function(n) {
                return n ? (ss(this.options, n),
                this.overlay.updateStyle(this.options),
                this) : this.options
            }
        }, {
            key: "open",
            value: function(n) {
                var e = this
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.options.onOpen;
                if (!this.shown && !this.lock) {
                    var a = "string" == typeof n ? document.querySelector(n) : n;
                    if ("IMG" === a.tagName) {
                        if (this.options.onBeforeOpen(a),
                        this.target.init(a, this),
                        !this.options.preloadImage) {
                            var i = this.target.srcOriginal;
                            null != i && (this.options.onImageLoading(a),
                            Gl(i, this.options.onImageLoaded))
                        }
                        this.shown = !0,
                        this.lock = !0,
                        this.target.zoomIn(),
                        this.overlay.insert(),
                        this.overlay.fadeIn(),
                        Kl(document, "scroll", this.handler.scroll),
                        Kl(document, "keydown", this.handler.keydown),
                        this.options.closeOnWindowResize && Kl(window, "resize", this.handler.resizeWindow);
                        var r = function n() {
                            Kl(a, Xl, n, !1),
                            e.lock = !1,
                            e.target.upgradeSource(),
                            e.options.enableGrab && us(document, e.handler, !0),
                            t(a)
                        };
                        return Kl(a, Xl, r),
                        this
                    }
                }
            }
        }, {
            key: "close",
            value: function() {
                var n = this
                  , e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.options.onClose;
                if (this.shown && !this.lock) {
                    var t = this.target.el;
                    this.options.onBeforeClose(t),
                    this.lock = !0,
                    this.body.style.cursor = Fl,
                    this.overlay.fadeOut(),
                    this.target.zoomOut(),
                    Kl(document, "scroll", this.handler.scroll, !1),
                    Kl(document, "keydown", this.handler.keydown, !1),
                    this.options.closeOnWindowResize && Kl(window, "resize", this.handler.resizeWindow, !1);
                    var a = function a() {
                        Kl(t, Xl, a, !1),
                        n.shown = !1,
                        n.lock = !1,
                        n.target.downgradeSource(),
                        n.options.enableGrab && us(document, n.handler, !1),
                        n.target.restoreCloseStyle(),
                        n.overlay.remove(),
                        e(t)
                    };
                    return Kl(t, Xl, a),
                    this
                }
            }
        }, {
            key: "grab",
            value: function(n, e) {
                var t = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.options.scaleExtra
                  , a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : this.options.onGrab;
                if (this.shown && !this.lock) {
                    var i = this.target.el;
                    this.options.onBeforeGrab(i),
                    this.released = !1,
                    this.target.grab(n, e, t);
                    var r = function n() {
                        Kl(i, Xl, n, !1),
                        a(i)
                    };
                    return Kl(i, Xl, r),
                    this
                }
            }
        }, {
            key: "move",
            value: function(n, e) {
                var t = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.options.scaleExtra
                  , a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : this.options.onMove;
                if (this.shown && !this.lock) {
                    this.released = !1,
                    this.body.style.cursor = $l,
                    this.target.move(n, e, t);
                    var i = this.target.el
                      , r = function n() {
                        Kl(i, Xl, n, !1),
                        a(i)
                    };
                    return Kl(i, Xl, r),
                    this
                }
            }
        }, {
            key: "release",
            value: function() {
                var n = this
                  , e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.options.onRelease;
                if (this.shown && !this.lock) {
                    var t = this.target.el;
                    this.options.onBeforeRelease(t),
                    this.lock = !0,
                    this.body.style.cursor = Fl,
                    this.target.restoreOpenStyle();
                    var a = function a() {
                        Kl(t, Xl, a, !1),
                        n.lock = !1,
                        n.released = !0,
                        e(t)
                    };
                    return Kl(t, Xl, a),
                    this
                }
            }
        }]),
        n
    }();
    const ps = JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}')
      , hs = Number("500");
    class gs {
        constructor() {
            this.instance = new ms(ps)
        }
        update(n=".theme-vdoing-content img:not(.no-zoom)") {
            "undefined" != typeof window && this.instance.listen(n)
        }
        updateDelay(n=".theme-vdoing-content img:not(.no-zoom)", e=hs) {
            setTimeout( () => this.update(n), e)
        }
    }
    var _s = [vl, Al, Ll, Ml, jl, {
        watch: {
            "$page.path"() {
                void 0 !== this.$vuepress.zooming && this.$vuepress.zooming.updateDelay()
            }
        },
        mounted() {
            this.$vuepress.zooming = new gs,
            this.$vuepress.zooming.updateDelay()
        }
    }]
      , vs = {
        name: "GlobalLayout",
        computed: {
            layout() {
                const n = this.getLayout();
                return ml("layout", n),
                Gt.component(n)
            }
        },
        methods: {
            getLayout() {
                if (this.$page.path) {
                    const n = this.$page.frontmatter.layout;
                    return n && (this.$vuepress.getLayoutAsyncComponent(n) || this.$vuepress.getVueComponent(n)) ? n : "Layout"
                }
                return "NotFound"
            }
        }
    }
      , bs = t(7)
      , fs = Object(bs.a)(vs, (function() {
        return (0,
        this._self._c)(this.layout, {
            tag: "component"
        })
    }
    ), [], !1, null, null, null).exports;
    !function(n, e, t) {
        switch (e) {
        case "components":
            n[e] || (n[e] = {}),
            Object.assign(n[e], t);
            break;
        case "mixins":
            n[e] || (n[e] = []),
            n[e].push(...t);
            break;
        default:
            throw new Error("Unknown option name.")
        }
    }(fs, "mixins", _s);
    const Es = [{
        name: "v-02b738c7",
        path: "/intro/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-02b738c7").then(t)
        }
    }, {
        path: "/intro/index.html",
        redirect: "/intro/"
    }, {
        path: "/01.开发指南/01.萌新必读/01.简介.html",
        redirect: "/intro/"
    }, {
        name: "v-429ee8f1",
        path: "/qun/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-429ee8f1").then(t)
        }
    }, {
        path: "/qun/index.html",
        redirect: "/qun/"
    }, {
        path: "/01.开发指南/01.萌新必读/02.交流群.html",
        redirect: "/qun/"
    }, {
        name: "v-2b88bf2c",
        path: "/feature/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-2b88bf2c").then(t)
        }
    }, {
        path: "/feature/index.html",
        redirect: "/feature/"
    }, {
        path: "/01.开发指南/01.萌新必读/04.功能列表.html",
        redirect: "/feature/"
    }, {
        name: "v-2fd82d08",
        path: "/video/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-2fd82d08").then(t)
        }
    }, {
        path: "/video/index.html",
        redirect: "/video/"
    }, {
        path: "/01.开发指南/01.萌新必读/03.视频教程.html",
        redirect: "/video/"
    }, {
        name: "v-0f8a606f",
        path: "/quick-start/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-0f8a606f").then(t)
        }
    }, {
        path: "/quick-start/index.html",
        redirect: "/quick-start/"
    }, {
        path: "/01.开发指南/01.萌新必读/05.快速启动【后端】.html",
        redirect: "/quick-start/"
    }, {
        name: "v-abcf704e",
        path: "/quick-start-front/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-abcf704e").then(t)
        }
    }, {
        path: "/quick-start-front/index.html",
        redirect: "/quick-start-front/"
    }, {
        path: "/01.开发指南/01.萌新必读/06.快速启动【前端】.html",
        redirect: "/quick-start-front/"
    }, {
        name: "v-06f1ade6",
        path: "/api-doc/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-06f1ade6").then(t)
        }
    }, {
        path: "/api-doc/index.html",
        redirect: "/api-doc/"
    }, {
        path: "/01.开发指南/01.萌新必读/07.接口文档.html",
        redirect: "/api-doc/"
    }, {
        name: "v-5c7d2de3",
        path: "/technology/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-5c7d2de3").then(t)
        }
    }, {
        path: "/technology/index.html",
        redirect: "/technology/"
    }, {
        path: "/01.开发指南/01.萌新必读/08.技术选型.html",
        redirect: "/technology/"
    }, {
        name: "v-999f7d24",
        path: "/project-intro/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-999f7d24").then(t)
        }
    }, {
        path: "/project-intro/index.html",
        redirect: "/project-intro/"
    }, {
        path: "/01.开发指南/01.萌新必读/09.项目结构.html",
        redirect: "/project-intro/"
    }, {
        name: "v-bc6df3f8",
        path: "/dev-hot-swap/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-bc6df3f8").then(t)
        }
    }, {
        path: "/dev-hot-swap/index.html",
        redirect: "/dev-hot-swap/"
    }, {
        path: "/01.开发指南/01.萌新必读/10.代码热加载.html",
        redirect: "/dev-hot-swap/"
    }, {
        name: "v-7389e108",
        path: "/project-rename/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-7389e108").then(t)
        }
    }, {
        path: "/project-rename/index.html",
        redirect: "/project-rename/"
    }, {
        path: "/01.开发指南/01.萌新必读/11.一键改包.html",
        redirect: "/project-rename/"
    }, {
        name: "v-44dfccd2",
        path: "/migrate-module/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-44dfccd2").then(t)
        }
    }, {
        path: "/migrate-module/index.html",
        redirect: "/migrate-module/"
    }, {
        path: "/01.开发指南/01.萌新必读/12.迁移模块.html",
        redirect: "/migrate-module/"
    }, {
        name: "v-2bac80ba",
        path: "/delete-code/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-2bac80ba").then(t)
        }
    }, {
        path: "/delete-code/index.html",
        redirect: "/delete-code/"
    }, {
        path: "/01.开发指南/01.萌新必读/13.删除功能.html",
        redirect: "/delete-code/"
    }, {
        name: "v-5e94a2f2",
        path: "/sql-update/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-5e94a2f2").then(t)
        }
    }, {
        path: "/sql-update/index.html",
        redirect: "/sql-update/"
    }, {
        path: "/01.开发指南/01.萌新必读/14.表结构变更.html",
        redirect: "/sql-update/"
    }, {
        name: "v-6fd4058c",
        path: "/interview/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-6fd4058c").then(t)
        }
    }, {
        path: "/interview/index.html",
        redirect: "/interview/"
    }, {
        path: "/01.开发指南/01.萌新必读/99.面试题&简历.html",
        redirect: "/interview/"
    }, {
        name: "v-25ea4e32",
        path: "/xinchuang-db/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-25ea4e32").then(t)
        }
    }, {
        path: "/xinchuang-db/index.html",
        redirect: "/xinchuang-db/"
    }, {
        path: "/01.开发指南/01.萌新必读/15.国产信创数据库.html",
        redirect: "/xinchuang-db/"
    }, {
        name: "v-1c8ff8ea",
        path: "/remove-redis/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-1c8ff8ea").then(t)
        }
    }, {
        path: "/remove-redis/index.html",
        redirect: "/remove-redis/"
    }, {
        path: "/01.开发指南/01.萌新必读/16.如何去除 Redis 依赖.html",
        redirect: "/remove-redis/"
    }, {
        name: "v-14de04f4",
        path: "/natapp/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-14de04f4").then(t)
        }
    }, {
        path: "/natapp/index.html",
        redirect: "/natapp/"
    }, {
        path: "/01.开发指南/01.萌新必读/98.内网穿透.html",
        redirect: "/natapp/"
    }, {
        name: "v-43c1547e",
        path: "/module-new/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-43c1547e").then(t)
        }
    }, {
        path: "/module-new/index.html",
        redirect: "/module-new/"
    }, {
        path: "/01.开发指南/02.后端手册/01.新建模块.html",
        redirect: "/module-new/"
    }, {
        name: "v-a1e90a8a",
        path: "/new-feature/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-a1e90a8a").then(t)
        }
    }, {
        path: "/new-feature/index.html",
        redirect: "/new-feature/"
    }, {
        path: "/01.开发指南/02.后端手册/02.代码生成（单表）.html",
        redirect: "/new-feature/"
    }, {
        name: "v-7eec88fb",
        path: "/new-feature/master-sub/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-7eec88fb").then(t)
        }
    }, {
        path: "/new-feature/master-sub/index.html",
        redirect: "/new-feature/master-sub/"
    }, {
        path: "/01.开发指南/02.后端手册/03.代码生成（主子表）.html",
        redirect: "/new-feature/master-sub/"
    }, {
        name: "v-8f5874c6",
        path: "/new-feature/tree/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-8f5874c6").then(t)
        }
    }, {
        path: "/new-feature/tree/index.html",
        redirect: "/new-feature/tree/"
    }, {
        path: "/01.开发指南/02.后端手册/04.代码生成（树表）.html",
        redirect: "/new-feature/tree/"
    }, {
        name: "v-d03982c2",
        path: "/data-permission/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-d03982c2").then(t)
        }
    }, {
        path: "/data-permission/index.html",
        redirect: "/data-permission/"
    }, {
        path: "/01.开发指南/02.后端手册/08.数据权限.html",
        redirect: "/data-permission/"
    }, {
        name: "v-6bf342bf",
        path: "/resource-permission/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-6bf342bf").then(t)
        }
    }, {
        path: "/resource-permission/index.html",
        redirect: "/resource-permission/"
    }, {
        path: "/01.开发指南/02.后端手册/07.功能权限.html",
        redirect: "/resource-permission/"
    }, {
        name: "v-29a135b6",
        path: "/social-user/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-29a135b6").then(t)
        }
    }, {
        path: "/social-user/index.html",
        redirect: "/social-user/"
    }, {
        path: "/01.开发指南/02.后端手册/10.三方登录.html",
        redirect: "/social-user/"
    }, {
        name: "v-06acd369",
        path: "/user-center/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-06acd369").then(t)
        }
    }, {
        path: "/user-center/index.html",
        redirect: "/user-center/"
    }, {
        path: "/01.开发指南/02.后端手册/09.用户体系.html",
        redirect: "/user-center/"
    }, {
        name: "v-016743b8",
        path: "/oauth2/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-016743b8").then(t)
        }
    }, {
        path: "/oauth2/index.html",
        redirect: "/oauth2/"
    }, {
        path: "/01.开发指南/02.后端手册/11.OAuth2x0.html",
        redirect: "/oauth2/"
    }, {
        name: "v-72c78798",
        path: "/websocket/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-72c78798").then(t)
        }
    }, {
        path: "/websocket/index.html",
        redirect: "/websocket/"
    }, {
        path: "/01.开发指南/02.后端手册/14.WebSocket.html",
        redirect: "/websocket/"
    }, {
        name: "v-a715ae90",
        path: "/saas-tenant/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-a715ae90").then(t)
        }
    }, {
        path: "/saas-tenant/index.html",
        redirect: "/saas-tenant/"
    }, {
        path: "/01.开发指南/02.后端手册/12.SaaS 多租户（字段隔离）.html",
        redirect: "/saas-tenant/"
    }, {
        name: "v-7c41859a",
        path: "/saas-tenant/dynamic/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-7c41859a").then(t)
        }
    }, {
        path: "/saas-tenant/dynamic/index.html",
        redirect: "/saas-tenant/dynamic/"
    }, {
        path: "/01.开发指南/02.后端手册/13.SaaS 多租户（数据库隔离）.html",
        redirect: "/saas-tenant/dynamic/"
    }, {
        name: "v-bee4c996",
        path: "/exception/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-bee4c996").then(t)
        }
    }, {
        path: "/exception/index.html",
        redirect: "/exception/"
    }, {
        path: "/01.开发指南/02.后端手册/15.异常处理.html",
        redirect: "/exception/"
    }, {
        name: "v-01a3c3ae",
        path: "/validator/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-01a3c3ae").then(t)
        }
    }, {
        path: "/validator/index.html",
        redirect: "/validator/"
    }, {
        path: "/01.开发指南/02.后端手册/16.参数校验.html",
        redirect: "/validator/"
    }, {
        name: "v-4e5e44e1",
        path: "/page-feature/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-4e5e44e1").then(t)
        }
    }, {
        path: "/page-feature/index.html",
        redirect: "/page-feature/"
    }, {
        path: "/01.开发指南/02.后端手册/17.分页实现.html",
        redirect: "/page-feature/"
    }, {
        name: "v-ea775c7e",
        path: "/vo/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-ea775c7e").then(t)
        }
    }, {
        path: "/vo/index.html",
        redirect: "/vo/"
    }, {
        path: "/01.开发指南/02.后端手册/18.VO 对象转换、数据翻译.html",
        redirect: "/vo/"
    }, {
        name: "v-0a50e53e",
        path: "/file/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-0a50e53e").then(t)
        }
    }, {
        path: "/file/index.html",
        redirect: "/file/"
    }, {
        path: "/01.开发指南/02.后端手册/19.上传下载.html",
        redirect: "/file/"
    }, {
        name: "v-34c1d3ae",
        path: "/excel-import-and-export/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-34c1d3ae").then(t)
        }
    }, {
        path: "/excel-import-and-export/index.html",
        redirect: "/excel-import-and-export/"
    }, {
        path: "/01.开发指南/02.后端手册/20.Excel 导入导出.html",
        redirect: "/excel-import-and-export/"
    }, {
        name: "v-f31a1c8e",
        path: "/system-log/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-f31a1c8e").then(t)
        }
    }, {
        path: "/system-log/index.html",
        redirect: "/system-log/"
    }, {
        path: "/01.开发指南/02.后端手册/21.系统日志.html",
        redirect: "/system-log/"
    }, {
        name: "v-a9ac9b64",
        path: "/mybatis-pro/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-a9ac9b64").then(t)
        }
    }, {
        path: "/mybatis-pro/index.html",
        redirect: "/mybatis-pro/"
    }, {
        path: "/01.开发指南/02.后端手册/26.MyBatis 联表x分页.html",
        redirect: "/mybatis-pro/"
    }, {
        name: "v-4a7d74a0",
        path: "/mybatis/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-4a7d74a0").then(t)
        }
    }, {
        path: "/mybatis/index.html",
        redirect: "/mybatis/"
    }, {
        path: "/01.开发指南/02.后端手册/25.MyBatis 数据库.html",
        redirect: "/mybatis/"
    }, {
        name: "v-b3cf38b6",
        path: "/redis-cache/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-b3cf38b6").then(t)
        }
    }, {
        path: "/redis-cache/index.html",
        redirect: "/redis-cache/"
    }, {
        path: "/01.开发指南/02.后端手册/28.Redis 缓存.html",
        redirect: "/redis-cache/"
    }, {
        name: "v-efcaad44",
        path: "/dynamic-datasource/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-efcaad44").then(t)
        }
    }, {
        path: "/dynamic-datasource/index.html",
        redirect: "/dynamic-datasource/"
    }, {
        path: "/01.开发指南/02.后端手册/27.多数据源.html",
        redirect: "/dynamic-datasource/"
    }, {
        name: "v-0ef32c3e",
        path: "/local-cache/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-0ef32c3e").then(t)
        }
    }, {
        path: "/local-cache/index.html",
        redirect: "/local-cache/"
    }, {
        path: "/01.开发指南/02.后端手册/29.本地缓存.html",
        redirect: "/local-cache/"
    }, {
        name: "v-78635b68",
        path: "/async-task/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-78635b68").then(t)
        }
    }, {
        path: "/async-task/index.html",
        redirect: "/async-task/"
    }, {
        path: "/01.开发指南/02.后端手册/30.异步任务.html",
        redirect: "/async-task/"
    }, {
        name: "v-cad135d2",
        path: "/distributed-lock/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-cad135d2").then(t)
        }
    }, {
        path: "/distributed-lock/index.html",
        redirect: "/distributed-lock/"
    }, {
        path: "/01.开发指南/02.后端手册/31.分布式锁.html",
        redirect: "/distributed-lock/"
    }, {
        name: "v-4542a8f3",
        path: "/idempotent/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-4542a8f3").then(t)
        }
    }, {
        path: "/idempotent/index.html",
        redirect: "/idempotent/"
    }, {
        path: "/01.开发指南/02.后端手册/32.幂等性.html",
        redirect: "/idempotent/"
    }, {
        name: "v-0e8d395b",
        path: "/rate-limiter/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-0e8d395b").then(t)
        }
    }, {
        path: "/rate-limiter/index.html",
        redirect: "/rate-limiter/"
    }, {
        path: "/01.开发指南/02.后端手册/33.请求限流.html",
        redirect: "/rate-limiter/"
    }, {
        name: "v-53547eb1",
        path: "/http-sign/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-53547eb1").then(t)
        }
    }, {
        path: "/http-sign/index.html",
        redirect: "/http-sign/"
    }, {
        path: "/01.开发指南/02.后端手册/34.HTTP 签名.html",
        redirect: "/http-sign/"
    }, {
        name: "v-1538c668",
        path: "/unit-test/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-1538c668").then(t)
        }
    }, {
        path: "/unit-test/index.html",
        redirect: "/unit-test/"
    }, {
        path: "/01.开发指南/02.后端手册/40.单元测试.html",
        redirect: "/unit-test/"
    }, {
        name: "v-29cec904",
        path: "/config-center/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-29cec904").then(t)
        }
    }, {
        path: "/config-center/index.html",
        redirect: "/config-center/"
    }, {
        path: "/01.开发指南/02.后端手册/43.配置管理.html",
        redirect: "/config-center/"
    }, {
        name: "v-083d3c72",
        path: "/util/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-083d3c72").then(t)
        }
    }, {
        path: "/util/index.html",
        redirect: "/util/"
    }, {
        path: "/01.开发指南/02.后端手册/42.工具类 Util.html",
        redirect: "/util/"
    }, {
        name: "v-68f656d5",
        path: "/job/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-68f656d5").then(t)
        }
    }, {
        path: "/job/index.html",
        redirect: "/job/"
    }, {
        path: "/01.开发指南/03.中间件手册/06.定时任务.html",
        redirect: "/job/"
    }, {
        name: "v-10102f0d",
        path: "/db-doc/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-10102f0d").then(t)
        }
    }, {
        path: "/db-doc/index.html",
        redirect: "/db-doc/"
    }, {
        path: "/01.开发指南/02.后端手册/44.数据库文档.html",
        redirect: "/db-doc/"
    }, {
        name: "v-c5941d2e",
        path: "/message-queue/event/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-c5941d2e").then(t)
        }
    }, {
        path: "/message-queue/event/index.html",
        redirect: "/message-queue/event/"
    }, {
        path: "/01.开发指南/03.中间件手册/11.消息队列（内存）.html",
        redirect: "/message-queue/event/"
    }, {
        name: "v-1d2b9a12",
        path: "/message-queue/redis/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-1d2b9a12").then(t)
        }
    }, {
        path: "/message-queue/redis/index.html",
        redirect: "/message-queue/redis/"
    }, {
        path: "/01.开发指南/03.中间件手册/12.消息队列（Redis）.html",
        redirect: "/message-queue/redis/"
    }, {
        name: "v-7e706b0d",
        path: "/message-queue/rocketmq/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-7e706b0d").then(t)
        }
    }, {
        path: "/message-queue/rocketmq/index.html",
        redirect: "/message-queue/rocketmq/"
    }, {
        path: "/01.开发指南/03.中间件手册/13.消息队列（RocketMQ）.html",
        redirect: "/message-queue/rocketmq/"
    }, {
        name: "v-c869afae",
        path: "/captcha/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-c869afae").then(t)
        }
    }, {
        path: "/captcha/index.html",
        redirect: "/captcha/"
    }, {
        path: "/01.开发指南/02.后端手册/41.验证码.html",
        redirect: "/captcha/"
    }, {
        name: "v-6af50b4a",
        path: "/message-queue/rabbitmq/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-6af50b4a").then(t)
        }
    }, {
        path: "/message-queue/rabbitmq/index.html",
        redirect: "/message-queue/rabbitmq/"
    }, {
        path: "/01.开发指南/03.中间件手册/14.消息队列（RabbitMQ）.html",
        redirect: "/message-queue/rabbitmq/"
    }, {
        name: "v-bcabe830",
        path: "/server-protection/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-bcabe830").then(t)
        }
    }, {
        path: "/server-protection/index.html",
        redirect: "/server-protection/"
    }, {
        path: "/01.开发指南/03.中间件手册/22.限流熔断.html",
        redirect: "/server-protection/"
    }, {
        name: "v-7f482612",
        path: "/message-queue/kafka/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-7f482612").then(t)
        }
    }, {
        path: "/message-queue/kafka/index.html",
        redirect: "/message-queue/kafka/"
    }, {
        path: "/01.开发指南/03.中间件手册/15.消息队列（Kafka）.html",
        redirect: "/message-queue/kafka/"
    }, {
        name: "v-fc3ae356",
        path: "/bpm/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-fc3ae356").then(t)
        }
    }, {
        path: "/bpm/index.html",
        redirect: "/bpm/"
    }, {
        path: "/01.开发指南/10.工作流手册/02.功能开启.html",
        redirect: "/bpm/"
    }, {
        name: "v-062f85ec",
        path: "/bpm-preview/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-062f85ec").then(t)
        }
    }, {
        path: "/bpm-preview/index.html",
        redirect: "/bpm-preview/"
    }, {
        path: "/01.开发指南/10.工作流手册/01.工作流演示.html",
        redirect: "/bpm-preview/"
    }, {
        name: "v-cc2f8ada",
        path: "/bpm/dameng/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-cc2f8ada").then(t)
        }
    }, {
        path: "/bpm/dameng/index.html",
        redirect: "/bpm/dameng/"
    }, {
        path: "/01.开发指南/10.工作流手册/03.工作流（达梦适配）.html",
        redirect: "/bpm/dameng/"
    }, {
        name: "v-1c97a241",
        path: "/bpm/use-business-form/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-1c97a241").then(t)
        }
    }, {
        path: "/bpm/use-business-form/index.html",
        redirect: "/bpm/use-business-form/"
    }, {
        path: "/01.开发指南/10.工作流手册/05.审批接入（业务表单）.html",
        redirect: "/bpm/use-business-form/"
    }, {
        name: "v-66fc1dcc",
        path: "/bpm/use-bpm-form/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-66fc1dcc").then(t)
        }
    }, {
        path: "/bpm/use-bpm-form/index.html",
        redirect: "/bpm/use-bpm-form/"
    }, {
        path: "/01.开发指南/10.工作流手册/04.审批接入（流程表单）.html",
        redirect: "/bpm/use-bpm-form/"
    }, {
        name: "v-b58f8daa",
        path: "/bpm/model-designer-bpmn/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-b58f8daa").then(t)
        }
    }, {
        path: "/bpm/model-designer-bpmn/index.html",
        redirect: "/bpm/model-designer-bpmn/"
    }, {
        path: "/01.开发指南/10.工作流手册/11.流程设计器（BPMN）.html",
        redirect: "/bpm/model-designer-bpmn/"
    }, {
        name: "v-74ea7ea9",
        path: "/bpm/model-designer-dingding/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-74ea7ea9").then(t)
        }
    }, {
        path: "/bpm/model-designer-dingding/index.html",
        redirect: "/bpm/model-designer-dingding/"
    }, {
        path: "/01.开发指南/10.工作流手册/12.流程设计器（钉钉、飞书）.html",
        redirect: "/bpm/model-designer-dingding/"
    }, {
        name: "v-fd046d40",
        path: "/bpm/assignee/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-fd046d40").then(t)
        }
    }, {
        path: "/bpm/assignee/index.html",
        redirect: "/bpm/assignee/"
    }, {
        path: "/01.开发指南/10.工作流手册/20.选择审批人、发起人自选.html",
        redirect: "/bpm/assignee/"
    }, {
        name: "v-36616294",
        path: "/bpm/multi-instance/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-36616294").then(t)
        }
    }, {
        path: "/bpm/multi-instance/index.html",
        redirect: "/bpm/multi-instance/"
    }, {
        path: "/01.开发指南/10.工作流手册/21.会签、或签、依次审批.html",
        redirect: "/bpm/multi-instance/"
    }, {
        name: "v-2ec9624a",
        path: "/bpm/task-todo-done/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-2ec9624a").then(t)
        }
    }, {
        path: "/bpm/task-todo-done/index.html",
        redirect: "/bpm/task-todo-done/"
    }, {
        path: "/01.开发指南/10.工作流手册/23.审批通过、不通过、驳回.html",
        redirect: "/bpm/task-todo-done/"
    }, {
        name: "v-206fa80a",
        path: "/bpm/sign/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-206fa80a").then(t)
        }
    }, {
        path: "/bpm/sign/index.html",
        redirect: "/bpm/sign/"
    }, {
        path: "/01.开发指南/10.工作流手册/24.审批加签、减签.html",
        redirect: "/bpm/sign/"
    }, {
        name: "v-7bcb8f4d",
        path: "/bpm/process-instance/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-7bcb8f4d").then(t)
        }
    }, {
        path: "/bpm/process-instance/index.html",
        redirect: "/bpm/process-instance/"
    }, {
        path: "/01.开发指南/10.工作流手册/22.流程发起、取消、重新发起.html",
        redirect: "/bpm/process-instance/"
    }, {
        name: "v-9101d9a2",
        path: "/bpm/listener/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-9101d9a2").then(t)
        }
    }, {
        path: "/bpm/listener/index.html",
        redirect: "/bpm/listener/"
    }, {
        path: "/01.开发指南/10.工作流手册/30.执行监听器、任务监听器.html",
        redirect: "/bpm/listener/"
    }, {
        name: "v-ffb49796",
        path: "/bpm/task-delegation-and-cc/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-ffb49796").then(t)
        }
    }, {
        path: "/bpm/task-delegation-and-cc/index.html",
        redirect: "/bpm/task-delegation-and-cc/"
    }, {
        path: "/01.开发指南/10.工作流手册/25.审批转办、委派、抄送.html",
        redirect: "/bpm/task-delegation-and-cc/"
    }, {
        name: "v-15fe64f5",
        path: "/bpm/expression/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-15fe64f5").then(t)
        }
    }, {
        path: "/bpm/expression/index.html",
        redirect: "/bpm/expression/"
    }, {
        path: "/01.开发指南/10.工作流手册/31.流程表达式.html",
        redirect: "/bpm/expression/"
    }, {
        name: "v-e09374cc",
        path: "/bpm/message/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-e09374cc").then(t)
        }
    }, {
        path: "/bpm/message/index.html",
        redirect: "/bpm/message/"
    }, {
        path: "/01.开发指南/10.工作流手册/41.流程审批通知.html",
        redirect: "/bpm/message/"
    }, {
        name: "v-51ece8cc",
        path: "/report/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-51ece8cc").then(t)
        }
    }, {
        path: "/report/index.html",
        redirect: "/report/"
    }, {
        path: "/01.开发指南/11.大屏手册/01.报表设计器.html",
        redirect: "/report/"
    }, {
        name: "v-387aeb79",
        path: "/pay/build/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-387aeb79").then(t)
        }
    }, {
        path: "/pay/build/index.html",
        redirect: "/pay/build/"
    }, {
        path: "/01.开发指南/12.支付手册/01.功能开启.html",
        redirect: "/pay/build/"
    }, {
        name: "v-90482726",
        path: "/pay/alipay-pay-demo/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-90482726").then(t)
        }
    }, {
        path: "/pay/alipay-pay-demo/index.html",
        redirect: "/pay/alipay-pay-demo/"
    }, {
        path: "/01.开发指南/12.支付手册/11.支付宝支付接入.html",
        redirect: "/pay/alipay-pay-demo/"
    }, {
        name: "v-4da5e558",
        path: "/pay/wx-pub-pay-demo/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-4da5e558").then(t)
        }
    }, {
        path: "/pay/wx-pub-pay-demo/index.html",
        redirect: "/pay/wx-pub-pay-demo/"
    }, {
        path: "/01.开发指南/12.支付手册/12.微信公众号支付接入.html",
        redirect: "/pay/wx-pub-pay-demo/"
    }, {
        name: "v-3a3955ca",
        path: "/report/screen/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-3a3955ca").then(t)
        }
    }, {
        path: "/report/screen/index.html",
        redirect: "/report/screen/"
    }, {
        path: "/01.开发指南/11.大屏手册/02.大屏设计器.html",
        redirect: "/report/screen/"
    }, {
        name: "v-18b6abc1",
        path: "/pay/wx-lite-pay-demo/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-18b6abc1").then(t)
        }
    }, {
        path: "/pay/wx-lite-pay-demo/index.html",
        redirect: "/pay/wx-lite-pay-demo/"
    }, {
        path: "/01.开发指南/12.支付手册/13.微信小程序支付接入.html",
        redirect: "/pay/wx-lite-pay-demo/"
    }, {
        name: "v-5e7d42dd",
        path: "/pay/wallet/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-5e7d42dd").then(t)
        }
    }, {
        path: "/pay/wallet/index.html",
        redirect: "/pay/wallet/"
    }, {
        path: "/01.开发指南/12.支付手册/30.钱包充值、支付、退款.html",
        redirect: "/pay/wallet/"
    }, {
        name: "v-74d1fe05",
        path: "/pay/refund-demo/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-74d1fe05").then(t)
        }
    }, {
        path: "/pay/refund-demo/index.html",
        redirect: "/pay/refund-demo/"
    }, {
        path: "/01.开发指南/12.支付手册/21.支付宝、微信退款接入.html",
        redirect: "/pay/refund-demo/"
    }, {
        name: "v-6807e4c0",
        path: "/member/build/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-6807e4c0").then(t)
        }
    }, {
        path: "/member/build/index.html",
        redirect: "/member/build/"
    }, {
        path: "/01.开发指南/13.会员手册/01.功能开启.html",
        redirect: "/member/build/"
    }, {
        name: "v-17169eb9",
        path: "/member/weixin-lite-login/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-17169eb9").then(t)
        }
    }, {
        path: "/member/weixin-lite-login/index.html",
        redirect: "/member/weixin-lite-login/"
    }, {
        path: "/01.开发指南/13.会员手册/03.微信小程序登录.html",
        redirect: "/member/weixin-lite-login/"
    }, {
        name: "v-579c34cc",
        path: "/pay/mock/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-579c34cc").then(t)
        }
    }, {
        path: "/pay/mock/index.html",
        redirect: "/pay/mock/"
    }, {
        path: "/01.开发指南/12.支付手册/31.模拟支付、退款.html",
        redirect: "/pay/mock/"
    }, {
        name: "v-4ee82b66",
        path: "/member/weixin-lite-subscribe-message/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-4ee82b66").then(t)
        }
    }, {
        path: "/member/weixin-lite-subscribe-message/index.html",
        redirect: "/member/weixin-lite-subscribe-message/"
    }, {
        path: "/01.开发指南/13.会员手册/04.微信小程序订阅消息.html",
        redirect: "/member/weixin-lite-subscribe-message/"
    }, {
        name: "v-6462c10c",
        path: "/member/weixin-mp-login/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-6462c10c").then(t)
        }
    }, {
        path: "/member/weixin-mp-login/index.html",
        redirect: "/member/weixin-mp-login/"
    }, {
        path: "/01.开发指南/13.会员手册/02.微信公众号登录.html",
        redirect: "/member/weixin-mp-login/"
    }, {
        name: "v-1561b62d",
        path: "/mall/build/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-1561b62d").then(t)
        }
    }, {
        path: "/mall/build/index.html",
        redirect: "/mall/build/"
    }, {
        path: "/01.开发指南/14.商城手册/02.功能开启.html",
        redirect: "/mall/build/"
    }, {
        name: "v-667d3c15",
        path: "/member/weixin-lite-qrcode/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-667d3c15").then(t)
        }
    }, {
        path: "/member/weixin-lite-qrcode/index.html",
        redirect: "/member/weixin-lite-qrcode/"
    }, {
        path: "/01.开发指南/13.会员手册/05.微信小程序码.html",
        redirect: "/member/weixin-lite-qrcode/"
    }, {
        name: "v-21105448",
        path: "/member/user/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-21105448").then(t)
        }
    }, {
        path: "/member/user/index.html",
        redirect: "/member/user/"
    }, {
        path: "/01.开发指南/13.会员手册/11.会员用户、标签、分组.html",
        redirect: "/member/user/"
    }, {
        name: "v-efc01664",
        path: "/member/level/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-efc01664").then(t)
        }
    }, {
        path: "/member/level/index.html",
        redirect: "/member/level/"
    }, {
        path: "/01.开发指南/13.会员手册/12.会员等级、积分、签到.html",
        redirect: "/member/level/"
    }, {
        name: "v-6909fb9a",
        path: "/mall-preview/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-6909fb9a").then(t)
        }
    }, {
        path: "/mall-preview/index.html",
        redirect: "/mall-preview/"
    }, {
        path: "/01.开发指南/14.商城手册/01.商城演示.html",
        redirect: "/mall-preview/"
    }, {
        name: "v-5f89bd8e",
        path: "/mall/diy/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-5f89bd8e").then(t)
        }
    }, {
        path: "/mall/diy/index.html",
        redirect: "/mall/diy/"
    }, {
        path: "/01.开发指南/14.商城手册/03.店铺装修.html",
        redirect: "/mall/diy/"
    }, {
        name: "v-2961facf",
        path: "/mall/kefu/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-2961facf").then(t)
        }
    }, {
        path: "/mall/kefu/index.html",
        redirect: "/mall/kefu/"
    }, {
        path: "/01.开发指南/14.商城手册/04.在线客服.html",
        redirect: "/mall/kefu/"
    }, {
        name: "v-2f67cc3d",
        path: "/mall/product-category/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-2f67cc3d").then(t)
        }
    }, {
        path: "/mall/product-category/index.html",
        redirect: "/mall/product-category/"
    }, {
        path: "/01.开发指南/14.商城手册/10.【商品】商品分类.html",
        redirect: "/mall/product-category/"
    }, {
        name: "v-05be4724",
        path: "/mall/product-property/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-05be4724").then(t)
        }
    }, {
        path: "/mall/product-property/index.html",
        redirect: "/mall/product-property/"
    }, {
        path: "/01.开发指南/14.商城手册/11.【商品】商品属性.html",
        redirect: "/mall/product-property/"
    }, {
        name: "v-37a586a9",
        path: "/mall/product-spu-sku/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-37a586a9").then(t)
        }
    }, {
        path: "/mall/product-spu-sku/index.html",
        redirect: "/mall/product-spu-sku/"
    }, {
        path: "/01.开发指南/14.商城手册/12.【商品】商品 SPU 与 SKU.html",
        redirect: "/mall/product-spu-sku/"
    }, {
        name: "v-743e4ef6",
        path: "/mall/product-comment/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-743e4ef6").then(t)
        }
    }, {
        path: "/mall/product-comment/index.html",
        redirect: "/mall/product-comment/"
    }, {
        path: "/01.开发指南/14.商城手册/13.【商品】商品评价.html",
        redirect: "/mall/product-comment/"
    }, {
        name: "v-d0f81f92",
        path: "/mall/trade-cart/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-d0f81f92").then(t)
        }
    }, {
        path: "/mall/trade-cart/index.html",
        redirect: "/mall/trade-cart/"
    }, {
        path: "/01.开发指南/14.商城手册/21.【交易】购物车.html",
        redirect: "/mall/trade-cart/"
    }, {
        name: "v-5dfa0e50",
        path: "/mall/trade-order/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-5dfa0e50").then(t)
        }
    }, {
        path: "/mall/trade-order/index.html",
        redirect: "/mall/trade-order/"
    }, {
        path: "/01.开发指南/14.商城手册/22.【交易】交易订单.html",
        redirect: "/mall/trade-order/"
    }, {
        name: "v-c0d3292c",
        path: "/mall/trade-aftersale/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-c0d3292c").then(t)
        }
    }, {
        path: "/mall/trade-aftersale/index.html",
        redirect: "/mall/trade-aftersale/"
    }, {
        path: "/01.开发指南/14.商城手册/23.【交易】售后退款.html",
        redirect: "/mall/trade-aftersale/"
    }, {
        name: "v-139162e2",
        path: "/mall/trade-delivery-express/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-139162e2").then(t)
        }
    }, {
        path: "/mall/trade-delivery-express/index.html",
        redirect: "/mall/trade-delivery-express/"
    }, {
        path: "/01.开发指南/14.商城手册/24.【交易】快递发货.html",
        redirect: "/mall/trade-delivery-express/"
    }, {
        name: "v-6077cf88",
        path: "/mall/trade-brokerage/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-6077cf88").then(t)
        }
    }, {
        path: "/mall/trade-brokerage/index.html",
        redirect: "/mall/trade-brokerage/"
    }, {
        path: "/01.开发指南/14.商城手册/26.【交易】分销返佣.html",
        redirect: "/mall/trade-brokerage/"
    }, {
        name: "v-030ec89a",
        path: "/mall/promotion-coupon/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-030ec89a").then(t)
        }
    }, {
        path: "/mall/promotion-coupon/index.html",
        redirect: "/mall/promotion-coupon/"
    }, {
        path: "/01.开发指南/14.商城手册/30.【营销】优惠劵.html",
        redirect: "/mall/promotion-coupon/"
    }, {
        name: "v-533a65b7",
        path: "/mall/point-activity/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-533a65b7").then(t)
        }
    }, {
        path: "/mall/point-activity/index.html",
        redirect: "/mall/point-activity/"
    }, {
        path: "/01.开发指南/14.商城手册/31.【营销】积分商城.html",
        redirect: "/mall/point-activity/"
    }, {
        name: "v-daa527f8",
        path: "/mall/trade-delivery-pickup/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-daa527f8").then(t)
        }
    }, {
        path: "/mall/trade-delivery-pickup/index.html",
        redirect: "/mall/trade-delivery-pickup/"
    }, {
        path: "/01.开发指南/14.商城手册/25.【交易】门店自提.html",
        redirect: "/mall/trade-delivery-pickup/"
    }, {
        name: "v-2c1efaa7",
        path: "/mall/promotion-combination/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-2c1efaa7").then(t)
        }
    }, {
        path: "/mall/promotion-combination/index.html",
        redirect: "/mall/promotion-combination/"
    }, {
        path: "/01.开发指南/14.商城手册/32.【营销】拼团活动.html",
        redirect: "/mall/promotion-combination/"
    }, {
        name: "v-718a2694",
        path: "/mall/promotion-seckill/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-718a2694").then(t)
        }
    }, {
        path: "/mall/promotion-seckill/index.html",
        redirect: "/mall/promotion-seckill/"
    }, {
        path: "/01.开发指南/14.商城手册/33.【营销】秒杀活动.html",
        redirect: "/mall/promotion-seckill/"
    }, {
        name: "v-6f357586",
        path: "/mall/promotion-bargain/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-6f357586").then(t)
        }
    }, {
        path: "/mall/promotion-bargain/index.html",
        redirect: "/mall/promotion-bargain/"
    }, {
        path: "/01.开发指南/14.商城手册/34.【营销】砍价活动.html",
        redirect: "/mall/promotion-bargain/"
    }, {
        name: "v-7b64b9ed",
        path: "/mall/promotion-content/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-7b64b9ed").then(t)
        }
    }, {
        path: "/mall/promotion-content/index.html",
        redirect: "/mall/promotion-content/"
    }, {
        path: "/01.开发指南/14.商城手册/37.【营销】内容管理.html",
        redirect: "/mall/promotion-content/"
    }, {
        name: "v-31a9a83c",
        path: "/mall/statistics/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-31a9a83c").then(t)
        }
    }, {
        path: "/mall/statistics/index.html",
        redirect: "/mall/statistics/"
    }, {
        path: "/01.开发指南/14.商城手册/40.【统计】会员、商品、交易统计.html",
        redirect: "/mall/statistics/"
    }, {
        name: "v-c7b93916",
        path: "/erp-preview/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-c7b93916").then(t)
        }
    }, {
        path: "/erp-preview/index.html",
        redirect: "/erp-preview/"
    }, {
        path: "/01.开发指南/15.ERP手册/01.ERP 演示.html",
        redirect: "/erp-preview/"
    }, {
        name: "v-3b32bf6e",
        path: "/erp/product/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-3b32bf6e").then(t)
        }
    }, {
        path: "/erp/product/index.html",
        redirect: "/erp/product/"
    }, {
        path: "/01.开发指南/15.ERP手册/10.【产品】产品信息、分类、单位.html",
        redirect: "/erp/product/"
    }, {
        name: "v-35ca4e46",
        path: "/mall/promotion-discount/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-35ca4e46").then(t)
        }
    }, {
        path: "/mall/promotion-discount/index.html",
        redirect: "/mall/promotion-discount/"
    }, {
        path: "/01.开发指南/14.商城手册/36.【营销】限时折扣.html",
        redirect: "/mall/promotion-discount/"
    }, {
        name: "v-3dd7997c",
        path: "/mall/promotion-record/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-3dd7997c").then(t)
        }
    }, {
        path: "/mall/promotion-record/index.html",
        redirect: "/mall/promotion-record/"
    }, {
        path: "/01.开发指南/14.商城手册/35.【营销】满减送活动.html",
        redirect: "/mall/promotion-record/"
    }, {
        name: "v-2a7a8dba",
        path: "/erp/build/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-2a7a8dba").then(t)
        }
    }, {
        path: "/erp/build/index.html",
        redirect: "/erp/build/"
    }, {
        path: "/01.开发指南/15.ERP手册/02.功能开启.html",
        redirect: "/erp/build/"
    }, {
        name: "v-72c968c8",
        path: "/erp/stock-in-out/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-72c968c8").then(t)
        }
    }, {
        path: "/erp/stock-in-out/index.html",
        redirect: "/erp/stock-in-out/"
    }, {
        path: "/01.开发指南/15.ERP手册/21.【库存】其它入库、其它出库.html",
        redirect: "/erp/stock-in-out/"
    }, {
        name: "v-281927db",
        path: "/erp/stock-move-check/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-281927db").then(t)
        }
    }, {
        path: "/erp/stock-move-check/index.html",
        redirect: "/erp/stock-move-check/"
    }, {
        path: "/01.开发指南/15.ERP手册/22.【库存】库存调拨、库存盘点.html",
        redirect: "/erp/stock-move-check/"
    }, {
        name: "v-481dc19e",
        path: "/erp/stock/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-481dc19e").then(t)
        }
    }, {
        path: "/erp/stock/index.html",
        redirect: "/erp/stock/"
    }, {
        path: "/01.开发指南/15.ERP手册/20.【库存】产品库存、库存明细.html",
        redirect: "/erp/stock/"
    }, {
        name: "v-7b9175cc",
        path: "/sale/finance-payment-receipt/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-7b9175cc").then(t)
        }
    }, {
        path: "/sale/finance-payment-receipt/index.html",
        redirect: "/sale/finance-payment-receipt/"
    }, {
        path: "/01.开发指南/15.ERP手册/50.【财务】采购付款、销售收款.html",
        redirect: "/sale/finance-payment-receipt/"
    }, {
        name: "v-6a4d8916",
        path: "/erp/purchase/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-6a4d8916").then(t)
        }
    }, {
        path: "/erp/purchase/index.html",
        redirect: "/erp/purchase/"
    }, {
        path: "/01.开发指南/15.ERP手册/30.【采购】采购订单、入库、退货.html",
        redirect: "/erp/purchase/"
    }, {
        name: "v-5a202116",
        path: "/erp/sale/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-5a202116").then(t)
        }
    }, {
        path: "/erp/sale/index.html",
        redirect: "/erp/sale/"
    }, {
        path: "/01.开发指南/15.ERP手册/40.【销售】销售订单、出库、退货.html",
        redirect: "/erp/sale/"
    }, {
        name: "v-299d87aa",
        path: "/crm/build/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-299d87aa").then(t)
        }
    }, {
        path: "/crm/build/index.html",
        redirect: "/crm/build/"
    }, {
        path: "/01.开发指南/16.CRM手册/02.功能开启.html",
        redirect: "/crm/build/"
    }, {
        name: "v-ffef209a",
        path: "/crm-preview/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-ffef209a").then(t)
        }
    }, {
        path: "/crm-preview/index.html",
        redirect: "/crm-preview/"
    }, {
        path: "/01.开发指南/16.CRM手册/01.CRM 演示.html",
        redirect: "/crm-preview/"
    }, {
        name: "v-21141a8d",
        path: "/crm/clue/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-21141a8d").then(t)
        }
    }, {
        path: "/crm/clue/index.html",
        redirect: "/crm/clue/"
    }, {
        path: "/01.开发指南/16.CRM手册/10.【线索】线索管理.html",
        redirect: "/crm/clue/"
    }, {
        name: "v-09e8ac9a",
        path: "/crm/customer/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-09e8ac9a").then(t)
        }
    }, {
        path: "/crm/customer/index.html",
        redirect: "/crm/customer/"
    }, {
        path: "/01.开发指南/16.CRM手册/20.【客户】客户管理、公海客户.html",
        redirect: "/crm/customer/"
    }, {
        name: "v-54f886d0",
        path: "/crm/business/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-54f886d0").then(t)
        }
    }, {
        path: "/crm/business/index.html",
        redirect: "/crm/business/"
    }, {
        path: "/01.开发指南/16.CRM手册/30.【商机】商机管理、商机状态.html",
        redirect: "/crm/business/"
    }, {
        name: "v-42013c00",
        path: "/crm/contract/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-42013c00").then(t)
        }
    }, {
        path: "/crm/contract/index.html",
        redirect: "/crm/contract/"
    }, {
        path: "/01.开发指南/16.CRM手册/40.【合同】合同管理、合同提醒.html",
        redirect: "/crm/contract/"
    }, {
        name: "v-41341d4b",
        path: "/crm/product/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-41341d4b").then(t)
        }
    }, {
        path: "/crm/product/index.html",
        redirect: "/crm/product/"
    }, {
        path: "/01.开发指南/16.CRM手册/60.【产品】产品管理、产品分类.html",
        redirect: "/crm/product/"
    }, {
        name: "v-343e687c",
        path: "/crm/receivable/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-343e687c").then(t)
        }
    }, {
        path: "/crm/receivable/index.html",
        redirect: "/crm/receivable/"
    }, {
        path: "/01.开发指南/16.CRM手册/50.【回款】回款管理、回款计划.html",
        redirect: "/crm/receivable/"
    }, {
        name: "v-7c10611a",
        path: "/crm/permission/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-7c10611a").then(t)
        }
    }, {
        path: "/crm/permission/index.html",
        redirect: "/crm/permission/"
    }, {
        path: "/01.开发指南/16.CRM手册/90.【通用】数据权限.html",
        redirect: "/crm/permission/"
    }, {
        name: "v-773f7e1e",
        path: "/crm/follow-up/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-773f7e1e").then(t)
        }
    }, {
        path: "/crm/follow-up/index.html",
        redirect: "/crm/follow-up/"
    }, {
        path: "/01.开发指南/16.CRM手册/91.【通用】跟进记录、待办事项.html",
        redirect: "/crm/follow-up/"
    }, {
        name: "v-7845bd88",
        path: "/ai/build/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-7845bd88").then(t)
        }
    }, {
        path: "/ai/build/index.html",
        redirect: "/ai/build/"
    }, {
        path: "/01.开发指南/17.AI大模型手册/02.功能开启.html",
        redirect: "/ai/build/"
    }, {
        name: "v-062f207d",
        path: "/ai-preview/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-062f207d").then(t)
        }
    }, {
        path: "/ai-preview/index.html",
        redirect: "/ai-preview/"
    }, {
        path: "/01.开发指南/17.AI大模型手册/01.AI 大模型演示.html",
        redirect: "/ai-preview/"
    }, {
        name: "v-58fea08e",
        path: "/ai/chat/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-58fea08e").then(t)
        }
    }, {
        path: "/ai/chat/index.html",
        redirect: "/ai/chat/"
    }, {
        path: "/01.开发指南/17.AI大模型手册/11.AI 对话聊天.html",
        redirect: "/ai/chat/"
    }, {
        name: "v-e6e74c38",
        path: "/ai/write/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-e6e74c38").then(t)
        }
    }, {
        path: "/ai/write/index.html",
        redirect: "/ai/write/"
    }, {
        path: "/01.开发指南/17.AI大模型手册/14.AI 写作助手.html",
        redirect: "/ai/write/"
    }, {
        name: "v-70a39a82",
        path: "/ai/image/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-70a39a82").then(t)
        }
    }, {
        path: "/ai/image/index.html",
        redirect: "/ai/image/"
    }, {
        path: "/01.开发指南/17.AI大模型手册/12.AI 绘画创作.html",
        redirect: "/ai/image/"
    }, {
        name: "v-176d8495",
        path: "/ai/openai/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-176d8495").then(t)
        }
    }, {
        path: "/ai/openai/index.html",
        redirect: "/ai/openai/"
    }, {
        path: "/01.开发指南/17.AI大模型手册/80.【模型接入】OpenAI.html",
        redirect: "/ai/openai/"
    }, {
        name: "v-c13f42f0",
        path: "/ai/music/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-c13f42f0").then(t)
        }
    }, {
        path: "/ai/music/index.html",
        redirect: "/ai/music/"
    }, {
        path: "/01.开发指南/17.AI大模型手册/13.AI 音乐创作.html",
        redirect: "/ai/music/"
    }, {
        name: "v-43441f7a",
        path: "/ai/mindmap/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-43441f7a").then(t)
        }
    }, {
        path: "/ai/mindmap/index.html",
        redirect: "/ai/mindmap/"
    }, {
        path: "/01.开发指南/17.AI大模型手册/15.AI 思维导图.html",
        redirect: "/ai/mindmap/"
    }, {
        name: "v-25aac8de",
        path: "/ai/tongyi/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-25aac8de").then(t)
        }
    }, {
        path: "/ai/tongyi/index.html",
        redirect: "/ai/tongyi/"
    }, {
        path: "/01.开发指南/17.AI大模型手册/81.【模型接入】通义千问.html",
        redirect: "/ai/tongyi/"
    }, {
        name: "v-fbfa8048",
        path: "/ai/doubao/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-fbfa8048").then(t)
        }
    }, {
        path: "/ai/doubao/index.html",
        redirect: "/ai/doubao/"
    }, {
        path: "/01.开发指南/17.AI大模型手册/83.【模型接入】字节豆包.html",
        redirect: "/ai/doubao/"
    }, {
        name: "v-50756546",
        path: "/ai/siliconflow/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-50756546").then(t)
        }
    }, {
        path: "/ai/siliconflow/index.html",
        redirect: "/ai/siliconflow/"
    }, {
        path: "/01.开发指南/17.AI大模型手册/85.【模型接入】硅基流动.html",
        redirect: "/ai/siliconflow/"
    }, {
        name: "v-a46abea8",
        path: "/ai/hunyuan/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-a46abea8").then(t)
        }
    }, {
        path: "/ai/hunyuan/index.html",
        redirect: "/ai/hunyuan/"
    }, {
        path: "/01.开发指南/17.AI大模型手册/84.【模型接入】腾讯混元.html",
        redirect: "/ai/hunyuan/"
    }, {
        name: "v-d71b1316",
        path: "/ai/deep-seek/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-d71b1316").then(t)
        }
    }, {
        path: "/ai/deep-seek/index.html",
        redirect: "/ai/deep-seek/"
    }, {
        path: "/01.开发指南/17.AI大模型手册/82.【模型接入】DeepSeek.html",
        redirect: "/ai/deep-seek/"
    }, {
        name: "v-a07ad6d0",
        path: "/ai/yiyan/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-a07ad6d0").then(t)
        }
    }, {
        path: "/ai/yiyan/index.html",
        redirect: "/ai/yiyan/"
    }, {
        path: "/01.开发指南/17.AI大模型手册/89.【模型接入】文心一言.html",
        redirect: "/ai/yiyan/"
    }, {
        name: "v-2487171a",
        path: "/ai/azure-openai/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-2487171a").then(t)
        }
    }, {
        path: "/ai/azure-openai/index.html",
        redirect: "/ai/azure-openai/"
    }, {
        path: "/01.开发指南/17.AI大模型手册/93.【模型接入】微软 OpenAI.html",
        redirect: "/ai/azure-openai/"
    }, {
        name: "v-cf80555e",
        path: "/ai/glm/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-cf80555e").then(t)
        }
    }, {
        path: "/ai/glm/index.html",
        redirect: "/ai/glm/"
    }, {
        path: "/01.开发指南/17.AI大模型手册/91.【模型接入】智谱 GLM.html",
        redirect: "/ai/glm/"
    }, {
        name: "v-eb35368e",
        path: "/ai/llama/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-eb35368e").then(t)
        }
    }, {
        path: "/ai/llama/index.html",
        redirect: "/ai/llama/"
    }, {
        path: "/01.开发指南/17.AI大模型手册/90.【模型接入】LLAMA.html",
        redirect: "/ai/llama/"
    }, {
        name: "v-11c4deaa",
        path: "/ai/xinghuo/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-11c4deaa").then(t)
        }
    }, {
        path: "/ai/xinghuo/index.html",
        redirect: "/ai/xinghuo/"
    }, {
        path: "/01.开发指南/17.AI大模型手册/92.【模型接入】讯飞星火.html",
        redirect: "/ai/xinghuo/"
    }, {
        name: "v-3203ab40",
        path: "/ai/gemini/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-3203ab40").then(t)
        }
    }, {
        path: "/ai/gemini/index.html",
        redirect: "/ai/gemini/"
    }, {
        path: "/01.开发指南/17.AI大模型手册/94.【模型接入】谷歌 Gemini.html",
        redirect: "/ai/gemini/"
    }, {
        name: "v-3a8738bf",
        path: "/ai/suno/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-3a8738bf").then(t)
        }
    }, {
        path: "/ai/suno/index.html",
        redirect: "/ai/suno/"
    }, {
        path: "/01.开发指南/17.AI大模型手册/97.【模型接入】Suno.html",
        redirect: "/ai/suno/"
    }, {
        name: "v-8117d9da",
        path: "/ai/midjourney/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-8117d9da").then(t)
        }
    }, {
        path: "/ai/midjourney/index.html",
        redirect: "/ai/midjourney/"
    }, {
        path: "/01.开发指南/17.AI大模型手册/96.【模型接入】Midjourney.html",
        redirect: "/ai/midjourney/"
    }, {
        name: "v-5b0d6144",
        path: "/ai/stable-diffusion/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-5b0d6144").then(t)
        }
    }, {
        path: "/ai/stable-diffusion/index.html",
        redirect: "/ai/stable-diffusion/"
    }, {
        path: "/01.开发指南/17.AI大模型手册/95.【模型接入】Stable Diffusion.html",
        redirect: "/ai/stable-diffusion/"
    }, {
        name: "v-3d6744a0",
        path: "/mp/build/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-3d6744a0").then(t)
        }
    }, {
        path: "/mp/build/index.html",
        redirect: "/mp/build/"
    }, {
        path: "/01.开发指南/18.公众号手册/01.功能开启.html",
        redirect: "/mp/build/"
    }, {
        name: "v-bd370bb0",
        path: "/mp/account/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-bd370bb0").then(t)
        }
    }, {
        path: "/mp/account/index.html",
        redirect: "/mp/account/"
    }, {
        path: "/01.开发指南/18.公众号手册/02.公众号接入.html",
        redirect: "/mp/account/"
    }, {
        name: "v-9cf724c4",
        path: "/mp/message/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-9cf724c4").then(t)
        }
    }, {
        path: "/mp/message/index.html",
        redirect: "/mp/message/"
    }, {
        path: "/01.开发指南/18.公众号手册/05.公众号消息.html",
        redirect: "/mp/message/"
    }, {
        name: "v-6cfef11d",
        path: "/mp/tag/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-6cfef11d").then(t)
        }
    }, {
        path: "/mp/tag/index.html",
        redirect: "/mp/tag/"
    }, {
        path: "/01.开发指南/18.公众号手册/04.公众号标签.html",
        redirect: "/mp/tag/"
    }, {
        name: "v-96bcf192",
        path: "/mp/auto-reply/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-96bcf192").then(t)
        }
    }, {
        path: "/mp/auto-reply/index.html",
        redirect: "/mp/auto-reply/"
    }, {
        path: "/01.开发指南/18.公众号手册/06.自动回复.html",
        redirect: "/mp/auto-reply/"
    }, {
        name: "v-2718e9ea",
        path: "/mp/user/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-2718e9ea").then(t)
        }
    }, {
        path: "/mp/user/index.html",
        redirect: "/mp/user/"
    }, {
        path: "/01.开发指南/18.公众号手册/03.公众号粉丝.html",
        redirect: "/mp/user/"
    }, {
        name: "v-33de6fc2",
        path: "/mp/menu/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-33de6fc2").then(t)
        }
    }, {
        path: "/mp/menu/index.html",
        redirect: "/mp/menu/"
    }, {
        path: "/01.开发指南/18.公众号手册/07.公众号菜单.html",
        redirect: "/mp/menu/"
    }, {
        name: "v-76a0b199",
        path: "/mp/statistics/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-76a0b199").then(t)
        }
    }, {
        path: "/mp/statistics/index.html",
        redirect: "/mp/statistics/"
    }, {
        path: "/01.开发指南/18.公众号手册/10.公众号统计.html",
        redirect: "/mp/statistics/"
    }, {
        name: "v-708f9059",
        path: "/mp/material/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-708f9059").then(t)
        }
    }, {
        path: "/mp/material/index.html",
        redirect: "/mp/material/"
    }, {
        path: "/01.开发指南/18.公众号手册/08.公众号素材.html",
        redirect: "/mp/material/"
    }, {
        name: "v-217c7a2a",
        path: "/sms/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-217c7a2a").then(t)
        }
    }, {
        path: "/sms/index.html",
        redirect: "/sms/"
    }, {
        path: "/01.开发指南/19.系统手册/40.短信配置.html",
        redirect: "/sms/"
    }, {
        name: "v-3e3c0a92",
        path: "/mp/article/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-3e3c0a92").then(t)
        }
    }, {
        path: "/mp/article/index.html",
        redirect: "/mp/article/"
    }, {
        path: "/01.开发指南/18.公众号手册/09.公众号图文.html",
        redirect: "/mp/article/"
    }, {
        name: "v-1d0606ec",
        path: "/sensitive-word/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-1d0606ec").then(t)
        }
    }, {
        path: "/sensitive-word/index.html",
        redirect: "/sensitive-word/"
    }, {
        path: "/01.开发指南/19.系统手册/46.敏感词.html",
        redirect: "/sensitive-word/"
    }, {
        name: "v-59619c72",
        path: "/desensitize/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-59619c72").then(t)
        }
    }, {
        path: "/desensitize/index.html",
        redirect: "/desensitize/"
    }, {
        path: "/01.开发指南/19.系统手册/45.数据脱敏.html",
        redirect: "/desensitize/"
    }, {
        name: "v-1f164a08",
        path: "/notify/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-1f164a08").then(t)
        }
    }, {
        path: "/notify/index.html",
        redirect: "/notify/"
    }, {
        path: "/01.开发指南/19.系统手册/42.站内信配置.html",
        redirect: "/notify/"
    }, {
        name: "v-1573c0d7",
        path: "/area-and-ip/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-1573c0d7").then(t)
        }
    }, {
        path: "/area-and-ip/index.html",
        redirect: "/area-and-ip/"
    }, {
        path: "/01.开发指南/19.系统手册/48.地区 & IP.html",
        redirect: "/area-and-ip/"
    }, {
        name: "v-7b1df228",
        path: "/mail/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-7b1df228").then(t)
        }
    }, {
        path: "/mail/index.html",
        redirect: "/mail/"
    }, {
        path: "/01.开发指南/19.系统手册/41.邮件配置.html",
        redirect: "/mail/"
    }, {
        name: "v-5f199590",
        path: "/deployment-linux/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-5f199590").then(t)
        }
    }, {
        path: "/deployment-linux/index.html",
        redirect: "/deployment-linux/"
    }, {
        path: "/01.开发指南/20.运维手册/02.Linux 部署.html",
        redirect: "/deployment-linux/"
    }, {
        name: "v-34a0a5ca",
        path: "/dev-env/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-34a0a5ca").then(t)
        }
    }, {
        path: "/dev-env/index.html",
        redirect: "/dev-env/"
    }, {
        path: "/01.开发指南/20.运维手册/01.开发环境.html",
        redirect: "/dev-env/"
    }, {
        name: "v-017c0fde",
        path: "/deployment-docker/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-017c0fde").then(t)
        }
    }, {
        path: "/deployment-docker/index.html",
        redirect: "/deployment-docker/"
    }, {
        path: "/01.开发指南/20.运维手册/03.Docker 部署.html",
        redirect: "/deployment-docker/"
    }, {
        name: "v-604907e0",
        path: "/deployment-jenkins/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-604907e0").then(t)
        }
    }, {
        path: "/deployment-jenkins/index.html",
        redirect: "/deployment-jenkins/"
    }, {
        path: "/01.开发指南/20.运维手册/04.Jenkins 部署.html",
        redirect: "/deployment-jenkins/"
    }, {
        name: "v-41a4a526",
        path: "/deployment-baota/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-41a4a526").then(t)
        }
    }, {
        path: "/deployment-baota/index.html",
        redirect: "/deployment-baota/"
    }, {
        path: "/01.开发指南/20.运维手册/05.宝塔部署.html",
        redirect: "/deployment-baota/"
    }, {
        name: "v-455bbf33",
        path: "/vue3/dev-spec/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-455bbf33").then(t)
        }
    }, {
        path: "/vue3/dev-spec/index.html",
        redirect: "/vue3/dev-spec/"
    }, {
        path: "/01.开发指南/21.前端手册 Vue 3.x/01.开发规范.html",
        redirect: "/vue3/dev-spec/"
    }, {
        name: "v-5979c815",
        path: "/https/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-5979c815").then(t)
        }
    }, {
        path: "/https/index.html",
        redirect: "/https/"
    }, {
        path: "/01.开发指南/20.运维手册/10.HTTPS 证书.html",
        redirect: "/https/"
    }, {
        name: "v-6fec2647",
        path: "/vue3/route/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-6fec2647").then(t)
        }
    }, {
        path: "/vue3/route/index.html",
        redirect: "/vue3/route/"
    }, {
        path: "/01.开发指南/21.前端手册 Vue 3.x/02.菜单路由.html",
        redirect: "/vue3/route/"
    }, {
        name: "v-f698ea34",
        path: "/server-monitor/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-f698ea34").then(t)
        }
    }, {
        path: "/server-monitor/index.html",
        redirect: "/server-monitor/"
    }, {
        path: "/01.开发指南/20.运维手册/11.服务监控.html",
        redirect: "/server-monitor/"
    }, {
        name: "v-191f91c3",
        path: "/vue3/icon/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-191f91c3").then(t)
        }
    }, {
        path: "/vue3/icon/index.html",
        redirect: "/vue3/icon/"
    }, {
        path: "/01.开发指南/21.前端手册 Vue 3.x/03.Icon 图标.html",
        redirect: "/vue3/icon/"
    }, {
        name: "v-6f969d4f",
        path: "/vue3/util/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-6f969d4f").then(t)
        }
    }, {
        path: "/vue3/util/index.html",
        redirect: "/vue3/util/"
    }, {
        path: "/01.开发指南/21.前端手册 Vue 3.x/06.通用方法.html",
        redirect: "/vue3/util/"
    }, {
        name: "v-6707f78a",
        path: "/vue3/dict/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-6707f78a").then(t)
        }
    }, {
        path: "/vue3/dict/index.html",
        redirect: "/vue3/dict/"
    }, {
        path: "/01.开发指南/21.前端手册 Vue 3.x/04.字典数据.html",
        redirect: "/vue3/dict/"
    }, {
        name: "v-63425dba",
        path: "/vue3/components/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-63425dba").then(t)
        }
    }, {
        path: "/vue3/components/index.html",
        redirect: "/vue3/components/"
    }, {
        path: "/01.开发指南/21.前端手册 Vue 3.x/05.系统组件.html",
        redirect: "/vue3/components/"
    }, {
        name: "v-b7a0fe8c",
        path: "/vue3/config-center/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-b7a0fe8c").then(t)
        }
    }, {
        path: "/vue3/config-center/index.html",
        redirect: "/vue3/config-center/"
    }, {
        path: "/01.开发指南/21.前端手册 Vue 3.x/07.配置读取.html",
        redirect: "/vue3/config-center/"
    }, {
        name: "v-f3732e0a",
        path: "/vue3/i18n/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-f3732e0a").then(t)
        }
    }, {
        path: "/vue3/i18n/index.html",
        redirect: "/vue3/i18n/"
    }, {
        path: "/01.开发指南/21.前端手册 Vue 3.x/09.国际化.html",
        redirect: "/vue3/i18n/"
    }, {
        name: "v-26f5609c",
        path: "/vue3/crud-schema/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-26f5609c").then(t)
        }
    }, {
        path: "/vue3/crud-schema/index.html",
        redirect: "/vue3/crud-schema/"
    }, {
        path: "/01.开发指南/21.前端手册 Vue 3.x/08.CRUD 组件.html",
        redirect: "/vue3/crud-schema/"
    }, {
        name: "v-1ff35d63",
        path: "/vue3/format/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-1ff35d63").then(t)
        }
    }, {
        path: "/vue3/format/index.html",
        redirect: "/vue3/format/"
    }, {
        path: "/01.开发指南/21.前端手册 Vue 3.x/11.代码格式化.html",
        redirect: "/vue3/format/"
    }, {
        name: "v-1f7300c5",
        path: "/vue3/debugger/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-1f7300c5").then(t)
        }
    }, {
        path: "/vue3/debugger/index.html",
        redirect: "/vue3/debugger/"
    }, {
        path: "/01.开发指南/21.前端手册 Vue 3.x/10.IDE 调试.html",
        redirect: "/vue3/debugger/"
    }, {
        name: "v-19b9a873",
        path: "/vue2/dev-spec/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-19b9a873").then(t)
        }
    }, {
        path: "/vue2/dev-spec/index.html",
        redirect: "/vue2/dev-spec/"
    }, {
        path: "/01.开发指南/22.前端手册 Vue 2.x/01.开发规范.html",
        redirect: "/vue2/dev-spec/"
    }, {
        name: "v-a2edb502",
        path: "/vue2/icon/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-a2edb502").then(t)
        }
    }, {
        path: "/vue2/icon/index.html",
        redirect: "/vue2/icon/"
    }, {
        path: "/01.开发指南/22.前端手册 Vue 2.x/03.Icon 图标.html",
        redirect: "/vue2/icon/"
    }, {
        name: "v-ba868b3a",
        path: "/vue2/components/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-ba868b3a").then(t)
        }
    }, {
        path: "/vue2/components/index.html",
        redirect: "/vue2/components/"
    }, {
        path: "/01.开发指南/22.前端手册 Vue 2.x/05.系统组件.html",
        redirect: "/vue2/components/"
    }, {
        name: "v-444a0f87",
        path: "/vue2/route/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-444a0f87").then(t)
        }
    }, {
        path: "/vue2/route/index.html",
        redirect: "/vue2/route/"
    }, {
        path: "/01.开发指南/22.前端手册 Vue 2.x/02.菜单路由.html",
        redirect: "/vue2/route/"
    }, {
        name: "v-be4c250a",
        path: "/vue2/dict/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-be4c250a").then(t)
        }
    }, {
        path: "/vue2/dict/index.html",
        redirect: "/vue2/dict/"
    }, {
        path: "/01.开发指南/22.前端手册 Vue 2.x/04.字典数据.html",
        redirect: "/vue2/dict/"
    }, {
        name: "v-43f4868f",
        path: "/vue2/util/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-43f4868f").then(t)
        }
    }, {
        path: "/vue2/util/index.html",
        redirect: "/vue2/util/"
    }, {
        path: "/01.开发指南/22.前端手册 Vue 2.x/06.通用方法.html",
        redirect: "/vue2/util/"
    }, {
        name: "v-788d69fa",
        path: "/vue2/config-center/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-788d69fa").then(t)
        }
    }, {
        path: "/vue2/config-center/index.html",
        redirect: "/vue2/config-center/"
    }, {
        path: "/01.开发指南/22.前端手册 Vue 2.x/07.配置读取.html",
        redirect: "/vue2/config-center/"
    }, {
        name: "v-4c301678",
        path: "/changelog/2.4.1/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-4c301678").then(t)
        }
    }, {
        path: "/changelog/2.4.1/index.html",
        redirect: "/changelog/2.4.1/"
    }, {
        path: "/01.开发指南/30.更新日志/70.【v2-4-1】2025-02-09.html",
        redirect: "/changelog/2.4.1/"
    }, {
        name: "v-08720438",
        path: "/changelog/2.4.2/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-08720438").then(t)
        }
    }, {
        path: "/changelog/2.4.2/index.html",
        redirect: "/changelog/2.4.2/"
    }, {
        path: "/01.开发指南/30.更新日志/69.【v2-4-2】开发中.html",
        redirect: "/changelog/2.4.2/"
    }, {
        name: "v-fa8c6850",
        path: "/changelog/2.4.0/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-fa8c6850").then(t)
        }
    }, {
        path: "/changelog/2.4.0/index.html",
        redirect: "/changelog/2.4.0/"
    }, {
        path: "/01.开发指南/30.更新日志/71.【v2-4-0】2024-12-31.html",
        redirect: "/changelog/2.4.0/"
    }, {
        name: "v-23b6cc78",
        path: "/changelog/2.3.0/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-23b6cc78").then(t)
        }
    }, {
        path: "/changelog/2.3.0/index.html",
        redirect: "/changelog/2.3.0/"
    }, {
        path: "/01.开发指南/30.更新日志/72.【v2-3-0】2024-10-07.html",
        redirect: "/changelog/2.3.0/"
    }, {
        name: "v-4abee190",
        path: "/changelog/2.2.0/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-4abee190").then(t)
        }
    }, {
        path: "/changelog/2.2.0/index.html",
        redirect: "/changelog/2.2.0/"
    }, {
        path: "/01.开发指南/30.更新日志/73.【v2-2-0】2024-08-02.html",
        redirect: "/changelog/2.2.0/"
    }, {
        name: "v-c0868a50",
        path: "/changelog/2.0.1/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-c0868a50").then(t)
        }
    }, {
        path: "/changelog/2.0.1/index.html",
        redirect: "/changelog/2.0.1/"
    }, {
        path: "/01.开发指南/30.更新日志/75.【v2-0-1】2024-03-01.html",
        redirect: "/changelog/2.0.1/"
    }, {
        name: "v-5f5ee778",
        path: "/changelog/2.1.0/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-5f5ee778").then(t)
        }
    }, {
        path: "/changelog/2.1.0/index.html",
        redirect: "/changelog/2.1.0/"
    }, {
        path: "/01.开发指南/30.更新日志/74.【v2-1-0】2024-05-05.html",
        redirect: "/changelog/2.1.0/"
    }, {
        name: "v-3f295e87",
        path: "/changelog/1.9.0/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-3f295e87").then(t)
        }
    }, {
        path: "/changelog/1.9.0/index.html",
        redirect: "/changelog/1.9.0/"
    }, {
        path: "/99.更新日志/77.【v1-9-0】2023-11-30.html",
        redirect: "/changelog/1.9.0/"
    }, {
        name: "v-7e58c238",
        path: "/changelog/2.0.0/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-7e58c238").then(t)
        }
    }, {
        path: "/changelog/2.0.0/index.html",
        redirect: "/changelog/2.0.0/"
    }, {
        path: "/01.开发指南/30.更新日志/76.【v2-0-0】2024-01-26.html",
        redirect: "/changelog/2.0.0/"
    }, {
        name: "v-f21f67b2",
        path: "/changelog/1.8.3/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-f21f67b2").then(t)
        }
    }, {
        path: "/changelog/1.8.3/index.html",
        redirect: "/changelog/1.8.3/"
    }, {
        path: "/99.更新日志/78.【v1-8-3】2023-10-24.html",
        redirect: "/changelog/1.8.3/"
    }, {
        name: "v-aded8732",
        path: "/changelog/1.8.2/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-aded8732").then(t)
        }
    }, {
        path: "/changelog/1.8.2/index.html",
        redirect: "/changelog/1.8.2/"
    }, {
        path: "/99.更新日志/79.【v1-8-2】2023-09-24.html",
        redirect: "/changelog/1.8.2/"
    }, {
        name: "v-74173047",
        path: "/changelog/1.7.3/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-74173047").then(t)
        }
    }, {
        path: "/changelog/1.7.3/index.html",
        redirect: "/changelog/1.7.3/"
    }, {
        path: "/99.更新日志/82.【v1-7-3】2023-05-29.html",
        redirect: "/changelog/1.7.3/"
    }, {
        name: "v-a77a1c72",
        path: "/changelog/1.8.1/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-a77a1c72").then(t)
        }
    }, {
        path: "/changelog/1.8.1/index.html",
        redirect: "/changelog/1.8.1/"
    }, {
        path: "/99.更新日志/80.【v1-8-1】2023-09-04.html",
        redirect: "/changelog/1.8.1/"
    }, {
        name: "v-4994ee47",
        path: "/changelog/1.7.1/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-4994ee47").then(t)
        }
    }, {
        path: "/changelog/1.7.1/index.html",
        redirect: "/changelog/1.7.1/"
    }, {
        path: "/99.更新日志/84.【v1-7-1】2023-03-05.html",
        redirect: "/changelog/1.7.1/"
    }, {
        name: "v-41bc0e67",
        path: "/changelog/1.8.0/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-41bc0e67").then(t)
        }
    }, {
        path: "/changelog/1.8.0/index.html",
        redirect: "/changelog/1.8.0/"
    }, {
        path: "/99.更新日志/81.【v1-8-0】2023-07-27.html",
        redirect: "/changelog/1.8.0/"
    }, {
        name: "v-171fe3f2",
        path: "/changelog/1.7.0/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-171fe3f2").then(t)
        }
    }, {
        path: "/changelog/1.7.0/index.html",
        redirect: "/changelog/1.7.0/"
    }, {
        path: "/99.更新日志/85.【v1-7-0】2023-01-30.html",
        redirect: "/changelog/1.7.0/"
    }, {
        name: "v-816439f2",
        path: "/changelog/1.7.2/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-816439f2").then(t)
        }
    }, {
        path: "/changelog/1.7.2/index.html",
        redirect: "/changelog/1.7.2/"
    }, {
        path: "/99.更新日志/83.【v1-7-2】2023-04-19.html",
        redirect: "/changelog/1.7.2/"
    }, {
        name: "v-99637f32",
        path: "/changelog/1.6.5/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-99637f32").then(t)
        }
    }, {
        path: "/changelog/1.6.5/index.html",
        redirect: "/changelog/1.6.5/"
    }, {
        path: "/99.更新日志/87.【v1-6-5】2022-12-01.html",
        redirect: "/changelog/1.6.5/"
    }, {
        name: "v-0f85e067",
        path: "/changelog/1.6.4/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-0f85e067").then(t)
        }
    }, {
        path: "/changelog/1.6.4/index.html",
        redirect: "/changelog/1.6.4/"
    }, {
        path: "/99.更新日志/88.【v1-6-4】2022-08-22.html",
        redirect: "/changelog/1.6.4/"
    }, {
        name: "v-10452a93",
        path: "/changelog/1.6.6/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-10452a93").then(t)
        }
    }, {
        path: "/changelog/1.6.6/index.html",
        redirect: "/changelog/1.6.6/"
    }, {
        path: "/99.更新日志/86.【v-1-6-6】2023-01-05.html",
        redirect: "/changelog/1.6.6/"
    }, {
        name: "v-03a14a67",
        path: "/changelog/1.6.3/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-03a14a67").then(t)
        }
    }, {
        path: "/changelog/1.6.3/index.html",
        redirect: "/changelog/1.6.3/"
    }, {
        path: "/99.更新日志/89.【v1-6-3】2022-07-29.html",
        redirect: "/changelog/1.6.3/"
    }, {
        name: "v-31567b87",
        path: "/changelog/1.6.1/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-31567b87").then(t)
        }
    }, {
        path: "/changelog/1.6.1/index.html",
        redirect: "/changelog/1.6.1/"
    }, {
        path: "/99.更新日志/91.【v1-6-1】2022-03-21.html",
        redirect: "/changelog/1.6.1/"
    }, {
        name: "v-79b60e27",
        path: "/changelog/1.6.2/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-79b60e27").then(t)
        }
    }, {
        path: "/changelog/1.6.2/index.html",
        redirect: "/changelog/1.6.2/"
    }, {
        path: "/99.更新日志/90.【v1-6-2】2022-06-05.html",
        redirect: "/changelog/1.6.2/"
    }, {
        name: "v-790095a7",
        path: "/changelog/1.5.1/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-790095a7").then(t)
        }
    }, {
        path: "/changelog/1.5.1/index.html",
        redirect: "/changelog/1.5.1/"
    }, {
        path: "/99.更新日志/93.【v1-5-1】2022-02-28.html",
        redirect: "/changelog/1.5.1/"
    }, {
        name: "v-4ef2e2f2",
        path: "/changelog/1.6.0/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-4ef2e2f2").then(t)
        }
    }, {
        path: "/changelog/1.6.0/index.html",
        redirect: "/changelog/1.6.0/"
    }, {
        path: "/99.更新日志/92.【v1-6-0】2022-03-10.html",
        redirect: "/changelog/1.6.0/"
    }, {
        name: "v-2030a8a7",
        path: "/changelog/1.5.0/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-2030a8a7").then(t)
        }
    }, {
        path: "/changelog/1.5.0/index.html",
        redirect: "/changelog/1.5.0/"
    }, {
        path: "/99.更新日志/94.【v1-5-0】2022-02-17.html",
        redirect: "/changelog/1.5.0/"
    }, {
        name: "v-406aafe7",
        path: "/changelog/1.4.0/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-406aafe7").then(t)
        }
    }, {
        path: "/changelog/1.4.0/index.html",
        redirect: "/changelog/1.4.0/"
    }, {
        path: "/99.更新日志/95.【v1-4-0】2022-02-04.html",
        redirect: "/changelog/1.4.0/"
    }, {
        name: "v-2c62e6c7",
        path: "/changelog/1.1.0/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-2c62e6c7").then(t)
        }
    }, {
        path: "/changelog/1.1.0/index.html",
        redirect: "/changelog/1.1.0/"
    }, {
        path: "/99.更新日志/98.【v1-1-0】2021-10-25.html",
        redirect: "/changelog/1.1.0/"
    }, {
        name: "v-255d11e7",
        path: "/changelog/1.2.0/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-255d11e7").then(t)
        }
    }, {
        path: "/changelog/1.2.0/index.html",
        redirect: "/changelog/1.2.0/"
    }, {
        path: "/99.更新日志/97.【v1-2-0】2021-12-15.html",
        redirect: "/changelog/1.2.0/"
    }, {
        name: "v-aa31bdf2",
        path: "/changelog/1.3.0/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-aa31bdf2").then(t)
        }
    }, {
        path: "/changelog/1.3.0/index.html",
        redirect: "/changelog/1.3.0/"
    }, {
        path: "/99.更新日志/96.【v1-3-0】2022-01-24.html",
        redirect: "/changelog/1.3.0/"
    }, {
        name: "v-682dfe87",
        path: "/changelog/1.0.0/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-682dfe87").then(t)
        }
    }, {
        path: "/changelog/1.0.0/index.html",
        redirect: "/changelog/1.0.0/"
    }, {
        path: "/99.更新日志/99.【v1-0-0】2021-05-03.html",
        redirect: "/changelog/1.0.0/"
    }, {
        name: "v-81a0e9b8",
        path: "/hello/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-81a0e9b8").then(t)
        }
    }, {
        path: "/hello/index.html",
        redirect: "/hello/"
    }, {
        path: "/@pages/01.hello.html",
        redirect: "/hello/"
    }, {
        name: "v-8f722e46",
        path: "/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-8f722e46").then(t)
        }
    }, {
        path: "/index.html",
        redirect: "/"
    }, {
        name: "v-0d120b84",
        path: "/archives/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-0d120b84").then(t)
        }
    }, {
        path: "/archives/index.html",
        redirect: "/archives/"
    }, {
        path: "/@pages/archivesPage.html",
        redirect: "/archives/"
    }, {
        name: "v-126d25a2",
        path: "/user-project/",
        component: fs,
        beforeEnter: (n, e, t) => {
            ul("Layout", "v-126d25a2").then(t)
        }
    }, {
        path: "/user-project/index.html",
        redirect: "/user-project/"
    }, {
        path: "/@pages/02.项目案例.html",
        redirect: "/user-project/"
    }, {
        path: "*",
        component: fs
    }]
      , ys = {
        title: "ruoyi-vue-pro 开发指南",
        description: "RuoYi-Vue 全新 Pro 版本，优化重构所有功能。基于 Spring Boot + MyBatis Plus + Vue & Element 实现的后台管理系统 + 微信小程序，支持 RBAC 动态权限、数据权限、SaaS 多租户、Activiti + Flowable 工作流、三方登录、支付、短信、商城等功能。",
        base: "/",
        headTags: [["link", {
            rel: "icon",
            href: "/img/favicon.ico"
        }], ["meta", {
            name: "keywords",
            content: "ruoyi-vue,权限,数据权限,SaaS,多租户,Activiti,Flowable,工作流,商城"
        }], ["meta", {
            name: "theme-color",
            content: "#11a8cd"
        }], ["script", {
            src: "https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/js-cookie/3.0.1/js.cookie.js"
        }], ["script", {
            src: "https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/jquery/3.6.0/jquery.min.js"
        }], ["script", {
            src: "https://static.iocoder.cn/answer.js"
        }], ["link", {
            rel: "stylesheet",
            href: "https://static.iocoder.cn/answer.css"
        }]],
        pages: [{
            title: "简介",
            frontmatter: {
                title: "简介",
                permalink: "/intro",
                date: "2022-03-01T23:02:53.000Z"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/01.%E8%90%8C%E6%96%B0%E5%BF%85%E8%AF%BB/01.%E7%AE%80%E4%BB%8B.html",
            relativePath: "01.开发指南/01.萌新必读/01.简介.md",
            key: "v-02b738c7",
            path: "/intro/",
            headers: [{
                level: 2,
                title: "🐴 严肃声明",
                slug: "🐴-严肃声明",
                normalizedTitle: "🐴 严肃声明",
                charIndex: 342
            }, {
                level: 2,
                title: "🐳 项目关系",
                slug: "🐳-项目关系",
                normalizedTitle: "🐳 项目关系",
                charIndex: 491
            }, {
                level: 3,
                title: "后端项目",
                slug: "后端项目",
                normalizedTitle: "后端项目",
                charIndex: 539
            }, {
                level: 3,
                title: "前端项目",
                slug: "前端项目",
                normalizedTitle: "前端项目",
                charIndex: 727
            }, {
                level: 2,
                title: "🐶 在线体验",
                slug: "🐶-在线体验",
                normalizedTitle: "🐶 在线体验",
                charIndex: 1132
            }, {
                level: 2,
                title: "📚 国内顶级开源项目对比",
                slug: "📚-国内顶级开源项目对比",
                normalizedTitle: "📚 国内顶级开源项目对比",
                charIndex: 1430
            }],
            headersStr: "🐴 严肃声明 🐳 项目关系 后端项目 前端项目 🐶 在线体验 📚 国内顶级开源项目对比",
            content: "yudao-vue-pro，RuoYi-Vue 全新 Pro 版本，优化重构所有功能。\n\n基于 Spring Boot + MyBatis Plus + Vue & Element 实现的后台管理系统 + UniApp 微信小程序，支持 RBAC 动态权限、数据权限、SaaS 多租户、Flowable 工作流、三方登录、支付、短信、商城等功能。\n\n\n\n😆 为开源继绝学，我辈义不容辞！\n\n2017 年，艿艿创建「芋道源码」公众号，帮助了 20w+ 工程师学习优秀框架的源码。\n\n2019 年，看了 Gitee 和 Github 非常多的业务开源项目，无法到达代码整洁、架构整洁。\n\n于是，艿艿利用休息时间，每天肝到晚上 1 点多，如此便有了芋道管理后台 + 微信小程序。\n\n\n# 🐴 严肃声明\n\n现在、未来都不会有商业版本，所有代码全部开源！\n\n「我喜欢写代码，乐此不疲」\n「我喜欢做开源，以此为乐」\n\n我 🐶 在上海艰苦奋斗，早中晚在 top3 大厂认真搬砖，夜里为开源做贡献。\n\n如果这个项目让你有所收获，记得 Star 关注哦，这对我是非常不错的鼓励与支持。\n\n\n# 🐳 项目关系\n\n\n\n三个项目的功能对比，可见社区共同整理的 国产开源项目对比 表格。\n\n\n# 后端项目\n\n项目                 STAR   简介\nruoyi-vue-pro             基于 Spring Boot 多模块架构\nyudao-cloud               基于 Spring Cloud 微服务架构\nSpring-Boot-Labs          系统学习 Spring Boot & Cloud 专栏\n\n\n# 前端项目\n\n项目                      STAR   简介\nyudao-ui-admin-vue3            基于 Vue3 + element-plus 实现的管理后台\nyudao-ui-admin-vben            基于 Vue3 + vben(ant-design-vue) 实现的管理后台\nyudao-mall-uniapp              基于 uni-app 实现的商城小程序\nyudao-ui-admin-vue2            基于 Vue2 + element-ui 实现的管理后台\nyudao-ui-admin-uniapp          基于 Vue2 + element-ui 实现的管理后台\nyudao-ui-go-view               基于 Vue3 + naive-ui 实现的大屏报表\n\n\n# 🐶 在线体验\n\n * 演示地址【Vue3 + element-plus】：http://dashboard-vue3.yudao.iocoder.cn\n * 演示地址【Vue3 + vben(ant-design-vue)】：http://dashboard-vben.yudao.iocoder.cn\n * 演示地址【Vue2 + element-ui】：http://dashboard.yudao.iocoder.cn\n\n如果你要搭建本地环境，可参考如下文档：\n\n * 《开发指南 —— 快速启动（适合“后端”工程师）》\n * 《开发指南 —— 快速启动（适合“前端”工程师）》\n\n\n# 📚 国内顶级开源项目对比\n\n社区整理，欢迎补充！传送门",
            normalizedContent: "yudao-vue-pro，ruoyi-vue 全新 pro 版本，优化重构所有功能。\n\n基于 spring boot + mybatis plus + vue & element 实现的后台管理系统 + uniapp 微信小程序，支持 rbac 动态权限、数据权限、saas 多租户、flowable 工作流、三方登录、支付、短信、商城等功能。\n\n\n\n😆 为开源继绝学，我辈义不容辞！\n\n2017 年，艿艿创建「芋道源码」公众号，帮助了 20w+ 工程师学习优秀框架的源码。\n\n2019 年，看了 gitee 和 github 非常多的业务开源项目，无法到达代码整洁、架构整洁。\n\n于是，艿艿利用休息时间，每天肝到晚上 1 点多，如此便有了芋道管理后台 + 微信小程序。\n\n\n# 🐴 严肃声明\n\n现在、未来都不会有商业版本，所有代码全部开源！\n\n「我喜欢写代码，乐此不疲」\n「我喜欢做开源，以此为乐」\n\n我 🐶 在上海艰苦奋斗，早中晚在 top3 大厂认真搬砖，夜里为开源做贡献。\n\n如果这个项目让你有所收获，记得 star 关注哦，这对我是非常不错的鼓励与支持。\n\n\n# 🐳 项目关系\n\n\n\n三个项目的功能对比，可见社区共同整理的 国产开源项目对比 表格。\n\n\n# 后端项目\n\n项目                 star   简介\nruoyi-vue-pro             基于 spring boot 多模块架构\nyudao-cloud               基于 spring cloud 微服务架构\nspring-boot-labs          系统学习 spring boot & cloud 专栏\n\n\n# 前端项目\n\n项目                      star   简介\nyudao-ui-admin-vue3            基于 vue3 + element-plus 实现的管理后台\nyudao-ui-admin-vben            基于 vue3 + vben(ant-design-vue) 实现的管理后台\nyudao-mall-uniapp              基于 uni-app 实现的商城小程序\nyudao-ui-admin-vue2            基于 vue2 + element-ui 实现的管理后台\nyudao-ui-admin-uniapp          基于 vue2 + element-ui 实现的管理后台\nyudao-ui-go-view               基于 vue3 + naive-ui 实现的大屏报表\n\n\n# 🐶 在线体验\n\n * 演示地址【vue3 + element-plus】：http://dashboard-vue3.yudao.iocoder.cn\n * 演示地址【vue3 + vben(ant-design-vue)】：http://dashboard-vben.yudao.iocoder.cn\n * 演示地址【vue2 + element-ui】：http://dashboard.yudao.iocoder.cn\n\n如果你要搭建本地环境，可参考如下文档：\n\n * 《开发指南 —— 快速启动（适合“后端”工程师）》\n * 《开发指南 —— 快速启动（适合“前端”工程师）》\n\n\n# 📚 国内顶级开源项目对比\n\n社区整理，欢迎补充！传送门",
            charsets: {
                cjk: !0
            }
        }, {
            title: "交流群",
            frontmatter: {
                title: "交流群",
                date: "2022-03-11T19:57:14.000Z",
                permalink: "/qun"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/01.%E8%90%8C%E6%96%B0%E5%BF%85%E8%AF%BB/02.%E4%BA%A4%E6%B5%81%E7%BE%A4.html",
            relativePath: "01.开发指南/01.萌新必读/02.交流群.md",
            key: "v-429ee8f1",
            path: "/qun/",
            headers: [{
                level: 2,
                title: "🐱 反馈交流",
                slug: "🐱-反馈交流",
                normalizedTitle: "🐱 反馈交流",
                charIndex: 2
            }, {
                level: 2,
                title: "🔥 VIP 群（推荐）",
                slug: "🔥-vip-群-推荐",
                normalizedTitle: "🔥 vip 群（推荐）",
                charIndex: 151
            }],
            headersStr: "🐱 反馈交流 🔥 VIP 群（推荐）",
            content: "# 🐱 反馈交流\n\n如果有问题，可以通过 Gitee Issue 或者 Github Issue 进行反馈。\n\n欢迎加入用户交流群，一起苦练技术基本功，每日精进 30 公里。\n\n\n\n如果微信提示“提示对方被加好友过于频繁，请稍后再试？”，可以过一会再尝试下！🙂 项目关注和使用的人太多了~\n\n\n# 🔥 VIP 群（推荐）\n\n微信加好友有限制，建议加入扫码加入知识星球，更好的获得开发团队的答疑，如下图所示：\n\n\n\n * 商城 VIP 交流群\n * 微服务 VIP 交流群\n * 工作流 VIP 交流群\n * 支付 VIP 交流群\n * ERP VIP 交流群\n * CRM VIP 交流群\n * 公众号 VIP 交流群\n\n上面的 VIP 群，都可以加入哈~\n\n= = 早点加，不然都要开 1 群满了，就要开 2 群了！",
            normalizedContent: "# 🐱 反馈交流\n\n如果有问题，可以通过 gitee issue 或者 github issue 进行反馈。\n\n欢迎加入用户交流群，一起苦练技术基本功，每日精进 30 公里。\n\n\n\n如果微信提示“提示对方被加好友过于频繁，请稍后再试？”，可以过一会再尝试下！🙂 项目关注和使用的人太多了~\n\n\n# 🔥 vip 群（推荐）\n\n微信加好友有限制，建议加入扫码加入知识星球，更好的获得开发团队的答疑，如下图所示：\n\n\n\n * 商城 vip 交流群\n * 微服务 vip 交流群\n * 工作流 vip 交流群\n * 支付 vip 交流群\n * erp vip 交流群\n * crm vip 交流群\n * 公众号 vip 交流群\n\n上面的 vip 群，都可以加入哈~\n\n= = 早点加，不然都要开 1 群满了，就要开 2 群了！",
            charsets: {
                cjk: !0
            }
        }, {
            title: "功能列表",
            frontmatter: {
                title: "功能列表",
                permalink: "/feature",
                date: "2022-03-01T22:23:09.000Z"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/01.%E8%90%8C%E6%96%B0%E5%BF%85%E8%AF%BB/04.%E5%8A%9F%E8%83%BD%E5%88%97%E8%A1%A8.html",
            relativePath: "01.开发指南/01.萌新必读/04.功能列表.md",
            key: "v-2b88bf2c",
            path: "/feature/",
            headers: [{
                level: 2,
                title: "👍 相关视频教程",
                slug: "👍-相关视频教程",
                normalizedTitle: "👍 相关视频教程",
                charIndex: 901
            }, {
                level: 2,
                title: "🐼 内置功能",
                slug: "🐼-内置功能",
                normalizedTitle: "🐼 内置功能",
                charIndex: 1007
            }, {
                level: 3,
                title: "系统功能",
                slug: "系统功能",
                normalizedTitle: "系统功能",
                charIndex: 1058
            }, {
                level: 3,
                title: "基础设施",
                slug: "基础设施",
                normalizedTitle: "基础设施",
                charIndex: 1063
            }, {
                level: 3,
                title: "工作流程",
                slug: "工作流程",
                normalizedTitle: "工作流程",
                charIndex: 1080
            }, {
                level: 3,
                title: "支付系统",
                slug: "支付系统",
                normalizedTitle: "支付系统",
                charIndex: 1085
            }, {
                level: 3,
                title: "数据报表",
                slug: "数据报表",
                normalizedTitle: "数据报表",
                charIndex: 1090
            }, {
                level: 3,
                title: "微信公众号",
                slug: "微信公众号",
                normalizedTitle: "微信公众号",
                charIndex: 784
            }, {
                level: 3,
                title: "商城系统",
                slug: "商城系统",
                normalizedTitle: "商城系统",
                charIndex: 1126
            }, {
                level: 3,
                title: "会员中心",
                slug: "会员中心",
                normalizedTitle: "会员中心",
                charIndex: 1095
            }, {
                level: 3,
                title: "ERP 系统",
                slug: "erp-系统",
                normalizedTitle: "erp 系统",
                charIndex: 1112
            }, {
                level: 3,
                title: "CRM 系统",
                slug: "crm-系统",
                normalizedTitle: "crm 系统",
                charIndex: 1119
            }, {
                level: 3,
                title: "AI 大模型",
                slug: "ai-大模型",
                normalizedTitle: "ai 大模型",
                charIndex: 1137
            }, {
                level: 2,
                title: "🐷 演示图",
                slug: "🐷-演示图",
                normalizedTitle: "🐷 演示图",
                charIndex: 4453
            }],
            headersStr: "👍 相关视频教程 🐼 内置功能 系统功能 基础设施 工作流程 支付系统 数据报表 微信公众号 商城系统 会员中心 ERP 系统 CRM 系统 AI 大模型 🐷 演示图",
            content: "芋道，以开发者为中心，打造中国第一流的快速开发平台，全部开源，个人与企业可 100% 免费使用。\n\n\n\n * Java 后端：master 分支为 JDK 8 + Spring Boot 2.7，master-jdk17 分支为 JDK 17/21 + Spring Boot 3.2\n * 管理后台的电脑端：Vue3 提供 element-plus、vben(ant-design-vue) 两个版本，Vue2 提供 element-ui 版本\n * 管理后台的移动端：采用 uni-app 方案，一份代码多终端适配，同时支持 APP、小程序、H5！\n * 后端采用 Spring Boot、MySQL + MyBatis Plus、Redis + Redisson\n * 数据库可使用 MySQL、Oracle、PostgreSQL、SQL Server、MariaDB、国产达梦 DM、TiDB 等\n * 消息队列可使用 Event、Redis、RabbitMQ、Kafka、RocketMQ 等\n * 权限认证使用 Spring Security & Token & Redis，支持多终端、多种用户的认证系统，支持 SSO 单点登录\n * 支持加载动态权限菜单，按钮级别权限控制，Redis 缓存提升性能\n * 支持 SaaS 多租户系统，可自定义每个租户的权限，提供透明化的多租户底层封装\n * 工作流使用 Flowable，支持动态表单、在线设计流程、会签 / 或签、多种任务分配方式\n * 高效率开发，使用代码生成器可以一键生成 Java、Vue 前后端代码、SQL 脚本、接口文档，支持单表、树表、主子表\n * 实时通信，采用 Spring WebSocket 实现，内置 Token 身份校验，支持 WebSocket 集群\n * 集成微信小程序、微信公众号、企业微信、钉钉等三方登陆，集成支付宝、微信等支付与退款\n * 集成阿里云、腾讯云等短信渠道，集成 MinIO、阿里云、腾讯云、七牛云等云存储服务\n * 集成报表设计器、大屏设计器，通过拖拽即可生成酷炫的报表与大屏\n\n\n# 👍 相关视频教程\n\n * 从零开始 01：视频课程导读：项目简介、功能列表、技术选型\n * 从零开始 04：自顶向下，讲解项目的整体结构（上）\n * 从零开始 04：自顶向下，讲解项目的整体结构（下）\n\n\n# 🐼 内置功能\n\n系统内置多种多种业务功能，可以用于快速你的业务系统：\n\n\n\n * 通用模块（必选）：系统功能、基础设施\n * 通用模块（可选）：工作流程、支付系统、数据报表、会员中心\n * 业务系统（按需）：ERP 系统、CRM 系统、商城系统、微信公众号、AI 大模型\n\n> 友情提示：本项目基于 RuoYi-Vue 修改，重构优化后端的代码，美化前端的界面。\n> \n>  * 额外新增的功能，我们使用 🚀 标记。\n>  * 重新实现的功能，我们使用 ⭐️ 标记。\n\n🙂 所有功能，都通过 单元测试 保证高质量。\n\n\n# 系统功能\n\n     功能      描述\n     用户管理    用户是系统操作者，该功能主要完成系统用户配置\n⭐️   在线用户    当前系统中活跃用户状态监控，支持手动踢下线\n     角色管理    角色菜单权限分配、设置角色按机构进行数据范围权限划分\n     菜单管理    配置系统菜单、操作权限、按钮权限标识等，本地缓存提供性能\n     部门管理    配置系统组织机构（公司、部门、小组），树结构展现支持数据权限\n     岗位管理    配置系统用户所属担任职务\n🚀   租户管理    配置系统租户，支持 SaaS 场景下的多租户功能\n🚀   租户套餐    配置租户套餐，自定每个租户的菜单、操作、按钮的权限\n     字典管理    对系统中经常使用的一些较为固定的数据进行维护\n🚀   短信管理    短信渠道、短息模板、短信日志，对接阿里云等主流短信平台\n🚀   邮件管理    邮箱账号、邮件模版、邮件发送日志，支持所有邮件平台\n🚀   站内信     系统内的消息通知，支持站内信模版、站内信消息\n🚀   操作日志    系统正常操作日志记录和查询，集成 Swagger 生成日志内容\n⭐️   登录日志    系统登录日志记录查询，包含登录异常\n🚀   错误码管理   系统所有错误码的管理，可在线修改错误提示，无需重启服务\n     通知公告    系统通知公告信息发布维护\n🚀   敏感词     配置系统敏感词，支持标签分组\n🚀   应用管理    管理 SSO 单点登录的应用，支持多种 OAuth2 授权方式\n🚀   地区管理    展示省份、城市、区镇等城市信息，支持 IP 对应城市\n\n\n\n\n# 基础设施\n\n     功能          描述\n🚀   代码生成        前后端代码的生成（Java、Vue、SQL、单元测试），支持 CRUD 下载\n🚀   系统接口        基于 Swagger 自动生成相关的 RESTful API 接口文档\n🚀   数据库文档       基于 Screw 自动生成数据库文档，支持导出 Word、HTML、MD 格式\n     表单构建        拖动表单元素生成相应的 HTML 代码，支持导出 JSON、Vue 文件\n🚀   配置管理        对系统动态配置常用参数，支持 SpringBoot 加载\n🚀   文件服务        支持将文件存储到 S3（MinIO、阿里云、腾讯云、七牛云）、本地、FTP、数据库等\n🚀   WebSocket   提供 WebSocket 接入示例，支持一对一、一对多发送方式\n🚀   API 日志      包括 RESTful API 访问日志、异常日志两部分，方便排查 API 相关的问题\n     MySQL 监控    监视当前系统数据库连接池状态，可进行分析SQL找出系统性能瓶颈\n     Redis 监控    监控 Redis 数据库的使用情况，使用的 Redis Key 管理\n🚀   消息队列        基于 Redis 实现消息队列，Stream 提供集群消费，Pub/Sub 提供广播消费\n🚀   Java 监控     基于 Spring Boot Admin 实现 Java 应用的监控\n🚀   链路追踪        接入 SkyWalking 组件，实现链路追踪\n🚀   日志中心        接入 SkyWalking 组件，实现日志中心\n🚀   服务保障        基于 Redis 实现分布式锁、幂等、限流功能，满足高并发场景\n🚀   日志服务        轻量级日志中心，查看远程服务器的日志\n🚀   单元测试        基于 JUnit + Mockito 实现单元测试，保证功能的正确性、代码的质量等\n\n\n\n\n# 工作流程\n\n     功能      描述\n🚀   流程模型    配置工作流的流程模型，支持 BPMN 和仿钉钉/飞书设计器\n🚀   流程表单    拖动表单元素生成相应的工作流表单，覆盖 Element UI 所有的表单组件\n🚀   用户分组    自定义用户分组，可用于工作流的审批分组\n🚀   我的流程    查看我发起的工作流程，支持新建、取消流程等操作，高亮流程图、审批时间线\n🚀   待办任务    查看自己【未】审批的工作任务，支持通过、不通过、转派、委派、退回、加减签等操作\n🚀   已办任务    查看自己【已】审批的工作任务，支持流程预测，展示未来审批人信息\n🚀   OA 请假   作为业务自定义接入工作流的使用示例，只需创建请求对应的工作流程，即可进行审批\n\n\n\nBPMN 设计器   钉钉/飞书设计器\n           \n\n\n# 支付系统\n\n     功能     描述\n🚀   应用信息   配置商户的应用信息，对接支付宝、微信等多个支付渠道\n🚀   支付订单   查看用户发起的支付宝、微信等的【支付】订单\n🚀   退款订单   查看用户发起的支付宝、微信等的【退款】订单\n🚀   回调通知   查看支付回调业务的【支付】【退款】的通知结果\n🚀   接入示例   提供接入支付系统的【支付】【退款】的功能实战\n\n\n# 数据报表\n\n     功能      描述\n🚀   报表设计器   支持数据报表、图形报表、打印设计等\n🚀   大屏设计器   拖拽生成数据大屏，内置几十种图表组件\n\n\n# 微信公众号\n\n     功能       描述\n🚀   账号管理     配置接入的微信公众号，可支持多个公众号\n🚀   数据统计     统计公众号的用户增减、累计用户、消息概况、接口分析等数据\n🚀   粉丝管理     查看已关注、取关的粉丝列表，可对粉丝进行同步、打标签等操作\n🚀   消息管理     查看粉丝发送的消息列表，可主动回复粉丝消息\n🚀   自动回复     自动回复粉丝发送的消息，支持关注回复、消息回复、关键字回复\n🚀   标签管理     对公众号的标签进行创建、查询、修改、删除等操作\n🚀   菜单管理     自定义公众号的菜单，也可以从公众号同步菜单\n🚀   素材管理     管理公众号的图片、语音、视频等素材，支持在线播放语音、视频\n🚀   图文草稿箱    新增常用的图文素材到草稿箱，可发布到公众号\n🚀   图文发表记录   查看已发布成功的图文素材，支持删除操作\n\n\n# 商城系统\n\n演示地址：https://doc.iocoder.cn/mall-preview/\n\n\n\n\n\n\n# 会员中心\n\n     功能     描述\n🚀   会员管理   会员是 C 端的消费者，该功能用于会员的搜索与管理\n🚀   会员标签   对会员的标签进行创建、查询、修改、删除等操作\n🚀   会员等级   对会员的等级、成长值进行管理，可用于订单折扣等会员权益\n🚀   会员分组   对会员进行分组，用于用户画像、内容推送等运营手段\n🚀   积分签到   回馈给签到、消费等行为的积分，会员可订单抵现、积分兑换等途径消耗\n\n\n# ERP 系统\n\n演示地址：https://doc.iocoder.cn/erp-preview/\n\n\n\n\n# CRM 系统\n\n演示地址：https://doc.iocoder.cn/crm-preview/\n\n\n\n\n# AI 大模型\n\n演示地址：https://doc.iocoder.cn/ai-preview/\n\n\n\n\n\n\n# 🐷 演示图\n\n * 演示地址【Vue3 + element-plus】：http://dashboard-vue3.yudao.iocoder.cn\n * 演示地址【Vue3 + vben(ant-design-vue)】：http://dashboard-vben.yudao.iocoder.cn\n * 演示地址【Vue2 + element-ui】：http://dashboard.yudao.iocoder.cn\n\n具体截图，点击 链接 查看。",
            normalizedContent: "芋道，以开发者为中心，打造中国第一流的快速开发平台，全部开源，个人与企业可 100% 免费使用。\n\n\n\n * java 后端：master 分支为 jdk 8 + spring boot 2.7，master-jdk17 分支为 jdk 17/21 + spring boot 3.2\n * 管理后台的电脑端：vue3 提供 element-plus、vben(ant-design-vue) 两个版本，vue2 提供 element-ui 版本\n * 管理后台的移动端：采用 uni-app 方案，一份代码多终端适配，同时支持 app、小程序、h5！\n * 后端采用 spring boot、mysql + mybatis plus、redis + redisson\n * 数据库可使用 mysql、oracle、postgresql、sql server、mariadb、国产达梦 dm、tidb 等\n * 消息队列可使用 event、redis、rabbitmq、kafka、rocketmq 等\n * 权限认证使用 spring security & token & redis，支持多终端、多种用户的认证系统，支持 sso 单点登录\n * 支持加载动态权限菜单，按钮级别权限控制，redis 缓存提升性能\n * 支持 saas 多租户系统，可自定义每个租户的权限，提供透明化的多租户底层封装\n * 工作流使用 flowable，支持动态表单、在线设计流程、会签 / 或签、多种任务分配方式\n * 高效率开发，使用代码生成器可以一键生成 java、vue 前后端代码、sql 脚本、接口文档，支持单表、树表、主子表\n * 实时通信，采用 spring websocket 实现，内置 token 身份校验，支持 websocket 集群\n * 集成微信小程序、微信公众号、企业微信、钉钉等三方登陆，集成支付宝、微信等支付与退款\n * 集成阿里云、腾讯云等短信渠道，集成 minio、阿里云、腾讯云、七牛云等云存储服务\n * 集成报表设计器、大屏设计器，通过拖拽即可生成酷炫的报表与大屏\n\n\n# 👍 相关视频教程\n\n * 从零开始 01：视频课程导读：项目简介、功能列表、技术选型\n * 从零开始 04：自顶向下，讲解项目的整体结构（上）\n * 从零开始 04：自顶向下，讲解项目的整体结构（下）\n\n\n# 🐼 内置功能\n\n系统内置多种多种业务功能，可以用于快速你的业务系统：\n\n\n\n * 通用模块（必选）：系统功能、基础设施\n * 通用模块（可选）：工作流程、支付系统、数据报表、会员中心\n * 业务系统（按需）：erp 系统、crm 系统、商城系统、微信公众号、ai 大模型\n\n> 友情提示：本项目基于 ruoyi-vue 修改，重构优化后端的代码，美化前端的界面。\n> \n>  * 额外新增的功能，我们使用 🚀 标记。\n>  * 重新实现的功能，我们使用 ⭐️ 标记。\n\n🙂 所有功能，都通过 单元测试 保证高质量。\n\n\n# 系统功能\n\n     功能      描述\n     用户管理    用户是系统操作者，该功能主要完成系统用户配置\n⭐️   在线用户    当前系统中活跃用户状态监控，支持手动踢下线\n     角色管理    角色菜单权限分配、设置角色按机构进行数据范围权限划分\n     菜单管理    配置系统菜单、操作权限、按钮权限标识等，本地缓存提供性能\n     部门管理    配置系统组织机构（公司、部门、小组），树结构展现支持数据权限\n     岗位管理    配置系统用户所属担任职务\n🚀   租户管理    配置系统租户，支持 saas 场景下的多租户功能\n🚀   租户套餐    配置租户套餐，自定每个租户的菜单、操作、按钮的权限\n     字典管理    对系统中经常使用的一些较为固定的数据进行维护\n🚀   短信管理    短信渠道、短息模板、短信日志，对接阿里云等主流短信平台\n🚀   邮件管理    邮箱账号、邮件模版、邮件发送日志，支持所有邮件平台\n🚀   站内信     系统内的消息通知，支持站内信模版、站内信消息\n🚀   操作日志    系统正常操作日志记录和查询，集成 swagger 生成日志内容\n⭐️   登录日志    系统登录日志记录查询，包含登录异常\n🚀   错误码管理   系统所有错误码的管理，可在线修改错误提示，无需重启服务\n     通知公告    系统通知公告信息发布维护\n🚀   敏感词     配置系统敏感词，支持标签分组\n🚀   应用管理    管理 sso 单点登录的应用，支持多种 oauth2 授权方式\n🚀   地区管理    展示省份、城市、区镇等城市信息，支持 ip 对应城市\n\n\n\n\n# 基础设施\n\n     功能          描述\n🚀   代码生成        前后端代码的生成（java、vue、sql、单元测试），支持 crud 下载\n🚀   系统接口        基于 swagger 自动生成相关的 restful api 接口文档\n🚀   数据库文档       基于 screw 自动生成数据库文档，支持导出 word、html、md 格式\n     表单构建        拖动表单元素生成相应的 html 代码，支持导出 json、vue 文件\n🚀   配置管理        对系统动态配置常用参数，支持 springboot 加载\n🚀   文件服务        支持将文件存储到 s3（minio、阿里云、腾讯云、七牛云）、本地、ftp、数据库等\n🚀   websocket   提供 websocket 接入示例，支持一对一、一对多发送方式\n🚀   api 日志      包括 restful api 访问日志、异常日志两部分，方便排查 api 相关的问题\n     mysql 监控    监视当前系统数据库连接池状态，可进行分析sql找出系统性能瓶颈\n     redis 监控    监控 redis 数据库的使用情况，使用的 redis key 管理\n🚀   消息队列        基于 redis 实现消息队列，stream 提供集群消费，pub/sub 提供广播消费\n🚀   java 监控     基于 spring boot admin 实现 java 应用的监控\n🚀   链路追踪        接入 skywalking 组件，实现链路追踪\n🚀   日志中心        接入 skywalking 组件，实现日志中心\n🚀   服务保障        基于 redis 实现分布式锁、幂等、限流功能，满足高并发场景\n🚀   日志服务        轻量级日志中心，查看远程服务器的日志\n🚀   单元测试        基于 junit + mockito 实现单元测试，保证功能的正确性、代码的质量等\n\n\n\n\n# 工作流程\n\n     功能      描述\n🚀   流程模型    配置工作流的流程模型，支持 bpmn 和仿钉钉/飞书设计器\n🚀   流程表单    拖动表单元素生成相应的工作流表单，覆盖 element ui 所有的表单组件\n🚀   用户分组    自定义用户分组，可用于工作流的审批分组\n🚀   我的流程    查看我发起的工作流程，支持新建、取消流程等操作，高亮流程图、审批时间线\n🚀   待办任务    查看自己【未】审批的工作任务，支持通过、不通过、转派、委派、退回、加减签等操作\n🚀   已办任务    查看自己【已】审批的工作任务，支持流程预测，展示未来审批人信息\n🚀   oa 请假   作为业务自定义接入工作流的使用示例，只需创建请求对应的工作流程，即可进行审批\n\n\n\nbpmn 设计器   钉钉/飞书设计器\n           \n\n\n# 支付系统\n\n     功能     描述\n🚀   应用信息   配置商户的应用信息，对接支付宝、微信等多个支付渠道\n🚀   支付订单   查看用户发起的支付宝、微信等的【支付】订单\n🚀   退款订单   查看用户发起的支付宝、微信等的【退款】订单\n🚀   回调通知   查看支付回调业务的【支付】【退款】的通知结果\n🚀   接入示例   提供接入支付系统的【支付】【退款】的功能实战\n\n\n# 数据报表\n\n     功能      描述\n🚀   报表设计器   支持数据报表、图形报表、打印设计等\n🚀   大屏设计器   拖拽生成数据大屏，内置几十种图表组件\n\n\n# 微信公众号\n\n     功能       描述\n🚀   账号管理     配置接入的微信公众号，可支持多个公众号\n🚀   数据统计     统计公众号的用户增减、累计用户、消息概况、接口分析等数据\n🚀   粉丝管理     查看已关注、取关的粉丝列表，可对粉丝进行同步、打标签等操作\n🚀   消息管理     查看粉丝发送的消息列表，可主动回复粉丝消息\n🚀   自动回复     自动回复粉丝发送的消息，支持关注回复、消息回复、关键字回复\n🚀   标签管理     对公众号的标签进行创建、查询、修改、删除等操作\n🚀   菜单管理     自定义公众号的菜单，也可以从公众号同步菜单\n🚀   素材管理     管理公众号的图片、语音、视频等素材，支持在线播放语音、视频\n🚀   图文草稿箱    新增常用的图文素材到草稿箱，可发布到公众号\n🚀   图文发表记录   查看已发布成功的图文素材，支持删除操作\n\n\n# 商城系统\n\n演示地址：https://doc.iocoder.cn/mall-preview/\n\n\n\n\n\n\n# 会员中心\n\n     功能     描述\n🚀   会员管理   会员是 c 端的消费者，该功能用于会员的搜索与管理\n🚀   会员标签   对会员的标签进行创建、查询、修改、删除等操作\n🚀   会员等级   对会员的等级、成长值进行管理，可用于订单折扣等会员权益\n🚀   会员分组   对会员进行分组，用于用户画像、内容推送等运营手段\n🚀   积分签到   回馈给签到、消费等行为的积分，会员可订单抵现、积分兑换等途径消耗\n\n\n# erp 系统\n\n演示地址：https://doc.iocoder.cn/erp-preview/\n\n\n\n\n# crm 系统\n\n演示地址：https://doc.iocoder.cn/crm-preview/\n\n\n\n\n# ai 大模型\n\n演示地址：https://doc.iocoder.cn/ai-preview/\n\n\n\n\n\n\n# 🐷 演示图\n\n * 演示地址【vue3 + element-plus】：http://dashboard-vue3.yudao.iocoder.cn\n * 演示地址【vue3 + vben(ant-design-vue)】：http://dashboard-vben.yudao.iocoder.cn\n * 演示地址【vue2 + element-ui】：http://dashboard.yudao.iocoder.cn\n\n具体截图，点击 链接 查看。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "视频教程",
            frontmatter: {
                title: "视频教程",
                date: "2022-07-02T19:57:14.000Z",
                permalink: "/video"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/01.%E8%90%8C%E6%96%B0%E5%BF%85%E8%AF%BB/03.%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B.html",
            relativePath: "01.开发指南/01.萌新必读/03.视频教程.md",
            key: "v-2fd82d08",
            path: "/video/",
            headers: [{
                level: 2,
                title: "大纲",
                slug: "大纲",
                normalizedTitle: "大纲",
                charIndex: 2
            }, {
                level: 2,
                title: "技术架构图",
                slug: "技术架构图",
                normalizedTitle: "技术架构图",
                charIndex: 177
            }, {
                level: 2,
                title: "为什么学习该视频？",
                slug: "为什么学习该视频",
                normalizedTitle: "为什么学习该视频？",
                charIndex: 189
            }, {
                level: 2,
                title: "获取方式",
                slug: "获取方式",
                normalizedTitle: "获取方式",
                charIndex: 394
            }, {
                level: 2,
                title: "项目答疑",
                slug: "项目答疑",
                normalizedTitle: "项目答疑",
                charIndex: 424
            }, {
                level: 2,
                title: "从零开始",
                slug: "从零开始",
                normalizedTitle: "从零开始",
                charIndex: 665
            }, {
                level: 2,
                title: "用户认证",
                slug: "用户认证",
                normalizedTitle: "用户认证",
                charIndex: 893
            }, {
                level: 2,
                title: "功能权限",
                slug: "功能权限",
                normalizedTitle: "功能权限",
                charIndex: 1173
            }, {
                level: 2,
                title: "数据权限",
                slug: "数据权限",
                normalizedTitle: "数据权限",
                charIndex: 1357
            }, {
                level: 2,
                title: "OAuth2 模块",
                slug: "oauth2-模块",
                normalizedTitle: "oauth2 模块",
                charIndex: 1579
            }, {
                level: 2,
                title: "工作流",
                slug: "工作流",
                normalizedTitle: "工作流",
                charIndex: 1958
            }, {
                level: 2,
                title: "SaaS 多租户",
                slug: "saas-多租户",
                normalizedTitle: "saas 多租户",
                charIndex: 2443
            }, {
                level: 2,
                title: "Web 组件",
                slug: "web-组件",
                normalizedTitle: "web 组件",
                charIndex: 2657
            }, {
                level: 2,
                title: "更多学习内容",
                slug: "更多学习内容",
                normalizedTitle: "更多学习内容",
                charIndex: 2814
            }, {
                level: 3,
                title: "面试招聘",
                slug: "面试招聘",
                normalizedTitle: "面试招聘",
                charIndex: 2833
            }, {
                level: 3,
                title: "源码解析",
                slug: "源码解析",
                normalizedTitle: "源码解析",
                charIndex: 2838
            }, {
                level: 3,
                title: "学习路线",
                slug: "学习路线",
                normalizedTitle: "学习路线",
                charIndex: 2843
            }],
            headersStr: "大纲 技术架构图 为什么学习该视频？ 获取方式 项目答疑 从零开始 用户认证 功能权限 数据权限 OAuth2 模块 工作流 SaaS 多租户 Web 组件 更多学习内容 面试招聘 源码解析 学习路线",
            content: "# 大纲\n\n\n\n每个点都是大章节，包含 10-20 小节的视频。\n\n * 每个视频，控制在 10 分钟左右，问题驱动，全程无废话，保证高质量的学习。\n * 视频的内容，会带你理解整个系统的设计思想，每一个组件和模块的代码实现。\n\n知其然，知其所以然！让你走出只会 CRUD 的困局~\n\n支持手机、平板、电脑设备，随时随地在线观看，无需下载！\n\n\n\n\n# 技术架构图\n\n\n\n\n# 为什么学习该视频？\n\n学习的过程中，往往会碰到如下的问题：\n\n * 一个人瞎摸索，走弯路，效率低\n * 一脸懵逼，不知道如何学习\n * 遇到问题，无人解答，信心备受打击\n * 遇到一些难题，自己无法透彻理解\n * 知识面狭窄，不知道的太多\n\n而通过这套视频，可以实现 “系统全面，效率高” 的效果。\n\n👍🏻 目前评价非常不错，点赞人数非常多。\n\n学完之后，可以将项目写到简历里噢。如下图所示：\n\n\n\n\n# 获取方式\n\n使用微信扫描下方二维码，即可获取~\n\n\n\n\n# 项目答疑\n\n如果你在使用 ruoyi-vue-pro 或 yudao-cloud 项目中碰到问题，可以直接发帖提问，并打上“项目答疑”标签。如下图所示：\n\n\n\n一般 6 小时内可以获得解答。解答的时间。一般在早通勤（9-10 点）、午饭（12-13 点）、晚饭（18 点）、晚通勤（21-22 点）。\n\n例如说：\n\n * 【订单领域】你的订单系统如何从单体项目，演进微服务架构？主要解决什么问题？\n * 【组件设计】基于 Redis 实现高性能、低延迟的延时消息的方案演进\n\n\n# 从零开始\n\n * 01、视频课程导读：项目简介、功能列表、技术选型\n * 02、在 Windows 环境下，如何运行前后端项目？\n * 03、在 MacOS 环境下，如何运行前后端项目？\n * 04、自顶向下，讲解项目的整体结构（上）\n * 04、自顶向下，讲解项目的整体结构（下）\n * 05、如何 5 分钟，开发一个新功能？\n * 06、如何 5 分钟，创建一个新模块？\n * 07、如何有效的删除不用的功能？\n * 08、如何实现一键改包？\n\n\n# 用户认证\n\n * 01、如何实现管理后台和微信小程序的用户？\n * 02、如何实现用户的创建？\n * 03、如何实现用户的账号密码登录？\n * 04、如何实现用户的手机验证码登录？\n * 05、如何实现用户的退出？\n * 06、如何生成用户认证 Token 令牌？\n * 07、如何校验用户认证 Token 令牌？\n * 08、如何刷新用户认证 Token 令牌？\n * 09、如何模拟用户认证 Token 令牌？\n * 10、如何实现 URL 是否需要登录？\n * 11、如何实现微信、钉钉等第三方登录？\n * 12、如何实现微信小程序的一键登录？\n\n\n# 功能权限\n\n * 01、如何设计一套权限系统？\n * 02、如何实现菜单的创建？\n * 03、如何实现角色的创建？\n * 04、如何给用户分配权限 —— 将菜单赋予角色？\n * 05、如何给用户分配权限 —— 将角色赋予用户？\n * 06、后端如何实现 URL 权限的校验？\n * 07、前端如何实现菜单的动态加载？\n * 08、前端如何实现按钮的权限校验？\n\n\n# 数据权限\n\n * 01、如何实现数据权限（内核）—— 原理剖析？\n * 02、如何实现数据权限（内核）—— 源码实现：MyBatis 如何重写 SQL？\n * 03、如何实现数据权限（内核）—— 源码实现：如何基于（数据规则）生成 WHERE 条件？\n * 04、如何实现【部门级别】的数据权限 —— 入门使用？\n * 05、如何实现【部门级别】的数据权限 —— 源码实现？\n * 06、如何实现【自定义】的数据权限 —— 案例实战？\n\n\n# OAuth2 模块\n\n * 01、快速入门 OAuth 2.0 授权？\n * 02、基于授权码模式，如何实现 SSO 单点登录？\n * 03、请求时，如何校验 accessToken 访问令牌？\n * 04、访问令牌过期时，如何刷新 Token 令牌？\n * 05、登录成功后，如何获得用户信息？\n * 06、退出时，如何删除 Token 令牌？\n * 07、基于密码模式，如何实现 SSO 单点登录？\n * 08、如何实现客户端的管理？\n * 09、单点登录界面，如何进行初始化？\n * 10、单点登录界面，如何进行【手动】授权？\n * 11、单点登录界面，如何进行【自动】授权？\n * 12、基于【授权码】模式，如何获得 Token 令牌？\n * 13、基于【密码】模式，如何获得 Token 令牌？\n * 14、如何校验、刷新、删除访问令牌？\n\n\n# 工作流\n\n * 01、如何集成 Flowable 框架？\n * 02、如何实现动态的流程表单？\n * 03、如何实现流程表单的保存？\n * 04、如何实现流程表单的展示？\n * 05、如何实现流程模型的新建？\n * 06、如何实现流程模型的流程图的设计？\n * 07、如何实现流程模型的流程图的预览？\n * 08、如何实现流程模型的分配规则？\n * 09、如何实现流程模型的发布？\n * 10、如何实现流程定义的查询？\n * 11、如何实现流程的发起？\n * 12、如何实现我的流程列表？\n * 13、如何实现流程的取消？\n * 14、如何实现流程的任务分配？\n * 15、如何实现会签、或签任务？\n * 16、如何实现我的待办任务列表？\n * 17、如何实现我的已办任务列表？\n * 18、如何实现任务的审批通过？\n * 19、如何实现任务的审批不通过？\n * 20、如何实现流程的审批记录？\n * 21、如何实现流程的流程图的高亮？\n * 22、如何实现工作流的短信通知？\n * 23、如何实现 OA 请假的发起？\n * 24、如何实现 OA 请假的审批？\n\n\n# SaaS 多租户\n\n * 01、如何实现多租户的 DB 封装？\n * 02、如何实现多租户的 Redis 封装？\n * 03、如何实现多租户的 Web 与 Security 封装？\n * 04、如何实现多租户的 Job 封装？\n * 05、如何实现多租户的 MQ 与 Async 封装？\n * 06、如何实现多租户的 AOP 与 Util 封装？\n * 07、如何实现多租户的管理？\n * 08、如何实现多租户的套餐？\n\n\n# Web 组件\n\n * 01、如何实现统一 API 前缀？\n * 02、如何实现统一 API 响应？\n * 03、如何实现 API 全局异常处理？\n * 04、如何实现全局错误码？\n * 05、如何实现 API 接口文档？\n * 06、如何记录 API 访问日志？\n * 07、如何校验 API 请求参数？\n\n\n# 更多学习内容\n\n除了上述上述视频，还有面试招聘、源码解析、学习路线等内容。\n\n\n\n使用微信扫描下方二维码，即可获取~\n\n\n\n\n# 面试招聘\n\n\n\n我是 11 年开始工作，之前在某互联网公司做基础架构的负责人，现在在某大厂做基础架构的技术主管。\n\n“个人觉得，今年确实挺难的，但是互联网依然是国内最 top3 的职业选择”\n\n# 简历优化\n\n简历优化、简历模版、简历案例：帮助你获得更多面试机会，支持大厂专属内推，Offer 选择建议！\n\n\n\n如下是一个简历优化的优化示例：\n\n\n\n * 《职业空窗 4 年，最近想找 Java 开发，简历要怎么包装工作经历、项目经验》\n * 《23 届毕业生，现在在深圳连一个面试都约不到，简历应该怎么优化？》\n * 《硕二毕业生，成功拿到大厂 SP Offer！》\n * 《工作 2 年，学历一般，已经离职两个月，怎么提升简历？》\n * 《杭州求职，毕业 2 年，第一次跳槽，如何完善项目经历？》\n\n# 面试题库\n\n涉及 20+ 技术栈，覆盖互联网主流问题，助你斩获心仪的 Offer\n\n\n# 源码解析\n\n\n\n我阅读过 20+ 套优秀框架的源码，收获非常非常非常大。只有通过阅读源码，才能真正做到“知其然，知其所以然”。\n\n从前我看很多技术的原理会很困惑，看过源码后豁然开朗。所以才有“原理让技术抽象化，源码让技术具象化”一说。\n\n第一次阅读源码肯定不是一件容易的事情，但这是成为优秀工程师必备的技能之一。不过个人感觉，其实也就 1-2 个月痛苦下，后面真的没那么难~\n\n# 开发框架篇\n\n * Spring 47 讲\n * Spring Boot 17 讲\n * Spring MVC 22 讲\n * MyBatis 32 讲\n\n如果你是个源码萌新，建议按照“由易入难”的顺序来看：MyBatis => SpringMVC => Spring => Spring Boot 。\n\n千万千万千万不要干看源码，而是要通过 Debug 调试的方式！！！\n\n# 微服务篇\n\n * Dubbo 72 讲\n * Spring Cloud Gateway 25 讲\n * 注册中心 Eureka 23 讲\n * 配置中心 Apollo 34 讲\n * 服务保障 Hystrix 9 讲\n\n建议阅读 Dubbo 源码解析，它是微服务架构的通信基石，可能是最值得死磕学习的。Dubbo 这种框架，是足够升多个 P8 工程师的。\n\n# 中间件篇\n\n * 消息队列 RocketMQ 9 讲\n * 分库分表 17 讲\n * 分布式事务 7 讲\n * 分布式作业 ElasticJob 22 讲\n * 链路追踪 SkyWalking 37 讲\n\n建议阅读 RocketMQ 源码解析，它是一个集大成者，包括了数据存储、高可用（主从同步）、RPC 通信、注册中心、配置中心等等方面的知识与代码实现。\n\n如果说什么源码让我收获最大（可能没有之一），那真的就是 RocketMQ，当然它的挑战也非常大。\n\n\n# 学习路线\n\n\n\n优质视频资源，涵盖互联网主流技术栈，全面系统学习，不走弯路。",
            normalizedContent: "# 大纲\n\n\n\n每个点都是大章节，包含 10-20 小节的视频。\n\n * 每个视频，控制在 10 分钟左右，问题驱动，全程无废话，保证高质量的学习。\n * 视频的内容，会带你理解整个系统的设计思想，每一个组件和模块的代码实现。\n\n知其然，知其所以然！让你走出只会 crud 的困局~\n\n支持手机、平板、电脑设备，随时随地在线观看，无需下载！\n\n\n\n\n# 技术架构图\n\n\n\n\n# 为什么学习该视频？\n\n学习的过程中，往往会碰到如下的问题：\n\n * 一个人瞎摸索，走弯路，效率低\n * 一脸懵逼，不知道如何学习\n * 遇到问题，无人解答，信心备受打击\n * 遇到一些难题，自己无法透彻理解\n * 知识面狭窄，不知道的太多\n\n而通过这套视频，可以实现 “系统全面，效率高” 的效果。\n\n👍🏻 目前评价非常不错，点赞人数非常多。\n\n学完之后，可以将项目写到简历里噢。如下图所示：\n\n\n\n\n# 获取方式\n\n使用微信扫描下方二维码，即可获取~\n\n\n\n\n# 项目答疑\n\n如果你在使用 ruoyi-vue-pro 或 yudao-cloud 项目中碰到问题，可以直接发帖提问，并打上“项目答疑”标签。如下图所示：\n\n\n\n一般 6 小时内可以获得解答。解答的时间。一般在早通勤（9-10 点）、午饭（12-13 点）、晚饭（18 点）、晚通勤（21-22 点）。\n\n例如说：\n\n * 【订单领域】你的订单系统如何从单体项目，演进微服务架构？主要解决什么问题？\n * 【组件设计】基于 redis 实现高性能、低延迟的延时消息的方案演进\n\n\n# 从零开始\n\n * 01、视频课程导读：项目简介、功能列表、技术选型\n * 02、在 windows 环境下，如何运行前后端项目？\n * 03、在 macos 环境下，如何运行前后端项目？\n * 04、自顶向下，讲解项目的整体结构（上）\n * 04、自顶向下，讲解项目的整体结构（下）\n * 05、如何 5 分钟，开发一个新功能？\n * 06、如何 5 分钟，创建一个新模块？\n * 07、如何有效的删除不用的功能？\n * 08、如何实现一键改包？\n\n\n# 用户认证\n\n * 01、如何实现管理后台和微信小程序的用户？\n * 02、如何实现用户的创建？\n * 03、如何实现用户的账号密码登录？\n * 04、如何实现用户的手机验证码登录？\n * 05、如何实现用户的退出？\n * 06、如何生成用户认证 token 令牌？\n * 07、如何校验用户认证 token 令牌？\n * 08、如何刷新用户认证 token 令牌？\n * 09、如何模拟用户认证 token 令牌？\n * 10、如何实现 url 是否需要登录？\n * 11、如何实现微信、钉钉等第三方登录？\n * 12、如何实现微信小程序的一键登录？\n\n\n# 功能权限\n\n * 01、如何设计一套权限系统？\n * 02、如何实现菜单的创建？\n * 03、如何实现角色的创建？\n * 04、如何给用户分配权限 —— 将菜单赋予角色？\n * 05、如何给用户分配权限 —— 将角色赋予用户？\n * 06、后端如何实现 url 权限的校验？\n * 07、前端如何实现菜单的动态加载？\n * 08、前端如何实现按钮的权限校验？\n\n\n# 数据权限\n\n * 01、如何实现数据权限（内核）—— 原理剖析？\n * 02、如何实现数据权限（内核）—— 源码实现：mybatis 如何重写 sql？\n * 03、如何实现数据权限（内核）—— 源码实现：如何基于（数据规则）生成 where 条件？\n * 04、如何实现【部门级别】的数据权限 —— 入门使用？\n * 05、如何实现【部门级别】的数据权限 —— 源码实现？\n * 06、如何实现【自定义】的数据权限 —— 案例实战？\n\n\n# oauth2 模块\n\n * 01、快速入门 oauth 2.0 授权？\n * 02、基于授权码模式，如何实现 sso 单点登录？\n * 03、请求时，如何校验 accesstoken 访问令牌？\n * 04、访问令牌过期时，如何刷新 token 令牌？\n * 05、登录成功后，如何获得用户信息？\n * 06、退出时，如何删除 token 令牌？\n * 07、基于密码模式，如何实现 sso 单点登录？\n * 08、如何实现客户端的管理？\n * 09、单点登录界面，如何进行初始化？\n * 10、单点登录界面，如何进行【手动】授权？\n * 11、单点登录界面，如何进行【自动】授权？\n * 12、基于【授权码】模式，如何获得 token 令牌？\n * 13、基于【密码】模式，如何获得 token 令牌？\n * 14、如何校验、刷新、删除访问令牌？\n\n\n# 工作流\n\n * 01、如何集成 flowable 框架？\n * 02、如何实现动态的流程表单？\n * 03、如何实现流程表单的保存？\n * 04、如何实现流程表单的展示？\n * 05、如何实现流程模型的新建？\n * 06、如何实现流程模型的流程图的设计？\n * 07、如何实现流程模型的流程图的预览？\n * 08、如何实现流程模型的分配规则？\n * 09、如何实现流程模型的发布？\n * 10、如何实现流程定义的查询？\n * 11、如何实现流程的发起？\n * 12、如何实现我的流程列表？\n * 13、如何实现流程的取消？\n * 14、如何实现流程的任务分配？\n * 15、如何实现会签、或签任务？\n * 16、如何实现我的待办任务列表？\n * 17、如何实现我的已办任务列表？\n * 18、如何实现任务的审批通过？\n * 19、如何实现任务的审批不通过？\n * 20、如何实现流程的审批记录？\n * 21、如何实现流程的流程图的高亮？\n * 22、如何实现工作流的短信通知？\n * 23、如何实现 oa 请假的发起？\n * 24、如何实现 oa 请假的审批？\n\n\n# saas 多租户\n\n * 01、如何实现多租户的 db 封装？\n * 02、如何实现多租户的 redis 封装？\n * 03、如何实现多租户的 web 与 security 封装？\n * 04、如何实现多租户的 job 封装？\n * 05、如何实现多租户的 mq 与 async 封装？\n * 06、如何实现多租户的 aop 与 util 封装？\n * 07、如何实现多租户的管理？\n * 08、如何实现多租户的套餐？\n\n\n# web 组件\n\n * 01、如何实现统一 api 前缀？\n * 02、如何实现统一 api 响应？\n * 03、如何实现 api 全局异常处理？\n * 04、如何实现全局错误码？\n * 05、如何实现 api 接口文档？\n * 06、如何记录 api 访问日志？\n * 07、如何校验 api 请求参数？\n\n\n# 更多学习内容\n\n除了上述上述视频，还有面试招聘、源码解析、学习路线等内容。\n\n\n\n使用微信扫描下方二维码，即可获取~\n\n\n\n\n# 面试招聘\n\n\n\n我是 11 年开始工作，之前在某互联网公司做基础架构的负责人，现在在某大厂做基础架构的技术主管。\n\n“个人觉得，今年确实挺难的，但是互联网依然是国内最 top3 的职业选择”\n\n# 简历优化\n\n简历优化、简历模版、简历案例：帮助你获得更多面试机会，支持大厂专属内推，offer 选择建议！\n\n\n\n如下是一个简历优化的优化示例：\n\n\n\n * 《职业空窗 4 年，最近想找 java 开发，简历要怎么包装工作经历、项目经验》\n * 《23 届毕业生，现在在深圳连一个面试都约不到，简历应该怎么优化？》\n * 《硕二毕业生，成功拿到大厂 sp offer！》\n * 《工作 2 年，学历一般，已经离职两个月，怎么提升简历？》\n * 《杭州求职，毕业 2 年，第一次跳槽，如何完善项目经历？》\n\n# 面试题库\n\n涉及 20+ 技术栈，覆盖互联网主流问题，助你斩获心仪的 offer\n\n\n# 源码解析\n\n\n\n我阅读过 20+ 套优秀框架的源码，收获非常非常非常大。只有通过阅读源码，才能真正做到“知其然，知其所以然”。\n\n从前我看很多技术的原理会很困惑，看过源码后豁然开朗。所以才有“原理让技术抽象化，源码让技术具象化”一说。\n\n第一次阅读源码肯定不是一件容易的事情，但这是成为优秀工程师必备的技能之一。不过个人感觉，其实也就 1-2 个月痛苦下，后面真的没那么难~\n\n# 开发框架篇\n\n * spring 47 讲\n * spring boot 17 讲\n * spring mvc 22 讲\n * mybatis 32 讲\n\n如果你是个源码萌新，建议按照“由易入难”的顺序来看：mybatis => springmvc => spring => spring boot 。\n\n千万千万千万不要干看源码，而是要通过 debug 调试的方式！！！\n\n# 微服务篇\n\n * dubbo 72 讲\n * spring cloud gateway 25 讲\n * 注册中心 eureka 23 讲\n * 配置中心 apollo 34 讲\n * 服务保障 hystrix 9 讲\n\n建议阅读 dubbo 源码解析，它是微服务架构的通信基石，可能是最值得死磕学习的。dubbo 这种框架，是足够升多个 p8 工程师的。\n\n# 中间件篇\n\n * 消息队列 rocketmq 9 讲\n * 分库分表 17 讲\n * 分布式事务 7 讲\n * 分布式作业 elasticjob 22 讲\n * 链路追踪 skywalking 37 讲\n\n建议阅读 rocketmq 源码解析，它是一个集大成者，包括了数据存储、高可用（主从同步）、rpc 通信、注册中心、配置中心等等方面的知识与代码实现。\n\n如果说什么源码让我收获最大（可能没有之一），那真的就是 rocketmq，当然它的挑战也非常大。\n\n\n# 学习路线\n\n\n\n优质视频资源，涵盖互联网主流技术栈，全面系统学习，不走弯路。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "快速启动（后端项目）",
            frontmatter: {
                title: "快速启动（后端项目）",
                permalink: "/quick-start",
                date: "2022-03-01T09:19:51.000Z"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/01.%E8%90%8C%E6%96%B0%E5%BF%85%E8%AF%BB/05.%E5%BF%AB%E9%80%9F%E5%90%AF%E5%8A%A8%E3%80%90%E5%90%8E%E7%AB%AF%E3%80%91.html",
            relativePath: "01.开发指南/01.萌新必读/05.快速启动【后端】.md",
            key: "v-0f8a606f",
            path: "/quick-start/",
            headers: [{
                level: 2,
                title: "👍 相关视频教程",
                slug: "👍-相关视频教程",
                normalizedTitle: "👍 相关视频教程",
                charIndex: 123
            }, {
                level: 2,
                title: "1. 克隆代码",
                slug: "_1-克隆代码",
                normalizedTitle: "1. 克隆代码",
                charIndex: 208
            }, {
                level: 2,
                title: "2. Apifox 接口工具",
                slug: "_2-apifox-接口工具",
                normalizedTitle: "2. apifox 接口工具",
                charIndex: 609
            }, {
                level: 2,
                title: "3. 初始化 MySQL",
                slug: "_3-初始化-mysql",
                normalizedTitle: "3. 初始化 mysql",
                charIndex: 846
            }, {
                level: 2,
                title: "4. 初始化 Redis",
                slug: "_4-初始化-redis",
                normalizedTitle: "4. 初始化 redis",
                charIndex: 1527
            }, {
                level: 2,
                title: "5. 启动后端项目",
                slug: "_5-启动后端项目",
                normalizedTitle: "5. 启动后端项目",
                charIndex: 1865
            }, {
                level: 3,
                title: "5.1 编译项目",
                slug: "_5-1-编译项目",
                normalizedTitle: "5.1 编译项目",
                charIndex: 1931
            }, {
                level: 3,
                title: "5.2 启动项目",
                slug: "_5-2-启动项目",
                normalizedTitle: "5.2 启动项目",
                charIndex: 2662
            }, {
                level: 3,
                title: "5.3 启动其它模块",
                slug: "_5-3-启动其它模块",
                normalizedTitle: "5.3 启动其它模块",
                charIndex: 3082
            }, {
                level: 2,
                title: "6. 启动前端项目【简易】",
                slug: "_6-启动前端项目【简易】",
                normalizedTitle: "6. 启动前端项目【简易】",
                charIndex: 3255
            }, {
                level: 2,
                title: "7. 启动前端项目【完整】",
                slug: "_7-启动前端项目【完整】",
                normalizedTitle: "7. 启动前端项目【完整】",
                charIndex: 3297
            }, {
                level: 2,
                title: "666. 彩蛋",
                slug: "_666-彩蛋",
                normalizedTitle: "666. 彩蛋",
                charIndex: 3701
            }],
            headersStr: "👍 相关视频教程 1. 克隆代码 2. Apifox 接口工具 3. 初始化 MySQL 4. 初始化 Redis 5. 启动后端项目 5.1 编译项目 5.2 启动项目 5.3 启动其它模块 6. 启动前端项目【简易】 7. 启动前端项目【完整】 666. 彩蛋",
            content: '目标：使用 IDEA 工具，将项目 ruoyi-vue-pro 的后端项目运行起来 🛫\n\n整个过程非常简单，预计 10 分钟就可以完成，取决于大家的网速。\n\n> ↓↓↓ 技术交流群，一起苦练技术基本功，每日精进 30 公里！↓↓↓\n\n\n\n\n# 👍 相关视频教程\n\n * 从零开始 02：在 Windows 环境下，如何运行前后端项目？\n * 从零开始 03：在 MacOS 环境下，如何运行前后端项目？\n\n\n# 1. 克隆代码\n\n使用 IDEA 克隆 https://github.com/YunaiV/ruoyi-vue-pro 仓库的最新代码，并给该仓库一个 Star。\n\n> 注意：不建议使用 Eclipse，因为它没有支持 Lombok 和 Mapstruct 插件。\n\n克隆完成后，耐心等待 Maven 下载完相关的依赖。一定要注意：\n\n * ① 默认情况下，使用 master 分支，它对应 JDK 8 + Spring Boot 2.7 版本。\n * ② 如果你想体验 JDK 17/21 + Spring Boot 3.2 版本，需要切换到 master-jdk17 分支。\n\n> 友情提示：项目的每个模块的作用，可见 《开发指南 —— 项目结构》 文档。\n\n使用的 Spring Boot 版本较新，所以需要下载一段时间。趁着这个时间，胖友可以给项目添加一个 Star，支持下艿艿。\n\n\n\n\n# 2. Apifox 接口工具\n\n点击 Apifox 首页，下载对应的 Apifox 桌面版。如下图所示：\n\n为什么要下载 Apifox 桌面版？\n\n艿艿已经卸载 Postman，使用 Apifox 进行替代。国产软件，yyds 永远滴神！\n\n国内很多互联网公司，包括百度、阿里、腾讯、字节跳动等等在内，都在使用 Apifox 作为 API 工具。\n\n\n\n解压后，双击进行安装即可。黑色界面，非常酷炫。\n\n\n\n接口文档？\n\n阅读 《开发指南 —— 接口文档》 呀~~\n\n\n# 3. 初始化 MySQL\n\n友情提示？\n\n如果你是 PostgreSQL、Oracle、SQL Server、DM、大金 等其它数据库，也是可以的。\n\n因为我主要使用 MySQL数据库为主，所以其它数据库的 SQL 文件可能存在滞后，可以加入 用户群 反馈。\n\n项目使用 MySQL 存储数据，所以需要启动一个 MySQL 服务。\n\n① 创建一个名字为 ruoyi-vue-pro 数据库，【只要】 执行对应数据库类型的 sql 目录下的 ruoyi-vue-pro.sql SQL 文件，进行初始化。\n\n\n\n② 默认配置下，MySQL 需要启动在 3306 端口，并且账号是 root，密码是 123456。如果不一致，需要修改 application-local.yaml 配置文件。\n\n\n\n----------------------------------------\n\n疑问：如果我不是 MySQL，想用其它数据库，怎么办？？？\n\n * 1、【如果是 PostgreSQL、Oracle、SQL Server 数据库】，修改 yudao-spring-boot-starter-mybatis 模块的 pom.xml 文件，将对应的 JDBC Driver 的 optional 移除（注意，需要使用 IDEA 刷新下 Maven 的依赖）。如下图所示：\n\n * 2、【如果是 DM 达梦、大金、OpenGauss 等国产信创数据库】建议先使用 MySQL 跑通，然后再阅读 《国产信创数据库（DM 达梦、大金、OpenGauss）》 文档。\n\n\n# 4. 初始化 Redis\n\n项目使用 Redis 缓存数据，所以需要启动一个 Redis 服务。\n\n> 不会安装的胖友，可以选择阅读下文，良心的艿艿。\n> \n>  * Windows 安装 Redis 指南：http://www.iocoder.cn/Redis/windows-install\n>  * Mac 安装 Redis 指南：http://www.iocoder.cn/Redis/mac-install\n\n默认配置下，Redis 启动在 6379 端口，不设置账号密码。如果不一致，需要修改 application-local.yaml 配置文件。\n\n\n\n友情提示：\n\n如果你的项目部希望使用 Redis，可以参考文档 《如何去除 Redis 缓存》。\n\n\n# 5. 启动后端项目\n\nyudao-server 是后端项目，提供管理后台、用户 APP 的 RESTful API 接口。\n\n\n# 5.1 编译项目\n\n第一步，使用 IDEA 自带的 Maven 插件，进行项目的编译。如下图所示：\n\n\n\n【可选】也可以使用 Maven 命令编译：\n\n * 使用 IDEA 打开 Terminal 终端，在 根目录 下直接执行 mvn clean install package \'-Dmaven.test.skip=true\' 命令。\n * 如果执行报 Unknown lifecycle phase “.test.skip=true” 错误，使用 mvn clean install package -Dmaven.test.skip=true 即可。\n\nps：只有首次需要执行 Maven 命令，解决基础 pom.xml 不存在，导致报 BaseDbUnitTest 类不存在的问题。\n\n整个过程，预计需要 1 分钟左右。成功后，控制台日志如下：\n\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  9.139 s (Wall Clock)\n[INFO] Finished at: 2024-05-03T18:56:03+08:00\n[INFO] ------------------------------------------------------------------------\n\n\n\n# 5.2 启动项目\n\n第二步，执行 YudaoServerApplication 类，进行启动。\n\n启动还是报类不存在？\n\n可能是 IDEA 的 bug，点击 [File -> Invalidate Caches] 菜单，清空下缓存，重启后在试试看。\n\n\n\n启动完成后，使用浏览器访问 http://127.0.0.1:48080 地址，返回如下 JSON 字符串，说明成功。\n\n> 友情提示：注意，默认配置下，后端项目启动在 48080 端口。\n\n{\n    "code": 401,\n    "data": null,\n    "msg": "账号未登录"\n}\n\n\n如果报 “Command line is too long” 错误，参考 《Intellij IDEA 运行时报 Command line is too long 解决方法 》 文章解决，或者直接点击 YudaoServerApplication 蓝字部分！\n\n\n\n\n# 5.3 启动其它模块\n\n考虑到启动速度，默认值启动 system 系统服务，infra 基础设施两个模块。如果你需要启动其它模块，可以参考下面的文档：\n\n * 《工作流手册 —— 工作流》\n * 《公众号手册 —— 功能开启》\n * 《支付手册 —— 功能开启》\n * 《大屏手册 —— 报表设计器》\n * 《商城手册 —— 功能开启》\n\n\n# 6. 启动前端项目【简易】\n\n友情提示：这是可选步骤，想要完整启动前端，可以直接看「7. 启动前端项目【完整】」小节噢！\n\n在 yudao-demo 项目中，提前编译好了前端项目的静态资源，无需安装 Node 等前端环境，可以直接体验和使用。操作步骤如下：\n\n① 克隆 https://gitee.com/yudaocode/yudao-demo 项目，运行对应的启动类：\n\n\n\n * Vue3 + element-plus ：ElementPlusApplication\n * Vue3 + vben ：VbenApplication\n * Vue2 + element-ui ：ElementUIApplication\n\n② 访问 http://127.0.0.1:2048/ 地址，即可看到对应的管理后台。\n\n补充说明：\n\n前端项目是不定期编译，可能不是最新版本。\n\n如果需要最新版本，请继续往下看。\n\n\n# 7. 启动前端项目【完整】\n\n参考 《快速启动（前端项目）》 文档\n\n\n# 666. 彩蛋\n\n至此，我们已经完成了项目 ruoyi-vue-pro 的启动。\n\n胖友可以根据自己的兴趣，阅读相关源码。如果你想更快速的学习，可以看看 《视频教程 》 教程哟。\n\n\n\n后面，艿艿会花大量的时间，继续优化这个项目。同时，输出与项目匹配的技术博客，方便胖友更好的学习与理解。\n\n还是那句话，😆 为开源继绝学，我辈义不容辞！\n\n----------------------------------------\n\n嘿嘿嘿，记得一定要给 https://github.com/YunaiV/ruoyi-vue-pro 一个 star，这对艿艿真的很重要。\n\n',
            normalizedContent: '目标：使用 idea 工具，将项目 ruoyi-vue-pro 的后端项目运行起来 🛫\n\n整个过程非常简单，预计 10 分钟就可以完成，取决于大家的网速。\n\n> ↓↓↓ 技术交流群，一起苦练技术基本功，每日精进 30 公里！↓↓↓\n\n\n\n\n# 👍 相关视频教程\n\n * 从零开始 02：在 windows 环境下，如何运行前后端项目？\n * 从零开始 03：在 macos 环境下，如何运行前后端项目？\n\n\n# 1. 克隆代码\n\n使用 idea 克隆 https://github.com/yunaiv/ruoyi-vue-pro 仓库的最新代码，并给该仓库一个 star。\n\n> 注意：不建议使用 eclipse，因为它没有支持 lombok 和 mapstruct 插件。\n\n克隆完成后，耐心等待 maven 下载完相关的依赖。一定要注意：\n\n * ① 默认情况下，使用 master 分支，它对应 jdk 8 + spring boot 2.7 版本。\n * ② 如果你想体验 jdk 17/21 + spring boot 3.2 版本，需要切换到 master-jdk17 分支。\n\n> 友情提示：项目的每个模块的作用，可见 《开发指南 —— 项目结构》 文档。\n\n使用的 spring boot 版本较新，所以需要下载一段时间。趁着这个时间，胖友可以给项目添加一个 star，支持下艿艿。\n\n\n\n\n# 2. apifox 接口工具\n\n点击 apifox 首页，下载对应的 apifox 桌面版。如下图所示：\n\n为什么要下载 apifox 桌面版？\n\n艿艿已经卸载 postman，使用 apifox 进行替代。国产软件，yyds 永远滴神！\n\n国内很多互联网公司，包括百度、阿里、腾讯、字节跳动等等在内，都在使用 apifox 作为 api 工具。\n\n\n\n解压后，双击进行安装即可。黑色界面，非常酷炫。\n\n\n\n接口文档？\n\n阅读 《开发指南 —— 接口文档》 呀~~\n\n\n# 3. 初始化 mysql\n\n友情提示？\n\n如果你是 postgresql、oracle、sql server、dm、大金 等其它数据库，也是可以的。\n\n因为我主要使用 mysql数据库为主，所以其它数据库的 sql 文件可能存在滞后，可以加入 用户群 反馈。\n\n项目使用 mysql 存储数据，所以需要启动一个 mysql 服务。\n\n① 创建一个名字为 ruoyi-vue-pro 数据库，【只要】 执行对应数据库类型的 sql 目录下的 ruoyi-vue-pro.sql sql 文件，进行初始化。\n\n\n\n② 默认配置下，mysql 需要启动在 3306 端口，并且账号是 root，密码是 123456。如果不一致，需要修改 application-local.yaml 配置文件。\n\n\n\n----------------------------------------\n\n疑问：如果我不是 mysql，想用其它数据库，怎么办？？？\n\n * 1、【如果是 postgresql、oracle、sql server 数据库】，修改 yudao-spring-boot-starter-mybatis 模块的 pom.xml 文件，将对应的 jdbc driver 的 optional 移除（注意，需要使用 idea 刷新下 maven 的依赖）。如下图所示：\n\n * 2、【如果是 dm 达梦、大金、opengauss 等国产信创数据库】建议先使用 mysql 跑通，然后再阅读 《国产信创数据库（dm 达梦、大金、opengauss）》 文档。\n\n\n# 4. 初始化 redis\n\n项目使用 redis 缓存数据，所以需要启动一个 redis 服务。\n\n> 不会安装的胖友，可以选择阅读下文，良心的艿艿。\n> \n>  * windows 安装 redis 指南：http://www.iocoder.cn/redis/windows-install\n>  * mac 安装 redis 指南：http://www.iocoder.cn/redis/mac-install\n\n默认配置下，redis 启动在 6379 端口，不设置账号密码。如果不一致，需要修改 application-local.yaml 配置文件。\n\n\n\n友情提示：\n\n如果你的项目部希望使用 redis，可以参考文档 《如何去除 redis 缓存》。\n\n\n# 5. 启动后端项目\n\nyudao-server 是后端项目，提供管理后台、用户 app 的 restful api 接口。\n\n\n# 5.1 编译项目\n\n第一步，使用 idea 自带的 maven 插件，进行项目的编译。如下图所示：\n\n\n\n【可选】也可以使用 maven 命令编译：\n\n * 使用 idea 打开 terminal 终端，在 根目录 下直接执行 mvn clean install package \'-dmaven.test.skip=true\' 命令。\n * 如果执行报 unknown lifecycle phase “.test.skip=true” 错误，使用 mvn clean install package -dmaven.test.skip=true 即可。\n\nps：只有首次需要执行 maven 命令，解决基础 pom.xml 不存在，导致报 basedbunittest 类不存在的问题。\n\n整个过程，预计需要 1 分钟左右。成功后，控制台日志如下：\n\n[info] ------------------------------------------------------------------------\n[info] build success\n[info] ------------------------------------------------------------------------\n[info] total time:  9.139 s (wall clock)\n[info] finished at: 2024-05-03t18:56:03+08:00\n[info] ------------------------------------------------------------------------\n\n\n\n# 5.2 启动项目\n\n第二步，执行 yudaoserverapplication 类，进行启动。\n\n启动还是报类不存在？\n\n可能是 idea 的 bug，点击 [file -> invalidate caches] 菜单，清空下缓存，重启后在试试看。\n\n\n\n启动完成后，使用浏览器访问 http://127.0.0.1:48080 地址，返回如下 json 字符串，说明成功。\n\n> 友情提示：注意，默认配置下，后端项目启动在 48080 端口。\n\n{\n    "code": 401,\n    "data": null,\n    "msg": "账号未登录"\n}\n\n\n如果报 “command line is too long” 错误，参考 《intellij idea 运行时报 command line is too long 解决方法 》 文章解决，或者直接点击 yudaoserverapplication 蓝字部分！\n\n\n\n\n# 5.3 启动其它模块\n\n考虑到启动速度，默认值启动 system 系统服务，infra 基础设施两个模块。如果你需要启动其它模块，可以参考下面的文档：\n\n * 《工作流手册 —— 工作流》\n * 《公众号手册 —— 功能开启》\n * 《支付手册 —— 功能开启》\n * 《大屏手册 —— 报表设计器》\n * 《商城手册 —— 功能开启》\n\n\n# 6. 启动前端项目【简易】\n\n友情提示：这是可选步骤，想要完整启动前端，可以直接看「7. 启动前端项目【完整】」小节噢！\n\n在 yudao-demo 项目中，提前编译好了前端项目的静态资源，无需安装 node 等前端环境，可以直接体验和使用。操作步骤如下：\n\n① 克隆 https://gitee.com/yudaocode/yudao-demo 项目，运行对应的启动类：\n\n\n\n * vue3 + element-plus ：elementplusapplication\n * vue3 + vben ：vbenapplication\n * vue2 + element-ui ：elementuiapplication\n\n② 访问 http://127.0.0.1:2048/ 地址，即可看到对应的管理后台。\n\n补充说明：\n\n前端项目是不定期编译，可能不是最新版本。\n\n如果需要最新版本，请继续往下看。\n\n\n# 7. 启动前端项目【完整】\n\n参考 《快速启动（前端项目）》 文档\n\n\n# 666. 彩蛋\n\n至此，我们已经完成了项目 ruoyi-vue-pro 的启动。\n\n胖友可以根据自己的兴趣，阅读相关源码。如果你想更快速的学习，可以看看 《视频教程 》 教程哟。\n\n\n\n后面，艿艿会花大量的时间，继续优化这个项目。同时，输出与项目匹配的技术博客，方便胖友更好的学习与理解。\n\n还是那句话，😆 为开源继绝学，我辈义不容辞！\n\n----------------------------------------\n\n嘿嘿嘿，记得一定要给 https://github.com/yunaiv/ruoyi-vue-pro 一个 star，这对艿艿真的很重要。\n\n',
            charsets: {
                cjk: !0
            }
        }, {
            title: "快速启动（前端项目）",
            frontmatter: {
                title: "快速启动（前端项目）",
                permalink: "/quick-start-front",
                date: "2023-03-05T11:39:51.000Z"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/01.%E8%90%8C%E6%96%B0%E5%BF%85%E8%AF%BB/06.%E5%BF%AB%E9%80%9F%E5%90%AF%E5%8A%A8%E3%80%90%E5%89%8D%E7%AB%AF%E3%80%91.html",
            relativePath: "01.开发指南/01.萌新必读/06.快速启动【前端】.md",
            key: "v-abcf704e",
            path: "/quick-start-front/",
            headers: [{
                level: 2,
                title: "👍 相关视频教程",
                slug: "👍-相关视频教程",
                normalizedTitle: "👍 相关视频教程",
                charIndex: 298
            }, {
                level: 2,
                title: "1. 管理后台",
                slug: "_1-管理后台",
                normalizedTitle: "1. 管理后台",
                charIndex: 383
            }, {
                level: 3,
                title: "1.1 Vue3 + element-plus 版本",
                slug: "_1-1-vue3-element-plus-版本",
                normalizedTitle: "1.1 vue3 + element-plus 版本",
                charIndex: 600
            }, {
                level: 3,
                title: "1.2 Vue3 + vben(ant-design-vue) 版本",
                slug: "_1-2-vue3-vben-ant-design-vue-版本",
                normalizedTitle: "1.2 vue3 + vben(ant-design-vue) 版本",
                charIndex: 1260
            }, {
                level: 3,
                title: "1.3 Vue2 + element-ui 版本",
                slug: "_1-3-vue2-element-ui-版本",
                normalizedTitle: "1.3 vue2 + element-ui 版本",
                charIndex: 1768
            }, {
                level: 3,
                title: "1.4 Vue2 + uni-app 版本",
                slug: "_1-4-vue2-uni-app-版本",
                normalizedTitle: "1.4 vue2 + uni-app 版本",
                charIndex: 2202
            }, {
                level: 2,
                title: "2. uni-app 商城移动端",
                slug: "_2-uni-app-商城移动端",
                normalizedTitle: "2. uni-app 商城移动端",
                charIndex: 2800
            }, {
                level: 2,
                title: "666. 参与项目",
                slug: "_666-参与项目",
                normalizedTitle: "666. 参与项目",
                charIndex: 3300
            }],
            headersStr: "👍 相关视频教程 1. 管理后台 1.1 Vue3 + element-plus 版本 1.2 Vue3 + vben(ant-design-vue) 版本 1.3 Vue2 + element-ui 版本 1.4 Vue2 + uni-app 版本 2. uni-app 商城移动端 666. 参与项目",
            content: "目标：将项目 ruoyi-vue-pro 的前端项目运行起来 🛫\n\n整个过程非常简单，预计 5 分钟就可以完成，取决于大家的网速。\n\n> ↓↓↓ 技术交流群，一起苦练技术基本功，每日精进 30 公里！↓↓↓\n\n\n\n> 友情提示：可能胖友本地没有安装 Node.js 的环境，导致报错。可以参考如下文档安装：\n> \n>  * Windows 安装 Node.js 指南：http://www.iocoder.cn/NodeJS/windows-install\n>  * Mac 安装 Node.js 指南：http://www.iocoder.cn/NodeJS/mac-install\n\n\n# 👍 相关视频教程\n\n * 从零开始 02：在 Windows 环境下，如何运行前后端项目？\n * 从零开始 03：在 MacOS 环境下，如何运行前后端项目？\n\n\n# 1. 管理后台\n\n项目的管理后台有 4 个版本：\n\n * yudao-ui-admin-vue3：基于 Vue3 + element-plus\n * yudao-ui-admin-vben：基于 Vue3 + vben(ant-design-vue)\n * yudao-ui-admin-vue2：基于 Vue2 + element-ui\n * yudao-ui-admin-uniapp：基于 Vue2 + uni-app\n\n\n# 1.1 Vue3 + element-plus 版本\n\nyudao-ui-admin-vue3 是前端 Vue3 管理后台项目。\n\n① 克隆 https://github.com/yudaocode/yudao-ui-admin-vue3.git 项目，并 Star 关注下该项目。\n\n② 在根目录执行如下命令，进行启动：\n\n# 安装 pnpm，提升依赖的安装速度\nnpm config set registry https://registry.npmmirror.com\nnpm install -g pnpm\n# 安装依赖\npnpm install\n\n# 启动服务\nnpm run dev\n\n\n③ 启动完成后，浏览器会自动打开 http://localhost:80 地址，可以看到前端界面。\n\n\n\n友情提示：Vue3 使用 Vite 构建，所以它存在如下的情况，都是正常的：\n\n 1. 项目启动很快，浏览器打开需要等待 1 分钟左右，请保持耐心。\n 2. 点击菜单，感觉会有一点卡顿，因为 Vite 采用懒加载机制。不用担心，最终部署到生产环境，就不存在这个问题了。\n\n详细说明，可见 《为什么有人说 Vite 快，有人却说 Vite 慢？》 文章。\n\n疑问：我是前端工程师，不想启动后端项目，怎么办？\n\n可以将上述的 npm run dev 命令，替代成 npm run dev-server 命令。\n\n远程 演示环境的后端服务，只允许 GET 请求，不允许 POST、PUT、DELETE 等请求。\n\n\n# 1.2 Vue3 + vben(ant-design-vue) 版本\n\nyudao-ui-admin-vue3 是前端 Vue3 + vben(ant-design-vue) 管理后台项目。\n\n① 克隆 https://github.com/yudaocode/yudao-ui-admin-vben.git 项目，并 Star 关注下该项目。\n\n② 在根目录执行如下命令，进行启动：\n\n# 安装 pnpm，提升依赖的安装速度\nnpm config set registry https://registry.npmmirror.com\nnpm install -g pnpm\n# 安装依赖\npnpm install\n\n# 启动服务\nnpm run dev\n\n\n③ 启动完成后，浏览器会自动打开 http://localhost:80 地址，可以看到前端界面。\n\n\n\n疑问：我是前端工程师，不想启动后端项目，怎么办？\n\n可以将上述的 npm run dev 命令，替代成 npm run front 命令。\n\n远程 演示环境的后端服务，只允许 GET 请求，不允许 POST、PUT、DELETE 等请求。\n\n\n# 1.3 Vue2 + element-ui 版本\n\nyudao-ui-admin-vue2 是前端 Vue2 管理后台项目。\n\n① 克隆 https://github.com/yudaocode/yudao-ui-admin-vue2.git 项目，并 Star 关注下该项目。\n\n② 在根目录执行如下命令，进行启动：\n\n# 安装 Yarn，提升依赖的安装速度\nnpm install --global yarn\n# 安装依赖\nyarn install\n\n# 启动服务\nnpm run local\n\n\n\n\n② 启动完成后，浏览器会自动打开 http://localhost:1024 地址，可以看到前端界面。\n\n\n\n疑问：我是前端工程师，不想启动后端项目，怎么办？\n\n可以将上述的 npm run local 命令，替代成 npm run front 命令。\n\n远程 演示环境的后端服务，只允许 GET 请求，不允许 POST、PUT、DELETE 等请求。\n\n\n# 1.4 Vue2 + uni-app 版本\n\nyudao-ui-admin-uniapp 是前端 uni-app 管理后台项目。\n\n① 克隆 https://github.com/yudaocode/yudao-ui-admin-uniapp.git 项目，并 Star 关注下该项目。\n\n② 下载 HBuilder 工具，并进行安装。\n\n③ 点击 HBuilder 的 [文件 -> 导入 -> 从本地项目导入...] 菜单，选择项目的 yudao-ui-admin-uniapp 目录。\n\n④ 执行如下命令，安装 npm 依赖：\n\n# 安装 npm 依赖\nnpm i\n\n\n⑤ 点击 HBuilder 的 [运行 -> 运行到内置浏览器] 菜单，使用 H5 的方式运行。成功后，界面如下图所示：\n\n\n\n友情提示：登录时，滑块验证码，在内存浏览器可能存在兼容性的问题，此时使用 Chrome 浏览器，并使用“开发者工具”，设置为 iPhone 12 Pro 模式！\n\n疑问：我是前端工程师，不想启动后端项目，怎么办？\n\n修改 config.js 配置文件的 baseUrl 后端服务的地址为 'http://api-dashboard.yudao.iocoder.cn。如下图所示：\n\n\n\n远程 演示环境的后端服务，只允许 GET 请求，不允许 POST、PUT、DELETE 等请求。\n\n\n# 2. uni-app 商城移动端\n\nyudao-mall-uniapp 是前端 uni-app 商城移动端项目。\n\n前置任务：\n\n需要参考 《商城手册 —— 功能开启》 文档，将商城的后端启动。\n\n① 克隆 https://github.com/yudaocode/yudao-mall-uniapp 项目，并 Star 关注下该项目。\n\n② 下载 HBuilder 工具，并进行安装。\n\n③ 点击 HBuilder 的 [文件 -> 导入 -> 从本地项目导入...] 菜单，选择克隆的 yudao-mall-uniapp 目录\n\n④ 执行如下命令，安装 npm 依赖：\n\n# 安装 npm 依赖\nnpm i\n\n\n⑤ 点击 HBuilder 的 [运行 -> 运行到浏览器 -> Chrome] 菜单，使用 H5 的方式运行。成功后，界面如下图所示：\n\n\n\n疑问：我是前端工程师，不想启动后端项目，怎么办？\n\n搜索 http://127.0.0.1:48080 关键字，修改后端服务的地址为 'http://api-dashboard.yudao.iocoder.cn/。如下图所示：\n\n\n\n\n# 666. 参与项目\n\n如果你想参与到前端项目的开发，可以微信 wangwenbin-server 噢。\n\n近期，重点开发 Vue3 管理后台、uniapp 商城，欢迎大家参与进来。",
            normalizedContent: "目标：将项目 ruoyi-vue-pro 的前端项目运行起来 🛫\n\n整个过程非常简单，预计 5 分钟就可以完成，取决于大家的网速。\n\n> ↓↓↓ 技术交流群，一起苦练技术基本功，每日精进 30 公里！↓↓↓\n\n\n\n> 友情提示：可能胖友本地没有安装 node.js 的环境，导致报错。可以参考如下文档安装：\n> \n>  * windows 安装 node.js 指南：http://www.iocoder.cn/nodejs/windows-install\n>  * mac 安装 node.js 指南：http://www.iocoder.cn/nodejs/mac-install\n\n\n# 👍 相关视频教程\n\n * 从零开始 02：在 windows 环境下，如何运行前后端项目？\n * 从零开始 03：在 macos 环境下，如何运行前后端项目？\n\n\n# 1. 管理后台\n\n项目的管理后台有 4 个版本：\n\n * yudao-ui-admin-vue3：基于 vue3 + element-plus\n * yudao-ui-admin-vben：基于 vue3 + vben(ant-design-vue)\n * yudao-ui-admin-vue2：基于 vue2 + element-ui\n * yudao-ui-admin-uniapp：基于 vue2 + uni-app\n\n\n# 1.1 vue3 + element-plus 版本\n\nyudao-ui-admin-vue3 是前端 vue3 管理后台项目。\n\n① 克隆 https://github.com/yudaocode/yudao-ui-admin-vue3.git 项目，并 star 关注下该项目。\n\n② 在根目录执行如下命令，进行启动：\n\n# 安装 pnpm，提升依赖的安装速度\nnpm config set registry https://registry.npmmirror.com\nnpm install -g pnpm\n# 安装依赖\npnpm install\n\n# 启动服务\nnpm run dev\n\n\n③ 启动完成后，浏览器会自动打开 http://localhost:80 地址，可以看到前端界面。\n\n\n\n友情提示：vue3 使用 vite 构建，所以它存在如下的情况，都是正常的：\n\n 1. 项目启动很快，浏览器打开需要等待 1 分钟左右，请保持耐心。\n 2. 点击菜单，感觉会有一点卡顿，因为 vite 采用懒加载机制。不用担心，最终部署到生产环境，就不存在这个问题了。\n\n详细说明，可见 《为什么有人说 vite 快，有人却说 vite 慢？》 文章。\n\n疑问：我是前端工程师，不想启动后端项目，怎么办？\n\n可以将上述的 npm run dev 命令，替代成 npm run dev-server 命令。\n\n远程 演示环境的后端服务，只允许 get 请求，不允许 post、put、delete 等请求。\n\n\n# 1.2 vue3 + vben(ant-design-vue) 版本\n\nyudao-ui-admin-vue3 是前端 vue3 + vben(ant-design-vue) 管理后台项目。\n\n① 克隆 https://github.com/yudaocode/yudao-ui-admin-vben.git 项目，并 star 关注下该项目。\n\n② 在根目录执行如下命令，进行启动：\n\n# 安装 pnpm，提升依赖的安装速度\nnpm config set registry https://registry.npmmirror.com\nnpm install -g pnpm\n# 安装依赖\npnpm install\n\n# 启动服务\nnpm run dev\n\n\n③ 启动完成后，浏览器会自动打开 http://localhost:80 地址，可以看到前端界面。\n\n\n\n疑问：我是前端工程师，不想启动后端项目，怎么办？\n\n可以将上述的 npm run dev 命令，替代成 npm run front 命令。\n\n远程 演示环境的后端服务，只允许 get 请求，不允许 post、put、delete 等请求。\n\n\n# 1.3 vue2 + element-ui 版本\n\nyudao-ui-admin-vue2 是前端 vue2 管理后台项目。\n\n① 克隆 https://github.com/yudaocode/yudao-ui-admin-vue2.git 项目，并 star 关注下该项目。\n\n② 在根目录执行如下命令，进行启动：\n\n# 安装 yarn，提升依赖的安装速度\nnpm install --global yarn\n# 安装依赖\nyarn install\n\n# 启动服务\nnpm run local\n\n\n\n\n② 启动完成后，浏览器会自动打开 http://localhost:1024 地址，可以看到前端界面。\n\n\n\n疑问：我是前端工程师，不想启动后端项目，怎么办？\n\n可以将上述的 npm run local 命令，替代成 npm run front 命令。\n\n远程 演示环境的后端服务，只允许 get 请求，不允许 post、put、delete 等请求。\n\n\n# 1.4 vue2 + uni-app 版本\n\nyudao-ui-admin-uniapp 是前端 uni-app 管理后台项目。\n\n① 克隆 https://github.com/yudaocode/yudao-ui-admin-uniapp.git 项目，并 star 关注下该项目。\n\n② 下载 hbuilder 工具，并进行安装。\n\n③ 点击 hbuilder 的 [文件 -> 导入 -> 从本地项目导入...] 菜单，选择项目的 yudao-ui-admin-uniapp 目录。\n\n④ 执行如下命令，安装 npm 依赖：\n\n# 安装 npm 依赖\nnpm i\n\n\n⑤ 点击 hbuilder 的 [运行 -> 运行到内置浏览器] 菜单，使用 h5 的方式运行。成功后，界面如下图所示：\n\n\n\n友情提示：登录时，滑块验证码，在内存浏览器可能存在兼容性的问题，此时使用 chrome 浏览器，并使用“开发者工具”，设置为 iphone 12 pro 模式！\n\n疑问：我是前端工程师，不想启动后端项目，怎么办？\n\n修改 config.js 配置文件的 baseurl 后端服务的地址为 'http://api-dashboard.yudao.iocoder.cn。如下图所示：\n\n\n\n远程 演示环境的后端服务，只允许 get 请求，不允许 post、put、delete 等请求。\n\n\n# 2. uni-app 商城移动端\n\nyudao-mall-uniapp 是前端 uni-app 商城移动端项目。\n\n前置任务：\n\n需要参考 《商城手册 —— 功能开启》 文档，将商城的后端启动。\n\n① 克隆 https://github.com/yudaocode/yudao-mall-uniapp 项目，并 star 关注下该项目。\n\n② 下载 hbuilder 工具，并进行安装。\n\n③ 点击 hbuilder 的 [文件 -> 导入 -> 从本地项目导入...] 菜单，选择克隆的 yudao-mall-uniapp 目录\n\n④ 执行如下命令，安装 npm 依赖：\n\n# 安装 npm 依赖\nnpm i\n\n\n⑤ 点击 hbuilder 的 [运行 -> 运行到浏览器 -> chrome] 菜单，使用 h5 的方式运行。成功后，界面如下图所示：\n\n\n\n疑问：我是前端工程师，不想启动后端项目，怎么办？\n\n搜索 http://127.0.0.1:48080 关键字，修改后端服务的地址为 'http://api-dashboard.yudao.iocoder.cn/。如下图所示：\n\n\n\n\n# 666. 参与项目\n\n如果你想参与到前端项目的开发，可以微信 wangwenbin-server 噢。\n\n近期，重点开发 vue3 管理后台、uniapp 商城，欢迎大家参与进来。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "接口文档",
            frontmatter: {
                title: "接口文档",
                date: "2022-03-26T09:09:00.000Z",
                permalink: "/api-doc"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/01.%E8%90%8C%E6%96%B0%E5%BF%85%E8%AF%BB/07.%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3.html",
            relativePath: "01.开发指南/01.萌新必读/07.接口文档.md",
            key: "v-06f1ade6",
            path: "/api-doc/",
            headers: [{
                level: 2,
                title: "1. Apifox 使用",
                slug: "_1-apifox-使用",
                normalizedTitle: "1. apifox 使用",
                charIndex: 306
            }, {
                level: 3,
                title: "1.1 下载工具",
                slug: "_1-1-下载工具",
                normalizedTitle: "1.1 下载工具",
                charIndex: 377
            }, {
                level: 3,
                title: "1.2 API 导入",
                slug: "_1-2-api-导入",
                normalizedTitle: "1.2 api 导入",
                charIndex: 578
            }, {
                level: 3,
                title: "1.3 API 调试",
                slug: "_1-3-api-调试",
                normalizedTitle: "1.3 api 调试",
                charIndex: 833
            }, {
                level: 3,
                title: "1.4 常见问题",
                slug: "_1-4-常见问题",
                normalizedTitle: "1.4 常见问题",
                charIndex: 1118
            }, {
                level: 2,
                title: "2. Knife4j 使用",
                slug: "_2-knife4j-使用",
                normalizedTitle: "2. knife4j 使用",
                charIndex: 1222
            }, {
                level: 3,
                title: "2.1 如何使用？",
                slug: "_2-1-如何使用",
                normalizedTitle: "2.1 如何使用？",
                charIndex: 1681
            }, {
                level: 3,
                title: "2.2 如何开启登录？",
                slug: "_2-2-如何开启登录",
                normalizedTitle: "2.2 如何开启登录？",
                charIndex: 2016
            }, {
                level: 2,
                title: "3. Swagger 技术组件",
                slug: "_3-swagger-技术组件",
                normalizedTitle: "3. swagger 技术组件",
                charIndex: 2232
            }],
            headersStr: "1. Apifox 使用 1.1 下载工具 1.2 API 导入 1.3 API 调试 1.4 常见问题 2. Knife4j 使用 2.1 如何使用？ 2.2 如何开启登录？ 3. Swagger 技术组件",
            content: '项目使用 Swagger 实现 RESTful API 的接口文档，提供两种解决方案：\n\n*【推荐】 Apifox：强大的 API 工具，支持 API 文档、API 调试、API Mock、API 自动化测试\n\n * Knife4j：简易的 API 工具，仅支持 API 文档、API 调试\n\n为什么选择 Swagger 呢？\n\nSwagger 通过 Java 注解实现 API 接口文档的编写。相比使用 Java 注释的方式，注解提供更加规范的接口定义方式，开发体验更好。\n\n如果你没有学习 Swagger，可以阅读 《芋道 Spring Boot API 接口文档 Swagger 入门 》 文章。\n\n\n# 1. Apifox 使用\n\n本小节，我们来将项目中的 API 接口，一键导入到 Apifox 中，并使用它发起一次 API 的调用。\n\n\n# 1.1 下载工具\n\n点击 Apifox 首页，下载对应的 Apifox 桌面版。如下图所示：\n\n为什么要下载 Apifox 桌面版？\n\n艿艿已经卸载 Postman，使用 Apifox 进行替代。国产软件，yyds 永远滴神！\n\n国内很多互联网公司，包括百度、阿里、腾讯、字节跳动等等在内，都在使用 Apifox 作为 API 工具。\n\n\n\n解压后，双击进行安装即可。黑色界面，非常酷炫。\n\n\n\n\n# 1.2 API 导入\n\n① 先点击「示例项目」，再点击「+」按钮，选择「导入」选项。\n\n\n\n② 先选择「URL 导入」按钮，填写 Swagger 数据 URL 为 http://127.0.0.1:48081/v3/api-docs 。如果失败，则可以尝试 http://127.0.0.1:48080/v3/api-docs/all 解决。\n\n\n\n③ 先点击「提交」按钮，再点击「确认导入」按钮，完成 API 接口的导入。\n\n\n\n④ 导入完成后，点击「接口管理」按钮，可以查看到 API 列表。\n\n\n\n\n# 1.3 API 调试\n\n① 先点击右上角「请选择环境」，再点击「管理环境」选项，填写测试环境的地址为 http://127.0.0.1:48080，并进行保存。\n\n\n\n② 点击「管理后台 —— 认证」的「使用账号密码登录」接口，查看该 API 接口的定义。\n\n\n\n③ 点击「运行」按钮，填写 Headers 的 tenant-id 为 1，再点击 Body 的「自动生成」按钮，最后点击「发送」按钮。\n\n\n\n注意，登录接口不要填写 socialType、socialCode、socialState 这三个参数，它们是三方登录的参数。一定要去掉，不然会报错噢！\n\n\n# 1.4 常见问题\n\n问题 ①：分页 GET 请求时，如果有 createTime 这种时间类型的数组参数，会报错。如下图所示：\n\n\n\n答：把 createTime 左右两边的 [] 去掉，即可解决。\n\n\n# 2. Knife4j 使用\n\n友情提问：Knife4j 在 `master` 分支（即 JDK8 版本呢），存在 POST 请求不能生成 JSON 的问题？！\n\n反馈来源：\n\n * https://t.zsxq.com/Urhsr\n * https://github.com/YunaiV/ruoyi-vue-pro/issues/639\n\n这个是 Knife4j 自带的 bug，目前只在 master-jdk17 分支（即 JDK17/21）版本可解决。\n\n比较无奈，没有完美解：\n\n * ① 如果你把 springdoc.default-flat-param-object 设置为 true 时（目前是这个配置），就会出现这个问题。\n * ② 如果你把 springdoc.default-flat-param-object 设置为 false 时，就不会出现这个问题，但是 GET 请求的参数格式又会不正确。\n\n= = 所幸，未来大家慢慢都会迁移到 JDK17/21 的版本，这个问题就会自然解决了。\n\n\n# 2.1 如何使用？\n\n浏览器访问 http://127.0.0.1:48080/doc.html 地址，使用 Knife4j 查看 API 接口文档。\n\n\n\n① 点击任意一个接口，进行接口的调用测试。这里，使用「管理后台 - 用户个中心」的“获得登录用户信息”举例子。\n\n② 点击左侧「调试」按钮，并将请求头部的 header-id 和 Authorization 勾选上。\n\n其中，header-id 为租户编号，Authorization 的 "Bearer test" 后面为用户编号（模拟哪个用户操作）。\n\n如果不勾选，会出现 "请求的租户标识未传递，请进行排查" 或 "账号未登录" 错误。\n\n③ 点击「发送」按钮，即可发起一次 API 的调用。\n\n\n\n\n# 2.2 如何开启登录？\n\n生产环境下，建议 Knife4j 接口界面开启“安全认证”的功能，避免出现安全事故。\n\n只需要在 knife4j.basic 配置项中，额外添加 Basic Auth 认证即可，如下所示：\n\nknife4j:\n  basic:\n    enable: true\n    username: admin # Basic 认证用户名\n    password: admin # Basic 认证密码\n\n\n\n# 3. Swagger 技术组件\n\n① 在 yudao-spring-boot-starter-web 技术组件的 swagger 包，实现了对 Swagger 的封装。\n\n② 如果想要禁用 Swagger 功能，可通过 springdoc.api-docs.enable 配置项为 false。一般情况下，建议 prod 生产环境进行禁用，避免发生安全问题。\n\n\n\n友情提示：除了通过 enable 进行关闭外，更建议的是通过 knife4j 提供的 `knife4j.production = true` 来实现\n\n * 可见星球：https://wx.zsxq.com/group/88858522214142/topic/4844122558542458\n * 可见文档：《Knife4j 文档 —— 访问权限控制》',
            normalizedContent: '项目使用 swagger 实现 restful api 的接口文档，提供两种解决方案：\n\n*【推荐】 apifox：强大的 api 工具，支持 api 文档、api 调试、api mock、api 自动化测试\n\n * knife4j：简易的 api 工具，仅支持 api 文档、api 调试\n\n为什么选择 swagger 呢？\n\nswagger 通过 java 注解实现 api 接口文档的编写。相比使用 java 注释的方式，注解提供更加规范的接口定义方式，开发体验更好。\n\n如果你没有学习 swagger，可以阅读 《芋道 spring boot api 接口文档 swagger 入门 》 文章。\n\n\n# 1. apifox 使用\n\n本小节，我们来将项目中的 api 接口，一键导入到 apifox 中，并使用它发起一次 api 的调用。\n\n\n# 1.1 下载工具\n\n点击 apifox 首页，下载对应的 apifox 桌面版。如下图所示：\n\n为什么要下载 apifox 桌面版？\n\n艿艿已经卸载 postman，使用 apifox 进行替代。国产软件，yyds 永远滴神！\n\n国内很多互联网公司，包括百度、阿里、腾讯、字节跳动等等在内，都在使用 apifox 作为 api 工具。\n\n\n\n解压后，双击进行安装即可。黑色界面，非常酷炫。\n\n\n\n\n# 1.2 api 导入\n\n① 先点击「示例项目」，再点击「+」按钮，选择「导入」选项。\n\n\n\n② 先选择「url 导入」按钮，填写 swagger 数据 url 为 http://127.0.0.1:48081/v3/api-docs 。如果失败，则可以尝试 http://127.0.0.1:48080/v3/api-docs/all 解决。\n\n\n\n③ 先点击「提交」按钮，再点击「确认导入」按钮，完成 api 接口的导入。\n\n\n\n④ 导入完成后，点击「接口管理」按钮，可以查看到 api 列表。\n\n\n\n\n# 1.3 api 调试\n\n① 先点击右上角「请选择环境」，再点击「管理环境」选项，填写测试环境的地址为 http://127.0.0.1:48080，并进行保存。\n\n\n\n② 点击「管理后台 —— 认证」的「使用账号密码登录」接口，查看该 api 接口的定义。\n\n\n\n③ 点击「运行」按钮，填写 headers 的 tenant-id 为 1，再点击 body 的「自动生成」按钮，最后点击「发送」按钮。\n\n\n\n注意，登录接口不要填写 socialtype、socialcode、socialstate 这三个参数，它们是三方登录的参数。一定要去掉，不然会报错噢！\n\n\n# 1.4 常见问题\n\n问题 ①：分页 get 请求时，如果有 createtime 这种时间类型的数组参数，会报错。如下图所示：\n\n\n\n答：把 createtime 左右两边的 [] 去掉，即可解决。\n\n\n# 2. knife4j 使用\n\n友情提问：knife4j 在 `master` 分支（即 jdk8 版本呢），存在 post 请求不能生成 json 的问题？！\n\n反馈来源：\n\n * https://t.zsxq.com/urhsr\n * https://github.com/yunaiv/ruoyi-vue-pro/issues/639\n\n这个是 knife4j 自带的 bug，目前只在 master-jdk17 分支（即 jdk17/21）版本可解决。\n\n比较无奈，没有完美解：\n\n * ① 如果你把 springdoc.default-flat-param-object 设置为 true 时（目前是这个配置），就会出现这个问题。\n * ② 如果你把 springdoc.default-flat-param-object 设置为 false 时，就不会出现这个问题，但是 get 请求的参数格式又会不正确。\n\n= = 所幸，未来大家慢慢都会迁移到 jdk17/21 的版本，这个问题就会自然解决了。\n\n\n# 2.1 如何使用？\n\n浏览器访问 http://127.0.0.1:48080/doc.html 地址，使用 knife4j 查看 api 接口文档。\n\n\n\n① 点击任意一个接口，进行接口的调用测试。这里，使用「管理后台 - 用户个中心」的“获得登录用户信息”举例子。\n\n② 点击左侧「调试」按钮，并将请求头部的 header-id 和 authorization 勾选上。\n\n其中，header-id 为租户编号，authorization 的 "bearer test" 后面为用户编号（模拟哪个用户操作）。\n\n如果不勾选，会出现 "请求的租户标识未传递，请进行排查" 或 "账号未登录" 错误。\n\n③ 点击「发送」按钮，即可发起一次 api 的调用。\n\n\n\n\n# 2.2 如何开启登录？\n\n生产环境下，建议 knife4j 接口界面开启“安全认证”的功能，避免出现安全事故。\n\n只需要在 knife4j.basic 配置项中，额外添加 basic auth 认证即可，如下所示：\n\nknife4j:\n  basic:\n    enable: true\n    username: admin # basic 认证用户名\n    password: admin # basic 认证密码\n\n\n\n# 3. swagger 技术组件\n\n① 在 yudao-spring-boot-starter-web 技术组件的 swagger 包，实现了对 swagger 的封装。\n\n② 如果想要禁用 swagger 功能，可通过 springdoc.api-docs.enable 配置项为 false。一般情况下，建议 prod 生产环境进行禁用，避免发生安全问题。\n\n\n\n友情提示：除了通过 enable 进行关闭外，更建议的是通过 knife4j 提供的 `knife4j.production = true` 来实现\n\n * 可见星球：https://wx.zsxq.com/group/88858522214142/topic/4844122558542458\n * 可见文档：《knife4j 文档 —— 访问权限控制》',
            charsets: {
                cjk: !0
            }
        }, {
            title: "技术选型",
            frontmatter: {
                title: "技术选型",
                permalink: "/technology",
                date: "2022-03-02T21:55:55.000Z"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/01.%E8%90%8C%E6%96%B0%E5%BF%85%E8%AF%BB/08.%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B.html",
            relativePath: "01.开发指南/01.萌新必读/08.技术选型.md",
            key: "v-5c7d2de3",
            path: "/technology/",
            headers: [{
                level: 2,
                title: "技术架构图",
                slug: "技术架构图",
                normalizedTitle: "技术架构图",
                charIndex: 2
            }, {
                level: 2,
                title: "👍 相关视频教程",
                slug: "👍-相关视频教程",
                normalizedTitle: "👍 相关视频教程",
                charIndex: 14
            }, {
                level: 2,
                title: "👻 后端",
                slug: "👻-后端",
                normalizedTitle: "👻 后端",
                charIndex: 120
            }, {
                level: 3,
                title: "系统环境",
                slug: "系统环境",
                normalizedTitle: "系统环境",
                charIndex: 130
            }, {
                level: 3,
                title: "主框架",
                slug: "主框架",
                normalizedTitle: "主框架",
                charIndex: 314
            }, {
                level: 3,
                title: "存储层",
                slug: "存储层",
                normalizedTitle: "存储层",
                charIndex: 565
            }, {
                level: 3,
                title: "中间件",
                slug: "中间件",
                normalizedTitle: "中间件",
                charIndex: 919
            }, {
                level: 3,
                title: "系统监控",
                slug: "系统监控",
                normalizedTitle: "系统监控",
                charIndex: 1023
            }, {
                level: 3,
                title: "单元测试",
                slug: "单元测试",
                normalizedTitle: "单元测试",
                charIndex: 1185
            }, {
                level: 3,
                title: "其它工具",
                slug: "其它工具",
                normalizedTitle: "其它工具",
                charIndex: 1306
            }, {
                level: 2,
                title: "👾 前端",
                slug: "👾-前端",
                normalizedTitle: "👾 前端",
                charIndex: 1541
            }, {
                level: 3,
                title: "管理后台（Vue3 + ElementPlus）",
                slug: "管理后台-vue3-elementplus",
                normalizedTitle: "管理后台（vue3 + elementplus）",
                charIndex: 1551
            }, {
                level: 3,
                title: "管理后台（Vue3 + Vben + Ant-Design-Vue）",
                slug: "管理后台-vue3-vben-ant-design-vue",
                normalizedTitle: "管理后台（vue3 + vben + ant-design-vue）",
                charIndex: 2103
            }, {
                level: 3,
                title: "管理后台（Vue2）",
                slug: "管理后台-vue2",
                normalizedTitle: "管理后台（vue2）",
                charIndex: 2607
            }, {
                level: 3,
                title: "管理后台（uni-app）",
                slug: "管理后台-uni-app",
                normalizedTitle: "管理后台（uni-app）",
                charIndex: 2826
            }, {
                level: 3,
                title: "用户 App",
                slug: "用户-app",
                normalizedTitle: "用户 app",
                charIndex: 2954
            }],
            headersStr: "技术架构图 👍 相关视频教程 👻 后端 系统环境 主框架 存储层 中间件 系统监控 单元测试 其它工具 👾 前端 管理后台（Vue3 + ElementPlus） 管理后台（Vue3 + Vben + Ant-Design-Vue） 管理后台（Vue2） 管理后台（uni-app） 用户 App",
            content: "# 技术架构图\n\n\n\n\n# 👍 相关视频教程\n\n * 从零开始 01：视频课程导读：项目简介、功能列表、技术选型\n * 从零开始 04：自顶向下，讲解项目的整体结构（上）\n * 从零开始 04：自顶向下，讲解项目的整体结构（下）\n\n\n# 👻 后端\n\n\n# 系统环境\n\n框架      说明             版本               学习指南\nJDK     Java 开发工具包     JDK 17 或者 JDK8   书单\nMaven   Java 管理与构建工具   >= 3.5.4         书单\nNginx   高性能 Web 服务器    -                文档\n\n\n# 主框架\n\n框架                    说明            版本       学习指南\nSpring Boot           应用开发框架        3.3.1    文档\nSpring MVC            MVC 框架        6.1.10   文档\nSpring Security       Spring 安全框架   6.3.1    文档\nHibernate Validator   参数校验组件        8.0.1    文档\n\n\n# 存储层\n\n框架                   说明              版本       学习指南\nMySQL                数据库服务器          >= 5.7   书单\nDruid                JDBC 连接池、监控组件   1.2.23   文档\nMyBatis Plus         MyBatis 增强工具包   3.5.7    文档\nDynamic Datasource   动态数据源           4.3.1    文档\nRedis                key-value 数据库   >= 5.0   书单\nRedisson             Redis 客户端       3.32.0   文档\n\n\n# 中间件\n\n框架         说明       版本      学习指南\nFlowable   工作流引擎    7.0.0   文档\nQuartz     任务调度组件   2.3.2   文档\n\n\n# 系统监控\n\n框架                  说明                 版本      学习指南\nSpring Boot Admin   Spring Boot 监控平台   3.3.2   文档\nSkyWalking          分布式应用追踪系统          9.0.0   文档\n\n\n# 单元测试\n\n框架        说明             版本       学习指南\nJUnit     Java 单元测试框架    5.10.1   -\nMockito   Java Mock 框架   5.7.0    -\n\n\n# 其它工具\n\n框架          说明              版本            学习指南\nSpringdoc   Swagger 文档      2.3.0         文档\nJackson     JSON 工具库        2.17.1        \nMapStruct   Java Bean 转换    1.5.5.Final   文档\nLombok      消除冗长的 Java 代码   1.18.34       文档\n\n\n# 👾 前端\n\n\n# 管理后台（Vue3 + ElementPlus）\n\n框架             说明                 版本\nVue            vue 框架             3.2.45\nVite           开发与构建工具            4.0.1\nElement Plus   Element Plus       2.2.26\nTypeScript     JavaScript 的超集     4.9.4\npinia          Vue 存储库 替代 vuex5   2.0.28\nvueuse         常用工具集              9.6.0\nvxe-table      vue 最强表单           4.3.7\nvue-i18n       国际化                9.2.2\nvue-router     vue 路由             4.1.6\nUnoCSS         下一代工具优先的 CSS 框架    0.58.9\niconify        在线图标库              3.0.0\nwangeditor     富文本编辑器             5.1.23\n\n\n# 管理后台（Vue3 + Vben + Ant-Design-Vue）\n\n框架               说明                 版本\nVue              Vue 框架             3.2.47\nVite             开发与构建工具            4.3.0\nant-design-vue   ant-design-vue     3.2.17\nTypeScript       JavaScript 的超集     5.0.4\npinia            Vue 存储库 替代 vuex5   2.0.34\nvueuse           常用工具集              9.13.0\nvue-i18n         国际化                9.2.2\nvue-router       Vue 路由             4.1.6\nUnoCSS           下一代工具优先的 CSS 框架    0.58.9\niconify          在线图标库              3.1.0\n\n\n# 管理后台（Vue2）\n\n框架                  说明                 版本       学习指南\nNode                JavaScript 运行时环境   >= 12    -\nVue                 JavaScript 框架      2.7.14   书单\nVue Element Admin   后台前端解决方案           2.5.10   \n\n\n# 管理后台（uni-app）\n\n框架        说明                   版本\nuni-app   跨平台框架                2.0.0\nuni-ui    基于 uni-app 的 UI 框架   1.4.20\n\n\n# 用户 App\n\n框架       说明                 版本       学习指南\nVue      JavaScript 框架      2.6.12   书单\nUniApp   小程序、H5、App 的统一框架   -        -",
            normalizedContent: "# 技术架构图\n\n\n\n\n# 👍 相关视频教程\n\n * 从零开始 01：视频课程导读：项目简介、功能列表、技术选型\n * 从零开始 04：自顶向下，讲解项目的整体结构（上）\n * 从零开始 04：自顶向下，讲解项目的整体结构（下）\n\n\n# 👻 后端\n\n\n# 系统环境\n\n框架      说明             版本               学习指南\njdk     java 开发工具包     jdk 17 或者 jdk8   书单\nmaven   java 管理与构建工具   >= 3.5.4         书单\nnginx   高性能 web 服务器    -                文档\n\n\n# 主框架\n\n框架                    说明            版本       学习指南\nspring boot           应用开发框架        3.3.1    文档\nspring mvc            mvc 框架        6.1.10   文档\nspring security       spring 安全框架   6.3.1    文档\nhibernate validator   参数校验组件        8.0.1    文档\n\n\n# 存储层\n\n框架                   说明              版本       学习指南\nmysql                数据库服务器          >= 5.7   书单\ndruid                jdbc 连接池、监控组件   1.2.23   文档\nmybatis plus         mybatis 增强工具包   3.5.7    文档\ndynamic datasource   动态数据源           4.3.1    文档\nredis                key-value 数据库   >= 5.0   书单\nredisson             redis 客户端       3.32.0   文档\n\n\n# 中间件\n\n框架         说明       版本      学习指南\nflowable   工作流引擎    7.0.0   文档\nquartz     任务调度组件   2.3.2   文档\n\n\n# 系统监控\n\n框架                  说明                 版本      学习指南\nspring boot admin   spring boot 监控平台   3.3.2   文档\nskywalking          分布式应用追踪系统          9.0.0   文档\n\n\n# 单元测试\n\n框架        说明             版本       学习指南\njunit     java 单元测试框架    5.10.1   -\nmockito   java mock 框架   5.7.0    -\n\n\n# 其它工具\n\n框架          说明              版本            学习指南\nspringdoc   swagger 文档      2.3.0         文档\njackson     json 工具库        2.17.1        \nmapstruct   java bean 转换    1.5.5.final   文档\nlombok      消除冗长的 java 代码   1.18.34       文档\n\n\n# 👾 前端\n\n\n# 管理后台（vue3 + elementplus）\n\n框架             说明                 版本\nvue            vue 框架             3.2.45\nvite           开发与构建工具            4.0.1\nelement plus   element plus       2.2.26\ntypescript     javascript 的超集     4.9.4\npinia          vue 存储库 替代 vuex5   2.0.28\nvueuse         常用工具集              9.6.0\nvxe-table      vue 最强表单           4.3.7\nvue-i18n       国际化                9.2.2\nvue-router     vue 路由             4.1.6\nunocss         下一代工具优先的 css 框架    0.58.9\niconify        在线图标库              3.0.0\nwangeditor     富文本编辑器             5.1.23\n\n\n# 管理后台（vue3 + vben + ant-design-vue）\n\n框架               说明                 版本\nvue              vue 框架             3.2.47\nvite             开发与构建工具            4.3.0\nant-design-vue   ant-design-vue     3.2.17\ntypescript       javascript 的超集     5.0.4\npinia            vue 存储库 替代 vuex5   2.0.34\nvueuse           常用工具集              9.13.0\nvue-i18n         国际化                9.2.2\nvue-router       vue 路由             4.1.6\nunocss           下一代工具优先的 css 框架    0.58.9\niconify          在线图标库              3.1.0\n\n\n# 管理后台（vue2）\n\n框架                  说明                 版本       学习指南\nnode                javascript 运行时环境   >= 12    -\nvue                 javascript 框架      2.7.14   书单\nvue element admin   后台前端解决方案           2.5.10   \n\n\n# 管理后台（uni-app）\n\n框架        说明                   版本\nuni-app   跨平台框架                2.0.0\nuni-ui    基于 uni-app 的 ui 框架   1.4.20\n\n\n# 用户 app\n\n框架       说明                 版本       学习指南\nvue      javascript 框架      2.6.12   书单\nuniapp   小程序、h5、app 的统一框架   -        -",
            charsets: {
                cjk: !0
            }
        }, {
            title: "项目结构",
            frontmatter: {
                title: "项目结构",
                permalink: "/project-intro",
                date: "2022-03-02T21:26:49.000Z"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/01.%E8%90%8C%E6%96%B0%E5%BF%85%E8%AF%BB/09.%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.html",
            relativePath: "01.开发指南/01.萌新必读/09.项目结构.md",
            key: "v-999f7d24",
            path: "/project-intro/",
            headers: [{
                level: 2,
                title: "👍 相关视频教程",
                slug: "👍-相关视频教程",
                normalizedTitle: "👍 相关视频教程",
                charIndex: 2
            }, {
                level: 2,
                title: "👻 后端结构",
                slug: "👻-后端结构",
                normalizedTitle: "👻 后端结构",
                charIndex: 108
            }, {
                level: 3,
                title: "1. yudao-dependencies",
                slug: "_1-yudao-dependencies",
                normalizedTitle: "1. yudao-dependencies",
                charIndex: 380
            }, {
                level: 3,
                title: "2. yudao-framework",
                slug: "_2-yudao-framework",
                normalizedTitle: "2. yudao-framework",
                charIndex: 795
            }, {
                level: 3,
                title: "3. yudao-module-xxx",
                slug: "_3-yudao-module-xxx",
                normalizedTitle: "3. yudao-module-xxx",
                charIndex: 3136
            }, {
                level: 3,
                title: "4. yudao-server",
                slug: "_4-yudao-server",
                normalizedTitle: "4. yudao-server",
                charIndex: 7577
            }, {
                level: 2,
                title: "👾 前端结构",
                slug: "👾-前端结构",
                normalizedTitle: "👾 前端结构",
                charIndex: 7739
            }, {
                level: 3,
                title: "1. yudao-ui-admin-vue3",
                slug: "_1-yudao-ui-admin-vue3",
                normalizedTitle: "1. yudao-ui-admin-vue3",
                charIndex: 8126
            }, {
                level: 3,
                title: "2. yudao-ui-admin-vben",
                slug: "_2-yudao-ui-admin-vben",
                normalizedTitle: "2. yudao-ui-admin-vben",
                charIndex: 9386
            }, {
                level: 3,
                title: "3. yudao-admin-ui",
                slug: "_3-yudao-admin-ui",
                normalizedTitle: "3. yudao-admin-ui",
                charIndex: 10685
            }, {
                level: 3,
                title: "4. yudao-admin-ui-uniapp",
                slug: "_4-yudao-admin-ui-uniapp",
                normalizedTitle: "4. yudao-admin-ui-uniapp",
                charIndex: 12037
            }, {
                level: 3,
                title: "5. yudao-mall-uniapp",
                slug: "_5-yudao-mall-uniapp",
                normalizedTitle: "5. yudao-mall-uniapp",
                charIndex: 12076
            }, {
                level: 3,
                title: "6. yudao-ui-go-view",
                slug: "_6-yudao-ui-go-view",
                normalizedTitle: "6. yudao-ui-go-view",
                charIndex: 13205
            }],
            headersStr: "👍 相关视频教程 👻 后端结构 1. yudao-dependencies 2. yudao-framework 3. yudao-module-xxx 4. yudao-server 👾 前端结构 1. yudao-ui-admin-vue3 2. yudao-ui-admin-vben 3. yudao-admin-ui 4. yudao-admin-ui-uniapp 5. yudao-mall-uniapp 6. yudao-ui-go-view",
            content: "# 👍 相关视频教程\n\n * 从零开始 01：视频课程导读：项目简介、功能列表、技术选型\n * 从零开始 04：自顶向下，讲解项目的整体结构（上）\n * 从零开始 04：自顶向下，讲解项目的整体结构（下）\n\n\n# 👻 后端结构\n\n后端采用模块化的架构，按照功能拆分成多个 Maven Module，提升开发与研发的效率，带来更好的可维护性。\n\n一共有四类 Maven Module：\n\nMAVEN MODULE         作用\nyudao-dependencies   Maven 依赖版本管理\nyudao-framework      Java 框架拓展\nyudao-module-xxx     XXX 功能的 Module 模块\nyudao-server         管理后台 + 用户 App 的服务端\n\n下面，我们来逐个看看。\n\n\n# 1. yudao-dependencies\n\n该模块是一个 Maven Bom，只有一个 pom.xml 文件，定义项目中所有 Maven 依赖的版本号，解决依赖冲突问题。\n\n> 详细的解释，可见 《微服务中使用 Maven BOM 来管理你的版本依赖 》 文章。\n\n从定位上来说，它和 Spring Boot 的 spring-boot-starter-parent 和 Spring Cloud 的 spring-cloud-dependencies 是一致的。\n\n实际上，ruoyi-vue-pro 本质上还是个单体项目，直接在根目录 pom.xml 管理依赖版本会更加方便，也符合绝大多数程序员的认知。但是要额外考虑一个场景，如果每个 yudao-module-xxx 模块都维护在一个独立的 Git 仓库，那么 yudao-dependencies 就可以在多个 yudao-module-xxx 模块下复用。\n\n\n# 2. yudao-framework\n\n该模块是 ruoyi-vue-pro 项目的框架封装，其下的每个 Maven Module 都是一个组件，分成两种类型：\n\n① 技术组件：技术相关的组件封装，例如说 MyBatis、Redis 等等。\n\nMAVEN MODULE                               作用\nyudao-common                               定义基础 pojo 类、枚举、工具类等\nyudao-spring-boot-starter-web              Web 封装，提供全局异常、访问日志等\nyudao-spring-boot-starter-websocket        WebSocket 封装，提供 Token 认证、WebSocket 集群广播、Message 监听\nyudao-spring-boot-starter-security         认证授权，基于 Spring Security 实现\nyudao-spring-boot-starter-mybatis          数据库操作，基于 MyBatis Plus 实现\nyudao-spring-boot-starter-redis            缓存操作，基于 Spring Data Redis + Redisson 实现\nyudao-spring-boot-starter-mq               消息队列，基于 Redis 实现，支持集群消费和广播消费\nyudao-spring-boot-starter-job              定时任务，基于 Quartz 实现，支持集群模式\nyudao-spring-boot-starter-protection       服务保障，提供幂等、分布式锁、限流、熔断等功能\nyudao-spring-boot-starter-excel            Excel 导入导出，基于 EasyExcel 实现\nyudao-spring-boot-starter-monitor          服务监控，提供链路追踪、日志服务、指标收集等功能\nyudao-spring-boot-starter-test             单元测试，基于 Junit + Mockito 实现\nyudao-spring-boot-starter-file 【已合并】       文件客户端，支持将文件存储到 S3（MinIO、阿里云、腾讯云、七牛云）、本地、FTP、SFTP、数据库等\nyudao-spring-boot-starter-captcha 【已合并】    验证码 Captcha，提供滑块验证码\nyudao-spring-boot-starter-flowable 【已合并】   工作流，基于 Flowable 实现\n\n友情提示：\n\n * yudao-spring-boot-starter-file 组件：自 2.0.1 版本，合并到 yudao-module-infra-biz 模块的 framework/file 包下，一方面减少 starter 提升编译速度，一方面只有 infra 模块使用到\n * yudao-spring-boot-starter-captcha 组件：自 2.0.1 版本，合并到 yudao-module-system-biz 模块的 framework/captcha 包下，一方面减少 starter 提升编译速度，一方面只有 system 模块使用到\n * yudao-spring-boot-starter-flowable 组件：自 2.0.1 版本，合并到 yudao-module-bpm-biz 模块的 framework/flowable 包下，一方面减少 starter 提升编译速度，一方面只有 bpm 模块使用到\n\n② 业务组件：业务相关的组件封装，例如说数据字典、操作日志等等。如果是业务组件，名字会包含 biz 关键字。\n\nMAVEN MODULE                                    作用\nyudao-spring-boot-starter-biz-tenant            SaaS 多租户\nyudao-spring-boot-starter-biz-data-permission   数据权限\nyudao-spring-boot-starter-biz-operatelog        操作日志\nyudao-spring-boot-starter-biz-pay               支付客户端，对接微信支付、支付宝等支付平台\nyudao-spring-boot-starter-biz-ip                地区 & IP 库\n\n友情提示：\n\n * yudao-spring-boot-starter-biz-operatelog 组件：自 2.1.0 版本，合并到 yudao-spring-boot-starter-security 组件的 operatelog 包下，主要减少 starter 提升编译速度\n\n----------------------------------------\n\n每个组件，包含两部分：\n\n 1. core 包：组件的核心封装，拓展相关的功能。\n 2. config 包：组件的 Spring Boot 自动配置。\n\n\n\n\n# 3. yudao-module-xxx\n\n该模块是 XXX 功能的 Module 模块，目前内置了 8 个模块。\n\n项目                    说明       是否必须\nyudao-module-system   系统功能     √\nyudao-module-infra    基础设施     √\nyudao-module-member   会员中心     x\nyudao-module-bpm      工作流程     x\nyudao-module-pay      支付系统     x\nyudao-module-report   大屏报表     x\nyudao-module-mall     商城系统     x\nyudao-module-erp      ERP 系统   x\nyudao-module-crm      CRM 系统   x\nyudao-module-ai       AI 大模型   x\nyudao-module-mp       微信公众号    x\n\n----------------------------------------\n\n每个模块包含两个 Maven Module，分别是：\n\nMAVEN MODULE           作用\nyudao-module-xxx-api   提供给其它模块的 API 定义\nyudao-module-xxx-biz   模块的功能的具体实现\n\n例如说，yudao-module-infra 想要访问 yudao-module-system 的用户、部门等数据，需要引入 yudao-module-system-api 子模块。示例如下：\n\n\n\n疑问：为什么设计 `yudao-module-xxx-api` 模块呢？\n\n 1. 明确需要提供给其它模块的 API 定义，方便未来迁移微服务架构。\n 2. 模块之间可能会存在相互引用的情况，虽然说从系统设计上要尽量避免，但是有时在快速迭代的情况下，可能会出现。此时，通过只引用对方模块的 API 子模块，解决相互引用导致 Maven 无法打包的问题。\n\nyudao-module-xxx-api 子模块的项目结构如下：\n\n\n\n所在包     类                      作用                            示例\napi     Api 接口                 提供给其它模块的 API 接口               AdminUserApi\napi     DTO 类                  Api 接口的入参 ReqDTO、出参 RespDTO   LoginLogCreateReqDTO DeptRespDTO\nenums   Enum 类                 字段的枚举                         LoginLogTypeEnum\nenums   DictTypeConstants 类    数据字典的枚举                       DictTypeConstants\nenums   ErrorCodeConstants 类   错误码的枚举                        ErrorCodeConstants\n\nyudao-module-xxx-biz 子模块的项目结构如下：\n\n\n\n所在包               类                        作用                                           示例\napi               ApiImpl 类                提供给其它模块的 API 实现类                             AdminUserApiImpl\ncontroler.admin   Controller 类             提供给管理后台的 RESTful API，默认以 admin-api/ 作为前缀。    AuthController\n                                           例如 admin-api/system/auth/login 登录接口\ncontroler.admin   VO 类                     Admin Controller 接口的入参 ReqVO、出参 RespVO       AuthLoginReqVO AuthLoginRespVO\ncontroler.app     Controller 类，以 App 为前缀   提供给用户 App 的 RESTful API，默认以 app-api/ 作为前缀。   AppAuthController\n                                           例如 app-api/member/auth/login 登录接口\ncontroler.app     VO 类，以 App 为前缀           App Controller 接口的入参 ReqVO、出参 RespVO         AppAuthLoginReqVO AppAuthLoginRespVO\ncontroler         .http 文件                 IDEA Http Client 插件，模拟请求 RESTful 接口          AuthController.http\nservice           Service 接口               业务逻辑的接口定义                                    AdminUserService\nservice           ServiceImpl 类            业务逻辑的实现类                                     AdminUserServiceImpl\ndal               -                        Data Access Layer，数据访问层                      \ndal.dataobject    DO 类                     Data Object，映射数据库表、或者 Redis 对象               AdminUserDO\ndal.mysql         Mapper 接口                数据库的操作                                       AdminUserMapper\ndal.redis         RedisDAO 类               Redis 的操作                                    LoginUserRedisDAO\nconvert           Convert 接口               DTO / VO / DO 等对象之间的转换器                      UserConvert\njob               Job 类                    定时任务                                         DemoJob\nmq                -                        Message Queue，消息队列                           \nmq.message        Message 类                发送和消费的消息                                     SmsSendMessage\nmq.producer       Producer 类               消息的生产者                                       SmsProducer\nmq.consumer       Producer 类               消息的消费者                                       SmsSendConsumer\nframework         -                        模块自身的框架封装                                    framework\n\n疑问：为什么 Controller 分成 Admin 和 App 两种？\n\n提供给 Admin 和 App 的 RESTful API 接口是不同的，拆分后更加清晰。\n\n疑问：为什么 VO 分成 Admin 和 App 两种？\n\n相同功能的 RESTful API 接口，对于 Admin 和 App 传入的参数、返回的结果都可能是不同的。例如说，Admin 查询某个用户的基本信息时，可以返回全部字段；而 App 查询时，不会返回 mobile 手机等敏感字段。\n\n疑问：为什么 DO 不作为 Controller 的出入参？\n\n 1. 明确每个 RESTful API 接口的出入参。例如说，创建部门时，只需要传入 name、parentId 字段，使用 DO 接参就会导致 type、createTime、creator 等字段可以被传入，导致前端同学一脸懵逼。\n 2. 每个 RESTful API 有自己独立的 VO，可以更好的设置 Swagger 注解、Validator 校验规则，而让 DO 保持整洁，专注映射好数据库表。\n\n疑问：为什么操作 Redis 需要通过 RedisDAO？\n\nService 直接使用 RedisTemplate 操作 Redis，导致大量 Redis 的操作细节和业务逻辑杂糅在一起，导致代码不够整洁。通过 RedisDAO 类，将每个 Redis Key 像一个数据表一样对待，清晰易维护。\n\n总结来说，每个模块采用三层架构 + 非严格分层，如下图所示：\n\n\n\n疑问：如果 message 需要跨模块共享，类似 api 的效果，可以怎么做？\n\n可以在 yudao-module-xxx-api 子模块下，新建一个 message 包，可参考 MemberUserCreateMessage 类。\n\n\n# 4. yudao-server\n\n该模块是后端 Server 的主项目，通过引入需要 yudao-module-xxx 业务模块，从而实现提供 RESTful API 给 yudao-ui-admin-vue3、yudao-mall-uniapp 等前端项目。\n\n本质上来说，它就是个空壳（容器）！如下图所示：\n\n\n\n\n# 👾 前端结构\n\n前端一共有六个项目，分别是：\n\n项目                      说明\nyudao-ui-admin-vue3     基于 Vue3 + element-plus 实现的管理后台\nyudao-ui-admin-vben     基于 Vue3 + vben(ant-design-vue) 实现的管理后台\nyudao-ui-admin-vue2     基于 Vue2 + element-ui 实现的管理后台\nyudao-ui-go-view        基于 Vue3 + naive-ui 实现的大屏报表\nyudao-ui-admin-uniapp   基于 uni-app + uni-ui 实现的管理后台的小程序\nyudao-mall-uniapp       基于 uni-app + uview 实现的用户 App\n\n\n# 1. yudao-ui-admin-vue3\n\n.\n├── .github # github workflows 相关\n├── .husky # husky 配置\n├── .vscode # vscode 配置\n├── mock # 自定义 mock 数据及配置\n├── public # 静态资源\n├── src # 项目代码\n│   ├── api # api接口管理\n│   ├── assets # 静态资源\n│   ├── components # 公用组件\n│   ├── hooks # 常用hooks\n│   ├── layout # 布局组件\n│   ├── locales # 语言文件\n│   ├── plugins # 外部插件\n│   ├── router # 路由配置\n│   ├── store # 状态管理\n│   ├── styles # 全局样式\n│   ├── utils # 全局工具类\n│   ├── views # 路由页面\n│   ├── App.vue # 入口vue文件\n│   ├── main.ts # 主入口文件\n│   └── permission.ts # 路由拦截\n├── types # 全局类型\n├── .env.base # 本地开发环境 环境变量配置\n├── .env.dev # 打包到开发环境 环境变量配置\n├── .env.gitee # 针对 gitee 的环境变量 可忽略\n├── .env.pro # 打包到生产环境 环境变量配置\n├── .env.test # 打包到测试环境 环境变量配置\n├── .eslintignore # eslint 跳过检测配置\n├── .eslintrc.js # eslint 配置\n├── .gitignore # git 跳过配置\n├── .prettierignore # prettier 跳过检测配置\n├── .stylelintignore # stylelint 跳过检测配置\n├── .versionrc 自动生成版本号及更新记录配置\n├── CHANGELOG.md # 更新记录\n├── commitlint.config.js # git commit 提交规范配置\n├── index.html # 入口页面\n├── package.json\n├── .postcssrc.js # postcss 配置\n├── prettier.config.js # prettier 配置\n├── README.md # 英文 README\n├── README.zh-CN.md # 中文 README\n├── stylelint.config.js # stylelint 配置\n├── tsconfig.json # typescript 配置\n├── vite.config.ts # vite 配置\n└── windi.config.ts # windicss 配置\n\n\n\n# 2. yudao-ui-admin-vben\n\n.\n├── build # 打包脚本相关\n│   ├── config # 配置文件\n│   ├── generate # 生成器\n│   ├── script # 脚本\n│   └── vite # vite配置\n├── mock # mock文件夹\n├── public # 公共静态资源目录\n├── src # 主目录\n│   ├── api # 接口文件\n│   ├── assets # 资源文件\n│   │   ├── icons # icon sprite 图标文件夹\n│   │   ├── images # 项目存放图片的文件夹\n│   │   └── svg # 项目存放svg图片的文件夹\n│   ├── components # 公共组件\n│   ├── design # 样式文件\n│   ├── directives # 指令\n│   ├── enums # 枚举/常量\n│   ├── hooks # hook\n│   │   ├── component # 组件相关hook\n│   │   ├── core # 基础hook\n│   │   ├── event # 事件相关hook\n│   │   ├── setting # 配置相关hook\n│   │   └── web # web相关hook\n│   ├── layouts # 布局文件\n│   │   ├── default # 默认布局\n│   │   ├── iframe # iframe布局\n│   │   └── page # 页面布局\n│   ├── locales # 多语言\n│   ├── logics # 逻辑\n│   ├── main.ts # 主入口\n│   ├── router # 路由配置\n│   ├── settings # 项目配置\n│   │   ├── componentSetting.ts # 组件配置\n│   │   ├── designSetting.ts # 样式配置\n│   │   ├── encryptionSetting.ts # 加密配置\n│   │   ├── localeSetting.ts # 多语言配置\n│   │   ├── projectSetting.ts # 项目配置\n│   │   └── siteSetting.ts # 站点配置\n│   ├── store # 数据仓库\n│   ├── utils # 工具类\n│   └── views # 页面\n├── test # 测试\n│   └── server # 测试用到的服务\n│       ├── api # 测试服务器\n│       ├── upload # 测试上传服务器\n│       └── websocket # 测试ws服务器\n├── types # 类型文件\n├── vite.config.ts # vite配置文件\n└── windi.config.ts # windcss配置文件\n\n\n\n# 3. yudao-admin-ui\n\n├── bin                        // 执行脚本\n├── build                      // 构建相关  \n├── public                     // 公共文件\n│   ├── favicon.ico            // favicon 图标\n│   └── index.html             // html 模板\n│   └── robots.txt             // 反爬虫\n├── src                        // 源代码\n│   ├── api                    // 所有请求【重要】\n│   ├── assets                 // 主题、字体等静态资源\n│   ├── components             // 全局公用组件\n│   ├── directive              // 全局指令\n│   ├── icons                  // 图标\n│   ├── layout                 // 布局\n│   ├── plugins                // 插件\n│   ├── router                 // 路由\n│   ├── store                  // 全局 store 管理\n│   ├── utils                  // 全局公用方法\n│   ├── views                  // 视图【重要】\n│   ├── App.vue                // 入口页面\n│   ├── main.js                // 入口 JS，加载组件、初始化等\n│   ├── permission.js          // 权限管理\n│   └── settings.js            // 系统配置\n├── .editorconfig              // 编码格式\n├── .env.development           // 开发环境配置\n├── .env.production            // 生产环境配置\n├── .env.staging               // 测试环境配置\n├── .eslintignore              // 忽略语法检查\n├── .eslintrc.js               // eslint 配置项\n├── .gitignore                 // git 忽略项\n├── babel.config.js            // babel.config.js\n├── package.json               // package.json\n└── vue.config.js              // vue.config.js\n\n\n\n# 4. yudao-admin-ui-uniapp\n\nTODO 待补充\n\n\n# 5. yudao-mall-uniapp\n\n├── pages                   // 页面\n│      ├── index            // 入口页面\n│      ├── user             // 用户相关\n│      ├── public           // 公共页面\n│      ├── activity         // 活动页面\n│      ├── app              // 积分、签到页面\n│      ├── chat             // 客服页面\n│      ├── commission       // 分销页面\n│      ├── coupon           // 优惠券页面\n│      ├── goods            // 商品页面\n│      ├── order            // 订单页面\n│      ├── pay              // 支付页面\n├── sheep                   // 底层依赖/工具库\n│      ├── api              // 服务端接口\n│      ├── components       // 自定义功能组件\n│      ├── config           // 配置文件\n│      ├── helper           // 助手函数\n│      ├── hooks            // vue-hooks\n│      ├── libs             // 自定义依赖\n│      ├── platform         // 第三方平台登录、分享、支付\n│      ├── request          // 请求类库\n│      ├── router           // 自定义路由跳转\n│      ├── scss             // 主样式库\n│      ├── store            // pinia状态管理模块\n│      ├── ui               // 自定义UI组件\n│      ├── url              // cdn图片地址格式化\n│      ├── validate         // 通用验证器\n│      ├── index.js         // Shopro入口文件\n├── uni_modules             // dcloud第三方插件\n\n\n\n# 6. yudao-ui-go-view\n\nTODO 待补充",
            normalizedContent: "# 👍 相关视频教程\n\n * 从零开始 01：视频课程导读：项目简介、功能列表、技术选型\n * 从零开始 04：自顶向下，讲解项目的整体结构（上）\n * 从零开始 04：自顶向下，讲解项目的整体结构（下）\n\n\n# 👻 后端结构\n\n后端采用模块化的架构，按照功能拆分成多个 maven module，提升开发与研发的效率，带来更好的可维护性。\n\n一共有四类 maven module：\n\nmaven module         作用\nyudao-dependencies   maven 依赖版本管理\nyudao-framework      java 框架拓展\nyudao-module-xxx     xxx 功能的 module 模块\nyudao-server         管理后台 + 用户 app 的服务端\n\n下面，我们来逐个看看。\n\n\n# 1. yudao-dependencies\n\n该模块是一个 maven bom，只有一个 pom.xml 文件，定义项目中所有 maven 依赖的版本号，解决依赖冲突问题。\n\n> 详细的解释，可见 《微服务中使用 maven bom 来管理你的版本依赖 》 文章。\n\n从定位上来说，它和 spring boot 的 spring-boot-starter-parent 和 spring cloud 的 spring-cloud-dependencies 是一致的。\n\n实际上，ruoyi-vue-pro 本质上还是个单体项目，直接在根目录 pom.xml 管理依赖版本会更加方便，也符合绝大多数程序员的认知。但是要额外考虑一个场景，如果每个 yudao-module-xxx 模块都维护在一个独立的 git 仓库，那么 yudao-dependencies 就可以在多个 yudao-module-xxx 模块下复用。\n\n\n# 2. yudao-framework\n\n该模块是 ruoyi-vue-pro 项目的框架封装，其下的每个 maven module 都是一个组件，分成两种类型：\n\n① 技术组件：技术相关的组件封装，例如说 mybatis、redis 等等。\n\nmaven module                               作用\nyudao-common                               定义基础 pojo 类、枚举、工具类等\nyudao-spring-boot-starter-web              web 封装，提供全局异常、访问日志等\nyudao-spring-boot-starter-websocket        websocket 封装，提供 token 认证、websocket 集群广播、message 监听\nyudao-spring-boot-starter-security         认证授权，基于 spring security 实现\nyudao-spring-boot-starter-mybatis          数据库操作，基于 mybatis plus 实现\nyudao-spring-boot-starter-redis            缓存操作，基于 spring data redis + redisson 实现\nyudao-spring-boot-starter-mq               消息队列，基于 redis 实现，支持集群消费和广播消费\nyudao-spring-boot-starter-job              定时任务，基于 quartz 实现，支持集群模式\nyudao-spring-boot-starter-protection       服务保障，提供幂等、分布式锁、限流、熔断等功能\nyudao-spring-boot-starter-excel            excel 导入导出，基于 easyexcel 实现\nyudao-spring-boot-starter-monitor          服务监控，提供链路追踪、日志服务、指标收集等功能\nyudao-spring-boot-starter-test             单元测试，基于 junit + mockito 实现\nyudao-spring-boot-starter-file 【已合并】       文件客户端，支持将文件存储到 s3（minio、阿里云、腾讯云、七牛云）、本地、ftp、sftp、数据库等\nyudao-spring-boot-starter-captcha 【已合并】    验证码 captcha，提供滑块验证码\nyudao-spring-boot-starter-flowable 【已合并】   工作流，基于 flowable 实现\n\n友情提示：\n\n * yudao-spring-boot-starter-file 组件：自 2.0.1 版本，合并到 yudao-module-infra-biz 模块的 framework/file 包下，一方面减少 starter 提升编译速度，一方面只有 infra 模块使用到\n * yudao-spring-boot-starter-captcha 组件：自 2.0.1 版本，合并到 yudao-module-system-biz 模块的 framework/captcha 包下，一方面减少 starter 提升编译速度，一方面只有 system 模块使用到\n * yudao-spring-boot-starter-flowable 组件：自 2.0.1 版本，合并到 yudao-module-bpm-biz 模块的 framework/flowable 包下，一方面减少 starter 提升编译速度，一方面只有 bpm 模块使用到\n\n② 业务组件：业务相关的组件封装，例如说数据字典、操作日志等等。如果是业务组件，名字会包含 biz 关键字。\n\nmaven module                                    作用\nyudao-spring-boot-starter-biz-tenant            saas 多租户\nyudao-spring-boot-starter-biz-data-permission   数据权限\nyudao-spring-boot-starter-biz-operatelog        操作日志\nyudao-spring-boot-starter-biz-pay               支付客户端，对接微信支付、支付宝等支付平台\nyudao-spring-boot-starter-biz-ip                地区 & ip 库\n\n友情提示：\n\n * yudao-spring-boot-starter-biz-operatelog 组件：自 2.1.0 版本，合并到 yudao-spring-boot-starter-security 组件的 operatelog 包下，主要减少 starter 提升编译速度\n\n----------------------------------------\n\n每个组件，包含两部分：\n\n 1. core 包：组件的核心封装，拓展相关的功能。\n 2. config 包：组件的 spring boot 自动配置。\n\n\n\n\n# 3. yudao-module-xxx\n\n该模块是 xxx 功能的 module 模块，目前内置了 8 个模块。\n\n项目                    说明       是否必须\nyudao-module-system   系统功能     √\nyudao-module-infra    基础设施     √\nyudao-module-member   会员中心     x\nyudao-module-bpm      工作流程     x\nyudao-module-pay      支付系统     x\nyudao-module-report   大屏报表     x\nyudao-module-mall     商城系统     x\nyudao-module-erp      erp 系统   x\nyudao-module-crm      crm 系统   x\nyudao-module-ai       ai 大模型   x\nyudao-module-mp       微信公众号    x\n\n----------------------------------------\n\n每个模块包含两个 maven module，分别是：\n\nmaven module           作用\nyudao-module-xxx-api   提供给其它模块的 api 定义\nyudao-module-xxx-biz   模块的功能的具体实现\n\n例如说，yudao-module-infra 想要访问 yudao-module-system 的用户、部门等数据，需要引入 yudao-module-system-api 子模块。示例如下：\n\n\n\n疑问：为什么设计 `yudao-module-xxx-api` 模块呢？\n\n 1. 明确需要提供给其它模块的 api 定义，方便未来迁移微服务架构。\n 2. 模块之间可能会存在相互引用的情况，虽然说从系统设计上要尽量避免，但是有时在快速迭代的情况下，可能会出现。此时，通过只引用对方模块的 api 子模块，解决相互引用导致 maven 无法打包的问题。\n\nyudao-module-xxx-api 子模块的项目结构如下：\n\n\n\n所在包     类                      作用                            示例\napi     api 接口                 提供给其它模块的 api 接口               adminuserapi\napi     dto 类                  api 接口的入参 reqdto、出参 respdto   loginlogcreatereqdto deptrespdto\nenums   enum 类                 字段的枚举                         loginlogtypeenum\nenums   dicttypeconstants 类    数据字典的枚举                       dicttypeconstants\nenums   errorcodeconstants 类   错误码的枚举                        errorcodeconstants\n\nyudao-module-xxx-biz 子模块的项目结构如下：\n\n\n\n所在包               类                        作用                                           示例\napi               apiimpl 类                提供给其它模块的 api 实现类                             adminuserapiimpl\ncontroler.admin   controller 类             提供给管理后台的 restful api，默认以 admin-api/ 作为前缀。    authcontroller\n                                           例如 admin-api/system/auth/login 登录接口\ncontroler.admin   vo 类                     admin controller 接口的入参 reqvo、出参 respvo       authloginreqvo authloginrespvo\ncontroler.app     controller 类，以 app 为前缀   提供给用户 app 的 restful api，默认以 app-api/ 作为前缀。   appauthcontroller\n                                           例如 app-api/member/auth/login 登录接口\ncontroler.app     vo 类，以 app 为前缀           app controller 接口的入参 reqvo、出参 respvo         appauthloginreqvo appauthloginrespvo\ncontroler         .http 文件                 idea http client 插件，模拟请求 restful 接口          authcontroller.http\nservice           service 接口               业务逻辑的接口定义                                    adminuserservice\nservice           serviceimpl 类            业务逻辑的实现类                                     adminuserserviceimpl\ndal               -                        data access layer，数据访问层                      \ndal.dataobject    do 类                     data object，映射数据库表、或者 redis 对象               adminuserdo\ndal.mysql         mapper 接口                数据库的操作                                       adminusermapper\ndal.redis         redisdao 类               redis 的操作                                    loginuserredisdao\nconvert           convert 接口               dto / vo / do 等对象之间的转换器                      userconvert\njob               job 类                    定时任务                                         demojob\nmq                -                        message queue，消息队列                           \nmq.message        message 类                发送和消费的消息                                     smssendmessage\nmq.producer       producer 类               消息的生产者                                       smsproducer\nmq.consumer       producer 类               消息的消费者                                       smssendconsumer\nframework         -                        模块自身的框架封装                                    framework\n\n疑问：为什么 controller 分成 admin 和 app 两种？\n\n提供给 admin 和 app 的 restful api 接口是不同的，拆分后更加清晰。\n\n疑问：为什么 vo 分成 admin 和 app 两种？\n\n相同功能的 restful api 接口，对于 admin 和 app 传入的参数、返回的结果都可能是不同的。例如说，admin 查询某个用户的基本信息时，可以返回全部字段；而 app 查询时，不会返回 mobile 手机等敏感字段。\n\n疑问：为什么 do 不作为 controller 的出入参？\n\n 1. 明确每个 restful api 接口的出入参。例如说，创建部门时，只需要传入 name、parentid 字段，使用 do 接参就会导致 type、createtime、creator 等字段可以被传入，导致前端同学一脸懵逼。\n 2. 每个 restful api 有自己独立的 vo，可以更好的设置 swagger 注解、validator 校验规则，而让 do 保持整洁，专注映射好数据库表。\n\n疑问：为什么操作 redis 需要通过 redisdao？\n\nservice 直接使用 redistemplate 操作 redis，导致大量 redis 的操作细节和业务逻辑杂糅在一起，导致代码不够整洁。通过 redisdao 类，将每个 redis key 像一个数据表一样对待，清晰易维护。\n\n总结来说，每个模块采用三层架构 + 非严格分层，如下图所示：\n\n\n\n疑问：如果 message 需要跨模块共享，类似 api 的效果，可以怎么做？\n\n可以在 yudao-module-xxx-api 子模块下，新建一个 message 包，可参考 memberusercreatemessage 类。\n\n\n# 4. yudao-server\n\n该模块是后端 server 的主项目，通过引入需要 yudao-module-xxx 业务模块，从而实现提供 restful api 给 yudao-ui-admin-vue3、yudao-mall-uniapp 等前端项目。\n\n本质上来说，它就是个空壳（容器）！如下图所示：\n\n\n\n\n# 👾 前端结构\n\n前端一共有六个项目，分别是：\n\n项目                      说明\nyudao-ui-admin-vue3     基于 vue3 + element-plus 实现的管理后台\nyudao-ui-admin-vben     基于 vue3 + vben(ant-design-vue) 实现的管理后台\nyudao-ui-admin-vue2     基于 vue2 + element-ui 实现的管理后台\nyudao-ui-go-view        基于 vue3 + naive-ui 实现的大屏报表\nyudao-ui-admin-uniapp   基于 uni-app + uni-ui 实现的管理后台的小程序\nyudao-mall-uniapp       基于 uni-app + uview 实现的用户 app\n\n\n# 1. yudao-ui-admin-vue3\n\n.\n├── .github # github workflows 相关\n├── .husky # husky 配置\n├── .vscode # vscode 配置\n├── mock # 自定义 mock 数据及配置\n├── public # 静态资源\n├── src # 项目代码\n│   ├── api # api接口管理\n│   ├── assets # 静态资源\n│   ├── components # 公用组件\n│   ├── hooks # 常用hooks\n│   ├── layout # 布局组件\n│   ├── locales # 语言文件\n│   ├── plugins # 外部插件\n│   ├── router # 路由配置\n│   ├── store # 状态管理\n│   ├── styles # 全局样式\n│   ├── utils # 全局工具类\n│   ├── views # 路由页面\n│   ├── app.vue # 入口vue文件\n│   ├── main.ts # 主入口文件\n│   └── permission.ts # 路由拦截\n├── types # 全局类型\n├── .env.base # 本地开发环境 环境变量配置\n├── .env.dev # 打包到开发环境 环境变量配置\n├── .env.gitee # 针对 gitee 的环境变量 可忽略\n├── .env.pro # 打包到生产环境 环境变量配置\n├── .env.test # 打包到测试环境 环境变量配置\n├── .eslintignore # eslint 跳过检测配置\n├── .eslintrc.js # eslint 配置\n├── .gitignore # git 跳过配置\n├── .prettierignore # prettier 跳过检测配置\n├── .stylelintignore # stylelint 跳过检测配置\n├── .versionrc 自动生成版本号及更新记录配置\n├── changelog.md # 更新记录\n├── commitlint.config.js # git commit 提交规范配置\n├── index.html # 入口页面\n├── package.json\n├── .postcssrc.js # postcss 配置\n├── prettier.config.js # prettier 配置\n├── readme.md # 英文 readme\n├── readme.zh-cn.md # 中文 readme\n├── stylelint.config.js # stylelint 配置\n├── tsconfig.json # typescript 配置\n├── vite.config.ts # vite 配置\n└── windi.config.ts # windicss 配置\n\n\n\n# 2. yudao-ui-admin-vben\n\n.\n├── build # 打包脚本相关\n│   ├── config # 配置文件\n│   ├── generate # 生成器\n│   ├── script # 脚本\n│   └── vite # vite配置\n├── mock # mock文件夹\n├── public # 公共静态资源目录\n├── src # 主目录\n│   ├── api # 接口文件\n│   ├── assets # 资源文件\n│   │   ├── icons # icon sprite 图标文件夹\n│   │   ├── images # 项目存放图片的文件夹\n│   │   └── svg # 项目存放svg图片的文件夹\n│   ├── components # 公共组件\n│   ├── design # 样式文件\n│   ├── directives # 指令\n│   ├── enums # 枚举/常量\n│   ├── hooks # hook\n│   │   ├── component # 组件相关hook\n│   │   ├── core # 基础hook\n│   │   ├── event # 事件相关hook\n│   │   ├── setting # 配置相关hook\n│   │   └── web # web相关hook\n│   ├── layouts # 布局文件\n│   │   ├── default # 默认布局\n│   │   ├── iframe # iframe布局\n│   │   └── page # 页面布局\n│   ├── locales # 多语言\n│   ├── logics # 逻辑\n│   ├── main.ts # 主入口\n│   ├── router # 路由配置\n│   ├── settings # 项目配置\n│   │   ├── componentsetting.ts # 组件配置\n│   │   ├── designsetting.ts # 样式配置\n│   │   ├── encryptionsetting.ts # 加密配置\n│   │   ├── localesetting.ts # 多语言配置\n│   │   ├── projectsetting.ts # 项目配置\n│   │   └── sitesetting.ts # 站点配置\n│   ├── store # 数据仓库\n│   ├── utils # 工具类\n│   └── views # 页面\n├── test # 测试\n│   └── server # 测试用到的服务\n│       ├── api # 测试服务器\n│       ├── upload # 测试上传服务器\n│       └── websocket # 测试ws服务器\n├── types # 类型文件\n├── vite.config.ts # vite配置文件\n└── windi.config.ts # windcss配置文件\n\n\n\n# 3. yudao-admin-ui\n\n├── bin                        // 执行脚本\n├── build                      // 构建相关  \n├── public                     // 公共文件\n│   ├── favicon.ico            // favicon 图标\n│   └── index.html             // html 模板\n│   └── robots.txt             // 反爬虫\n├── src                        // 源代码\n│   ├── api                    // 所有请求【重要】\n│   ├── assets                 // 主题、字体等静态资源\n│   ├── components             // 全局公用组件\n│   ├── directive              // 全局指令\n│   ├── icons                  // 图标\n│   ├── layout                 // 布局\n│   ├── plugins                // 插件\n│   ├── router                 // 路由\n│   ├── store                  // 全局 store 管理\n│   ├── utils                  // 全局公用方法\n│   ├── views                  // 视图【重要】\n│   ├── app.vue                // 入口页面\n│   ├── main.js                // 入口 js，加载组件、初始化等\n│   ├── permission.js          // 权限管理\n│   └── settings.js            // 系统配置\n├── .editorconfig              // 编码格式\n├── .env.development           // 开发环境配置\n├── .env.production            // 生产环境配置\n├── .env.staging               // 测试环境配置\n├── .eslintignore              // 忽略语法检查\n├── .eslintrc.js               // eslint 配置项\n├── .gitignore                 // git 忽略项\n├── babel.config.js            // babel.config.js\n├── package.json               // package.json\n└── vue.config.js              // vue.config.js\n\n\n\n# 4. yudao-admin-ui-uniapp\n\ntodo 待补充\n\n\n# 5. yudao-mall-uniapp\n\n├── pages                   // 页面\n│      ├── index            // 入口页面\n│      ├── user             // 用户相关\n│      ├── public           // 公共页面\n│      ├── activity         // 活动页面\n│      ├── app              // 积分、签到页面\n│      ├── chat             // 客服页面\n│      ├── commission       // 分销页面\n│      ├── coupon           // 优惠券页面\n│      ├── goods            // 商品页面\n│      ├── order            // 订单页面\n│      ├── pay              // 支付页面\n├── sheep                   // 底层依赖/工具库\n│      ├── api              // 服务端接口\n│      ├── components       // 自定义功能组件\n│      ├── config           // 配置文件\n│      ├── helper           // 助手函数\n│      ├── hooks            // vue-hooks\n│      ├── libs             // 自定义依赖\n│      ├── platform         // 第三方平台登录、分享、支付\n│      ├── request          // 请求类库\n│      ├── router           // 自定义路由跳转\n│      ├── scss             // 主样式库\n│      ├── store            // pinia状态管理模块\n│      ├── ui               // 自定义ui组件\n│      ├── url              // cdn图片地址格式化\n│      ├── validate         // 通用验证器\n│      ├── index.js         // shopro入口文件\n├── uni_modules             // dcloud第三方插件\n\n\n\n# 6. yudao-ui-go-view\n\ntodo 待补充",
            charsets: {
                cjk: !0
            }
        }, {
            title: "代码热加载",
            frontmatter: {
                title: "代码热加载",
                permalink: "/dev-hot-swap/",
                date: "2022-03-02T21:26:49.000Z"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/01.%E8%90%8C%E6%96%B0%E5%BF%85%E8%AF%BB/10.%E4%BB%A3%E7%A0%81%E7%83%AD%E5%8A%A0%E8%BD%BD.html",
            relativePath: "01.开发指南/01.萌新必读/10.代码热加载.md",
            key: "v-bc6df3f8",
            path: "/dev-hot-swap/",
            headers: [{
                level: 2,
                title: "1. spring-boot-devtools",
                slug: "_1-spring-boot-devtools",
                normalizedTitle: "1. spring-boot-devtools",
                charIndex: 205
            }, {
                level: 2,
                title: "2. IDEA 自带 HowSwap 功能",
                slug: "_2-idea-自带-howswap-功能",
                normalizedTitle: "2. idea 自带 howswap 功能",
                charIndex: 235
            }, {
                level: 3,
                title: "2.1 如何使用",
                slug: "_2-1-如何使用",
                normalizedTitle: "2.1 如何使用",
                charIndex: 504
            }, {
                level: 3,
                title: "2.2 存在问题",
                slug: "_2-2-存在问题",
                normalizedTitle: "2.2 存在问题",
                charIndex: 638
            }, {
                level: 2,
                title: "3. JRebel 插件【最推荐】",
                slug: "_3-jrebel-插件【最推荐】",
                normalizedTitle: "3. jrebel 插件【最推荐】",
                charIndex: 262
            }, {
                level: 3,
                title: "3.1 如何安装",
                slug: "_3-1-如何安装",
                normalizedTitle: "3.1 如何安装",
                charIndex: 889
            }, {
                level: 3,
                title: "3.2 如何使用",
                slug: "_3-2-如何使用",
                normalizedTitle: "3.2 如何使用",
                charIndex: 1476
            }],
            headersStr: "1. spring-boot-devtools 2. IDEA 自带 HowSwap 功能 2.1 如何使用 2.2 存在问题 3. JRebel 插件【最推荐】 3.1 如何安装 3.2 如何使用",
            content: "在日常开发中，我们需要经常修改 Java 代码，手动重启项目，查看修改后的效果。如果在项目小时，重启速度比较快，等待的时间是较短的。但是随着项目逐渐变大，重启的速度变慢，等待时间 1-2 min 是比较常见的。\n\n这样就导致我们开发效率降低，影响我们的下班时间，哈哈哈~\n\n那么是否有方式能够实现，在我们修改完 Java 代码之后，能够不重启项目呢？答案是有的，通过 代码热加载 的方式。实现方案有三种：\n\n 1. spring-boot-devtools【不推荐】\n 2. IDEA 自带 HowSwap 功能【推荐】\n 3. JRebel 插件【最推荐】\n\n\n# 1. spring-boot-devtools\n\nspring-boot-devtools 是 Spring Boot 提供的开发者工具，它会监控当前应用所在的 classpath 下的文件发生变化，进行自动重启。\n\ndevtools 存在重启速度较慢的问题，所以不推荐！\n\n\n# 2. IDEA 自带 HowSwap 功能\n\n该功能是 IDEA Ultimate 旗舰版的专属功能，不支持 IDEA Community 社区版。\n\n\n# 2.1 如何使用\n\n① 设置 Spring Boot 启动类，开启 HotSwap 功能。如下图所示：\n\n\n\n② Debug 运行该启动类，等待项目启动完成。\n\n③ 每次修改 Java 代码后，点击左下角的「热加载」按钮，即可实现代码热加载。如下图所示：\n\n\n\n\n# 2.2 存在问题\n\nIDEA 自带 HowSwap 功能，支持比较有限，很多修改都不支持。例如说：\n\n * 只能增加方法或字段但不可以减少方法或字段\n * 只能增加可见性不能减少\n * 只能维持已有方法的签名而不能修改等等。\n\n你可以认为，只支持方法内的代码修改热加载。\n\n如果想要相对完美的方案，建议使用 JRebel 插件。\n\n\n# 3. JRebel 插件【最推荐】\n\nJRebel 插件是目前最好用的热加载插件，它支持 IDEA Ultimate 旗舰版、Community 社区版。\n\n\n# 3.1 如何安装\n\n友情提示：不同的 JetBrains 版本，JRebel 插件的激活方式不同：\n\n * 2022.4.1 版本：阅读本文即可。\n * 2024.1.2 版本：https://www.cnblogs.com/Flat-White/p/18090651 （别的版本，应该也可以）\n\n① 点击 https://plugins.jetbrains.com/plugin/4441-jrebel-and-xrebel/versions 地址，必须下载 2022.4.1 版本。如下图所示：\n\n\n\n② 打开 [Preference -> Plugins] 菜单，点击「Install Plugin from Disk...」按钮，选择刚下载的 JRebel 插件的压缩包。如下图所示：\n\n\n\n安装完成后，需要重启 IDEA 生效。\n\n③ 打开 [Preference -> JRebel & XRebel] 菜单，输入 GUID address 为 https://jrebel.qekang.com/1e67ec1b-122f-4708-87d0-c1995dc0cdaa ，邮件随便写，完成 JRebel 的激活。如下图所示：\n\n\n\n之后，点击「Work Offline」按钮，设置 JRebel 为离线，避免因为网络问题导致激活失效。如下图所示：\n\n\n\n\n# 3.2 如何使用\n\n① 点击「Debug With JRebel」按钮，使用 JRebel 启动项目。如下图所示：\n\n\n\n② 每次修改 Java 代码后，点击左下角的「热加载」按钮，即可实现代码热加载。如下图所示：\n\n",
            normalizedContent: "在日常开发中，我们需要经常修改 java 代码，手动重启项目，查看修改后的效果。如果在项目小时，重启速度比较快，等待的时间是较短的。但是随着项目逐渐变大，重启的速度变慢，等待时间 1-2 min 是比较常见的。\n\n这样就导致我们开发效率降低，影响我们的下班时间，哈哈哈~\n\n那么是否有方式能够实现，在我们修改完 java 代码之后，能够不重启项目呢？答案是有的，通过 代码热加载 的方式。实现方案有三种：\n\n 1. spring-boot-devtools【不推荐】\n 2. idea 自带 howswap 功能【推荐】\n 3. jrebel 插件【最推荐】\n\n\n# 1. spring-boot-devtools\n\nspring-boot-devtools 是 spring boot 提供的开发者工具，它会监控当前应用所在的 classpath 下的文件发生变化，进行自动重启。\n\ndevtools 存在重启速度较慢的问题，所以不推荐！\n\n\n# 2. idea 自带 howswap 功能\n\n该功能是 idea ultimate 旗舰版的专属功能，不支持 idea community 社区版。\n\n\n# 2.1 如何使用\n\n① 设置 spring boot 启动类，开启 hotswap 功能。如下图所示：\n\n\n\n② debug 运行该启动类，等待项目启动完成。\n\n③ 每次修改 java 代码后，点击左下角的「热加载」按钮，即可实现代码热加载。如下图所示：\n\n\n\n\n# 2.2 存在问题\n\nidea 自带 howswap 功能，支持比较有限，很多修改都不支持。例如说：\n\n * 只能增加方法或字段但不可以减少方法或字段\n * 只能增加可见性不能减少\n * 只能维持已有方法的签名而不能修改等等。\n\n你可以认为，只支持方法内的代码修改热加载。\n\n如果想要相对完美的方案，建议使用 jrebel 插件。\n\n\n# 3. jrebel 插件【最推荐】\n\njrebel 插件是目前最好用的热加载插件，它支持 idea ultimate 旗舰版、community 社区版。\n\n\n# 3.1 如何安装\n\n友情提示：不同的 jetbrains 版本，jrebel 插件的激活方式不同：\n\n * 2022.4.1 版本：阅读本文即可。\n * 2024.1.2 版本：https://www.cnblogs.com/flat-white/p/18090651 （别的版本，应该也可以）\n\n① 点击 https://plugins.jetbrains.com/plugin/4441-jrebel-and-xrebel/versions 地址，必须下载 2022.4.1 版本。如下图所示：\n\n\n\n② 打开 [preference -> plugins] 菜单，点击「install plugin from disk...」按钮，选择刚下载的 jrebel 插件的压缩包。如下图所示：\n\n\n\n安装完成后，需要重启 idea 生效。\n\n③ 打开 [preference -> jrebel & xrebel] 菜单，输入 guid address 为 https://jrebel.qekang.com/1e67ec1b-122f-4708-87d0-c1995dc0cdaa ，邮件随便写，完成 jrebel 的激活。如下图所示：\n\n\n\n之后，点击「work offline」按钮，设置 jrebel 为离线，避免因为网络问题导致激活失效。如下图所示：\n\n\n\n\n# 3.2 如何使用\n\n① 点击「debug with jrebel」按钮，使用 jrebel 启动项目。如下图所示：\n\n\n\n② 每次修改 java 代码后，点击左下角的「热加载」按钮，即可实现代码热加载。如下图所示：\n\n",
            charsets: {
                cjk: !0
            }
        }, {
            title: "一键改包",
            frontmatter: {
                title: "一键改包",
                date: "2022-03-27T12:37:40.000Z",
                permalink: "/project-rename"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/01.%E8%90%8C%E6%96%B0%E5%BF%85%E8%AF%BB/11.%E4%B8%80%E9%94%AE%E6%94%B9%E5%8C%85.html",
            relativePath: "01.开发指南/01.萌新必读/11.一键改包.md",
            key: "v-7389e108",
            path: "/project-rename/",
            headers: [{
                level: 2,
                title: "👍 相关视频教程",
                slug: "👍-相关视频教程",
                normalizedTitle: "👍 相关视频教程",
                charIndex: 273
            }, {
                level: 2,
                title: "操作步骤",
                slug: "操作步骤",
                normalizedTitle: "操作步骤",
                charIndex: 304
            }],
            headersStr: "👍 相关视频教程 操作步骤",
            content: "项目提供了 ProjectReactor 程序，支持一键改包，包括 Maven 的 groupId、artifactId、Java 的根 package、前端的 title、数据库的 SQL 配置、应用的 application.yaml 配置文件等等。效果如下图所示：\n\n\n\n友情提示：修改包名后，未来合并最新的代码可能会有一定的成本。\n\n主要有两点原因：\n\n * ① 改包后，无法继续通过 git pull 拉取最新代码\n * ② 市面上没有合适的工具，合并改包后的代码\n\n这个存在于所有开源项目，不属于本项目的问题，希望可以理解！\n\n\n# 👍 相关视频教程\n\n * 08、如何实现一键改包？\n\n\n# 操作步骤\n\n① 第一步，使用 IDEA 克隆 https://github.com/YunaiV/ruoyi-vue-pro 仓库的最新代码，并给该仓库一个 Star。\n\n② 第二步，打开 ProjectReactor 类，填写 groupIdNew、artifactIdNew、packageNameNew、titleNew 属性。如下图所示：\n\n\n\n③ 第三步，执行 ProjectReactor 的 #main(String[] args) 方法，它会基于当前项目，复制一个新项目到 projectBaseDirNew 目录，并进行相关的改名逻辑。\n\n13:02:36.765 [main] INFO cn.iocoder.yudao.ProjectReactor - [main][开始获得需要重写的文件]\n13:02:41.530 [main] INFO cn.iocoder.yudao.ProjectReactor - [main][需要重写的文件数量：2825，预计需要 5-10 秒]\n13:02:45.799 [main] INFO cn.iocoder.yudao.ProjectReactor - [main][重写完成]\n\n\n④ 第四步，使用 IDEA 打开 projectBaseDirNew 目录，参考 《开发指南 —— 快速启动》 文档，进行项目的启动。注意，一定要重新执行 SQL 的导入！！！\n\n----------------------------------------\n\n整个过程非常简单，如果碰到问题，请添加项目的技术交流群。\n\n> ↓↓↓ 技术交流群，一起苦练技术基本功，每日精进 30 公里！↓↓↓\n\n",
            normalizedContent: "项目提供了 projectreactor 程序，支持一键改包，包括 maven 的 groupid、artifactid、java 的根 package、前端的 title、数据库的 sql 配置、应用的 application.yaml 配置文件等等。效果如下图所示：\n\n\n\n友情提示：修改包名后，未来合并最新的代码可能会有一定的成本。\n\n主要有两点原因：\n\n * ① 改包后，无法继续通过 git pull 拉取最新代码\n * ② 市面上没有合适的工具，合并改包后的代码\n\n这个存在于所有开源项目，不属于本项目的问题，希望可以理解！\n\n\n# 👍 相关视频教程\n\n * 08、如何实现一键改包？\n\n\n# 操作步骤\n\n① 第一步，使用 idea 克隆 https://github.com/yunaiv/ruoyi-vue-pro 仓库的最新代码，并给该仓库一个 star。\n\n② 第二步，打开 projectreactor 类，填写 groupidnew、artifactidnew、packagenamenew、titlenew 属性。如下图所示：\n\n\n\n③ 第三步，执行 projectreactor 的 #main(string[] args) 方法，它会基于当前项目，复制一个新项目到 projectbasedirnew 目录，并进行相关的改名逻辑。\n\n13:02:36.765 [main] info cn.iocoder.yudao.projectreactor - [main][开始获得需要重写的文件]\n13:02:41.530 [main] info cn.iocoder.yudao.projectreactor - [main][需要重写的文件数量：2825，预计需要 5-10 秒]\n13:02:45.799 [main] info cn.iocoder.yudao.projectreactor - [main][重写完成]\n\n\n④ 第四步，使用 idea 打开 projectbasedirnew 目录，参考 《开发指南 —— 快速启动》 文档，进行项目的启动。注意，一定要重新执行 sql 的导入！！！\n\n----------------------------------------\n\n整个过程非常简单，如果碰到问题，请添加项目的技术交流群。\n\n> ↓↓↓ 技术交流群，一起苦练技术基本功，每日精进 30 公里！↓↓↓\n\n",
            charsets: {
                cjk: !0
            }
        }, {
            title: "迁移模块（适合新项目）",
            frontmatter: {
                title: "迁移模块（适合新项目）",
                date: "2024-05-01T00:41:36.000Z",
                permalink: "/migrate-module/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/01.%E8%90%8C%E6%96%B0%E5%BF%85%E8%AF%BB/12.%E8%BF%81%E7%A7%BB%E6%A8%A1%E5%9D%97.html",
            relativePath: "01.开发指南/01.萌新必读/12.迁移模块.md",
            key: "v-44dfccd2",
            path: "/migrate-module/",
            headers: [{
                level: 2,
                title: "1. 后端代码迁移",
                slug: "_1-后端代码迁移",
                normalizedTitle: "1. 后端代码迁移",
                charIndex: 612
            }, {
                level: 3,
                title: "1.1 迁移步骤",
                slug: "_1-1-迁移步骤",
                normalizedTitle: "1.1 迁移步骤",
                charIndex: 955
            }, {
                level: 3,
                title: "1.2 场景：我要做 BPM 工作流",
                slug: "_1-2-场景-我要做-bpm-工作流",
                normalizedTitle: "1.2 场景：我要做 bpm 工作流",
                charIndex: 1246
            }, {
                level: 3,
                title: "1.3 场景：我要做 CRM 系统",
                slug: "_1-3-场景-我要做-crm-系统",
                normalizedTitle: "1.3 场景：我要做 crm 系统",
                charIndex: 1333
            }, {
                level: 3,
                title: "1.4 场景：我要做 ERP 系统",
                slug: "_1-4-场景-我要做-erp-系统",
                normalizedTitle: "1.4 场景：我要做 erp 系统",
                charIndex: 1490
            }, {
                level: 3,
                title: "1.5 场景：我要做 MALL 商城",
                slug: "_1-5-场景-我要做-mall-商城",
                normalizedTitle: "1.5 场景：我要做 mall 商城",
                charIndex: 1579
            }, {
                level: 3,
                title: "1.6 场景：我要做 REPORT 大屏报表",
                slug: "_1-6-场景-我要做-report-大屏报表",
                normalizedTitle: "1.6 场景：我要做 report 大屏报表",
                charIndex: 1970
            }, {
                level: 3,
                title: "1.7 其它场景补充",
                slug: "_1-7-其它场景补充",
                normalizedTitle: "1.7 其它场景补充",
                charIndex: 2063
            }, {
                level: 2,
                title: "2. 前端代码清理",
                slug: "_2-前端代码清理",
                normalizedTitle: "2. 前端代码清理",
                charIndex: 2381
            }, {
                level: 2,
                title: "3. 数据库清理",
                slug: "_3-数据库清理",
                normalizedTitle: "3. 数据库清理",
                charIndex: 2588
            }, {
                level: 3,
                title: "3.1 清理菜单",
                slug: "_3-1-清理菜单",
                normalizedTitle: "3.1 清理菜单",
                charIndex: 2685
            }, {
                level: 3,
                title: "3.2 字典清理",
                slug: "_3-2-字典清理",
                normalizedTitle: "3.2 字典清理",
                charIndex: 3085
            }],
            headersStr: "1. 后端代码迁移 1.1 迁移步骤 1.2 场景：我要做 BPM 工作流 1.3 场景：我要做 CRM 系统 1.4 场景：我要做 ERP 系统 1.5 场景：我要做 MALL 商城 1.6 场景：我要做 REPORT 大屏报表 1.7 其它场景补充 2. 前端代码清理 3. 数据库清理 3.1 清理菜单 3.2 字典清理",
            content: "系统内置多种多种业务功能，可以用于快速你的业务系统：\n\n\n\n * 通用模块（必选）：系统功能、基础设施\n * 通用模块（可选）：工作流程、支付系统、数据报表、会员中心\n * 业务系统（按需）：ERP 系统、CRM 系统、商城系统、微信公众号\n\n系统分成两个版本：\n\n版本                     JDK 8 + SPRING BOOT 2.7   JDK 17/21 + SPRING BOOT 3.2\n【完整版】ruoyi-vue-pro     master 分支                 master-jdk17 分支\n【精简版】yudao-boot-mini   master 分支                 master-jdk17 分支\n\n * 【完整版】：包括系统功能、基础设施、会员中心、数据报表、工作流程、商城系统、微信公众号、CRM、ERP 等功能\n * 【精简版】：只包括系统功能、基础设施功能，不包括会员中心、数据报表、工作流程、商城系统、微信公众号、CRM、ERP 等功能\n\n参考本文档，只需要 5-10 分钟，即可将【完整版】按需迁移到【精简版】。只需要完成以下 3 个步骤：\n\n * 第一步，后端代码迁移\n * 第二步，前端代码清理\n * 第三步，数据库清理\n\n友情提示：虽然有 3 个步骤，实际只要第一步做完就可以看到效果，候选两步只是为了清理的更干净\n\n\n# 1. 后端代码迁移\n\n后端代码迁移，指的是将【完整版】的代码，复制张贴到【精简版】。\n\n项目                    说明\nyudao-module-member   会员中心的 Module 模块\nyudao-module-pay      支付系统的 Module 模块\nyudao-module-mall     商城系统的 Module 模块\nyudao-module-erp      ERP 系统的 Module 模块\nyudao-module-crm      CRM 系统的 Module 模块\nyudao-module-mp       微信公众号的 Module 模块\nyudao-module-report   大屏报表 Module 模块\n\n\n# 1.1 迁移步骤\n\n① 第一步，选择一个你想要迁移的 Maven 模块的代码，复制粘贴过去。例如说：\n\n\n\n② 第二步（可选），如果迁移的模块有 test 单元测试，需要删除对应的 test 目录，和 yudao-spring-boot-starter-test 依赖，如下图所示：\n\n疑问：为什么要删除 test 目录和依赖呢？\n\n因为【精简版】考虑到大家可能不需要单元测试，所以一并清理了。\n\n----------------------------------------\n\n下面，可以按照你的场景，进行一下操作。\n\n注意！不需要每个场景都操作，只需要你需要的！！！\n\n\n# 1.2 场景：我要做 BPM 工作流\n\n将 yudao-module-bpm 模块，从【完整版】复制到【精简版】。然后参考 《工作流手册》 文档，测试迁移的正确性。\n\n\n# 1.3 场景：我要做 CRM 系统\n\n① 将 yudao-module-bpm 模块，从【完整版】复制到【精简版】。然后参考 《工作流手册》 文档，测试迁移的正确性。\n\n② 将 yudao-module-crm 模块，从【完整版】复制到【精简版】。然后参考 《CRM 系统手册》 文档，测试迁移的正确性。\n\n\n# 1.4 场景：我要做 ERP 系统\n\n将 yudao-module-erp 模块，从【完整版】复制到【精简版】。然后参考 《ERP 系统手册》 文档，测试迁移的正确性。\n\n\n# 1.5 场景：我要做 MALL 商城\n\n① 将 yudao-module-member 模块，从【完整版】复制到【精简版】。然后参考 《会员中心手册》 文档，测试迁移的正确性。\n\n② 将 yudao-module-pay 模块，从【完整版】复制到【精简版】。然后参考 《支付系统手册》 文档，测试迁移的正确性。\n\n③ 将 yudao-module-mall 模块，从【完整版】复制到【精简版】。然后参考 《商城系统手册》 文档，测试迁移的正确性。\n\n友情提示：因为 MALL 商城需要的模块比较多，我们其实也可以基于【完整版】，删除不需要的 Module 模块。\n\n只需要删除 yudao-module-erp、yudao-module-report、yudao-module-mp、yudao-module-bpm、yudao-module-crm 模块，也是蛮方便的！\n\n\n# 1.6 场景：我要做 REPORT 大屏报表\n\n将 yudao-module-report 模块，从【完整版】复制到【精简版】。然后参考 《大屏手册》 文档，测试迁移的正确性。\n\n\n# 1.7 其它场景补充\n\n① 【会员】如果你要给你 C 端（会员）做一个 App 或者 H5，需要使用到「会员」功能，可以将 yudao-module-member 模块，从【完整版】复制到【精简版】。然后参考 《会员中心手册》 文档，测试迁移的正确性。\n\n② 【支付】如果你的系统需要使用到支付宝、微信等支付功能，可以将 yudao-module-pay 模块，从【完整版】复制到【精简版】。然后参考 《支付系统手册》 文档，测试迁移的正确性。\n\n③ 【公众号】如果你的系统需要使用到微信公众号功能，可以将 yudao-module-mp 模块，从【完整版】复制到【精简版】。然后参考 《公众号手册》 文档，测试迁移的正确性。\n\n\n# 2. 前端代码清理\n\n前端仓库，不区分【完整版】【精简版】，因为它本身就比较简单。只需要删除 api 和 views 下面对应的模块即可。如下图所示：\n\n\n\n前端 api 和 views 下面的模块，对应后端的 yudao-module-xxx 模块。所以后端没有迁移的模块，前端也需要删除。\n\n如果碰到 remaining.ts 路由报错，可见 https://t.zsxq.com/69GWJ 帖子！\n\n\n# 3. 数据库清理\n\n数据库的迁移，只设计到两份“配置”表：\n\n * 菜单相关：system_menu\n * 字典相关：system_dict_data、system_dict_type\n\n\n# 3.1 清理菜单\n\n系统的菜单划分，也是按照模块来的。所以只需要删除没迁移的模块的菜单即可。如下图所示：\n\n\n\n可以通过如下 SQL 清理：\n\n# 删除顶级菜单：name 需要换成想要删除模块的菜单名\nDELETE FROM system_menu WHERE name = '支付管理';\n\n# 删除子菜单：多次执行，直到 Affected rows: 0 影响条数为 0\nDELETE FROM system_menu WHERE parent_id NOT IN (SELECT id FROM (SELECT id FROM system_menu) AS TEMP) AND parent_id > 0\n\n# 删除关联表\nDELETE FROM system_role_menu WHERE menu_id NOT IN (SELECT id FROM system_menu)\n\n\n\n# 3.2 字典清理\n\n字典的清理，可以通过 SQL 完成。\n\n# 删除 `yudao-module-member` 不要的字典数据\nDELETE FROM system_dict_type WHERE type LIKE 'member_%';\nDELETE FROM system_dict_data WHERE dict_type LIKE 'member_%';\n\n# 删除 `yudao-module-pay` 不要的字典数据\nDELETE FROM system_dict_type WHERE type LIKE 'pay_%';\nDELETE FROM system_dict_data WHERE dict_type LIKE 'pay_%';\n\n# 删除 `yudao-module-mall` 不要的字典数据\nDELETE FROM system_dict_type WHERE type LIKE 'product_%';\nDELETE FROM system_dict_data WHERE dict_type LIKE 'product_%';\nDELETE FROM system_dict_type WHERE type LIKE 'trade_%';\nDELETE FROM system_dict_data WHERE dict_type LIKE 'trade_%';\nDELETE FROM system_dict_type WHERE type LIKE 'promotion_%';\nDELETE FROM system_dict_data WHERE dict_type LIKE 'promotion_%';\nDELETE FROM system_dict_type WHERE type LIKE 'brokerage_enabled_condition_%';\nDELETE FROM system_dict_data WHERE dict_type LIKE 'brokerage_enabled_condition_%';\n\n# 删除 `yudao-module-erp` 不要的字典数据\nDELETE FROM system_dict_type WHERE type LIKE 'erp_%';\nDELETE FROM system_dict_data WHERE dict_type LIKE 'erp_%';\n\n# 删除 `yudao-module-crm` 不要的字典数据\nDELETE FROM system_dict_type WHERE type LIKE 'crm_%';\nDELETE FROM system_dict_data WHERE dict_type LIKE 'crm_%';\n\n# 删除 `yudao-module-mp` 不要的字典数据\nDELETE FROM system_dict_type WHERE type LIKE 'mp_%';\nDELETE FROM system_dict_data WHERE dict_type LIKE 'mp_%';\n\n# 删除 `yudao-module-report` 不要的字典数据\nDELETE FROM system_dict_type WHERE type LIKE 'report_%';\nDELETE FROM system_dict_data WHERE dict_type LIKE 'report_%';\n",
            normalizedContent: "系统内置多种多种业务功能，可以用于快速你的业务系统：\n\n\n\n * 通用模块（必选）：系统功能、基础设施\n * 通用模块（可选）：工作流程、支付系统、数据报表、会员中心\n * 业务系统（按需）：erp 系统、crm 系统、商城系统、微信公众号\n\n系统分成两个版本：\n\n版本                     jdk 8 + spring boot 2.7   jdk 17/21 + spring boot 3.2\n【完整版】ruoyi-vue-pro     master 分支                 master-jdk17 分支\n【精简版】yudao-boot-mini   master 分支                 master-jdk17 分支\n\n * 【完整版】：包括系统功能、基础设施、会员中心、数据报表、工作流程、商城系统、微信公众号、crm、erp 等功能\n * 【精简版】：只包括系统功能、基础设施功能，不包括会员中心、数据报表、工作流程、商城系统、微信公众号、crm、erp 等功能\n\n参考本文档，只需要 5-10 分钟，即可将【完整版】按需迁移到【精简版】。只需要完成以下 3 个步骤：\n\n * 第一步，后端代码迁移\n * 第二步，前端代码清理\n * 第三步，数据库清理\n\n友情提示：虽然有 3 个步骤，实际只要第一步做完就可以看到效果，候选两步只是为了清理的更干净\n\n\n# 1. 后端代码迁移\n\n后端代码迁移，指的是将【完整版】的代码，复制张贴到【精简版】。\n\n项目                    说明\nyudao-module-member   会员中心的 module 模块\nyudao-module-pay      支付系统的 module 模块\nyudao-module-mall     商城系统的 module 模块\nyudao-module-erp      erp 系统的 module 模块\nyudao-module-crm      crm 系统的 module 模块\nyudao-module-mp       微信公众号的 module 模块\nyudao-module-report   大屏报表 module 模块\n\n\n# 1.1 迁移步骤\n\n① 第一步，选择一个你想要迁移的 maven 模块的代码，复制粘贴过去。例如说：\n\n\n\n② 第二步（可选），如果迁移的模块有 test 单元测试，需要删除对应的 test 目录，和 yudao-spring-boot-starter-test 依赖，如下图所示：\n\n疑问：为什么要删除 test 目录和依赖呢？\n\n因为【精简版】考虑到大家可能不需要单元测试，所以一并清理了。\n\n----------------------------------------\n\n下面，可以按照你的场景，进行一下操作。\n\n注意！不需要每个场景都操作，只需要你需要的！！！\n\n\n# 1.2 场景：我要做 bpm 工作流\n\n将 yudao-module-bpm 模块，从【完整版】复制到【精简版】。然后参考 《工作流手册》 文档，测试迁移的正确性。\n\n\n# 1.3 场景：我要做 crm 系统\n\n① 将 yudao-module-bpm 模块，从【完整版】复制到【精简版】。然后参考 《工作流手册》 文档，测试迁移的正确性。\n\n② 将 yudao-module-crm 模块，从【完整版】复制到【精简版】。然后参考 《crm 系统手册》 文档，测试迁移的正确性。\n\n\n# 1.4 场景：我要做 erp 系统\n\n将 yudao-module-erp 模块，从【完整版】复制到【精简版】。然后参考 《erp 系统手册》 文档，测试迁移的正确性。\n\n\n# 1.5 场景：我要做 mall 商城\n\n① 将 yudao-module-member 模块，从【完整版】复制到【精简版】。然后参考 《会员中心手册》 文档，测试迁移的正确性。\n\n② 将 yudao-module-pay 模块，从【完整版】复制到【精简版】。然后参考 《支付系统手册》 文档，测试迁移的正确性。\n\n③ 将 yudao-module-mall 模块，从【完整版】复制到【精简版】。然后参考 《商城系统手册》 文档，测试迁移的正确性。\n\n友情提示：因为 mall 商城需要的模块比较多，我们其实也可以基于【完整版】，删除不需要的 module 模块。\n\n只需要删除 yudao-module-erp、yudao-module-report、yudao-module-mp、yudao-module-bpm、yudao-module-crm 模块，也是蛮方便的！\n\n\n# 1.6 场景：我要做 report 大屏报表\n\n将 yudao-module-report 模块，从【完整版】复制到【精简版】。然后参考 《大屏手册》 文档，测试迁移的正确性。\n\n\n# 1.7 其它场景补充\n\n① 【会员】如果你要给你 c 端（会员）做一个 app 或者 h5，需要使用到「会员」功能，可以将 yudao-module-member 模块，从【完整版】复制到【精简版】。然后参考 《会员中心手册》 文档，测试迁移的正确性。\n\n② 【支付】如果你的系统需要使用到支付宝、微信等支付功能，可以将 yudao-module-pay 模块，从【完整版】复制到【精简版】。然后参考 《支付系统手册》 文档，测试迁移的正确性。\n\n③ 【公众号】如果你的系统需要使用到微信公众号功能，可以将 yudao-module-mp 模块，从【完整版】复制到【精简版】。然后参考 《公众号手册》 文档，测试迁移的正确性。\n\n\n# 2. 前端代码清理\n\n前端仓库，不区分【完整版】【精简版】，因为它本身就比较简单。只需要删除 api 和 views 下面对应的模块即可。如下图所示：\n\n\n\n前端 api 和 views 下面的模块，对应后端的 yudao-module-xxx 模块。所以后端没有迁移的模块，前端也需要删除。\n\n如果碰到 remaining.ts 路由报错，可见 https://t.zsxq.com/69gwj 帖子！\n\n\n# 3. 数据库清理\n\n数据库的迁移，只设计到两份“配置”表：\n\n * 菜单相关：system_menu\n * 字典相关：system_dict_data、system_dict_type\n\n\n# 3.1 清理菜单\n\n系统的菜单划分，也是按照模块来的。所以只需要删除没迁移的模块的菜单即可。如下图所示：\n\n\n\n可以通过如下 sql 清理：\n\n# 删除顶级菜单：name 需要换成想要删除模块的菜单名\ndelete from system_menu where name = '支付管理';\n\n# 删除子菜单：多次执行，直到 affected rows: 0 影响条数为 0\ndelete from system_menu where parent_id not in (select id from (select id from system_menu) as temp) and parent_id > 0\n\n# 删除关联表\ndelete from system_role_menu where menu_id not in (select id from system_menu)\n\n\n\n# 3.2 字典清理\n\n字典的清理，可以通过 sql 完成。\n\n# 删除 `yudao-module-member` 不要的字典数据\ndelete from system_dict_type where type like 'member_%';\ndelete from system_dict_data where dict_type like 'member_%';\n\n# 删除 `yudao-module-pay` 不要的字典数据\ndelete from system_dict_type where type like 'pay_%';\ndelete from system_dict_data where dict_type like 'pay_%';\n\n# 删除 `yudao-module-mall` 不要的字典数据\ndelete from system_dict_type where type like 'product_%';\ndelete from system_dict_data where dict_type like 'product_%';\ndelete from system_dict_type where type like 'trade_%';\ndelete from system_dict_data where dict_type like 'trade_%';\ndelete from system_dict_type where type like 'promotion_%';\ndelete from system_dict_data where dict_type like 'promotion_%';\ndelete from system_dict_type where type like 'brokerage_enabled_condition_%';\ndelete from system_dict_data where dict_type like 'brokerage_enabled_condition_%';\n\n# 删除 `yudao-module-erp` 不要的字典数据\ndelete from system_dict_type where type like 'erp_%';\ndelete from system_dict_data where dict_type like 'erp_%';\n\n# 删除 `yudao-module-crm` 不要的字典数据\ndelete from system_dict_type where type like 'crm_%';\ndelete from system_dict_data where dict_type like 'crm_%';\n\n# 删除 `yudao-module-mp` 不要的字典数据\ndelete from system_dict_type where type like 'mp_%';\ndelete from system_dict_data where dict_type like 'mp_%';\n\n# 删除 `yudao-module-report` 不要的字典数据\ndelete from system_dict_type where type like 'report_%';\ndelete from system_dict_data where dict_type like 'report_%';\n",
            charsets: {
                cjk: !0
            }
        }, {
            title: "删除功能（以租户为例）",
            frontmatter: {
                title: "删除功能（以租户为例）",
                date: "2022-10-17T21:31:58.000Z",
                permalink: "/delete-code"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/01.%E8%90%8C%E6%96%B0%E5%BF%85%E8%AF%BB/13.%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD.html",
            relativePath: "01.开发指南/01.萌新必读/13.删除功能.md",
            key: "v-2bac80ba",
            path: "/delete-code/",
            headers: [{
                level: 2,
                title: "👍 相关视频教程",
                slug: "👍-相关视频教程",
                normalizedTitle: "👍 相关视频教程",
                charIndex: 394
            }, {
                level: 2,
                title: "删除「多租户」功能",
                slug: "删除「多租户」功能",
                normalizedTitle: "删除「多租户」功能",
                charIndex: 434
            }, {
                level: 3,
                title: "第一步，删除菜单",
                slug: "第一步-删除菜单",
                normalizedTitle: "第一步，删除菜单",
                charIndex: 482
            }, {
                level: 3,
                title: "第二步，删除数据库表",
                slug: "第二步-删除数据库表",
                normalizedTitle: "第二步，删除数据库表",
                charIndex: 530
            }, {
                level: 3,
                title: "第三步，删除后端代码",
                slug: "第三步-删除后端代码",
                normalizedTitle: "第三步，删除后端代码",
                charIndex: 598
            }, {
                level: 3,
                title: "第四步，删除前端代码",
                slug: "第四步-删除前端代码",
                normalizedTitle: "第四步，删除前端代码",
                charIndex: 1747
            }, {
                level: 3,
                title: "第五步，测试验收",
                slug: "第五步-测试验收",
                normalizedTitle: "第五步，测试验收",
                charIndex: 2097
            }, {
                level: 2,
                title: "更多...",
                slug: "更多",
                normalizedTitle: "更多...",
                charIndex: 2171
            }],
            headersStr: "👍 相关视频教程 删除「多租户」功能 第一步，删除菜单 第二步，删除数据库表 第三步，删除后端代码 第四步，删除前端代码 第五步，测试验收 更多...",
            content: "项目内置功能较多，会存在一些你可能用不到的功能。一般的情况下，建议通过设置该功能对应的菜单为【禁用】，实现功能的“删除”。如下图所示：\n\n\n\n后续，如果你又需要使用到该功能，只需要设置该功能对应的菜单为【开启】即可。\n\n🙂 当然，如果你希望彻底删除功能，那么就需要采用删除代码的方式。整个过程如下：\n\n① 【菜单】第一步，使用管理后台的菜单管理，删除对应的菜单、按钮。\n② 【数据库表】第二步，删除对应的数据库表。\n③ 【后端代码】第三步，删除对应的 Controller、Service、数据库实体等后端代码；然后启动后端项目，若存在代码报错，则继续删除相关联的代码，之后如此反复，直到成功。\n④ 【前端代码】第四步，删除对应的 View 和 API 等前端代码；然后启动前端项目，若存在代码报错，则继续删除相关联的代码，之后如此反复，直到成功。\n\n下面，我们来举一些例子。\n\n\n# 👍 相关视频教程\n\n * 从零开始 07：如何有效的删除不用的功能？\n\n\n# 删除「多租户」功能\n\n * 对应功能的文档：多租户\n * 对应的关键字是 tenant\n\n\n# 第一步，删除菜单\n\n删除“租户管理“下的所有菜单，从最里层的按钮开始。如下图所示：\n\n\n\n\n# 第二步，删除数据库表\n\n删除 system_tenant 和 system_tenant_package 表。如下图所示：\n\n\n\n\n# 第三步，删除后端代码\n\n① 删除 yudao-module-system-api 模块的 api/tenant 包。\n\n② 删除 yudao-module-system-api 模块的 ErrorCodeConstants 类中，和租户、租户套餐相关的错误码。如下图所示：\n\n\n\n如果想删除的更干净，可以把 system_error_code 表中，对应编号的错误码也都删除一下。\n\n③ 删除 yudao-module-system-biz 模块的如下包：\n\n * api/tenant\n * controller/admin/tenant\n * service/tenant\n * test/service/tenant\n * dal/dataobject/tenant\n * dal/mysql/tenant\n * convert/tenant\n\n④ 删除 yudao-spring-boot-starter-biz-tenant 模块。\n\n然后，使用 IDEA 搜索 yudao-spring-boot-starter-biz-tenant 关键字，删除 Maven 中所有对它的定义与引用。如下图所示：\n\n\n\n之后，使用 IDEA 刷新下 Maven 依赖。如下图所示：\n\n\n\n⑤ 运行 YudaoServerApplication 启动类，会报 cn.iocoder.yudao.framework.tenant.core.db 不存在的错误，需要将继承 TenantBaseDO 的数据库实体，都改成继承 BaseDO 基类。\n\n\n\n⑥ 运行 YudaoServerApplication 启动类，会报 cn.iocoder.yudao.framework.tenant.core.aop 不存在的错误，需要去除对 @TenantIgnore 注解的使用。如下图所示：\n\n\n\n⑦ 运行 YudaoServerApplication 启动类，会报 cn.iocoder.yudao.module.system.service.tenant 不存在的错误，需要去除对 TenantService 的使用。如下图所示：\n\n\n\n⑧ 运行 YudaoServerApplication 启动类，会报 cn.iocoder.yudao.framework.tenant.core.context 不存在的错误，需要去除对 TenantContextHolder 的使用。如下图所示：\n\n\n\n⑨ 运行 YudaoServerApplication 启动类，终于成功了！！！\n\nps：可以将 application.yaml 配置文件中，对应的 yudao.tenant 配置项给进一步删除。\n\n\n# 第四步，删除前端代码\n\n以 yudao-admin-ui 为示例~\n\n① 删除 View 和 API 的前端代码：\n\n * views/system/tenant\n * views/system/tenantPackage\n * api/system/tenant.js\n * api/system/tenantPackage.js\n\n② 在 yudao-admin-ui 目录下，执行 npm run local 成功。访问登录页，结果访问白屏。需要清理 login.vue 页，涉及 tenant 关键字的代码。例如说：\n\n\n\n刷新，成功访问登录界面。\n\n③ 在 yudao-admin-ui 目录下，搜索 tenant 或 Tenant 关键字，可进一步清理多租户的代码。例如说：\n\n\n\n\n# 第五步，测试验收\n\n至此，我们已经完成了多租户的代码删除，还是蛮艰辛的~\n\n后续，你可以简单测试一下，看看是不是删除代码，导致一些小问题。\n\n\n# 更多...\n\n如果你有其它功能想要删除，可以在 Issue 留言，可以不断补充到该文档。",
            normalizedContent: "项目内置功能较多，会存在一些你可能用不到的功能。一般的情况下，建议通过设置该功能对应的菜单为【禁用】，实现功能的“删除”。如下图所示：\n\n\n\n后续，如果你又需要使用到该功能，只需要设置该功能对应的菜单为【开启】即可。\n\n🙂 当然，如果你希望彻底删除功能，那么就需要采用删除代码的方式。整个过程如下：\n\n① 【菜单】第一步，使用管理后台的菜单管理，删除对应的菜单、按钮。\n② 【数据库表】第二步，删除对应的数据库表。\n③ 【后端代码】第三步，删除对应的 controller、service、数据库实体等后端代码；然后启动后端项目，若存在代码报错，则继续删除相关联的代码，之后如此反复，直到成功。\n④ 【前端代码】第四步，删除对应的 view 和 api 等前端代码；然后启动前端项目，若存在代码报错，则继续删除相关联的代码，之后如此反复，直到成功。\n\n下面，我们来举一些例子。\n\n\n# 👍 相关视频教程\n\n * 从零开始 07：如何有效的删除不用的功能？\n\n\n# 删除「多租户」功能\n\n * 对应功能的文档：多租户\n * 对应的关键字是 tenant\n\n\n# 第一步，删除菜单\n\n删除“租户管理“下的所有菜单，从最里层的按钮开始。如下图所示：\n\n\n\n\n# 第二步，删除数据库表\n\n删除 system_tenant 和 system_tenant_package 表。如下图所示：\n\n\n\n\n# 第三步，删除后端代码\n\n① 删除 yudao-module-system-api 模块的 api/tenant 包。\n\n② 删除 yudao-module-system-api 模块的 errorcodeconstants 类中，和租户、租户套餐相关的错误码。如下图所示：\n\n\n\n如果想删除的更干净，可以把 system_error_code 表中，对应编号的错误码也都删除一下。\n\n③ 删除 yudao-module-system-biz 模块的如下包：\n\n * api/tenant\n * controller/admin/tenant\n * service/tenant\n * test/service/tenant\n * dal/dataobject/tenant\n * dal/mysql/tenant\n * convert/tenant\n\n④ 删除 yudao-spring-boot-starter-biz-tenant 模块。\n\n然后，使用 idea 搜索 yudao-spring-boot-starter-biz-tenant 关键字，删除 maven 中所有对它的定义与引用。如下图所示：\n\n\n\n之后，使用 idea 刷新下 maven 依赖。如下图所示：\n\n\n\n⑤ 运行 yudaoserverapplication 启动类，会报 cn.iocoder.yudao.framework.tenant.core.db 不存在的错误，需要将继承 tenantbasedo 的数据库实体，都改成继承 basedo 基类。\n\n\n\n⑥ 运行 yudaoserverapplication 启动类，会报 cn.iocoder.yudao.framework.tenant.core.aop 不存在的错误，需要去除对 @tenantignore 注解的使用。如下图所示：\n\n\n\n⑦ 运行 yudaoserverapplication 启动类，会报 cn.iocoder.yudao.module.system.service.tenant 不存在的错误，需要去除对 tenantservice 的使用。如下图所示：\n\n\n\n⑧ 运行 yudaoserverapplication 启动类，会报 cn.iocoder.yudao.framework.tenant.core.context 不存在的错误，需要去除对 tenantcontextholder 的使用。如下图所示：\n\n\n\n⑨ 运行 yudaoserverapplication 启动类，终于成功了！！！\n\nps：可以将 application.yaml 配置文件中，对应的 yudao.tenant 配置项给进一步删除。\n\n\n# 第四步，删除前端代码\n\n以 yudao-admin-ui 为示例~\n\n① 删除 view 和 api 的前端代码：\n\n * views/system/tenant\n * views/system/tenantpackage\n * api/system/tenant.js\n * api/system/tenantpackage.js\n\n② 在 yudao-admin-ui 目录下，执行 npm run local 成功。访问登录页，结果访问白屏。需要清理 login.vue 页，涉及 tenant 关键字的代码。例如说：\n\n\n\n刷新，成功访问登录界面。\n\n③ 在 yudao-admin-ui 目录下，搜索 tenant 或 tenant 关键字，可进一步清理多租户的代码。例如说：\n\n\n\n\n# 第五步，测试验收\n\n至此，我们已经完成了多租户的代码删除，还是蛮艰辛的~\n\n后续，你可以简单测试一下，看看是不是删除代码，导致一些小问题。\n\n\n# 更多...\n\n如果你有其它功能想要删除，可以在 issue 留言，可以不断补充到该文档。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "表结构变更（版本升级）",
            frontmatter: {
                title: "表结构变更（版本升级）",
                date: "2022-10-17T21:31:58.000Z",
                permalink: "/sql-update"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/01.%E8%90%8C%E6%96%B0%E5%BF%85%E8%AF%BB/14.%E8%A1%A8%E7%BB%93%E6%9E%84%E5%8F%98%E6%9B%B4.html",
            relativePath: "01.开发指南/01.萌新必读/14.表结构变更.md",
            key: "v-5e94a2f2",
            path: "/sql-update/",
            headers: [{
                level: 2,
                title: "1. 结构同步",
                slug: "_1-结构同步",
                normalizedTitle: "1. 结构同步",
                charIndex: 172
            }, {
                level: 2,
                title: "2. 数据同步",
                slug: "_2-数据同步",
                normalizedTitle: "2. 数据同步",
                charIndex: 643
            }, {
                level: 2,
                title: "3. 数据库转换",
                slug: "_3-数据库转换",
                normalizedTitle: "3. 数据库转换",
                charIndex: 920
            }, {
                level: 3,
                title: "3.1 实现原理",
                slug: "_3-1-实现原理",
                normalizedTitle: "3.1 实现原理",
                charIndex: 1176
            }, {
                level: 3,
                title: "3.2 如何使用？",
                slug: "_3-2-如何使用",
                normalizedTitle: "3.2 如何使用？",
                charIndex: 1403
            }],
            headersStr: "1. 结构同步 2. 数据同步 3. 数据库转换 3.1 实现原理 3.2 如何使用？",
            content: "系统每次发新版本，会伴随着数据库表结构、数据的变更。这个时候，我们可以通过 Navicat 提供的「结构同步」「数据同步」功能，来进行数据库的升级。\n\n\n\n友情提示：\n\n你自己的项目发布上线，如果涉及到数据库表结构的变更，也可以试试 Navicat 的「结构同步」「数据同步」功能。\n\n我们之前项目，蛮多同学都是这么干的，避免漏字段！\n\n\n# 1. 结构同步\n\n本小节，我们以 2.0.0 版本升级到 2.1.0 版本为例。需要先自己初始化对应的两个数据库，如下图所示：\n\n\n\n① 点击 Navicat 的 [工具 -> 结构同步] 菜单，配置源数据库是 2.1.0，目标数据库是 2.0.0，因为是将“新”应到“老”数据库。如下图所示：\n\n\n\n② 点击左下角的 [选项] 按钮，取消掉“比较自动递增值”，因为我们不希望自增值也同步。如下图所示：\n\n\n\n③ 点击右下角的 [下一步] 按钮，可以看到每个表的表更情况（新增、修改、删除）。如下图所示：\n\n\n\n此时，如果你只想看部分表的变更，可以点击“源对象”下的选项，取消掉不需要同步的表。\n\n④ 继续点击右下角的 [下一步] 按钮，可以看到具体的 SQL 变更语句。如下图所示：\n\n\n\n注意，不要点击有效的 [开始] 按钮，而是将 SQL 语句复制出来，二次检查后，选择你需要的部分，手动执行变更！\n\n友情提示：DataGrip 也提供类似功能，后面也可以尝试下。\n\n《使用 datagrip 实现不同数据库表之间的结构同步》\n\n\n# 2. 数据同步\n\nNavicat 的「数据同步」功能，和「结构同步」同步是一致的，只是在最后一步，会展示数据的变更情况（新增、修改、删除），这里就不重复演示了。\n\n\n\n系统绝大多数表的数据变更不用关注，只需要关注偏 全局配置 的表，例如说：\n\n * 字段相关：system_dict_type、system_dict_data\n * 权限相关：system_menu\n * 邮件相关：system_mail_template\n * 短信相关：system_sms_template\n * 站内信相关：system_notify_template\n\n\n# 3. 数据库转换\n\n项目提供了 sql/tools/convertor.py 脚本，支持将 MySQL 转换为 Oracle、PostgreSQL、SQL Server、达梦、人大金仓、OpenGauss 等数据库的脚本。\n\n疑问：什么时候需要转换数据库？\n\n场景一：项目主要使用 MySQL 开发，其它数据库可能滞后，此时可以自己转换下。\n\n场景二：项目类似 mall、bpm、ai、member、pay、crm、erp 等其它模块的数据库，只提供了 MySQL 的数据库脚本，此时也可以自己转换下。\n\n\n# 3.1 实现原理\n\n通过读取 MySQL 的 sql/mysql/ruoyi-vue-pro.sql 数据库文件，转换成对应的数据库脚本。\n\n疑问：如果我想转换 mall、bpm、ai、member、pay、crm、erp 等其它模块的数据库，怎么办？\n\n第一步，将对应的 SQL 拷贝到 ssql/mysql/ 目录下。\n\n第二步，将 convertor.py 脚本中的 ruoyi-vue-pro.sql 变量，修改为对应的 SQL 文件。\n\n\n# 3.2 如何使用？\n\n① 安装依赖库 simple-ddl-parser\n\npip install simple-ddl-parser\n# pip3 install simple-ddl-parser\n\n\n② 在 sql/tools/ 目录下，执行如下命令打印生成 postgres 的脚本内容，其他可选参数有：oracle、sqlserver、dm8、kingbase、opengauss：\n\npython3 convertor.py postgres\n# python3 convertor.py postgres > tmp.sql\n\n\n程序将 SQL 脚本打印到终端，可以重定向到临时文件 tmp.sql。\n\n确认无误后，可以利用 IDEA 进行格式化。当然，也可以直接导入到数据库中。",
            normalizedContent: "系统每次发新版本，会伴随着数据库表结构、数据的变更。这个时候，我们可以通过 navicat 提供的「结构同步」「数据同步」功能，来进行数据库的升级。\n\n\n\n友情提示：\n\n你自己的项目发布上线，如果涉及到数据库表结构的变更，也可以试试 navicat 的「结构同步」「数据同步」功能。\n\n我们之前项目，蛮多同学都是这么干的，避免漏字段！\n\n\n# 1. 结构同步\n\n本小节，我们以 2.0.0 版本升级到 2.1.0 版本为例。需要先自己初始化对应的两个数据库，如下图所示：\n\n\n\n① 点击 navicat 的 [工具 -> 结构同步] 菜单，配置源数据库是 2.1.0，目标数据库是 2.0.0，因为是将“新”应到“老”数据库。如下图所示：\n\n\n\n② 点击左下角的 [选项] 按钮，取消掉“比较自动递增值”，因为我们不希望自增值也同步。如下图所示：\n\n\n\n③ 点击右下角的 [下一步] 按钮，可以看到每个表的表更情况（新增、修改、删除）。如下图所示：\n\n\n\n此时，如果你只想看部分表的变更，可以点击“源对象”下的选项，取消掉不需要同步的表。\n\n④ 继续点击右下角的 [下一步] 按钮，可以看到具体的 sql 变更语句。如下图所示：\n\n\n\n注意，不要点击有效的 [开始] 按钮，而是将 sql 语句复制出来，二次检查后，选择你需要的部分，手动执行变更！\n\n友情提示：datagrip 也提供类似功能，后面也可以尝试下。\n\n《使用 datagrip 实现不同数据库表之间的结构同步》\n\n\n# 2. 数据同步\n\nnavicat 的「数据同步」功能，和「结构同步」同步是一致的，只是在最后一步，会展示数据的变更情况（新增、修改、删除），这里就不重复演示了。\n\n\n\n系统绝大多数表的数据变更不用关注，只需要关注偏 全局配置 的表，例如说：\n\n * 字段相关：system_dict_type、system_dict_data\n * 权限相关：system_menu\n * 邮件相关：system_mail_template\n * 短信相关：system_sms_template\n * 站内信相关：system_notify_template\n\n\n# 3. 数据库转换\n\n项目提供了 sql/tools/convertor.py 脚本，支持将 mysql 转换为 oracle、postgresql、sql server、达梦、人大金仓、opengauss 等数据库的脚本。\n\n疑问：什么时候需要转换数据库？\n\n场景一：项目主要使用 mysql 开发，其它数据库可能滞后，此时可以自己转换下。\n\n场景二：项目类似 mall、bpm、ai、member、pay、crm、erp 等其它模块的数据库，只提供了 mysql 的数据库脚本，此时也可以自己转换下。\n\n\n# 3.1 实现原理\n\n通过读取 mysql 的 sql/mysql/ruoyi-vue-pro.sql 数据库文件，转换成对应的数据库脚本。\n\n疑问：如果我想转换 mall、bpm、ai、member、pay、crm、erp 等其它模块的数据库，怎么办？\n\n第一步，将对应的 sql 拷贝到 ssql/mysql/ 目录下。\n\n第二步，将 convertor.py 脚本中的 ruoyi-vue-pro.sql 变量，修改为对应的 sql 文件。\n\n\n# 3.2 如何使用？\n\n① 安装依赖库 simple-ddl-parser\n\npip install simple-ddl-parser\n# pip3 install simple-ddl-parser\n\n\n② 在 sql/tools/ 目录下，执行如下命令打印生成 postgres 的脚本内容，其他可选参数有：oracle、sqlserver、dm8、kingbase、opengauss：\n\npython3 convertor.py postgres\n# python3 convertor.py postgres > tmp.sql\n\n\n程序将 sql 脚本打印到终端，可以重定向到临时文件 tmp.sql。\n\n确认无误后，可以利用 idea 进行格式化。当然，也可以直接导入到数据库中。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "面试题、简历模版、简历优化",
            frontmatter: {
                title: "面试题、简历模版、简历优化",
                date: "2024-06-22T16:17:28.000Z",
                permalink: "/interview"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/01.%E8%90%8C%E6%96%B0%E5%BF%85%E8%AF%BB/99.%E9%9D%A2%E8%AF%95%E9%A2%98&%E7%AE%80%E5%8E%86.html",
            relativePath: "01.开发指南/01.萌新必读/99.面试题&简历.md",
            key: "v-6fd4058c",
            path: "/interview/",
            headers: [{
                level: 2,
                title: "1. 面试题",
                slug: "_1-面试题",
                normalizedTitle: "1. 面试题",
                charIndex: 42
            }, {
                level: 2,
                title: "2. 简历模版",
                slug: "_2-简历模版",
                normalizedTitle: "2. 简历模版",
                charIndex: 144
            }, {
                level: 2,
                title: "3. 简历优化",
                slug: "_3-简历优化",
                normalizedTitle: "3. 简历优化",
                charIndex: 207
            }, {
                level: 3,
                title: "实习 & 校招 & 应届案例",
                slug: "实习-校招-应届案例",
                normalizedTitle: "实习 &amp; 校招 &amp; 应届案例",
                charIndex: null
            }, {
                level: 3,
                title: "1 年工作经验案例",
                slug: "_1-年工作经验案例",
                normalizedTitle: "1 年工作经验案例",
                charIndex: 1277
            }, {
                level: 3,
                title: "2 年工作经验案例",
                slug: "_2-年工作经验案例",
                normalizedTitle: "2 年工作经验案例",
                charIndex: 1624
            }, {
                level: 3,
                title: "3 年工作经验案例",
                slug: "_3-年工作经验案例",
                normalizedTitle: "3 年工作经验案例",
                charIndex: 2120
            }, {
                level: 3,
                title: "4 年工作经验案例",
                slug: "_4-年工作经验案例",
                normalizedTitle: "4 年工作经验案例",
                charIndex: 2570
            }, {
                level: 3,
                title: "5 年工作经验案例",
                slug: "_5-年工作经验案例",
                normalizedTitle: "5 年工作经验案例",
                charIndex: 2920
            }, {
                level: 3,
                title: "6 年工作经验案例",
                slug: "_6-年工作经验案例",
                normalizedTitle: "6 年工作经验案例",
                charIndex: 2997
            }, {
                level: 3,
                title: "7 年工作经验案例",
                slug: "_7-年工作经验案例",
                normalizedTitle: "7 年工作经验案例",
                charIndex: 3225
            }, {
                level: 3,
                title: "8 年工作经验案例",
                slug: "_8-年工作经验案例",
                normalizedTitle: "8 年工作经验案例",
                charIndex: 3426
            }, {
                level: 3,
                title: "9 年工作经验案例",
                slug: "_9-年工作经验案例",
                normalizedTitle: "9 年工作经验案例",
                charIndex: 3744
            }, {
                level: 3,
                title: "10 年工作经验案例",
                slug: "_10-年工作经验案例",
                normalizedTitle: "10 年工作经验案例",
                charIndex: 3908
            }, {
                level: 3,
                title: "11 年工作经验案例",
                slug: "_11-年工作经验案例",
                normalizedTitle: "11 年工作经验案例",
                charIndex: 3955
            }, {
                level: 3,
                title: "20 年工作经验案例",
                slug: "_20-年工作经验案例",
                normalizedTitle: "20 年工作经验案例",
                charIndex: 4002
            }],
            headersStr: "1. 面试题 2. 简历模版 3. 简历优化 实习 & 校招 & 应届案例 1 年工作经验案例 2 年工作经验案例 3 年工作经验案例 4 年工作经验案例 5 年工作经验案例 6 年工作经验案例 7 年工作经验案例 8 年工作经验案例 9 年工作经验案例 10 年工作经验案例 11 年工作经验案例 20 年工作经验案例",
            content: "扫码下方二维码，加入知识星球，可获得面试题、简历模版、简历优化等资料。\n\n\n\n\n# 1. 面试题\n\n\n\n我是 11 年开始工作，之前在某互联网公司做基础架构的负责人，现在在某大厂做基础架构的技术主管。\n\n“个人觉得，今年确实挺难的，但是互联网依然是国内最 top3 的职业选择”\n\n\n# 2. 简历模版\n\n简历优化、简历模版、简历案例：帮助你获得更多面试机会，支持大厂专属内推，Offer 选择建议！\n\n\n\n\n# 3. 简历优化\n\n如下是一个简历优化的优化示例：\n\n\n\n * 《职业空窗 4 年，最近想找 Java 开发，简历要怎么包装工作经历、项目经验》\n * 《23 届毕业生，现在在深圳连一个面试都约不到，简历应该怎么优化？》\n * 《硕二毕业生，成功拿到大厂 SP Offer！》\n * 《工作 2 年，学历一般，已经离职两个月，怎么提升简历？》\n * 《杭州求职，毕业 2 年，第一次跳槽，如何完善项目经历？》\n\n\n# 实习 & 校招 & 应届案例\n\n * 杭州：https://t.zsxq.com/FzOUx\n * 杭州：https://t.zsxq.com/BMjgN\n * 杭州：https://t.zsxq.com/FyT3o\n * 杭州：https://t.zsxq.com/LOQ38\n * 深圳：https://t.zsxq.com/P94bk\n * 深圳：https://t.zsxq.com/Pmrg0\n * 苏州：https://t.zsxq.com/45ECR\n * 东北：https://t.zsxq.com/GYQjK\n * 武汉：https://t.zsxq.com/67wlA\n * 西安：https://t.zsxq.com/JLhv5\n * https://t.zsxq.com/wYAxE\n * https://t.zsxq.com/bPsub\n * https://t.zsxq.com/CHLP7\n * https://t.zsxq.com/eM0Xt\n * https://t.zsxq.com/SXGvl\n * https://t.zsxq.com/EPeD3\n * https://t.zsxq.com/jA70V\n * https://t.zsxq.com/fHTMF\n * https://t.zsxq.com/Gtyb9\n * https://t.zsxq.com/HPRGo\n * https://t.zsxq.com/xFcKW\n * https://t.zsxq.com/j6ti8\n * https://t.zsxq.com/QIhts\n * https://t.zsxq.com/oaEK3\n * https://t.zsxq.com/9BnB4\n * https://t.zsxq.com/YGApI\n * https://t.zsxq.com/xJvVa\n * https://t.zsxq.com/gJjPd\n * https://t.zsxq.com/glgNv\n\n\n# 1 年工作经验案例\n\n * 杭州：https://t.zsxq.com/U53gk\n * 杭州：https://t.zsxq.com/wKWRn\n * 杭州：https://t.zsxq.com/9Xf6e\n * 南京：https://t.zsxq.com/IZWXs\n * 成都：https://t.zsxq.com/fvz99\n * 湖南：https://t.zsxq.com/BWMm9\n * 北京：https://t.zsxq.com/aytzI\n * 广州：https://t.zsxq.com/k6jsx\n * https://t.zsxq.com/WUjv5\n * https://t.zsxq.com/0kxC3\n * https://t.zsxq.com/8WVBj\n\n\n# 2 年工作经验案例\n\n * 北京：https://t.zsxq.com/aytzI\n * 杭州：https://t.zsxq.com/JiCqn\n * 杭州：https://t.zsxq.com/RlqOH\n * 杭州：https://t.zsxq.com/VkM0e\n * 杭州：https://t.zsxq.com/3uXFD\n * 杭州：https://t.zsxq.com/lo3XX\n * 杭州：https://t.zsxq.com/ejG9m\n * 深圳：https://t.zsxq.com/RuRWF\n * 上海：https://t.zsxq.com/QmZBv\n * 长沙：https://t.zsxq.com/mGXDe\n * 福建：https://t.zsxq.com/Q00P7\n * https://t.zsxq.com/oSKAa\n * https://t.zsxq.com/AeKW3\n * https://t.zsxq.com/YqUQA\n * https://t.zsxq.com/f3t9o\n * https://t.zsxq.com/TaeKn\n\n\n# 3 年工作经验案例\n\n * 北京：https://t.zsxq.com/m8aZQ\n * 上海：https://t.zsxq.com/2LReL\n * 上海：https://t.zsxq.com/UtLcz\n * 长沙：https://t.zsxq.com/02RWe\n * 长沙：https://t.zsxq.com/ZYa8i\n * 杭州：https://t.zsxq.com/sF4VH\n * 杭州：https://t.zsxq.com/8TTij\n * 深圳：https://t.zsxq.com/I7i8o\n * 嘉兴：https://t.zsxq.com/XGT0N\n * 苏州：https://t.zsxq.com/PvzEj 【转码】\n * 广州：https://t.zsxq.com/7fxz3\n * https://t.zsxq.com/YsZGZ 【前端】\n * https://t.zsxq.com/vyjXO\n * https://t.zsxq.com/8IQeh\n\n\n# 4 年工作经验案例\n\n * 深圳：https://t.zsxq.com/ZoyX5\n * 深圳：https://t.zsxq.com/PpGBP\n * 杭州：https://t.zsxq.com/xmmJc\n * 北京：https://t.zsxq.com/Rx206\n * 北京：https://t.zsxq.com/5C4u2\n * 北京：https://t.zsxq.com/KXhL2\n * 佛山：https://t.zsxq.com/oeMK0\n * 福建：https://t.zsxq.com/VcriR\n * 江苏：https://t.zsxq.com/NiwHV\n * https://t.zsxq.com/rrE3A\n * https://t.zsxq.com/6za6u\n\n\n# 5 年工作经验案例\n\n * 厦门：https://t.zsxq.com/jt5KY\n * 武汉：https://t.zsxq.com/w14vq\n\n\n# 6 年工作经验案例\n\n * 南京：https://t.zsxq.com/Q4mZe\n * 合肥：https://t.zsxq.com/DKxrh\n * 苏州：https://t.zsxq.com/nEGxM 【硕士】\n * 江苏：https://t.zsxq.com/akWcw\n * https://t.zsxq.com/qzElZ\n * https://t.zsxq.com/plsKc\n * https://t.zsxq.com/1irGs\n\n\n# 7 年工作经验案例\n\n * 杭州：https://t.zsxq.com/zAD0m\n * 杭州：https://t.zsxq.com/OMjB5\n * 南京：https://t.zsxq.com/Q3QeE\n * 安徽：https://t.zsxq.com/ymMCp\n * 福建：https://t.zsxq.com/i00XP\n * 北京：https://t.zsxq.com/SXXez\n\n\n# 8 年工作经验案例\n\n * https://t.zsxq.com/X973V 【技术总监】\n * https://t.zsxq.com/UQ6S6 【技术经理】\n * 杭州：https://t.zsxq.com/YLvuq\n * 天津：https://t.zsxq.com/W8eW2\n * 长沙：https://t.zsxq.com/tCeSu\n * https://t.zsxq.com/StOc4\n * https://t.zsxq.com/qKZwV\n * https://t.zsxq.com/pHGVX\n * https://t.zsxq.com/GP45c\n * https://t.zsxq.com/t9HbZ\n\n\n# 9 年工作经验案例\n\n * 上海：https://t.zsxq.com/TRqF9\n * 上海：https://t.zsxq.com/9asvM\n * 大连：https://t.zsxq.com/HYpmc\n * https://t.zsxq.com/p2egt\n * https://t.zsxq.com/VfcBN\n\n\n# 10 年工作经验案例\n\n * 深圳：https://t.zsxq.com/JemQA\n\n\n# 11 年工作经验案例\n\n * 厦门：https://t.zsxq.com/FpRsd\n\n\n# 20 年工作经验案例\n\n * 石家庄：https://t.zsxq.com/pwl5K",
            normalizedContent: "扫码下方二维码，加入知识星球，可获得面试题、简历模版、简历优化等资料。\n\n\n\n\n# 1. 面试题\n\n\n\n我是 11 年开始工作，之前在某互联网公司做基础架构的负责人，现在在某大厂做基础架构的技术主管。\n\n“个人觉得，今年确实挺难的，但是互联网依然是国内最 top3 的职业选择”\n\n\n# 2. 简历模版\n\n简历优化、简历模版、简历案例：帮助你获得更多面试机会，支持大厂专属内推，offer 选择建议！\n\n\n\n\n# 3. 简历优化\n\n如下是一个简历优化的优化示例：\n\n\n\n * 《职业空窗 4 年，最近想找 java 开发，简历要怎么包装工作经历、项目经验》\n * 《23 届毕业生，现在在深圳连一个面试都约不到，简历应该怎么优化？》\n * 《硕二毕业生，成功拿到大厂 sp offer！》\n * 《工作 2 年，学历一般，已经离职两个月，怎么提升简历？》\n * 《杭州求职，毕业 2 年，第一次跳槽，如何完善项目经历？》\n\n\n# 实习 & 校招 & 应届案例\n\n * 杭州：https://t.zsxq.com/fzoux\n * 杭州：https://t.zsxq.com/bmjgn\n * 杭州：https://t.zsxq.com/fyt3o\n * 杭州：https://t.zsxq.com/loq38\n * 深圳：https://t.zsxq.com/p94bk\n * 深圳：https://t.zsxq.com/pmrg0\n * 苏州：https://t.zsxq.com/45ecr\n * 东北：https://t.zsxq.com/gyqjk\n * 武汉：https://t.zsxq.com/67wla\n * 西安：https://t.zsxq.com/jlhv5\n * https://t.zsxq.com/wyaxe\n * https://t.zsxq.com/bpsub\n * https://t.zsxq.com/chlp7\n * https://t.zsxq.com/em0xt\n * https://t.zsxq.com/sxgvl\n * https://t.zsxq.com/eped3\n * https://t.zsxq.com/ja70v\n * https://t.zsxq.com/fhtmf\n * https://t.zsxq.com/gtyb9\n * https://t.zsxq.com/hprgo\n * https://t.zsxq.com/xfckw\n * https://t.zsxq.com/j6ti8\n * https://t.zsxq.com/qihts\n * https://t.zsxq.com/oaek3\n * https://t.zsxq.com/9bnb4\n * https://t.zsxq.com/ygapi\n * https://t.zsxq.com/xjvva\n * https://t.zsxq.com/gjjpd\n * https://t.zsxq.com/glgnv\n\n\n# 1 年工作经验案例\n\n * 杭州：https://t.zsxq.com/u53gk\n * 杭州：https://t.zsxq.com/wkwrn\n * 杭州：https://t.zsxq.com/9xf6e\n * 南京：https://t.zsxq.com/izwxs\n * 成都：https://t.zsxq.com/fvz99\n * 湖南：https://t.zsxq.com/bwmm9\n * 北京：https://t.zsxq.com/aytzi\n * 广州：https://t.zsxq.com/k6jsx\n * https://t.zsxq.com/wujv5\n * https://t.zsxq.com/0kxc3\n * https://t.zsxq.com/8wvbj\n\n\n# 2 年工作经验案例\n\n * 北京：https://t.zsxq.com/aytzi\n * 杭州：https://t.zsxq.com/jicqn\n * 杭州：https://t.zsxq.com/rlqoh\n * 杭州：https://t.zsxq.com/vkm0e\n * 杭州：https://t.zsxq.com/3uxfd\n * 杭州：https://t.zsxq.com/lo3xx\n * 杭州：https://t.zsxq.com/ejg9m\n * 深圳：https://t.zsxq.com/rurwf\n * 上海：https://t.zsxq.com/qmzbv\n * 长沙：https://t.zsxq.com/mgxde\n * 福建：https://t.zsxq.com/q00p7\n * https://t.zsxq.com/oskaa\n * https://t.zsxq.com/aekw3\n * https://t.zsxq.com/yquqa\n * https://t.zsxq.com/f3t9o\n * https://t.zsxq.com/taekn\n\n\n# 3 年工作经验案例\n\n * 北京：https://t.zsxq.com/m8azq\n * 上海：https://t.zsxq.com/2lrel\n * 上海：https://t.zsxq.com/utlcz\n * 长沙：https://t.zsxq.com/02rwe\n * 长沙：https://t.zsxq.com/zya8i\n * 杭州：https://t.zsxq.com/sf4vh\n * 杭州：https://t.zsxq.com/8ttij\n * 深圳：https://t.zsxq.com/i7i8o\n * 嘉兴：https://t.zsxq.com/xgt0n\n * 苏州：https://t.zsxq.com/pvzej 【转码】\n * 广州：https://t.zsxq.com/7fxz3\n * https://t.zsxq.com/yszgz 【前端】\n * https://t.zsxq.com/vyjxo\n * https://t.zsxq.com/8iqeh\n\n\n# 4 年工作经验案例\n\n * 深圳：https://t.zsxq.com/zoyx5\n * 深圳：https://t.zsxq.com/ppgbp\n * 杭州：https://t.zsxq.com/xmmjc\n * 北京：https://t.zsxq.com/rx206\n * 北京：https://t.zsxq.com/5c4u2\n * 北京：https://t.zsxq.com/kxhl2\n * 佛山：https://t.zsxq.com/oemk0\n * 福建：https://t.zsxq.com/vcrir\n * 江苏：https://t.zsxq.com/niwhv\n * https://t.zsxq.com/rre3a\n * https://t.zsxq.com/6za6u\n\n\n# 5 年工作经验案例\n\n * 厦门：https://t.zsxq.com/jt5ky\n * 武汉：https://t.zsxq.com/w14vq\n\n\n# 6 年工作经验案例\n\n * 南京：https://t.zsxq.com/q4mze\n * 合肥：https://t.zsxq.com/dkxrh\n * 苏州：https://t.zsxq.com/negxm 【硕士】\n * 江苏：https://t.zsxq.com/akwcw\n * https://t.zsxq.com/qzelz\n * https://t.zsxq.com/plskc\n * https://t.zsxq.com/1irgs\n\n\n# 7 年工作经验案例\n\n * 杭州：https://t.zsxq.com/zad0m\n * 杭州：https://t.zsxq.com/omjb5\n * 南京：https://t.zsxq.com/q3qee\n * 安徽：https://t.zsxq.com/ymmcp\n * 福建：https://t.zsxq.com/i00xp\n * 北京：https://t.zsxq.com/sxxez\n\n\n# 8 年工作经验案例\n\n * https://t.zsxq.com/x973v 【技术总监】\n * https://t.zsxq.com/uq6s6 【技术经理】\n * 杭州：https://t.zsxq.com/ylvuq\n * 天津：https://t.zsxq.com/w8ew2\n * 长沙：https://t.zsxq.com/tcesu\n * https://t.zsxq.com/stoc4\n * https://t.zsxq.com/qkzwv\n * https://t.zsxq.com/phgvx\n * https://t.zsxq.com/gp45c\n * https://t.zsxq.com/t9hbz\n\n\n# 9 年工作经验案例\n\n * 上海：https://t.zsxq.com/trqf9\n * 上海：https://t.zsxq.com/9asvm\n * 大连：https://t.zsxq.com/hypmc\n * https://t.zsxq.com/p2egt\n * https://t.zsxq.com/vfcbn\n\n\n# 10 年工作经验案例\n\n * 深圳：https://t.zsxq.com/jemqa\n\n\n# 11 年工作经验案例\n\n * 厦门：https://t.zsxq.com/fprsd\n\n\n# 20 年工作经验案例\n\n * 石家庄：https://t.zsxq.com/pwl5k",
            charsets: {
                cjk: !0
            }
        }, {
            title: "国产信创数据库（DM 达梦、大金、OpenGauss）",
            frontmatter: {
                title: "国产信创数据库（DM 达梦、大金、OpenGauss）",
                permalink: "/xinchuang-db",
                date: "2023-11-06T11:06:23.000Z"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/01.%E8%90%8C%E6%96%B0%E5%BF%85%E8%AF%BB/15.%E5%9B%BD%E4%BA%A7%E4%BF%A1%E5%88%9B%E6%95%B0%E6%8D%AE%E5%BA%93.html",
            relativePath: "01.开发指南/01.萌新必读/15.国产信创数据库.md",
            key: "v-25ea4e32",
            path: "/xinchuang-db/",
            headers: [{
                level: 2,
                title: "1. DM 达梦数据库",
                slug: "_1-dm-达梦数据库",
                normalizedTitle: "1. dm 达梦数据库",
                charIndex: 2
            }, {
                level: 3,
                title: "1.1 如何安装？",
                slug: "_1-1-如何安装",
                normalizedTitle: "1.1 如何安装？",
                charIndex: 18
            }, {
                level: 3,
                title: "1.2 如何导入数据？",
                slug: "_1-2-如何导入数据",
                normalizedTitle: "1.2 如何导入数据？",
                charIndex: 873
            }, {
                level: 3,
                title: "1.3 如何启动项目？",
                slug: "_1-3-如何启动项目",
                normalizedTitle: "1.3 如何启动项目？",
                charIndex: 1305
            }, {
                level: 3,
                title: "1.4 常见问题？",
                slug: "_1-4-常见问题",
                normalizedTitle: "1.4 常见问题？",
                charIndex: 1639
            }, {
                level: 2,
                title: "2. KingbaseES 大金数据库",
                slug: "_2-kingbasees-大金数据库",
                normalizedTitle: "2. kingbasees 大金数据库",
                charIndex: 2116
            }, {
                level: 3,
                title: "1.1 如何安装？",
                slug: "_1-1-如何安装-2",
                normalizedTitle: "1.1 如何安装？",
                charIndex: 18
            }, {
                level: 3,
                title: "2.2 如何导入数据？",
                slug: "_2-2-如何导入数据",
                normalizedTitle: "2.2 如何导入数据？",
                charIndex: 2776
            }, {
                level: 3,
                title: "2.3 如何启动项目？",
                slug: "_2-3-如何启动项目",
                normalizedTitle: "2.3 如何启动项目？",
                charIndex: 2940
            }, {
                level: 3,
                title: "2.4 常见问题？",
                slug: "_2-4-常见问题",
                normalizedTitle: "2.4 常见问题？",
                charIndex: 3199
            }, {
                level: 2,
                title: "3. 华为 OpenGauss",
                slug: "_3-华为-opengauss",
                normalizedTitle: "3. 华为 opengauss",
                charIndex: 3660
            }, {
                level: 3,
                title: "3.1 如何安装？",
                slug: "_3-1-如何安装",
                normalizedTitle: "3.1 如何安装？",
                charIndex: 3680
            }, {
                level: 3,
                title: "3.2 如何导入数据？",
                slug: "_3-2-如何导入数据",
                normalizedTitle: "3.2 如何导入数据？",
                charIndex: 4081
            }, {
                level: 3,
                title: "3.3 如何启动项目？",
                slug: "_3-3-如何启动项目",
                normalizedTitle: "3.3 如何启动项目？",
                charIndex: 4424
            }, {
                level: 3,
                title: "3.4 常见问题？",
                slug: "_3-4-常见问题",
                normalizedTitle: "3.4 常见问题？",
                charIndex: 4826
            }],
            headersStr: "1. DM 达梦数据库 1.1 如何安装？ 1.2 如何导入数据？ 1.3 如何启动项目？ 1.4 常见问题？ 2. KingbaseES 大金数据库 1.1 如何安装？ 2.2 如何导入数据？ 2.3 如何启动项目？ 2.4 常见问题？ 3. 华为 OpenGauss 3.1 如何安装？ 3.2 如何导入数据？ 3.3 如何启动项目？ 3.4 常见问题？",
            content: "# 1. DM 达梦数据库\n\n\n# 1.1 如何安装？\n\n可以使用 Windows 或 Docker 等多种方式。\n\n注意，目前我们使用的是 DM 8.0 的版本。\n\n# 1.1 Windows 方式\n\n参考 官方文档\n\n① 访问 https://eco.dameng.com/download/ 地址，点击“开发版 (X86平台)”选项，进行下载。\n\n② 傻瓜式安装、数据库实例化，一路下去就好，不用修改任何参数。\n\n# 1.2 Docker 方式\n\n参考 官方文档\n\n① 访问 https://eco.dameng.com/download/ 地址，点击“Docker 镜像”选项，进行下载。\n\n② 执行如下脚本，启动 Docker 服务：\n\ndocker load -i dm8_20240715_x86_rh6_rq_single.tar\n\ndocker run -d -p 5236:5236 \\\n    --restart=unless-stopped \\\n    --name dm8_test \\\n    --privileged=true \\\n    -e PAGE_SIZE=16 \\\n    -e LD_LIBRARY_PATH=/opt/dmdbms/binn \\\n    -e EXTENT_SIZE=32 \\\n    -e BLANK_PAD_MODE=1 \\\n    -e LOG_SIZE=1024 \\\n    -e UNICODE_FLAG=1 \\\n    -e LENGTH_IN_CHAR=1 \\\n    -e INSTANCE_NAME=dm8_test \\\n    -v $PWD/dm8_test:/opt/dmdbms/data \\\n    dm8_single:dm8_20240715_rev232765_x86_rh6_64\n\n\n备注：可以尝试使用大小写不敏感配置 -e CASE_SENSITIVE=N。需要停止并删除容器后，删除 dm8_test 目录，重新docker run。\n\n\n# 1.2 如何导入数据？\n\n使用 DM 管理工具 进行数据的导入。如果你不是很了解，已可以看看文档：\n\n * 《达梦数据库（二）DM Manager 管理工具》\n * 《达梦数据库导入 SQL》\n\n具体步骤如下：\n\n① 使用 DM 管理工具，新建一个名字为 RUOYI_VUE_PRO 的 schema 模式。如下图所示：\n\n\n\n为什么名字是 RUOYI_VUE_PRO 呢？\n\n因为稍后使用的 sql/dm/ruoyi-vue-pro-dm8.sql 文件，使用的 schema 是它噢。后续跑通了，你可以按照自己的修改。\n\n② 点击 DM 管理工具的 [执行 -> 执行脚本] 菜单，选中项目中的 sql/dm/ruoyi-vue-pro-dm8.sql 文件，之后点击 [绿色箭头] 进行执行即可。\n\n友情提示：如果你不想 DM 管理工具，也可以使用其它工具：\n\n * 《DataGrip 连接达梦数据库》\n * 《DBeaver 连接达梦数据库 》\n\n\n# 1.3 如何启动项目？\n\n① 修改 yudao-spring-boot-starter-mybatis 模块的 pom.xml 文件，将 DM 依赖的 DmJdbcDriver18 的 optional 移除（注意，需要使用 IDEA 刷新下 Maven 的依赖）。如下图所示：\n\n\n\n② 修改 application-local.yaml 配置文件，将数据库的 url、username、password 修改为 DM 数据库。例如说：\n\n\n\n③ 后续启动项目，就可以了。\n\n疑问：启动报“无效的模式名[RUOYI_VUE_PRO]”错误，怎么解决？\n\n可以把上图的 url 中的 ?schema=RUOYI_VUE_PRO 部分去掉后，再重启下，试试看。\n\n\n# 1.4 常见问题？\n\n# 1.4.1 大小写敏感？\n\n参考 《详解 DM 数据库字符串大小写敏感》 文档\n\n# 1.4.2 Quartz 定时任务？\n\nQuartz 定时任务，已经适配，直接参考 《定时任务》 使用。\n\n实现思路非常简单：\n\n * Quartz 初始化使用 tables_oracle 脚本，去掉前面的 delete 和 drop 部分\n * spring.quartz.properties.org.quartz.jobStore.driverDelegateClass 使用 org.quartz.impl.jdbcjobstore.StdJDBCDelegate 类。不过网上也有人说使用 org.quartz.impl.jdbcjobstore.oracle.OracleDelegate 类，我暂时没跑成功\n\n# 1.4.3 Flowable 工作流？\n\nFlowable 工作流的适配，可参考 《工作流（达梦适配）》。\n\n短期内暂时没时间适配，欢迎你搞了之后，pull request 贡献给项目，从而帮助到更多人！\n\n\n# 2. KingbaseES 大金数据库\n\n\n# 1.1 如何安装？\n\n可以使用 Windows 或 Docker 等多种方式。\n\n注意，目前我们使用的是 V008R006C008B0020 的版本。\n\n# 1.1 Windows 方式\n\n参考 官方文档\n\n# 1.2 Docker 方式\n\n参考 官方文档\n\n① 访问 https://www.kingbase.com.cn/xzzx/index.htm 地址，点击左侧的“软件版本 -> 数据库” 菜单，再点击“docker镜像”选项，进行下载：\n\n * x86_64 版本 【Windows 选择这个】\n * aarch64 版本 【MacBook Apple Silicon 选择这个】\n\n② 执行如下脚本，启动 Docker 服务：\n\ndocker load -i kdb_x86_64_V009R001C001B0025.tar\n\ndocker run -d -p 54321:54321 \\\n    --restart=unless-stopped \\\n    --name kingbase_test \\\n    --privileged=true \\\n    -e NEED_START=yes  \\\n    -e DB_USER=root  \\\n    -e DB_PASSWORD=123456  \\\n    -e DB_MODE=oracle  \\\n    kingbase_v009r001c001b0025_single_x86:v1\n\n\n\n# 2.2 如何导入数据？\n\n① 使用 Navicat 工具，选择 PostgreSQL 数据库，即可连接。如下图所示：\n\n\n\n② 选择 test 数据库的 public 模式，右键选择“运行 SQL 文件”，选择项目中的 sql/kingbasees/ruoyi-vue-pro.sql 文件，之后点击 [开始] 按钮。\n\n\n# 2.3 如何启动项目？\n\n① 修改 yudao-spring-boot-starter-mybatis 模块的 pom.xml 文件，将 KingbaseES 依赖的 kingbasees-jdbc 的 optional 移除（注意，需要使用 IDEA 刷新下 Maven 的依赖）。如下图所示：\n\n\n\n② 修改 application-local.yaml 配置文件，将数据库的 url、username、password 修改为 KingbaseES 数据库。例如说：\n\n\n\n③ 后续启动项目，就可以了。\n\n\n# 2.4 常见问题？\n\n# 2.4.1 Quartz 定时任务？\n\nQuartz 定时任务，已经适配，直接参考 《定时任务》 使用。\n\n实现思路非常简单：\n\n * Quartz 初始化使用 tables_postgres 脚本\n * spring.quartz.properties.org.quartz.jobStore.driverDelegateClass 使用 org.quartz.impl.jdbcjobstore.StdJDBCDelegate 类。\n\n# 2.4.2 Flowable 工作流？\n\nFlowable 工作流的适配，可参考如下文章：\n\n * 《flowable 6.7.2 在 spring boot 项目中兼容人大金仓》\n * 《flowable 适配人大金仓 Kingbase 数据库》\n * 《【Kingbase8 数据库】flowable兼容人大金仓 Kingbase8 过程》\n\n短期内暂时没时间适配，欢迎你搞了之后，pull request 贡献给项目，从而帮助到更多人！\n\n\n# 3. 华为 OpenGauss\n\n\n# 3.1 如何安装？\n\n可以使用 Linux 或 Docker 等多种方式。\n\n注意，目前我们使用的是 openGauss 5.0.0 的版本。\n\n友情提示：openGauss 不支持 Windows 系统，所以请使用 Linux 或 Docker 等方式。\n\n# 3.1 Docker 方式\n\n执行如下脚本，启动 Docker 服务：\n\ndocker run -d \\\n  --name opengauss-test \\\n  --restart unless-stopped \\\n  -e GS_USERNAME=root \\\n  -e GS_PASSWORD=Yudao@2024 \\\n  -e LD_LIBRARY_PATH=/usr/local/opengauss/lib:/usr/lib \\\n  -p 5432:5432 \\\n  opengauss/opengauss:5.0.0\n\n\n\n# 3.2 如何导入数据？\n\n① 参考 《用 JetBrains DataGrip 连接 Huawei openGauss》 文档，连接 openGauss 数据库。\n\n疑问：为什么不使用 Navicat 进行连接？\n\n因为 Navicat 不支持 openGauss 数据库，而使用 PostgreSQL 进行连接，会出现 “none of the server's SASL authentication mechanisms are supported” 报错。\n\n② 选择 postgres 数据库，右键选择“SQL Scripts -> Run SQL Script...”，选择项目中的 sql/opengauss/ruoyi-vue-pro.sql 文件，之后执行。\n\n\n# 3.3 如何启动项目？\n\n① 修改 yudao-spring-boot-starter-mybatis 模块的 pom.xml 文件，将 openGauss 依赖的 opengauss 的 optional 移除（注意，需要使用 IDEA 刷新下 Maven 的依赖）。如下图所示：\n\n\n\n② 修改 application-local.yaml 配置文件，将数据库的 url、username、password 修改为 openGauss 数据库。例如说：\n\n\n\n::: 疑问：为什么 jdbc 使用 postgres 数据库连接？\n\n因为 openGauss 是兼容 PostgreSQL 的，所以 JDBC 驱动使用的是 org.postgresql.Driver。这样，后续和 Quartz 定时任务、Flowable 工作流等等，都是可以兼容的。 :::\n\n③ 后续启动项目，就可以了。\n\n\n# 3.4 常见问题？\n\n# 3.4.1 Quartz 定时任务？\n\nQuartz 定时任务，已经适配，直接参考 《定时任务》 使用。\n\n实现思路非常简单（因为 jdbc 使用 postgres 数据库连接）：\n\n * Quartz 初始化使用 tables_postgres 脚本\n\n# 3.4.2 Flowable 工作流？\n\nFlowable 工作流，已经适配，直接参考 《工作流》 使用。\n\n也是因为 jdbc 使用 postgres 数据库连接，所以无需去兼容。",
            normalizedContent: "# 1. dm 达梦数据库\n\n\n# 1.1 如何安装？\n\n可以使用 windows 或 docker 等多种方式。\n\n注意，目前我们使用的是 dm 8.0 的版本。\n\n# 1.1 windows 方式\n\n参考 官方文档\n\n① 访问 https://eco.dameng.com/download/ 地址，点击“开发版 (x86平台)”选项，进行下载。\n\n② 傻瓜式安装、数据库实例化，一路下去就好，不用修改任何参数。\n\n# 1.2 docker 方式\n\n参考 官方文档\n\n① 访问 https://eco.dameng.com/download/ 地址，点击“docker 镜像”选项，进行下载。\n\n② 执行如下脚本，启动 docker 服务：\n\ndocker load -i dm8_20240715_x86_rh6_rq_single.tar\n\ndocker run -d -p 5236:5236 \\\n    --restart=unless-stopped \\\n    --name dm8_test \\\n    --privileged=true \\\n    -e page_size=16 \\\n    -e ld_library_path=/opt/dmdbms/binn \\\n    -e extent_size=32 \\\n    -e blank_pad_mode=1 \\\n    -e log_size=1024 \\\n    -e unicode_flag=1 \\\n    -e length_in_char=1 \\\n    -e instance_name=dm8_test \\\n    -v $pwd/dm8_test:/opt/dmdbms/data \\\n    dm8_single:dm8_20240715_rev232765_x86_rh6_64\n\n\n备注：可以尝试使用大小写不敏感配置 -e case_sensitive=n。需要停止并删除容器后，删除 dm8_test 目录，重新docker run。\n\n\n# 1.2 如何导入数据？\n\n使用 dm 管理工具 进行数据的导入。如果你不是很了解，已可以看看文档：\n\n * 《达梦数据库（二）dm manager 管理工具》\n * 《达梦数据库导入 sql》\n\n具体步骤如下：\n\n① 使用 dm 管理工具，新建一个名字为 ruoyi_vue_pro 的 schema 模式。如下图所示：\n\n\n\n为什么名字是 ruoyi_vue_pro 呢？\n\n因为稍后使用的 sql/dm/ruoyi-vue-pro-dm8.sql 文件，使用的 schema 是它噢。后续跑通了，你可以按照自己的修改。\n\n② 点击 dm 管理工具的 [执行 -> 执行脚本] 菜单，选中项目中的 sql/dm/ruoyi-vue-pro-dm8.sql 文件，之后点击 [绿色箭头] 进行执行即可。\n\n友情提示：如果你不想 dm 管理工具，也可以使用其它工具：\n\n * 《datagrip 连接达梦数据库》\n * 《dbeaver 连接达梦数据库 》\n\n\n# 1.3 如何启动项目？\n\n① 修改 yudao-spring-boot-starter-mybatis 模块的 pom.xml 文件，将 dm 依赖的 dmjdbcdriver18 的 optional 移除（注意，需要使用 idea 刷新下 maven 的依赖）。如下图所示：\n\n\n\n② 修改 application-local.yaml 配置文件，将数据库的 url、username、password 修改为 dm 数据库。例如说：\n\n\n\n③ 后续启动项目，就可以了。\n\n疑问：启动报“无效的模式名[ruoyi_vue_pro]”错误，怎么解决？\n\n可以把上图的 url 中的 ?schema=ruoyi_vue_pro 部分去掉后，再重启下，试试看。\n\n\n# 1.4 常见问题？\n\n# 1.4.1 大小写敏感？\n\n参考 《详解 dm 数据库字符串大小写敏感》 文档\n\n# 1.4.2 quartz 定时任务？\n\nquartz 定时任务，已经适配，直接参考 《定时任务》 使用。\n\n实现思路非常简单：\n\n * quartz 初始化使用 tables_oracle 脚本，去掉前面的 delete 和 drop 部分\n * spring.quartz.properties.org.quartz.jobstore.driverdelegateclass 使用 org.quartz.impl.jdbcjobstore.stdjdbcdelegate 类。不过网上也有人说使用 org.quartz.impl.jdbcjobstore.oracle.oracledelegate 类，我暂时没跑成功\n\n# 1.4.3 flowable 工作流？\n\nflowable 工作流的适配，可参考 《工作流（达梦适配）》。\n\n短期内暂时没时间适配，欢迎你搞了之后，pull request 贡献给项目，从而帮助到更多人！\n\n\n# 2. kingbasees 大金数据库\n\n\n# 1.1 如何安装？\n\n可以使用 windows 或 docker 等多种方式。\n\n注意，目前我们使用的是 v008r006c008b0020 的版本。\n\n# 1.1 windows 方式\n\n参考 官方文档\n\n# 1.2 docker 方式\n\n参考 官方文档\n\n① 访问 https://www.kingbase.com.cn/xzzx/index.htm 地址，点击左侧的“软件版本 -> 数据库” 菜单，再点击“docker镜像”选项，进行下载：\n\n * x86_64 版本 【windows 选择这个】\n * aarch64 版本 【macbook apple silicon 选择这个】\n\n② 执行如下脚本，启动 docker 服务：\n\ndocker load -i kdb_x86_64_v009r001c001b0025.tar\n\ndocker run -d -p 54321:54321 \\\n    --restart=unless-stopped \\\n    --name kingbase_test \\\n    --privileged=true \\\n    -e need_start=yes  \\\n    -e db_user=root  \\\n    -e db_password=123456  \\\n    -e db_mode=oracle  \\\n    kingbase_v009r001c001b0025_single_x86:v1\n\n\n\n# 2.2 如何导入数据？\n\n① 使用 navicat 工具，选择 postgresql 数据库，即可连接。如下图所示：\n\n\n\n② 选择 test 数据库的 public 模式，右键选择“运行 sql 文件”，选择项目中的 sql/kingbasees/ruoyi-vue-pro.sql 文件，之后点击 [开始] 按钮。\n\n\n# 2.3 如何启动项目？\n\n① 修改 yudao-spring-boot-starter-mybatis 模块的 pom.xml 文件，将 kingbasees 依赖的 kingbasees-jdbc 的 optional 移除（注意，需要使用 idea 刷新下 maven 的依赖）。如下图所示：\n\n\n\n② 修改 application-local.yaml 配置文件，将数据库的 url、username、password 修改为 kingbasees 数据库。例如说：\n\n\n\n③ 后续启动项目，就可以了。\n\n\n# 2.4 常见问题？\n\n# 2.4.1 quartz 定时任务？\n\nquartz 定时任务，已经适配，直接参考 《定时任务》 使用。\n\n实现思路非常简单：\n\n * quartz 初始化使用 tables_postgres 脚本\n * spring.quartz.properties.org.quartz.jobstore.driverdelegateclass 使用 org.quartz.impl.jdbcjobstore.stdjdbcdelegate 类。\n\n# 2.4.2 flowable 工作流？\n\nflowable 工作流的适配，可参考如下文章：\n\n * 《flowable 6.7.2 在 spring boot 项目中兼容人大金仓》\n * 《flowable 适配人大金仓 kingbase 数据库》\n * 《【kingbase8 数据库】flowable兼容人大金仓 kingbase8 过程》\n\n短期内暂时没时间适配，欢迎你搞了之后，pull request 贡献给项目，从而帮助到更多人！\n\n\n# 3. 华为 opengauss\n\n\n# 3.1 如何安装？\n\n可以使用 linux 或 docker 等多种方式。\n\n注意，目前我们使用的是 opengauss 5.0.0 的版本。\n\n友情提示：opengauss 不支持 windows 系统，所以请使用 linux 或 docker 等方式。\n\n# 3.1 docker 方式\n\n执行如下脚本，启动 docker 服务：\n\ndocker run -d \\\n  --name opengauss-test \\\n  --restart unless-stopped \\\n  -e gs_username=root \\\n  -e gs_password=yudao@2024 \\\n  -e ld_library_path=/usr/local/opengauss/lib:/usr/lib \\\n  -p 5432:5432 \\\n  opengauss/opengauss:5.0.0\n\n\n\n# 3.2 如何导入数据？\n\n① 参考 《用 jetbrains datagrip 连接 huawei opengauss》 文档，连接 opengauss 数据库。\n\n疑问：为什么不使用 navicat 进行连接？\n\n因为 navicat 不支持 opengauss 数据库，而使用 postgresql 进行连接，会出现 “none of the server's sasl authentication mechanisms are supported” 报错。\n\n② 选择 postgres 数据库，右键选择“sql scripts -> run sql script...”，选择项目中的 sql/opengauss/ruoyi-vue-pro.sql 文件，之后执行。\n\n\n# 3.3 如何启动项目？\n\n① 修改 yudao-spring-boot-starter-mybatis 模块的 pom.xml 文件，将 opengauss 依赖的 opengauss 的 optional 移除（注意，需要使用 idea 刷新下 maven 的依赖）。如下图所示：\n\n\n\n② 修改 application-local.yaml 配置文件，将数据库的 url、username、password 修改为 opengauss 数据库。例如说：\n\n\n\n::: 疑问：为什么 jdbc 使用 postgres 数据库连接？\n\n因为 opengauss 是兼容 postgresql 的，所以 jdbc 驱动使用的是 org.postgresql.driver。这样，后续和 quartz 定时任务、flowable 工作流等等，都是可以兼容的。 :::\n\n③ 后续启动项目，就可以了。\n\n\n# 3.4 常见问题？\n\n# 3.4.1 quartz 定时任务？\n\nquartz 定时任务，已经适配，直接参考 《定时任务》 使用。\n\n实现思路非常简单（因为 jdbc 使用 postgres 数据库连接）：\n\n * quartz 初始化使用 tables_postgres 脚本\n\n# 3.4.2 flowable 工作流？\n\nflowable 工作流，已经适配，直接参考 《工作流》 使用。\n\n也是因为 jdbc 使用 postgres 数据库连接，所以无需去兼容。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "如何去除 Redis 缓存",
            frontmatter: {
                title: "如何去除 Redis 缓存",
                date: "2024-09-02T09:23:43.000Z",
                permalink: "/remove-redis"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/01.%E8%90%8C%E6%96%B0%E5%BF%85%E8%AF%BB/16.%E5%A6%82%E4%BD%95%E5%8E%BB%E9%99%A4%20Redis%20%E4%BE%9D%E8%B5%96.html",
            relativePath: "01.开发指南/01.萌新必读/16.如何去除 Redis 依赖.md",
            key: "v-1c8ff8ea",
            path: "/remove-redis/",
            headers: [{
                level: 2,
                title: "1. 如何启动？",
                slug: "_1-如何启动",
                normalizedTitle: "1. 如何启动？",
                charIndex: 242
            }, {
                level: 2,
                title: "2. 常见问题？",
                slug: "_2-常见问题",
                normalizedTitle: "2. 常见问题？",
                charIndex: 1077
            }],
            headersStr: "1. 如何启动？ 2. 常见问题？",
            content: "在一些场景下，不希望有 Redis 依赖，也有很多用户提出类似的诉求：\n\n * 有大佬实现了不带 Redis 的版本了吗？\n * 某个环境没有 Redis，所以需要把 Redis 给禁用掉？\n\n但是，项目大量使用了 Redis 作为缓存、分布式锁、幂等性等功能，所以直接去除 Redis 会导致项目无法正常运行。\n\n不过，我们可以换个思路，使用 jedis-mock 库，在项目启动时，自动启动一个 Mock 的 Redis 服务，这样就可以实现不依赖 Redis 的运行。\n\n\n# 1. 如何启动？\n\n① 在 yudao-server 模块的 pom.xml 文件中，添加 jedis-mock 依赖：\n\n        <dependency>\n            <groupId>com.github.fppt</groupId>\n            <artifactId>jedis-mock</artifactId>\n            <version>1.1.2</version>\n        </dependency>\n\n\n然后，记得需要在 IDEA 中，刷新 Maven 依赖。\n\n② 在 YudaoServerApplication 的 main 方法的开头，添加“启动 Redis 服务”的如下代码：\n\nimport com.github.fppt.jedismock.RedisServer;\n\npublic class YudaoServerApplication {\n\n    public static void main(String[] args) {\n        // 启动 Redis 服务\n        RedisServer redisServer = new RedisServer(6379);\n        try {\n            redisServer.start();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n\n        SpringApplication.run(YudaoServerApplication.class, args);\n    }\n\n}\n\n\n之后，启动 YudaoServerApplication 即可。\n\n③ 打开管理后台，进行登录测试。如果登录成功，说明 Redis 已经被成功替换。\n\n\n# 2. 常见问题？\n\n① 启动的时候，出现如下的报错信息，可以直接忽略。\n\n2024-09-02 09:34:03.166 |  WARN 57508 | redisson-netty-1-2 [TID: N/A] o.s.b.a.d.r.RedisReactiveHealthIndicator | Redis health check failed\n\njava.lang.IllegalArgumentException: Value must not be null\n\tat org.springframework.util.Assert.notNull(Assert.java:172)\n\tat org.springframework.boot.actuate.health.Health$Builder.withDetail(Health.java:247)\n\tat org.springframework.boot.actuate.data.redis.RedisHealth.up(RedisHealth.java:37)\n\tat org.springframework.boot.actuate.data.redis.RedisReactiveHealthIndicator.up(RedisReactiveHealthIndicator.java:73)\n\tat org.springframework.boot.actuate.data.redis.RedisReactiveHealthIndicator.lambda$getHealth$4(RedisReactiveHealthIndicator.java:69)\n\n\n② 如果你在多个主机上部署了 Java 服务，无法使用这个方案。如果你在一个主机上部署了多个 Java 服务，可以使用这个方案。\n\n原因是：jedis-mock 是在当前主机上启动的 Redis 服务，无法在多个主机上共享。",
            normalizedContent: "在一些场景下，不希望有 redis 依赖，也有很多用户提出类似的诉求：\n\n * 有大佬实现了不带 redis 的版本了吗？\n * 某个环境没有 redis，所以需要把 redis 给禁用掉？\n\n但是，项目大量使用了 redis 作为缓存、分布式锁、幂等性等功能，所以直接去除 redis 会导致项目无法正常运行。\n\n不过，我们可以换个思路，使用 jedis-mock 库，在项目启动时，自动启动一个 mock 的 redis 服务，这样就可以实现不依赖 redis 的运行。\n\n\n# 1. 如何启动？\n\n① 在 yudao-server 模块的 pom.xml 文件中，添加 jedis-mock 依赖：\n\n        <dependency>\n            <groupid>com.github.fppt</groupid>\n            <artifactid>jedis-mock</artifactid>\n            <version>1.1.2</version>\n        </dependency>\n\n\n然后，记得需要在 idea 中，刷新 maven 依赖。\n\n② 在 yudaoserverapplication 的 main 方法的开头，添加“启动 redis 服务”的如下代码：\n\nimport com.github.fppt.jedismock.redisserver;\n\npublic class yudaoserverapplication {\n\n    public static void main(string[] args) {\n        // 启动 redis 服务\n        redisserver redisserver = new redisserver(6379);\n        try {\n            redisserver.start();\n        } catch (ioexception e) {\n            throw new runtimeexception(e);\n        }\n\n        springapplication.run(yudaoserverapplication.class, args);\n    }\n\n}\n\n\n之后，启动 yudaoserverapplication 即可。\n\n③ 打开管理后台，进行登录测试。如果登录成功，说明 redis 已经被成功替换。\n\n\n# 2. 常见问题？\n\n① 启动的时候，出现如下的报错信息，可以直接忽略。\n\n2024-09-02 09:34:03.166 |  warn 57508 | redisson-netty-1-2 [tid: n/a] o.s.b.a.d.r.redisreactivehealthindicator | redis health check failed\n\njava.lang.illegalargumentexception: value must not be null\n\tat org.springframework.util.assert.notnull(assert.java:172)\n\tat org.springframework.boot.actuate.health.health$builder.withdetail(health.java:247)\n\tat org.springframework.boot.actuate.data.redis.redishealth.up(redishealth.java:37)\n\tat org.springframework.boot.actuate.data.redis.redisreactivehealthindicator.up(redisreactivehealthindicator.java:73)\n\tat org.springframework.boot.actuate.data.redis.redisreactivehealthindicator.lambda$gethealth$4(redisreactivehealthindicator.java:69)\n\n\n② 如果你在多个主机上部署了 java 服务，无法使用这个方案。如果你在一个主机上部署了多个 java 服务，可以使用这个方案。\n\n原因是：jedis-mock 是在当前主机上启动的 redis 服务，无法在多个主机上共享。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "内网穿透",
            frontmatter: {
                title: "内网穿透",
                date: "2023-07-10T10:47:22.000Z",
                permalink: "/natapp"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/01.%E8%90%8C%E6%96%B0%E5%BF%85%E8%AF%BB/98.%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F.html",
            relativePath: "01.开发指南/01.萌新必读/98.内网穿透.md",
            key: "v-14de04f4",
            path: "/natapp/",
            headers: [{
                level: 2,
                title: "1. 第一步，购买隧道",
                slug: "_1-第一步-购买隧道",
                normalizedTitle: "1. 第一步，购买隧道",
                charIndex: 163
            }, {
                level: 2,
                title: "2. 第二步，启动隧道",
                slug: "_2-第二步-启动隧道",
                normalizedTitle: "2. 第二步，启动隧道",
                charIndex: 238
            }],
            headersStr: "1. 第一步，购买隧道 2. 第二步，启动隧道",
            content: "在和外部系统对接时，经常需要将本地的服务，暴露到外网中。这时候，就需要使用内网穿透工具了。例如说：支付宝回调、微信支付回调、微信公众号接入、微信小程序接入等等。\n\n常见的内网穿透工具，例如说，ngrok、frp、natapp 等等。\n\n这里，我们使用 natapp 作为内网穿透工具，转发到后端的 48080 端口。\n\n\n# 1. 第一步，购买隧道\n\n访问 https://natapp.cn/tunnel/buy/free 地址，免费购买一个隧道。如下图所示：\n\n\n\n\n# 2. 第二步，启动隧道\n\n购买完成后，参考 《NATAPP 1 分钟快速新手图文教程》 文档，将 natapp 进行启动。如下图所示：\n\n",
            normalizedContent: "在和外部系统对接时，经常需要将本地的服务，暴露到外网中。这时候，就需要使用内网穿透工具了。例如说：支付宝回调、微信支付回调、微信公众号接入、微信小程序接入等等。\n\n常见的内网穿透工具，例如说，ngrok、frp、natapp 等等。\n\n这里，我们使用 natapp 作为内网穿透工具，转发到后端的 48080 端口。\n\n\n# 1. 第一步，购买隧道\n\n访问 https://natapp.cn/tunnel/buy/free 地址，免费购买一个隧道。如下图所示：\n\n\n\n\n# 2. 第二步，启动隧道\n\n购买完成后，参考 《natapp 1 分钟快速新手图文教程》 文档，将 natapp 进行启动。如下图所示：\n\n",
            charsets: {
                cjk: !0
            }
        }, {
            title: "新建模块",
            frontmatter: {
                title: "新建模块",
                permalink: "/module-new/",
                date: "2022-03-02T13:02:26.000Z"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/02.%E5%90%8E%E7%AB%AF%E6%89%8B%E5%86%8C/01.%E6%96%B0%E5%BB%BA%E6%A8%A1%E5%9D%97.html",
            relativePath: "01.开发指南/02.后端手册/01.新建模块.md",
            key: "v-43c1547e",
            path: "/module-new/",
            headers: [{
                level: 2,
                title: "👍 相关视频教程",
                slug: "👍-相关视频教程",
                normalizedTitle: "👍 相关视频教程",
                charIndex: 149
            }, {
                level: 2,
                title: "1. 新建 demo 模块",
                slug: "_1-新建-demo-模块",
                normalizedTitle: "1. 新建 demo 模块",
                charIndex: 192
            }, {
                level: 2,
                title: "2. 新建 demo-api 子模块",
                slug: "_2-新建-demo-api-子模块",
                normalizedTitle: "2. 新建 demo-api 子模块",
                charIndex: 1281
            }, {
                level: 2,
                title: "3. 新建 demo-biz 子模块",
                slug: "_3-新建-demo-biz-子模块",
                normalizedTitle: "3. 新建 demo-biz 子模块",
                charIndex: 2530
            }, {
                level: 2,
                title: "4. 新建 RESTful API 接口",
                slug: "_4-新建-restful-api-接口",
                normalizedTitle: "4. 新建 restful api 接口",
                charIndex: 4640
            }, {
                level: 2,
                title: "5. 引入 demo 模块",
                slug: "_5-引入-demo-模块",
                normalizedTitle: "5. 引入 demo 模块",
                charIndex: 6788
            }, {
                level: 2,
                title: "6. 访问接口返回 404？",
                slug: "_6-访问接口返回-404",
                normalizedTitle: "6. 访问接口返回 404？",
                charIndex: 7125
            }, {
                level: 2,
                title: "7. 补充说明",
                slug: "_7-补充说明",
                normalizedTitle: "7. 补充说明",
                charIndex: 7434
            }, {
                level: 3,
                title: "7.1 接口分组",
                slug: "_7-1-接口分组",
                normalizedTitle: "7.1 接口分组",
                charIndex: 7446
            }, {
                level: 3,
                title: "7.2 MyBatis 日志",
                slug: "_7-2-mybatis-日志",
                normalizedTitle: "7.2 mybatis 日志",
                charIndex: 7518
            }],
            headersStr: "👍 相关视频教程 1. 新建 demo 模块 2. 新建 demo-api 子模块 3. 新建 demo-biz 子模块 4. 新建 RESTful API 接口 5. 引入 demo 模块 6. 访问接口返回 404？ 7. 补充说明 7.1 接口分组 7.2 MyBatis 日志",
            content: '本章节，将介绍如何新建名字为 yudao-module-demo 的示例模块，并添加 RESTful API 接口。\n\n虽然内容看起来比较长，是因为艿艿写的比较详细，大量截图，保姆级教程！其实只有五个步骤，保持耐心，跟着艿艿一点点来。🙂 完成之后，你会对整个 项目结构 有更充分的了解。\n\n\n# 👍 相关视频教程\n\n * 从零开始 06：如何 5 分钟，创建一个新模块？\n\n\n# 1. 新建 demo 模块\n\n① 选择 File -> New -> Module 菜单，如下图所示：\n\n\n\n② 选择 Maven 类型，并点击 Next 按钮，如下图所示：\n\n\n\n③ 选择父模块为 yudao，输入名字为 yudao-module-demo，并点击 Finish 按钮，如下图所示：\n\n\n\n④ 打开 yudao-module-demo 模块，删除 src 文件，如下图所示：\n\n\n\n⑤ 打开 yudao-module-demo 模块的 pom.xml 文件，修改内容如下：\n\n提示\n\n\x3c!-- --\x3e 部分，只是注释，不需要写到 XML 中。\n\n<?xml version="1.0" encoding="UTF-8"?>\n<project xmlns="http://maven.apache.org/POM/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <parent>\n        <artifactId>yudao</artifactId>\n        <groupId>cn.iocoder.boot</groupId>\n        <version>${revision}</version> \x3c!-- 1. 修改 version 为 ${revision} --\x3e\n    </parent>\n    <modelVersion>4.0.0</modelVersion>\n\n    <artifactId>yudao-module-demo</artifactId>\n    <packaging>pom</packaging> \x3c!-- 2. 新增 packaging 为 pom --\x3e\n\n    <name>${project.artifactId}</name> \x3c!-- 3. 新增 name 为 ${project.artifactId} --\x3e\n    <description> \x3c!-- 4. 新增 description 为该模块的描述 --\x3e\n        demo 模块，主要实现 XXX、YYY、ZZZ 等功能。\n    </description>\n\n</project>\n\n\n\n# 2. 新建 demo-api 子模块\n\n① 新建 yudao-module-demo-api 子模块，整个过程和“新建 demo 模块”是一致的，如下图所示：\n\n\n\n\n\n\n\n② 打开 yudao-module-demo-api 模块的 pom.xml 文件，修改内容如下：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<project xmlns="http://maven.apache.org/POM/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <parent>\n        <artifactId>yudao-module-demo</artifactId>\n        <groupId>cn.iocoder.boot</groupId>\n        <version>${revision}</version> \x3c!-- 1. 修改 version 为 ${revision} --\x3e\n    </parent>\n    <modelVersion>4.0.0</modelVersion>\n    <artifactId>yudao-module-demo-api</artifactId>\n    <packaging>jar</packaging> \x3c!-- 2. 新增 packaging 为 jar --\x3e\n\n    <name>${project.artifactId}</name> \x3c!-- 3. 新增 name 为 ${project.artifactId} --\x3e\n    <description> \x3c!-- 4. 新增 description 为该模块的描述 --\x3e\n        demo 模块 API，暴露给其它模块调用\n    </description>\n\n    <dependencies>  \x3c!-- 5. 新增 yudao-common 依赖 --\x3e\n        <dependency>\n            <groupId>cn.iocoder.boot</groupId>\n            <artifactId>yudao-common</artifactId>\n        </dependency>\n    </dependencies>\n\n</project>\n\n\n③ 【可选】新建 cn.iocoder.yudao.module.demo 基础包，其中 demo 为模块名。之后，新建 api 和 enums 包。如下图所示：\n\n\n\n\n# 3. 新建 demo-biz 子模块\n\n① 新建 yudao-module-demo-biz 子模块，整个过程和“新建 demo 模块”也是一致的，如下图所示：\n\n\n\n\n\n\n\n② 打开 yudao-module-demo-biz 模块的 pom.xml 文件，修改成内容如下：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<project xmlns="http://maven.apache.org/POM/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <parent>\n        <artifactId>yudao-module-demo</artifactId>\n        <groupId>cn.iocoder.boot</groupId>\n        <version>${revision}</version> \x3c!-- 1. 修改 version 为 ${revision} --\x3e\n    </parent>\n    <modelVersion>4.0.0</modelVersion>\n    <packaging>jar</packaging> \x3c!-- 2. 新增 packaging 为 jar --\x3e\n\n    <artifactId>yudao-module-demo-biz</artifactId>\n\n    <name>${project.artifactId}</name> \x3c!-- 3. 新增 name 为 ${project.artifactId} --\x3e\n    <description> \x3c!-- 4. 新增 description 为该模块的描述 --\x3e\n        demo 模块，主要实现 XXX、YYY、ZZZ 等功能。\n    </description>\n\n    <dependencies>  \x3c!-- 5. 新增依赖，这里引入的都是比较常用的业务组件、技术组件 --\x3e\n        <dependency>\n            <groupId>cn.iocoder.boot</groupId>\n            <artifactId>yudao-module-demo-api</artifactId>\n            <version>${revision}</version>\n        </dependency>\n\n        \x3c!-- Web 相关 --\x3e\n        <dependency>\n            <groupId>cn.iocoder.boot</groupId>\n            <artifactId>yudao-spring-boot-starter-web</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>cn.iocoder.boot</groupId>\n            <artifactId>yudao-spring-boot-starter-security</artifactId>\n        </dependency>\n\n        \x3c!-- DB 相关 --\x3e\n        <dependency>\n            <groupId>cn.iocoder.boot</groupId>\n            <artifactId>yudao-spring-boot-starter-mybatis</artifactId>\n        </dependency>\n\n        \x3c!-- Test 测试相关 --\x3e\n        <dependency>\n            <groupId>cn.iocoder.boot</groupId>\n            <artifactId>yudao-spring-boot-starter-test</artifactId>\n        </dependency>\n    </dependencies>\n    \n</project>\n\n\n③ 【必选】新建 cn.iocoder.yudao.module.demo 基础包，其中 demo 为模块名。之后，新建 controller.admin 和 controller.app 等包。如下图所示：\n\n\n\n④ 打开 Maven 菜单，点击刷新按钮，让引入的 Maven 依赖生效。如下图所示：\n\n\n\n\n# 4. 新建 RESTful API 接口\n\n① 在 controller.admin 包，新建一个 DemoTestController 类，并新建一个 /demo/test/get 接口。代码如下：\n\npackage cn.iocoder.yudao.module.demo.controller.admin;\n\nimport cn.iocoder.yudao.framework.common.pojo.CommonResult;\nimport io.swagger.v3.oas.annotations.tags.Tag;\nimport io.swagger.v3.oas.annotations.Operation;\nimport org.springframework.validation.annotation.Validated;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport static cn.iocoder.yudao.framework.common.pojo.CommonResult.success;\n\n@Tag(name = "管理后台 - Test")\n@RestController\n@RequestMapping("/demo/test")\n@Validated\npublic class DemoTestController {\n\n    @GetMapping("/get")\n    @Operation(summary = "获取 test 信息")\n    public CommonResult<String> get() {\n        return success("true");\n    }\n\n}\n\n\n注意，/demo 是该模块所有 RESTful API 的基础路径，/test 是 Test 功能的基础路径。\n\n① 在 controller.app 包，新建一个 AppDemoTestController 类，并新建一个 /demo/test/get 接口。代码如下：\n\npackage cn.iocoder.yudao.module.demo.controller.app;\n\nimport cn.iocoder.yudao.framework.common.pojo.CommonResult;\nimport io.swagger.v3.oas.annotations.tags.Tag;\nimport io.swagger.v3.oas.annotations.Operation;\nimport org.springframework.validation.annotation.Validated;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport static cn.iocoder.yudao.framework.common.pojo.CommonResult.success;\n\n@Tag(name = "用户 App - Test")\n@RestController\n@RequestMapping("/demo/test")\n@Validated\npublic class AppDemoTestController {\n\n    @GetMapping("/get")\n    @Operation(summary = "获取 test 信息")\n    public CommonResult<String> get() {\n        return success("true");\n    }\n\n}\n\n\n在 Controller 的命名上，额外增加 App 作为前缀，一方面区分是管理后台还是用户 App 的 Controller，另一方面避免 Spring Bean 的名字冲突。\n\n可能你会奇怪，这里我们定义了两个 /demo/test/get 接口，会不会存在重复导致冲突呢？答案，当然是并不会。原因是：\n\n * controller.admin 包下的接口，默认会增加 /admin-api，即最终的访问地址是 /admin-api/demo/test/get\n * controller.app 包下的接口，默认会增加 /app-api，即最终的访问地址是 /app-api/demo/test/get\n\n\n# 5. 引入 demo 模块\n\n① 在 yudao-server 模块的 pom.xml 文件，引入 yudao-module-demo-biz 子模块，并点击 Maven 刷新。如下图所示：\n\n\n\n② 运行 YudaoServerApplication 类，将后端项目进行启动。启动完成后，使用浏览器打开 http://127.0.0.1:48080/doc.html 地址，进入 Swagger 接口文档。\n\n③ 打开“管理后台 - Test”接口，进行 /admin-api/demo/test/get 接口的调试，如下图所示：\n\n\n\n④ 打开“用户 App - Test”接口，进行 /app-api/demo/test/get 接口的调试，如下图所示：\n\n\n\n\n# 6. 访问接口返回 404？\n\n请检查，你新建的模块的 package 包名是不是在 cn.iocoder.yudao.module 下！\n\n如果不是，修改 YudaoServerApplication 类，增加新建的模块的 package 包名。例如说：\n\n@SpringBootApplication(scanBasePackages = {"${yudao.info.base-package}.server", "${yudao.info.base-package}.module",\n    "xxx.yyy.zzz"}) // xxx.yyy.zzz 是你新建的模块的 `package` 包名\n\n\n\n# 7. 补充说明\n\n\n# 7.1 接口分组\n\n如果你想 Swagger 有该模块的接口分组，则需要新建 GroupedOpenApi Bean。如下图所示：\n\n\n\n\n# 7.2 MyBatis 日志\n\n如果你希望新模块的 MyBatis 查询会打印 SQL 日志，需要在 logging.level 配置对应的 Logger。如下图所示：\n\n',
            normalizedContent: '本章节，将介绍如何新建名字为 yudao-module-demo 的示例模块，并添加 restful api 接口。\n\n虽然内容看起来比较长，是因为艿艿写的比较详细，大量截图，保姆级教程！其实只有五个步骤，保持耐心，跟着艿艿一点点来。🙂 完成之后，你会对整个 项目结构 有更充分的了解。\n\n\n# 👍 相关视频教程\n\n * 从零开始 06：如何 5 分钟，创建一个新模块？\n\n\n# 1. 新建 demo 模块\n\n① 选择 file -> new -> module 菜单，如下图所示：\n\n\n\n② 选择 maven 类型，并点击 next 按钮，如下图所示：\n\n\n\n③ 选择父模块为 yudao，输入名字为 yudao-module-demo，并点击 finish 按钮，如下图所示：\n\n\n\n④ 打开 yudao-module-demo 模块，删除 src 文件，如下图所示：\n\n\n\n⑤ 打开 yudao-module-demo 模块的 pom.xml 文件，修改内容如下：\n\n提示\n\n\x3c!-- --\x3e 部分，只是注释，不需要写到 xml 中。\n\n<?xml version="1.0" encoding="utf-8"?>\n<project xmlns="http://maven.apache.org/pom/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n         xsi:schemalocation="http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <parent>\n        <artifactid>yudao</artifactid>\n        <groupid>cn.iocoder.boot</groupid>\n        <version>${revision}</version> \x3c!-- 1. 修改 version 为 ${revision} --\x3e\n    </parent>\n    <modelversion>4.0.0</modelversion>\n\n    <artifactid>yudao-module-demo</artifactid>\n    <packaging>pom</packaging> \x3c!-- 2. 新增 packaging 为 pom --\x3e\n\n    <name>${project.artifactid}</name> \x3c!-- 3. 新增 name 为 ${project.artifactid} --\x3e\n    <description> \x3c!-- 4. 新增 description 为该模块的描述 --\x3e\n        demo 模块，主要实现 xxx、yyy、zzz 等功能。\n    </description>\n\n</project>\n\n\n\n# 2. 新建 demo-api 子模块\n\n① 新建 yudao-module-demo-api 子模块，整个过程和“新建 demo 模块”是一致的，如下图所示：\n\n\n\n\n\n\n\n② 打开 yudao-module-demo-api 模块的 pom.xml 文件，修改内容如下：\n\n<?xml version="1.0" encoding="utf-8"?>\n<project xmlns="http://maven.apache.org/pom/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n         xsi:schemalocation="http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <parent>\n        <artifactid>yudao-module-demo</artifactid>\n        <groupid>cn.iocoder.boot</groupid>\n        <version>${revision}</version> \x3c!-- 1. 修改 version 为 ${revision} --\x3e\n    </parent>\n    <modelversion>4.0.0</modelversion>\n    <artifactid>yudao-module-demo-api</artifactid>\n    <packaging>jar</packaging> \x3c!-- 2. 新增 packaging 为 jar --\x3e\n\n    <name>${project.artifactid}</name> \x3c!-- 3. 新增 name 为 ${project.artifactid} --\x3e\n    <description> \x3c!-- 4. 新增 description 为该模块的描述 --\x3e\n        demo 模块 api，暴露给其它模块调用\n    </description>\n\n    <dependencies>  \x3c!-- 5. 新增 yudao-common 依赖 --\x3e\n        <dependency>\n            <groupid>cn.iocoder.boot</groupid>\n            <artifactid>yudao-common</artifactid>\n        </dependency>\n    </dependencies>\n\n</project>\n\n\n③ 【可选】新建 cn.iocoder.yudao.module.demo 基础包，其中 demo 为模块名。之后，新建 api 和 enums 包。如下图所示：\n\n\n\n\n# 3. 新建 demo-biz 子模块\n\n① 新建 yudao-module-demo-biz 子模块，整个过程和“新建 demo 模块”也是一致的，如下图所示：\n\n\n\n\n\n\n\n② 打开 yudao-module-demo-biz 模块的 pom.xml 文件，修改成内容如下：\n\n<?xml version="1.0" encoding="utf-8"?>\n<project xmlns="http://maven.apache.org/pom/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n         xsi:schemalocation="http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <parent>\n        <artifactid>yudao-module-demo</artifactid>\n        <groupid>cn.iocoder.boot</groupid>\n        <version>${revision}</version> \x3c!-- 1. 修改 version 为 ${revision} --\x3e\n    </parent>\n    <modelversion>4.0.0</modelversion>\n    <packaging>jar</packaging> \x3c!-- 2. 新增 packaging 为 jar --\x3e\n\n    <artifactid>yudao-module-demo-biz</artifactid>\n\n    <name>${project.artifactid}</name> \x3c!-- 3. 新增 name 为 ${project.artifactid} --\x3e\n    <description> \x3c!-- 4. 新增 description 为该模块的描述 --\x3e\n        demo 模块，主要实现 xxx、yyy、zzz 等功能。\n    </description>\n\n    <dependencies>  \x3c!-- 5. 新增依赖，这里引入的都是比较常用的业务组件、技术组件 --\x3e\n        <dependency>\n            <groupid>cn.iocoder.boot</groupid>\n            <artifactid>yudao-module-demo-api</artifactid>\n            <version>${revision}</version>\n        </dependency>\n\n        \x3c!-- web 相关 --\x3e\n        <dependency>\n            <groupid>cn.iocoder.boot</groupid>\n            <artifactid>yudao-spring-boot-starter-web</artifactid>\n        </dependency>\n\n        <dependency>\n            <groupid>cn.iocoder.boot</groupid>\n            <artifactid>yudao-spring-boot-starter-security</artifactid>\n        </dependency>\n\n        \x3c!-- db 相关 --\x3e\n        <dependency>\n            <groupid>cn.iocoder.boot</groupid>\n            <artifactid>yudao-spring-boot-starter-mybatis</artifactid>\n        </dependency>\n\n        \x3c!-- test 测试相关 --\x3e\n        <dependency>\n            <groupid>cn.iocoder.boot</groupid>\n            <artifactid>yudao-spring-boot-starter-test</artifactid>\n        </dependency>\n    </dependencies>\n    \n</project>\n\n\n③ 【必选】新建 cn.iocoder.yudao.module.demo 基础包，其中 demo 为模块名。之后，新建 controller.admin 和 controller.app 等包。如下图所示：\n\n\n\n④ 打开 maven 菜单，点击刷新按钮，让引入的 maven 依赖生效。如下图所示：\n\n\n\n\n# 4. 新建 restful api 接口\n\n① 在 controller.admin 包，新建一个 demotestcontroller 类，并新建一个 /demo/test/get 接口。代码如下：\n\npackage cn.iocoder.yudao.module.demo.controller.admin;\n\nimport cn.iocoder.yudao.framework.common.pojo.commonresult;\nimport io.swagger.v3.oas.annotations.tags.tag;\nimport io.swagger.v3.oas.annotations.operation;\nimport org.springframework.validation.annotation.validated;\nimport org.springframework.web.bind.annotation.getmapping;\nimport org.springframework.web.bind.annotation.requestmapping;\nimport org.springframework.web.bind.annotation.restcontroller;\n\nimport static cn.iocoder.yudao.framework.common.pojo.commonresult.success;\n\n@tag(name = "管理后台 - test")\n@restcontroller\n@requestmapping("/demo/test")\n@validated\npublic class demotestcontroller {\n\n    @getmapping("/get")\n    @operation(summary = "获取 test 信息")\n    public commonresult<string> get() {\n        return success("true");\n    }\n\n}\n\n\n注意，/demo 是该模块所有 restful api 的基础路径，/test 是 test 功能的基础路径。\n\n① 在 controller.app 包，新建一个 appdemotestcontroller 类，并新建一个 /demo/test/get 接口。代码如下：\n\npackage cn.iocoder.yudao.module.demo.controller.app;\n\nimport cn.iocoder.yudao.framework.common.pojo.commonresult;\nimport io.swagger.v3.oas.annotations.tags.tag;\nimport io.swagger.v3.oas.annotations.operation;\nimport org.springframework.validation.annotation.validated;\nimport org.springframework.web.bind.annotation.getmapping;\nimport org.springframework.web.bind.annotation.requestmapping;\nimport org.springframework.web.bind.annotation.restcontroller;\n\nimport static cn.iocoder.yudao.framework.common.pojo.commonresult.success;\n\n@tag(name = "用户 app - test")\n@restcontroller\n@requestmapping("/demo/test")\n@validated\npublic class appdemotestcontroller {\n\n    @getmapping("/get")\n    @operation(summary = "获取 test 信息")\n    public commonresult<string> get() {\n        return success("true");\n    }\n\n}\n\n\n在 controller 的命名上，额外增加 app 作为前缀，一方面区分是管理后台还是用户 app 的 controller，另一方面避免 spring bean 的名字冲突。\n\n可能你会奇怪，这里我们定义了两个 /demo/test/get 接口，会不会存在重复导致冲突呢？答案，当然是并不会。原因是：\n\n * controller.admin 包下的接口，默认会增加 /admin-api，即最终的访问地址是 /admin-api/demo/test/get\n * controller.app 包下的接口，默认会增加 /app-api，即最终的访问地址是 /app-api/demo/test/get\n\n\n# 5. 引入 demo 模块\n\n① 在 yudao-server 模块的 pom.xml 文件，引入 yudao-module-demo-biz 子模块，并点击 maven 刷新。如下图所示：\n\n\n\n② 运行 yudaoserverapplication 类，将后端项目进行启动。启动完成后，使用浏览器打开 http://127.0.0.1:48080/doc.html 地址，进入 swagger 接口文档。\n\n③ 打开“管理后台 - test”接口，进行 /admin-api/demo/test/get 接口的调试，如下图所示：\n\n\n\n④ 打开“用户 app - test”接口，进行 /app-api/demo/test/get 接口的调试，如下图所示：\n\n\n\n\n# 6. 访问接口返回 404？\n\n请检查，你新建的模块的 package 包名是不是在 cn.iocoder.yudao.module 下！\n\n如果不是，修改 yudaoserverapplication 类，增加新建的模块的 package 包名。例如说：\n\n@springbootapplication(scanbasepackages = {"${yudao.info.base-package}.server", "${yudao.info.base-package}.module",\n    "xxx.yyy.zzz"}) // xxx.yyy.zzz 是你新建的模块的 `package` 包名\n\n\n\n# 7. 补充说明\n\n\n# 7.1 接口分组\n\n如果你想 swagger 有该模块的接口分组，则需要新建 groupedopenapi bean。如下图所示：\n\n\n\n\n# 7.2 mybatis 日志\n\n如果你希望新模块的 mybatis 查询会打印 sql 日志，需要在 logging.level 配置对应的 logger。如下图所示：\n\n',
            charsets: {
                cjk: !0
            }
        }, {
            title: "代码生成【单表】（新增功能）",
            frontmatter: {
                title: "代码生成【单表】（新增功能）",
                date: "2022-03-07T12:34:03.000Z",
                permalink: "/new-feature",
                vue3: !0
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/02.%E5%90%8E%E7%AB%AF%E6%89%8B%E5%86%8C/02.%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%EF%BC%88%E5%8D%95%E8%A1%A8%EF%BC%89.html",
            relativePath: "01.开发指南/02.后端手册/02.代码生成（单表）.md",
            key: "v-a1e90a8a",
            path: "/new-feature/",
            headers: [{
                level: 2,
                title: "👍 相关视频教程",
                slug: "👍-相关视频教程",
                normalizedTitle: "👍 相关视频教程",
                charIndex: 300
            }, {
                level: 2,
                title: "1. 数据库表结构设计",
                slug: "_1-数据库表结构设计",
                normalizedTitle: "1. 数据库表结构设计",
                charIndex: 343
            }, {
                level: 2,
                title: "2. 代码生成",
                slug: "_2-代码生成",
                normalizedTitle: "2. 代码生成",
                charIndex: 1675
            }, {
                level: 3,
                title: "2.1 导入表",
                slug: "_2-1-导入表",
                normalizedTitle: "2.1 导入表",
                charIndex: 1687
            }, {
                level: 3,
                title: "2.2 编辑配置",
                slug: "_2-2-编辑配置",
                normalizedTitle: "2.2 编辑配置",
                charIndex: 1820
            }, {
                level: 3,
                title: "2.3 预览代码",
                slug: "_2-3-预览代码",
                normalizedTitle: "2.3 预览代码",
                charIndex: 2707
            }, {
                level: 3,
                title: "2.4 生成代码",
                slug: "_2-4-生成代码",
                normalizedTitle: "2.4 生成代码",
                charIndex: 2772
            }, {
                level: 2,
                title: "3. 代码运行",
                slug: "_3-代码运行",
                normalizedTitle: "3. 代码运行",
                charIndex: 2919
            }, {
                level: 3,
                title: "3.1 后端运行",
                slug: "_3-1-后端运行",
                normalizedTitle: "3.1 后端运行",
                charIndex: 2959
            }, {
                level: 3,
                title: "3.2 前端运行",
                slug: "_3-2-前端运行",
                normalizedTitle: "3.2 前端运行",
                charIndex: 3771
            }, {
                level: 2,
                title: "4. 后续变更",
                slug: "_4-后续变更",
                normalizedTitle: "4. 后续变更",
                charIndex: 4059
            }, {
                level: 2,
                title: "5. 常见问题",
                slug: "_5-常见问题",
                normalizedTitle: "5. 常见问题",
                charIndex: 4368
            }],
            headersStr: "👍 相关视频教程 1. 数据库表结构设计 2. 代码生成 2.1 导入表 2.2 编辑配置 2.3 预览代码 2.4 生成代码 3. 代码运行 3.1 后端运行 3.2 前端运行 4. 后续变更 5. 常见问题",
            content: "大部分项目里，其实有很多代码是重复的，几乎每个模块都有 CRUD 增删改查的功能，而这些功能的实现代码往往是大同小异的。如果这些功能都要自己去手写，非常无聊枯燥，浪费时间且效率很低，还可能会写错。\n\n所以这种重复性的代码，项目提供了 codegen 代码生成器，只需要在数据库中设计好表结构，就可以一键生成前后端代码 + 单元测试 + Swagger 接口文档 + Validator 参数校验。\n\n针对不同的业务场景，项目提供了三种模式：单表、树表、主子表。\n\n本文，我们将演示“单表”的使用，基于代码生成器，在 yudao-module-system 模块中，开发一个【用户组】的功能。\n\n\n# 👍 相关视频教程\n\n * 从零开始 05：如何 5 分钟，开发一个新功能？\n\n\n# 1. 数据库表结构设计\n\n设计用户组的数据库表名为 system_group，其建表语句如下：\n\nCREATE TABLE `system_group` (\n    `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n    `name` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '名字',\n    `description` varchar(512) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '描述',\n    `status` tinyint NOT NULL COMMENT '状态',\n    `creator` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT '' COMMENT '创建者',\n    `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\n    `updater` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT '' COMMENT '更新者',\n    `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',\n    `deleted` bit(1) NOT NULL DEFAULT b'0' COMMENT '是否删除',\n    `tenant_id` bigint NOT NULL DEFAULT '0' COMMENT '租户编号',\n    PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='用户组';\n\n\n\n\n① 表名的前缀，要和 Maven Module 的模块名保持一致。例如说，用户组在 yudao-module-system 模块，所以表名的前缀是 system_。\n\n疑问：为什么要保持一致？\n\n代码生成器会自动解析表名的前缀，获得其所属的 Maven Module 模块，简化配置过程。\n\n② 设置 ID 主键，一般推荐使用 bigint 长整形，并设置自增长。\n\n③ 正确设置每个字段是否允许空，代码生成器会根据它生成参数是否允许空的校验规则。\n\n④ 正确设置注释，代码生成器会根据它生成字段名与提示等信息。\n\n⑤ 添加 creator、create_time、updater、update_time、deleted 是必须设置的系统字段；如果开启多租户的功能，并且该表需要多租户的隔离，则需要添加 tenant_id 字段。\n\n\n# 2. 代码生成\n\n\n# 2.1 导入表\n\n点击 [基础设施 -> 代码生成] 菜单，点击 [基于 DB 导入] 按钮，选择 system_group 表，后点击 [确认] 按钮。\n\n\n\n代码实现？\n\n可见 CodegenBuilder 类，自动解析数据库的表结构，生成默认的配置。\n\n\n# 2.2 编辑配置\n\n点击 system_group 所在行的 [编辑] 按钮，修改生成配置。后操作如下：\n\n\n\n\n\n * 将 status 字段的显示类型为【下拉框】，字典类型为【系统状态】。\n * 将 description 字段的【查询】取消。\n * 将 id、name、description、status 字段的【示例】填写上。\n\n字段信息\n\n * 插入：新增时，是否传递该字段。\n * 编辑：修改时，是否传递该字段。\n * 列表：Table 表格，是否展示该字段。\n * 查询：搜索框，是否支持该字段查询，查询的条件是什么。\n * 允许空：新增或修改时，是否必须传递该字段，用于 Validator 参数校验。\n * 字典类型：在显示类型是下拉框、单选框、复选框时，选择使用的字典。\n * 示例：参数示例，用于 Swagger 接口文档的 example 示例。\n\n\n\n * 将【上级菜单】设置为【系统管理】。\n * 将【前端类型】设置为“前端项目”对应的“前端类型”。例如说，我们这里演示的是 yudao-ui-admin-vue3 前端项目，则选择了【Vue3 Element Plus 标准模版】。\n\n前端项目                  前端类型\nyudao-ui-admin-vue2   Vue2 Element UI 标准模版\nyudao-ui-admin-vue3   Vue3 Element Plus 标准模版\nyudao-ui-admin-vben   Vue3 Vben 模版\n\n生成信息\n\n * 生成场景：分成管理后台、用户 App 两种，用于生成 Controller 放在 admin 还是 app 包。\n * 上级菜单：生成场景是管理后台时，需要设置其所属的上级菜单。\n * 前端类型： 提供多种 UI 模版。后端的 application.yaml 配置文件中的 yudao.codegen.front-type 配置项，设置默认的 UI 模版，避免每次都需要设置。\n\n完成后，点击 [提交] 按钮，保存生成配置。\n\n\n# 2.3 预览代码\n\n点击 system_group 所在行的 [预览] 按钮，在线预览生成的代码，检查是否符合预期。\n\n\n\n\n# 2.4 生成代码\n\n点击 system_group 所在行的 [生成代码] 按钮，下载生成代码的压缩包，双击进行解压。\n\n\n\n代码实现？\n\n可见 CodegenEngine 类，基于 Velocity 模板引擎，生成具体代码。模板文件，可见 resources/codegen 目录。\n\n\n# 3. 代码运行\n\n本小节，我们将生成的代码，复制到项目中，并进行运行。\n\n\n# 3.1 后端运行\n\n① 将生成的后端代码，复制到项目中。操作如下图所示：\n\n\n\n② 将 ErrorCodeConstants.java_手动操作 文件的错误码，复制到该模块 ErrorCodeConstants 类中，并设置对应的错误码编号，之后进行删除。操作如下图所示：\n\n\n\n③ 将 h2.sql 的 CREATE 语句复制到该模块的 create_tables.sql 文件，DELETE 语句复制到该模块的 clean.sql。操作如下图：\n\n友情提示：最新版本，第 ③ 部分的单元测试，默认已经不在生成。所以，不需要操作这一步。\n\n原因是：大多数团队，没有编写单元测试的习惯，导致生成的单元测试代码，会被直接删除。所以，我们默认不生成单元测试代码，减少不必要的代码生成。\n\n如果想要开启，可以把 yudao.codegen.unit-test-enable 配置项设置为 true，然后重新生成代码。\n\n另外，如果你想要编写单元测试，可以考虑使用 MarsCode 智能编码插件，可以免费生成不错的单元测试。\n\n\n\n疑问：`create_tables.sql` 和 `clean.sql` 文件的作用是什么？\n\n项目的单元测试，需要使用到 H2 内存数据库，create_tables.sql 用于创建所有的表结构，clean.sql 用于每个单元测试的方法跑完后清理数据。\n\n然后，运行 GroupServiceImplTest 单元测试，执行通过。\n\n④ 打开数据库工具，运行代码生成的 sql/sql.sql 文件，用于菜单的初始化。\n\n\n\n⑤ Debug 运行 YudaoServerApplication 类，启动后端项目。通过 IDEA 的 [Actuator -> Mappings] 菜单，可以看到代码生成的 GroupController 的 RESTful API 接口已经生效。\n\n\n\n\n# 3.2 前端运行\n\n① 将生成的前端代码，复制到项目中。操作如下图所示：\n\n\n\n② 重新执行 npm run dev 命令，启动前端项目。点击 [系统管理 -> 菜单管理] 菜单，点击【刷新菜单缓存】，因为前端项目会缓存菜单在内存中的，所以需要刷新一下。\n\n③ 点击 [系统管理 -> 用户组管理] 菜单，就可以看到用户组的 UI 界面。\n\n\n\n----------------------------------------\n\n至此，我们已经完成了【用户组】功能的代码生成，基本节省了你 80% 左右的开发任务，后续可以根据自己的需求，进行剩余的 20% 的开发！\n\n\n# 4. 后续变更\n\n随着业务的发展，已经生成代码的功能需要变更。继续以【用户组】举例子，它的 system_group 表需要新增一个分类 category 字段，此时不建议使用代码生成器，而是直接修改已经生成的代码：\n\n① 后端：修改 GroupDO 数据实体类、GroupSaveReqVO 保存 VO 类、GroupSaveRespVO 响应 VO 类，新增 category 字段。\n\n② 前端：修改 Vue 的 index.vue 列表和 Form 表单组件，新增 category 字段。\n\n③ 重新编译后后端，并进行启动。\n\nover！非常简单方便，即保证了代码的整洁规范，又不增加过多的开发量。\n\n\n# 5. 常见问题\n\n① 生成的代码结构，有没具体说明？\n\n答：参见 《项目结构》 文档的说明，最好把对应视频好好看下。\n\n② 为什么要分 XXXSaveReqVO、XXXRespVO、XXXPageReqVO 三个 VO 类？\n\n答：星球里 https://t.zsxq.com/14Fc743WH 进行了 VO 拆分的讨论，总体大家倾向拆分成三个 VO 类，因为这样更加清晰，而且也不会增加太多的维护工作量。\n\n可能你会想，能不能把 XXXSaveReqVO 和 XXXRespVO 合并成一个呢？有两方面的考虑：\n\n 1. 一般来说，新增/修改是不传递 createTime、creator 等字段，响应是需要返回 createTime、creator 等字段，两者的字段无法不一致。\n 2. 一旦 VO 和 DO 拆分开后，调整字段时，例如说新增一个 xxx 字段，两个 VO 的修改成本，和一个 VO 实际是差不多的。\n\n③ 为什么 UI 界面的数据字典，下拉没有选项，或者列表没有展示它的文本？\n\n类似 https://t.zsxq.com/owJzU 的问题。\n\n原因是：需要在前端的代码里，枚举一下。例如说 Vue3 + Element-Plus 版本，需要在 yudao-ui-admin-vue3/src/utils/dict.ts 的 DICT_TYPE 添加字典的 type 枚举值。",
            normalizedContent: "大部分项目里，其实有很多代码是重复的，几乎每个模块都有 crud 增删改查的功能，而这些功能的实现代码往往是大同小异的。如果这些功能都要自己去手写，非常无聊枯燥，浪费时间且效率很低，还可能会写错。\n\n所以这种重复性的代码，项目提供了 codegen 代码生成器，只需要在数据库中设计好表结构，就可以一键生成前后端代码 + 单元测试 + swagger 接口文档 + validator 参数校验。\n\n针对不同的业务场景，项目提供了三种模式：单表、树表、主子表。\n\n本文，我们将演示“单表”的使用，基于代码生成器，在 yudao-module-system 模块中，开发一个【用户组】的功能。\n\n\n# 👍 相关视频教程\n\n * 从零开始 05：如何 5 分钟，开发一个新功能？\n\n\n# 1. 数据库表结构设计\n\n设计用户组的数据库表名为 system_group，其建表语句如下：\n\ncreate table `system_group` (\n    `id` bigint not null auto_increment comment '编号',\n    `name` varchar(255) collate utf8mb4_unicode_ci not null comment '名字',\n    `description` varchar(512) collate utf8mb4_unicode_ci default null comment '描述',\n    `status` tinyint not null comment '状态',\n    `creator` varchar(64) character set utf8mb4 collate utf8mb4_unicode_ci default '' comment '创建者',\n    `create_time` datetime not null default current_timestamp comment '创建时间',\n    `updater` varchar(64) character set utf8mb4 collate utf8mb4_unicode_ci default '' comment '更新者',\n    `update_time` datetime not null default current_timestamp on update current_timestamp comment '更新时间',\n    `deleted` bit(1) not null default b'0' comment '是否删除',\n    `tenant_id` bigint not null default '0' comment '租户编号',\n    primary key (`id`) using btree\n) engine=innodb default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='用户组';\n\n\n\n\n① 表名的前缀，要和 maven module 的模块名保持一致。例如说，用户组在 yudao-module-system 模块，所以表名的前缀是 system_。\n\n疑问：为什么要保持一致？\n\n代码生成器会自动解析表名的前缀，获得其所属的 maven module 模块，简化配置过程。\n\n② 设置 id 主键，一般推荐使用 bigint 长整形，并设置自增长。\n\n③ 正确设置每个字段是否允许空，代码生成器会根据它生成参数是否允许空的校验规则。\n\n④ 正确设置注释，代码生成器会根据它生成字段名与提示等信息。\n\n⑤ 添加 creator、create_time、updater、update_time、deleted 是必须设置的系统字段；如果开启多租户的功能，并且该表需要多租户的隔离，则需要添加 tenant_id 字段。\n\n\n# 2. 代码生成\n\n\n# 2.1 导入表\n\n点击 [基础设施 -> 代码生成] 菜单，点击 [基于 db 导入] 按钮，选择 system_group 表，后点击 [确认] 按钮。\n\n\n\n代码实现？\n\n可见 codegenbuilder 类，自动解析数据库的表结构，生成默认的配置。\n\n\n# 2.2 编辑配置\n\n点击 system_group 所在行的 [编辑] 按钮，修改生成配置。后操作如下：\n\n\n\n\n\n * 将 status 字段的显示类型为【下拉框】，字典类型为【系统状态】。\n * 将 description 字段的【查询】取消。\n * 将 id、name、description、status 字段的【示例】填写上。\n\n字段信息\n\n * 插入：新增时，是否传递该字段。\n * 编辑：修改时，是否传递该字段。\n * 列表：table 表格，是否展示该字段。\n * 查询：搜索框，是否支持该字段查询，查询的条件是什么。\n * 允许空：新增或修改时，是否必须传递该字段，用于 validator 参数校验。\n * 字典类型：在显示类型是下拉框、单选框、复选框时，选择使用的字典。\n * 示例：参数示例，用于 swagger 接口文档的 example 示例。\n\n\n\n * 将【上级菜单】设置为【系统管理】。\n * 将【前端类型】设置为“前端项目”对应的“前端类型”。例如说，我们这里演示的是 yudao-ui-admin-vue3 前端项目，则选择了【vue3 element plus 标准模版】。\n\n前端项目                  前端类型\nyudao-ui-admin-vue2   vue2 element ui 标准模版\nyudao-ui-admin-vue3   vue3 element plus 标准模版\nyudao-ui-admin-vben   vue3 vben 模版\n\n生成信息\n\n * 生成场景：分成管理后台、用户 app 两种，用于生成 controller 放在 admin 还是 app 包。\n * 上级菜单：生成场景是管理后台时，需要设置其所属的上级菜单。\n * 前端类型： 提供多种 ui 模版。后端的 application.yaml 配置文件中的 yudao.codegen.front-type 配置项，设置默认的 ui 模版，避免每次都需要设置。\n\n完成后，点击 [提交] 按钮，保存生成配置。\n\n\n# 2.3 预览代码\n\n点击 system_group 所在行的 [预览] 按钮，在线预览生成的代码，检查是否符合预期。\n\n\n\n\n# 2.4 生成代码\n\n点击 system_group 所在行的 [生成代码] 按钮，下载生成代码的压缩包，双击进行解压。\n\n\n\n代码实现？\n\n可见 codegenengine 类，基于 velocity 模板引擎，生成具体代码。模板文件，可见 resources/codegen 目录。\n\n\n# 3. 代码运行\n\n本小节，我们将生成的代码，复制到项目中，并进行运行。\n\n\n# 3.1 后端运行\n\n① 将生成的后端代码，复制到项目中。操作如下图所示：\n\n\n\n② 将 errorcodeconstants.java_手动操作 文件的错误码，复制到该模块 errorcodeconstants 类中，并设置对应的错误码编号，之后进行删除。操作如下图所示：\n\n\n\n③ 将 h2.sql 的 create 语句复制到该模块的 create_tables.sql 文件，delete 语句复制到该模块的 clean.sql。操作如下图：\n\n友情提示：最新版本，第 ③ 部分的单元测试，默认已经不在生成。所以，不需要操作这一步。\n\n原因是：大多数团队，没有编写单元测试的习惯，导致生成的单元测试代码，会被直接删除。所以，我们默认不生成单元测试代码，减少不必要的代码生成。\n\n如果想要开启，可以把 yudao.codegen.unit-test-enable 配置项设置为 true，然后重新生成代码。\n\n另外，如果你想要编写单元测试，可以考虑使用 marscode 智能编码插件，可以免费生成不错的单元测试。\n\n\n\n疑问：`create_tables.sql` 和 `clean.sql` 文件的作用是什么？\n\n项目的单元测试，需要使用到 h2 内存数据库，create_tables.sql 用于创建所有的表结构，clean.sql 用于每个单元测试的方法跑完后清理数据。\n\n然后，运行 groupserviceimpltest 单元测试，执行通过。\n\n④ 打开数据库工具，运行代码生成的 sql/sql.sql 文件，用于菜单的初始化。\n\n\n\n⑤ debug 运行 yudaoserverapplication 类，启动后端项目。通过 idea 的 [actuator -> mappings] 菜单，可以看到代码生成的 groupcontroller 的 restful api 接口已经生效。\n\n\n\n\n# 3.2 前端运行\n\n① 将生成的前端代码，复制到项目中。操作如下图所示：\n\n\n\n② 重新执行 npm run dev 命令，启动前端项目。点击 [系统管理 -> 菜单管理] 菜单，点击【刷新菜单缓存】，因为前端项目会缓存菜单在内存中的，所以需要刷新一下。\n\n③ 点击 [系统管理 -> 用户组管理] 菜单，就可以看到用户组的 ui 界面。\n\n\n\n----------------------------------------\n\n至此，我们已经完成了【用户组】功能的代码生成，基本节省了你 80% 左右的开发任务，后续可以根据自己的需求，进行剩余的 20% 的开发！\n\n\n# 4. 后续变更\n\n随着业务的发展，已经生成代码的功能需要变更。继续以【用户组】举例子，它的 system_group 表需要新增一个分类 category 字段，此时不建议使用代码生成器，而是直接修改已经生成的代码：\n\n① 后端：修改 groupdo 数据实体类、groupsavereqvo 保存 vo 类、groupsaverespvo 响应 vo 类，新增 category 字段。\n\n② 前端：修改 vue 的 index.vue 列表和 form 表单组件，新增 category 字段。\n\n③ 重新编译后后端，并进行启动。\n\nover！非常简单方便，即保证了代码的整洁规范，又不增加过多的开发量。\n\n\n# 5. 常见问题\n\n① 生成的代码结构，有没具体说明？\n\n答：参见 《项目结构》 文档的说明，最好把对应视频好好看下。\n\n② 为什么要分 xxxsavereqvo、xxxrespvo、xxxpagereqvo 三个 vo 类？\n\n答：星球里 https://t.zsxq.com/14fc743wh 进行了 vo 拆分的讨论，总体大家倾向拆分成三个 vo 类，因为这样更加清晰，而且也不会增加太多的维护工作量。\n\n可能你会想，能不能把 xxxsavereqvo 和 xxxrespvo 合并成一个呢？有两方面的考虑：\n\n 1. 一般来说，新增/修改是不传递 createtime、creator 等字段，响应是需要返回 createtime、creator 等字段，两者的字段无法不一致。\n 2. 一旦 vo 和 do 拆分开后，调整字段时，例如说新增一个 xxx 字段，两个 vo 的修改成本，和一个 vo 实际是差不多的。\n\n③ 为什么 ui 界面的数据字典，下拉没有选项，或者列表没有展示它的文本？\n\n类似 https://t.zsxq.com/owjzu 的问题。\n\n原因是：需要在前端的代码里，枚举一下。例如说 vue3 + element-plus 版本，需要在 yudao-ui-admin-vue3/src/utils/dict.ts 的 dict_type 添加字典的 type 枚举值。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "代码生成【主子表】",
            frontmatter: {
                title: "代码生成【主子表】",
                date: "2023-11-17T23:40:03.000Z",
                permalink: "/new-feature/master-sub",
                vue3: !0
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/02.%E5%90%8E%E7%AB%AF%E6%89%8B%E5%86%8C/03.%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%EF%BC%88%E4%B8%BB%E5%AD%90%E8%A1%A8%EF%BC%89.html",
            relativePath: "01.开发指南/02.后端手册/03.代码生成（主子表）.md",
            key: "v-7eec88fb",
            path: "/new-feature/master-sub/",
            headers: [{
                level: 2,
                title: "0. 主子表模式",
                slug: "_0-主子表模式",
                normalizedTitle: "0. 主子表模式",
                charIndex: 331
            }, {
                level: 3,
                title: "0.1 标准模式",
                slug: "_0-1-标准模式",
                normalizedTitle: "0.1 标准模式",
                charIndex: 379
            }, {
                level: 3,
                title: "0.2 内嵌模式",
                slug: "_0-2-内嵌模式",
                normalizedTitle: "0.2 内嵌模式",
                charIndex: 465
            }, {
                level: 3,
                title: "0.3 ERP 模式",
                slug: "_0-3-erp-模式",
                normalizedTitle: "0.3 erp 模式",
                charIndex: 549
            }, {
                level: 2,
                title: "1. 数据库表结构设计",
                slug: "_1-数据库表结构设计",
                normalizedTitle: "1. 数据库表结构设计",
                charIndex: 628
            }, {
                level: 2,
                title: "2. 代码生成",
                slug: "_2-代码生成",
                normalizedTitle: "2. 代码生成",
                charIndex: 3716
            }, {
                level: 3,
                title: "2.1 导入表",
                slug: "_2-1-导入表",
                normalizedTitle: "2.1 导入表",
                charIndex: 3728
            }, {
                level: 3,
                title: "2.2 编辑配置（主表）",
                slug: "_2-2-编辑配置-主表",
                normalizedTitle: "2.2 编辑配置（主表）",
                charIndex: 3855
            }, {
                level: 3,
                title: "2.3 编辑配置（子表）",
                slug: "_2-3-编辑配置-子表",
                normalizedTitle: "2.3 编辑配置（子表）",
                charIndex: 4074
            }, {
                level: 3,
                title: "2.4 预览代码",
                slug: "_2-4-预览代码",
                normalizedTitle: "2.4 预览代码",
                charIndex: 4525
            }, {
                level: 3,
                title: "2.5 生成代码",
                slug: "_2-5-生成代码",
                normalizedTitle: "2.5 生成代码",
                charIndex: 4590
            }],
            headersStr: "0. 主子表模式 0.1 标准模式 0.2 内嵌模式 0.3 ERP 模式 1. 数据库表结构设计 2. 代码生成 2.1 导入表 2.2 编辑配置（主表） 2.3 编辑配置（子表） 2.4 预览代码 2.5 生成代码",
            content: "友情提示：\n\n本文接 《代码生成【单表】》，请务必先阅读。因为重复的内容，本文会不再赘述！\n\n主子表，指的是一个主表，被多个子表所关联，关联的关系是一对一或一对多。\n\n例如说：主表是【学生】，子表可以是：\n\n * 子表是【成绩】，两者是“一对多”的关系，一个学生可以有多个成绩。\n * 子表是【班级】，两者是“一对一”的关系，一个学生只能有一个班级。\n\n下面，我们将演示“主子表”的使用，基于代码生成器，在 yudao-module-system 模块中，开发一个【学生】的功能。\n\n友情提示：\n\n目前只有 yudao-ui-admin-vue3 支持主子表，yudao-ui-admin-vue2、yudao-ui-admin-vben 正在适配中！\n\n\n# 0. 主子表模式\n\n针对不同的交互模式，项目提供了三种主子表模式：标准、ERP、内嵌。\n\n\n# 0.1 标准模式\n\n对应 [基础设施 -> 代码生成案例 -> 主子表（标准）] 菜单。\n\n在新增和修改时，主表和子表在一个弹窗表单中，一起提交。如下图所示：\n\n\n\n\n# 0.2 内嵌模式\n\n对应 [基础设施 -> 代码生成案例 -> 主子表（内嵌）] 菜单。\n\n在「标准模式」的基础之上，列表 内嵌 子表的列表。如下图所示：\n\n\n\n\n# 0.3 ERP 模式\n\n对应 [基础设施 -> 代码生成案例 -> 主子表（ERP）] 菜单。\n\n主表和子表，独立列表，也独立表单。如下图所示：\n\n\n\n\n# 1. 数据库表结构设计\n\n① 设计 主表 的数据库表名为 system_student 学生表，其建表语句如下：\n\nCREATE TABLE `system_student` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  `name` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '名字',\n  `birthday` datetime NOT NULL COMMENT '出生日期',\n  `description` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '简介',\n  `creator` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT '' COMMENT '创建者',\n  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\n  `updater` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT '' COMMENT '更新者',\n  `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',\n  `deleted` bit(1) NOT NULL DEFAULT b'0' COMMENT '是否删除',\n  `tenant_id` bigint NOT NULL DEFAULT '0' COMMENT '租户编号',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='学生表';\n\n\n② 设计 子表 的数据库表名为 system_student_course 学生课程表，其建表语句如下：\n\nCREATE TABLE `system_student_course` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  `student_id` bigint NOT NULL COMMENT '学生编号',\n  `name` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '名字',\n  `score` tinyint NOT NULL COMMENT '分数',\n  `creator` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT '' COMMENT '创建者',\n  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\n  `updater` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT '' COMMENT '更新者',\n  `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',\n  `deleted` bit(1) NOT NULL DEFAULT b'0' COMMENT '是否删除',\n  `tenant_id` bigint NOT NULL DEFAULT '0' COMMENT '租户编号',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=14 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='学生课程表';\n\n\n它和主表的关系是一对多，一个学生可以有多个课程，通过 student_id 字段进行关联。\n\n③ 设计 子表 的数据表名为 system_student_grade 学生班级表，其建表语句如下：\n\nCREATE TABLE `system_student_grade` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  `student_id` bigint NOT NULL COMMENT '学生编号',\n  `name` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '名字',\n  `teacher` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '班主任',\n  `creator` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT '' COMMENT '创建者',\n  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\n  `updater` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT '' COMMENT '更新者',\n  `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',\n  `deleted` bit(1) NOT NULL DEFAULT b'0' COMMENT '是否删除',\n  `tenant_id` bigint NOT NULL DEFAULT '0' COMMENT '租户编号',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='学生班级表';\n\n\n它和主表的关系是一对一，一个学生只能有一个班级，通过 student_id 字段进行关联。\n\n\n# 2. 代码生成\n\n\n# 2.1 导入表\n\n点击 [基础设施 -> 代码生成] 菜单，点击 [基于 DB 导入] 按钮，选择 system_student、system_student_course、system_student_grade 表，后点击 [确认] 按钮。\n\n\n# 2.2 编辑配置（主表）\n\n点击 system_student 所在行的 [编辑] 按钮，修改生成配置。后操作如下：\n\n\n\n * 将【生成模版】设置为【主表（标准模式）】。🔥最最关键的步骤！\n * 将【上级菜单】设置为【系统管理】。\n * 将【前端类型】设置为“前端项目”对应的“前端类型”。例如说，我们这里演示的是 yudao-ui-admin-vue3 前端项目，则选择了【Vue3 Element Plus 标准模版】。\n\n\n# 2.3 编辑配置（子表）\n\n① 点击 system_student_course 所在行的 [编辑] 按钮，修改生成配置。后操作如下：\n\n\n\n * 将【生成模版】设置为【子表】。🔥最最关键的步骤！\n * 业务名：一般建议和【主表】保持一致，所以这里改成了 student。\n * 主表信息：将【关联的主表】设置为 system_student 表，将【子表关联的字段】设置为 student_id 字段，将【关联关系】设置为“一对多”。\n\n② 点击 system_student_grade 所在行的 [编辑] 按钮，修改生成配置。后操作如下：\n\n\n\n * （同上）将【生成模版】设置为【子表】。🔥最最关键的步骤！\n * （同上）业务名：一般建议和【主表】保持一致，所以这里改成了 student。\n * （基本同上，关联关系不同）主表信息：将【关联的主表】设置为 system_student 表，将【子表关联的字段】设置为 student_id 字段，将【关联关系】设置为“一对一”。\n\n\n# 2.4 预览代码\n\n点击 system_student 所在行的 [预览] 按钮，在线预览生成的代码，检查是否符合预期。\n\n\n# 2.5 生成代码\n\n点击 system_student 所在行的 [生成] 按钮，生成代码。\n\n\n# 3. 代码运行\n\n和 《代码生成【单表】》 的「3. 代码运行」一致，就不重复赘述。",
            normalizedContent: "友情提示：\n\n本文接 《代码生成【单表】》，请务必先阅读。因为重复的内容，本文会不再赘述！\n\n主子表，指的是一个主表，被多个子表所关联，关联的关系是一对一或一对多。\n\n例如说：主表是【学生】，子表可以是：\n\n * 子表是【成绩】，两者是“一对多”的关系，一个学生可以有多个成绩。\n * 子表是【班级】，两者是“一对一”的关系，一个学生只能有一个班级。\n\n下面，我们将演示“主子表”的使用，基于代码生成器，在 yudao-module-system 模块中，开发一个【学生】的功能。\n\n友情提示：\n\n目前只有 yudao-ui-admin-vue3 支持主子表，yudao-ui-admin-vue2、yudao-ui-admin-vben 正在适配中！\n\n\n# 0. 主子表模式\n\n针对不同的交互模式，项目提供了三种主子表模式：标准、erp、内嵌。\n\n\n# 0.1 标准模式\n\n对应 [基础设施 -> 代码生成案例 -> 主子表（标准）] 菜单。\n\n在新增和修改时，主表和子表在一个弹窗表单中，一起提交。如下图所示：\n\n\n\n\n# 0.2 内嵌模式\n\n对应 [基础设施 -> 代码生成案例 -> 主子表（内嵌）] 菜单。\n\n在「标准模式」的基础之上，列表 内嵌 子表的列表。如下图所示：\n\n\n\n\n# 0.3 erp 模式\n\n对应 [基础设施 -> 代码生成案例 -> 主子表（erp）] 菜单。\n\n主表和子表，独立列表，也独立表单。如下图所示：\n\n\n\n\n# 1. 数据库表结构设计\n\n① 设计 主表 的数据库表名为 system_student 学生表，其建表语句如下：\n\ncreate table `system_student` (\n  `id` bigint not null auto_increment comment '编号',\n  `name` varchar(100) character set utf8mb4 collate utf8mb4_unicode_ci not null default '' comment '名字',\n  `birthday` datetime not null comment '出生日期',\n  `description` varchar(255) character set utf8mb4 collate utf8mb4_0900_ai_ci not null comment '简介',\n  `creator` varchar(64) character set utf8mb4 collate utf8mb4_unicode_ci default '' comment '创建者',\n  `create_time` datetime not null default current_timestamp comment '创建时间',\n  `updater` varchar(64) character set utf8mb4 collate utf8mb4_unicode_ci default '' comment '更新者',\n  `update_time` datetime not null default current_timestamp on update current_timestamp comment '更新时间',\n  `deleted` bit(1) not null default b'0' comment '是否删除',\n  `tenant_id` bigint not null default '0' comment '租户编号',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=10 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='学生表';\n\n\n② 设计 子表 的数据库表名为 system_student_course 学生课程表，其建表语句如下：\n\ncreate table `system_student_course` (\n  `id` bigint not null auto_increment comment '编号',\n  `student_id` bigint not null comment '学生编号',\n  `name` varchar(100) character set utf8mb4 collate utf8mb4_unicode_ci not null default '' comment '名字',\n  `score` tinyint not null comment '分数',\n  `creator` varchar(64) character set utf8mb4 collate utf8mb4_unicode_ci default '' comment '创建者',\n  `create_time` datetime not null default current_timestamp comment '创建时间',\n  `updater` varchar(64) character set utf8mb4 collate utf8mb4_unicode_ci default '' comment '更新者',\n  `update_time` datetime not null default current_timestamp on update current_timestamp comment '更新时间',\n  `deleted` bit(1) not null default b'0' comment '是否删除',\n  `tenant_id` bigint not null default '0' comment '租户编号',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=14 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='学生课程表';\n\n\n它和主表的关系是一对多，一个学生可以有多个课程，通过 student_id 字段进行关联。\n\n③ 设计 子表 的数据表名为 system_student_grade 学生班级表，其建表语句如下：\n\ncreate table `system_student_grade` (\n  `id` bigint not null auto_increment comment '编号',\n  `student_id` bigint not null comment '学生编号',\n  `name` varchar(100) character set utf8mb4 collate utf8mb4_unicode_ci not null default '' comment '名字',\n  `teacher` varchar(255) collate utf8mb4_unicode_ci not null comment '班主任',\n  `creator` varchar(64) character set utf8mb4 collate utf8mb4_unicode_ci default '' comment '创建者',\n  `create_time` datetime not null default current_timestamp comment '创建时间',\n  `updater` varchar(64) character set utf8mb4 collate utf8mb4_unicode_ci default '' comment '更新者',\n  `update_time` datetime not null default current_timestamp on update current_timestamp comment '更新时间',\n  `deleted` bit(1) not null default b'0' comment '是否删除',\n  `tenant_id` bigint not null default '0' comment '租户编号',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=10 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='学生班级表';\n\n\n它和主表的关系是一对一，一个学生只能有一个班级，通过 student_id 字段进行关联。\n\n\n# 2. 代码生成\n\n\n# 2.1 导入表\n\n点击 [基础设施 -> 代码生成] 菜单，点击 [基于 db 导入] 按钮，选择 system_student、system_student_course、system_student_grade 表，后点击 [确认] 按钮。\n\n\n# 2.2 编辑配置（主表）\n\n点击 system_student 所在行的 [编辑] 按钮，修改生成配置。后操作如下：\n\n\n\n * 将【生成模版】设置为【主表（标准模式）】。🔥最最关键的步骤！\n * 将【上级菜单】设置为【系统管理】。\n * 将【前端类型】设置为“前端项目”对应的“前端类型”。例如说，我们这里演示的是 yudao-ui-admin-vue3 前端项目，则选择了【vue3 element plus 标准模版】。\n\n\n# 2.3 编辑配置（子表）\n\n① 点击 system_student_course 所在行的 [编辑] 按钮，修改生成配置。后操作如下：\n\n\n\n * 将【生成模版】设置为【子表】。🔥最最关键的步骤！\n * 业务名：一般建议和【主表】保持一致，所以这里改成了 student。\n * 主表信息：将【关联的主表】设置为 system_student 表，将【子表关联的字段】设置为 student_id 字段，将【关联关系】设置为“一对多”。\n\n② 点击 system_student_grade 所在行的 [编辑] 按钮，修改生成配置。后操作如下：\n\n\n\n * （同上）将【生成模版】设置为【子表】。🔥最最关键的步骤！\n * （同上）业务名：一般建议和【主表】保持一致，所以这里改成了 student。\n * （基本同上，关联关系不同）主表信息：将【关联的主表】设置为 system_student 表，将【子表关联的字段】设置为 student_id 字段，将【关联关系】设置为“一对一”。\n\n\n# 2.4 预览代码\n\n点击 system_student 所在行的 [预览] 按钮，在线预览生成的代码，检查是否符合预期。\n\n\n# 2.5 生成代码\n\n点击 system_student 所在行的 [生成] 按钮，生成代码。\n\n\n# 3. 代码运行\n\n和 《代码生成【单表】》 的「3. 代码运行」一致，就不重复赘述。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "代码生成（树表）",
            frontmatter: {
                title: "代码生成（树表）",
                date: "2023-11-18T10:14:25.000Z",
                permalink: "/new-feature/tree"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/02.%E5%90%8E%E7%AB%AF%E6%89%8B%E5%86%8C/04.%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%EF%BC%88%E6%A0%91%E8%A1%A8%EF%BC%89.html",
            relativePath: "01.开发指南/02.后端手册/04.代码生成（树表）.md",
            key: "v-8f5874c6",
            path: "/new-feature/tree/",
            headers: [{
                level: 2,
                title: "1. 数据库表结构设计",
                slug: "_1-数据库表结构设计",
                normalizedTitle: "1. 数据库表结构设计",
                charIndex: 191
            }, {
                level: 2,
                title: "2. 代码生成",
                slug: "_2-代码生成",
                normalizedTitle: "2. 代码生成",
                charIndex: 1162
            }, {
                level: 3,
                title: "2.1 导入表",
                slug: "_2-1-导入表",
                normalizedTitle: "2.1 导入表",
                charIndex: 1174
            }, {
                level: 3,
                title: "2.2 编辑配置",
                slug: "_2-2-编辑配置",
                normalizedTitle: "2.2 编辑配置",
                charIndex: 1259
            }, {
                level: 3,
                title: "2.3 预览代码",
                slug: "_2-3-预览代码",
                normalizedTitle: "2.3 预览代码",
                charIndex: 1523
            }, {
                level: 3,
                title: "2.3 生成代码",
                slug: "_2-3-生成代码",
                normalizedTitle: "2.3 生成代码",
                charIndex: 1589
            }],
            headersStr: "1. 数据库表结构设计 2. 代码生成 2.1 导入表 2.2 编辑配置 2.3 预览代码 2.3 生成代码",
            content: "友情提示：\n\n本文接 《代码生成【单表】》，请务必先阅读。因为重复的内容，本文会不再赘述！\n\n树表，是在“单表”的基础上，增加了「树形结构」的功能。\n\n\n\n例如说：部门、分类等，是一个树形结构。我们可以通过树形结构，来展示部门、分类的层级关系。\n\n下面，我们将演示“树表”的使用，基于代码生成器，在 yudao-module-system 模块中，开发一个【分类】的功能。\n\n\n# 1. 数据库表结构设计\n\n设计分类的数据库表名为 system_category，其建表语句如下：\n\nCREATE TABLE `system_category` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  `name` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '名字',\n  `parent_id` bigint NOT NULL COMMENT '父级编号',\n  `creator` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT '' COMMENT '创建者',\n  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\n  `updater` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT '' COMMENT '更新者',\n  `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',\n  `deleted` bit(1) NOT NULL DEFAULT b'0' COMMENT '是否删除',\n  `tenant_id` bigint NOT NULL DEFAULT '0' COMMENT '租户编号',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='分类表';\n\n\n其中 parent_id 字段，用于标识父级分类的编号。如果是顶级分类，则 parent_id 为 0。\n\n\n# 2. 代码生成\n\n\n# 2.1 导入表\n\n点击 [基础设施 -> 代码生成] 菜单，点击 [基于 DB 导入] 按钮，选择 system_category 表，后点击 [确认] 按钮。\n\n\n# 2.2 编辑配置\n\n点击 system_category 所在行的 [编辑] 按钮，修改生成配置。后操作如下：\n\n\n\n * 将【生成模版】设置为【树表】。🔥最最关键的步骤！\n * 树表信息：将【父编号字段】设置为 parent_id 字段，将【树名称字段】设置为 name 字段。\n * 将【上级菜单】设置为【系统管理】。\n * 将【前端类型】设置为“前端项目”对应的“前端类型”。例如说，我们这里演示的是 yudao-ui-admin-vue3 前端项目，则选择了【Vue3 Element Plus 标准模版】。\n\n\n# 2.3 预览代码\n\n点击 system_category 所在行的 [预览] 按钮，在线预览生成的代码，检查是否符合预期。\n\n\n# 2.3 生成代码\n\n点击 system_category 所在行的 [生成] 按钮，生成代码。\n\n\n# 3. 代码运行\n\n和 《代码生成【单表】》 的「3. 代码运行」一致，就不重复赘述。",
            normalizedContent: "友情提示：\n\n本文接 《代码生成【单表】》，请务必先阅读。因为重复的内容，本文会不再赘述！\n\n树表，是在“单表”的基础上，增加了「树形结构」的功能。\n\n\n\n例如说：部门、分类等，是一个树形结构。我们可以通过树形结构，来展示部门、分类的层级关系。\n\n下面，我们将演示“树表”的使用，基于代码生成器，在 yudao-module-system 模块中，开发一个【分类】的功能。\n\n\n# 1. 数据库表结构设计\n\n设计分类的数据库表名为 system_category，其建表语句如下：\n\ncreate table `system_category` (\n  `id` bigint not null auto_increment comment '编号',\n  `name` varchar(100) character set utf8mb4 collate utf8mb4_unicode_ci not null default '' comment '名字',\n  `parent_id` bigint not null comment '父级编号',\n  `creator` varchar(64) character set utf8mb4 collate utf8mb4_unicode_ci default '' comment '创建者',\n  `create_time` datetime not null default current_timestamp comment '创建时间',\n  `updater` varchar(64) character set utf8mb4 collate utf8mb4_unicode_ci default '' comment '更新者',\n  `update_time` datetime not null default current_timestamp on update current_timestamp comment '更新时间',\n  `deleted` bit(1) not null default b'0' comment '是否删除',\n  `tenant_id` bigint not null default '0' comment '租户编号',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=6 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='分类表';\n\n\n其中 parent_id 字段，用于标识父级分类的编号。如果是顶级分类，则 parent_id 为 0。\n\n\n# 2. 代码生成\n\n\n# 2.1 导入表\n\n点击 [基础设施 -> 代码生成] 菜单，点击 [基于 db 导入] 按钮，选择 system_category 表，后点击 [确认] 按钮。\n\n\n# 2.2 编辑配置\n\n点击 system_category 所在行的 [编辑] 按钮，修改生成配置。后操作如下：\n\n\n\n * 将【生成模版】设置为【树表】。🔥最最关键的步骤！\n * 树表信息：将【父编号字段】设置为 parent_id 字段，将【树名称字段】设置为 name 字段。\n * 将【上级菜单】设置为【系统管理】。\n * 将【前端类型】设置为“前端项目”对应的“前端类型”。例如说，我们这里演示的是 yudao-ui-admin-vue3 前端项目，则选择了【vue3 element plus 标准模版】。\n\n\n# 2.3 预览代码\n\n点击 system_category 所在行的 [预览] 按钮，在线预览生成的代码，检查是否符合预期。\n\n\n# 2.3 生成代码\n\n点击 system_category 所在行的 [生成] 按钮，生成代码。\n\n\n# 3. 代码运行\n\n和 《代码生成【单表】》 的「3. 代码运行」一致，就不重复赘述。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "数据权限",
            frontmatter: {
                title: "数据权限",
                date: "2022-03-07T12:37:52.000Z",
                permalink: "/data-permission"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/02.%E5%90%8E%E7%AB%AF%E6%89%8B%E5%86%8C/08.%E6%95%B0%E6%8D%AE%E6%9D%83%E9%99%90.html",
            relativePath: "01.开发指南/02.后端手册/08.数据权限.md",
            key: "v-d03982c2",
            path: "/data-permission/",
            headers: [{
                level: 2,
                title: "1. 实现原理",
                slug: "_1-实现原理",
                normalizedTitle: "1. 实现原理",
                charIndex: 416
            }, {
                level: 2,
                title: "2. 基于部门的数据权限",
                slug: "_2-基于部门的数据权限",
                normalizedTitle: "2. 基于部门的数据权限",
                charIndex: 1217
            }, {
                level: 3,
                title: "2.1 后台配置",
                slug: "_2-1-后台配置",
                normalizedTitle: "2.1 后台配置",
                charIndex: 1407
            }, {
                level: 3,
                title: "2.2 字段配置",
                slug: "_2-2-字段配置",
                normalizedTitle: "2.2 字段配置",
                charIndex: 1505
            }, {
                level: 2,
                title: "3. @DataPermission 注解",
                slug: "_3-datapermission-注解",
                normalizedTitle: "3. @datapermission 注解",
                charIndex: 2326
            }, {
                level: 2,
                title: "4. 自定义的数据权限规则",
                slug: "_4-自定义的数据权限规则",
                normalizedTitle: "4. 自定义的数据权限规则",
                charIndex: 3232
            }, {
                level: 2,
                title: "5. 如何忽略数据权限",
                slug: "_5-如何忽略数据权限",
                normalizedTitle: "5. 如何忽略数据权限",
                charIndex: 5732
            }, {
                level: 2,
                title: "6. 社区贡献的数据权限规则",
                slug: "_6-社区贡献的数据权限规则",
                normalizedTitle: "6. 社区贡献的数据权限规则",
                charIndex: 5847
            }],
            headersStr: "1. 实现原理 2. 基于部门的数据权限 2.1 后台配置 2.2 字段配置 3. @DataPermission 注解 4. 自定义的数据权限规则 5. 如何忽略数据权限 6. 社区贡献的数据权限规则",
            content: '数据权限，实现指定用户可以操作指定范围的数据。例如说，针对员工信息的数据权限：\n\n用户       数据范围\n普通员工     自己\n部门领导     所属部门的所有员工\nHR 小姐姐   整个公司的所有员工\n\n上述的这个示例，使用硬编码是可以实现的，并且也非常简单。但是，在业务快速迭代的过程中，类似这种数据需求会越来越多，如果全部采用硬编码的方式，无疑会给我们带来非常大的开发与维护成本。\n\n因此，项目提供 yudao-spring-boot-starter-biz-data-permission 技术组件，只需要少量的编码，无需入侵到业务代码，即可实现数据权限。\n\n友情提示：数据权限是否支持指定用户只能查看数据的某些字段？\n\n不支持。权限可以分成三类：功能权限、数据权限、字段权限。\n\n字段权限的控制，不属于数据权限，而是属于字段权限，会在未来提供，敬请期待。\n\n目前可以通过 《数据脱敏》 实现一定的字段权限。\n\n\n# 1. 实现原理\n\nyudao-spring-boot-starter-biz-data-permission 技术组件的实现原理非常简单，每次对数据库操作时，他会自动拼接 WHERE data_column = ? 条件来进行数据的过滤。\n\n例如说，查看员工信息的功能，对应 SQL 是 SELECT * FROM system_users，那么拼接后的 SQL 结果会是：\n\n用户       数据范围        SQL\n普通员工     自己          SELECT * FROM system_users WHERE id = 自己\n部门领导     所属部门的所有员工   SELECT * FROM system_users WHERE dept_id = 自己的部门\nHR 小姐姐   整个公司的所有员工   SELECT * FROM system_users 无需拼接\n\n明白了实现原理之后，想要进一步加入理解，后续可以找时间 Debug 调试下 MyBatis Plus 的 DataPermissionInterceptor 类的这三个方法：\n\n * #processSelect(...) 方法：处理 SELECT 语句的 WHERE 条件。\n * #processUpdate(...) 方法：处理 UPDATE 语句的 WHERE 条件。\n * #processDelete(...) 方法：处理 DELETE 语句的 WHERE 条件。\n\n主要还是基于 MyBatis Plus 的 数据权限插件。\n\n具体的条件生成，可见项目的 DataPermissionRuleHandler 类。\n\n友情提示：MyBatis Plus 的数据权限方案，在我们在 MyBatis XML 手写 SQL 时，是不生效的，即不会拼接 `WHERE` 数据权限条件！！！\n\n\n# 2. 基于部门的数据权限\n\n项目内置了基于部门的数据权限，支持 5 种数据范围：\n\n 1. 全部数据权限：无数据权限的限制。\n 2. 指定部门数据权限：根据实际需要，设置可操作的部门。\n 3. 本部门数据权限：只能操作用户所在的部门。\n 4. 本部门及以下数据权限：在【本部门数据权限】的基础上，额外可操作子部门。\n 5. 仅本人数据权限：相对特殊，只能操作自己的数据。\n\n\n# 2.1 后台配置\n\n可通过管理后台的 [系统管理 -> 角色管理] 菜单，设置用户角色的数据权限。\n\n\n\n实现代码？\n\n可见 DeptDataPermissionRule 数据权限规则。\n\n\n# 2.2 字段配置\n\n每个 Maven Module， 通过自定义 DeptDataPermissionRuleCustomizer Bean，配置哪些表的哪些字段，进行数据权限的过滤。以 yudao-module-system 模块来举例子，代码如下：\n\n@Configuration(proxyBeanMethods = false)\npublic class DataPermissionConfiguration {\n\n    @Bean\n    public DeptDataPermissionRuleCustomizer sysDeptDataPermissionRuleCustomizer() {\n        return rule -> {\n            // dept 基于部门的数据权限\n            rule.addDeptColumn(AdminUserDO.class); // WHERE dept_id = ?\n            rule.addDeptColumn(DeptDO.class, "id"); // WHERE id = ?\n            \n            // user 基于用户的数据权限\n            rule.addUserColumn(AdminUserDO.class, "id"); // WHERE id = ?\n//            rule.addUserColumn(OrderDO.class); // WHERE user_id = ?\n        };\n    }\n\n}\n\n\n注意，数据库的表字段必须添加：\n\n * 基于【部门】过滤数据权限的表，需要添加部门编号字段，例如说 dept_id 字段。\n * 基于【用户】过滤数据权限的表，需要添加部门用户字段，例如说 user_id 字段。\n\n\n# 3. @DataPermission 注解\n\n@DataPermission 数据权限注解，可声明在类或者方法上，配置使用的数据权限规则。\n\n① enable 属性：当前类或方法是否开启数据权限，默认是 true 开启状态，可设置 false 禁用状态。\n\n也就是说，数据权限默认是开启的，无需添加 @DataPermission 注解\n也就是说，数据权限默认是开启的，无需添加 @DataPermission 注解\n也就是说，数据权限默认是开启的，无需添加 @DataPermission 注解\n\n使用示例如下，可见 UserProfileController 类：\n\n// UserProfileController.java\n\n@GetMapping("/get")\n@Operation(summary = "获得登录用户信息")\n@DataPermission(enable = false) // 关闭数据权限，避免只查看自己时，查询不到部门。\npublic CommonResult<UserProfileRespVO> profile() {\n    // .. 省略代码\n    if (user.getDeptId() != null) {\n        DeptDO dept = deptService.getDept(user.getDeptId());\n        resp.setDept(UserConvert.INSTANCE.convert02(dept));\n    }\n    // .. 省略代码\n}\n\n\n② includeRules 属性，配置生效的 DataPermissionRule 数据权限规则。例如说，项目里有 10 种 DataPermissionRule 规则，某个方法只想其中的 1 种生效，则可以使用该属性。\n\n③ excludeRules 属性，配置排除的 DataPermissionRule 数据权限规则。例如说，项目里有 10 种 DataPermissionRule 规则，某个方法不想其中的 1 种生效，则可以使用该属性。\n\n\n# 4. 自定义的数据权限规则\n\n如果想要自定义数据权限规则，只需要实现 DataPermissionRule 数据权限规则接口，并声明成 Spring Bean 即可。需要实现的只有两个方法：\n\npublic interface DataPermissionRule {\n\n    /**\n     * 返回需要生效的表名数组\n     * 为什么需要该方法？Data Permission 数组基于 SQL 重写，通过 Where 返回只有权限的数据\n     *\n     * 如果需要基于实体名获得表名，可调用 {@link TableInfoHelper#getTableInfo(Class)} 获得\n     *\n     * @return 表名数组\n     */\n    Set<String> getTableNames();\n\n    /**\n     * 根据表名和别名，生成对应的 WHERE / OR 过滤条件\n     *\n     * @param tableName 表名\n     * @param tableAlias 别名，可能为空\n     * @return 过滤条件 Expression 表达式\n     */\n    Expression getExpression(String tableName, Alias tableAlias);\n\n}\n\n\n * #getTableNames() 方法：哪些数据库表，需要使用该数据权限规则。\n * #getExpression(...) 方法：当操作这些数据库表，需要额外拼接怎么样的 WHERE 条件。\n\n下面，艿艿带你写个自定义数据权限规则的示例，它的数据权限规则是：\n\n * 针对 system_dict_type 表，它的创建人 creator 要是当前用户。\n * 针对 system_post 表，它的更新人 updater 要是当前用户。\n\n具体实现代码如下：\n\npackage cn.iocoder.yudao.module.system.framework.datapermission;\n\nimport cn.iocoder.yudao.framework.datapermission.core.rule.DataPermissionRule;\nimport cn.iocoder.yudao.framework.mybatis.core.util.MyBatisUtils;\nimport cn.iocoder.yudao.framework.security.core.util.SecurityFrameworkUtils;\nimport com.google.common.collect.Sets;\nimport net.sf.jsqlparser.expression.Alias;\nimport net.sf.jsqlparser.expression.Expression;\nimport net.sf.jsqlparser.expression.LongValue;\nimport net.sf.jsqlparser.expression.operators.relational.EqualsTo;\nimport org.springframework.stereotype.Component;\n\nimport java.util.Set;\n\n@Component // 声明为 Spring Bean，保证被 yudao-spring-boot-starter-biz-data-permission 组件扫描到\npublic class DemoDataPermissionRule implements DataPermissionRule {\n\n    @Override\n    public Set<String> getTableNames() {\n        return Sets.newHashSet("system_dict_type", "system_post");\n    }\n\n    @Override\n    public Expression getExpression(String tableName, Alias tableAlias) {\n        Long userId = SecurityFrameworkUtils.getLoginUserId();\n        assert userId != null;\n        switch (tableName) {\n            case "system_dict_type":\n                return new EqualsTo(MyBatisUtils.buildColumn(tableName, tableAlias, "creator"), new LongValue(userId));\n            case "system_post":\n                return new EqualsTo(MyBatisUtils.buildColumn(tableName, tableAlias, "updater"), new LongValue(userId));\n            default: return null;\n        }\n    }\n\n}\n\n\n① 启动前端 + 后端项目。\n\n② 访问 [系统管理 -> 字典管理] 菜单，查看 IDEA 控制台，可以看到 system_dict_type 表的查询自动拼接了 AND creator = 1 的查询条件。\n\n\n\n② 访问 [系统管理 -> 岗位管理] 菜单，查看 IDEA 控制台，可以看到 system_post 表的查询自动拼接了 AND updater = 1 的查询条件。\n\n\n\n\n# 5. 如何忽略数据权限\n\n可以使用 DataPermissionUtils 的 #executeIgnore(...) 方法，设置忽略数据权限。\n\n具体的案例，可以通过 IDEA 查找下项目里，哪些地方调用了这个方法噢！\n\n\n# 6. 社区贡献的数据权限规则\n\n * 数据权限组件改进建议：改成更通用的，取消内置的部门数据权限\n * 推荐：通用的数据权限的具体实现及示例说明',
            normalizedContent: '数据权限，实现指定用户可以操作指定范围的数据。例如说，针对员工信息的数据权限：\n\n用户       数据范围\n普通员工     自己\n部门领导     所属部门的所有员工\nhr 小姐姐   整个公司的所有员工\n\n上述的这个示例，使用硬编码是可以实现的，并且也非常简单。但是，在业务快速迭代的过程中，类似这种数据需求会越来越多，如果全部采用硬编码的方式，无疑会给我们带来非常大的开发与维护成本。\n\n因此，项目提供 yudao-spring-boot-starter-biz-data-permission 技术组件，只需要少量的编码，无需入侵到业务代码，即可实现数据权限。\n\n友情提示：数据权限是否支持指定用户只能查看数据的某些字段？\n\n不支持。权限可以分成三类：功能权限、数据权限、字段权限。\n\n字段权限的控制，不属于数据权限，而是属于字段权限，会在未来提供，敬请期待。\n\n目前可以通过 《数据脱敏》 实现一定的字段权限。\n\n\n# 1. 实现原理\n\nyudao-spring-boot-starter-biz-data-permission 技术组件的实现原理非常简单，每次对数据库操作时，他会自动拼接 where data_column = ? 条件来进行数据的过滤。\n\n例如说，查看员工信息的功能，对应 sql 是 select * from system_users，那么拼接后的 sql 结果会是：\n\n用户       数据范围        sql\n普通员工     自己          select * from system_users where id = 自己\n部门领导     所属部门的所有员工   select * from system_users where dept_id = 自己的部门\nhr 小姐姐   整个公司的所有员工   select * from system_users 无需拼接\n\n明白了实现原理之后，想要进一步加入理解，后续可以找时间 debug 调试下 mybatis plus 的 datapermissioninterceptor 类的这三个方法：\n\n * #processselect(...) 方法：处理 select 语句的 where 条件。\n * #processupdate(...) 方法：处理 update 语句的 where 条件。\n * #processdelete(...) 方法：处理 delete 语句的 where 条件。\n\n主要还是基于 mybatis plus 的 数据权限插件。\n\n具体的条件生成，可见项目的 datapermissionrulehandler 类。\n\n友情提示：mybatis plus 的数据权限方案，在我们在 mybatis xml 手写 sql 时，是不生效的，即不会拼接 `where` 数据权限条件！！！\n\n\n# 2. 基于部门的数据权限\n\n项目内置了基于部门的数据权限，支持 5 种数据范围：\n\n 1. 全部数据权限：无数据权限的限制。\n 2. 指定部门数据权限：根据实际需要，设置可操作的部门。\n 3. 本部门数据权限：只能操作用户所在的部门。\n 4. 本部门及以下数据权限：在【本部门数据权限】的基础上，额外可操作子部门。\n 5. 仅本人数据权限：相对特殊，只能操作自己的数据。\n\n\n# 2.1 后台配置\n\n可通过管理后台的 [系统管理 -> 角色管理] 菜单，设置用户角色的数据权限。\n\n\n\n实现代码？\n\n可见 deptdatapermissionrule 数据权限规则。\n\n\n# 2.2 字段配置\n\n每个 maven module， 通过自定义 deptdatapermissionrulecustomizer bean，配置哪些表的哪些字段，进行数据权限的过滤。以 yudao-module-system 模块来举例子，代码如下：\n\n@configuration(proxybeanmethods = false)\npublic class datapermissionconfiguration {\n\n    @bean\n    public deptdatapermissionrulecustomizer sysdeptdatapermissionrulecustomizer() {\n        return rule -> {\n            // dept 基于部门的数据权限\n            rule.adddeptcolumn(adminuserdo.class); // where dept_id = ?\n            rule.adddeptcolumn(deptdo.class, "id"); // where id = ?\n            \n            // user 基于用户的数据权限\n            rule.addusercolumn(adminuserdo.class, "id"); // where id = ?\n//            rule.addusercolumn(orderdo.class); // where user_id = ?\n        };\n    }\n\n}\n\n\n注意，数据库的表字段必须添加：\n\n * 基于【部门】过滤数据权限的表，需要添加部门编号字段，例如说 dept_id 字段。\n * 基于【用户】过滤数据权限的表，需要添加部门用户字段，例如说 user_id 字段。\n\n\n# 3. @datapermission 注解\n\n@datapermission 数据权限注解，可声明在类或者方法上，配置使用的数据权限规则。\n\n① enable 属性：当前类或方法是否开启数据权限，默认是 true 开启状态，可设置 false 禁用状态。\n\n也就是说，数据权限默认是开启的，无需添加 @datapermission 注解\n也就是说，数据权限默认是开启的，无需添加 @datapermission 注解\n也就是说，数据权限默认是开启的，无需添加 @datapermission 注解\n\n使用示例如下，可见 userprofilecontroller 类：\n\n// userprofilecontroller.java\n\n@getmapping("/get")\n@operation(summary = "获得登录用户信息")\n@datapermission(enable = false) // 关闭数据权限，避免只查看自己时，查询不到部门。\npublic commonresult<userprofilerespvo> profile() {\n    // .. 省略代码\n    if (user.getdeptid() != null) {\n        deptdo dept = deptservice.getdept(user.getdeptid());\n        resp.setdept(userconvert.instance.convert02(dept));\n    }\n    // .. 省略代码\n}\n\n\n② includerules 属性，配置生效的 datapermissionrule 数据权限规则。例如说，项目里有 10 种 datapermissionrule 规则，某个方法只想其中的 1 种生效，则可以使用该属性。\n\n③ excluderules 属性，配置排除的 datapermissionrule 数据权限规则。例如说，项目里有 10 种 datapermissionrule 规则，某个方法不想其中的 1 种生效，则可以使用该属性。\n\n\n# 4. 自定义的数据权限规则\n\n如果想要自定义数据权限规则，只需要实现 datapermissionrule 数据权限规则接口，并声明成 spring bean 即可。需要实现的只有两个方法：\n\npublic interface datapermissionrule {\n\n    /**\n     * 返回需要生效的表名数组\n     * 为什么需要该方法？data permission 数组基于 sql 重写，通过 where 返回只有权限的数据\n     *\n     * 如果需要基于实体名获得表名，可调用 {@link tableinfohelper#gettableinfo(class)} 获得\n     *\n     * @return 表名数组\n     */\n    set<string> gettablenames();\n\n    /**\n     * 根据表名和别名，生成对应的 where / or 过滤条件\n     *\n     * @param tablename 表名\n     * @param tablealias 别名，可能为空\n     * @return 过滤条件 expression 表达式\n     */\n    expression getexpression(string tablename, alias tablealias);\n\n}\n\n\n * #gettablenames() 方法：哪些数据库表，需要使用该数据权限规则。\n * #getexpression(...) 方法：当操作这些数据库表，需要额外拼接怎么样的 where 条件。\n\n下面，艿艿带你写个自定义数据权限规则的示例，它的数据权限规则是：\n\n * 针对 system_dict_type 表，它的创建人 creator 要是当前用户。\n * 针对 system_post 表，它的更新人 updater 要是当前用户。\n\n具体实现代码如下：\n\npackage cn.iocoder.yudao.module.system.framework.datapermission;\n\nimport cn.iocoder.yudao.framework.datapermission.core.rule.datapermissionrule;\nimport cn.iocoder.yudao.framework.mybatis.core.util.mybatisutils;\nimport cn.iocoder.yudao.framework.security.core.util.securityframeworkutils;\nimport com.google.common.collect.sets;\nimport net.sf.jsqlparser.expression.alias;\nimport net.sf.jsqlparser.expression.expression;\nimport net.sf.jsqlparser.expression.longvalue;\nimport net.sf.jsqlparser.expression.operators.relational.equalsto;\nimport org.springframework.stereotype.component;\n\nimport java.util.set;\n\n@component // 声明为 spring bean，保证被 yudao-spring-boot-starter-biz-data-permission 组件扫描到\npublic class demodatapermissionrule implements datapermissionrule {\n\n    @override\n    public set<string> gettablenames() {\n        return sets.newhashset("system_dict_type", "system_post");\n    }\n\n    @override\n    public expression getexpression(string tablename, alias tablealias) {\n        long userid = securityframeworkutils.getloginuserid();\n        assert userid != null;\n        switch (tablename) {\n            case "system_dict_type":\n                return new equalsto(mybatisutils.buildcolumn(tablename, tablealias, "creator"), new longvalue(userid));\n            case "system_post":\n                return new equalsto(mybatisutils.buildcolumn(tablename, tablealias, "updater"), new longvalue(userid));\n            default: return null;\n        }\n    }\n\n}\n\n\n① 启动前端 + 后端项目。\n\n② 访问 [系统管理 -> 字典管理] 菜单，查看 idea 控制台，可以看到 system_dict_type 表的查询自动拼接了 and creator = 1 的查询条件。\n\n\n\n② 访问 [系统管理 -> 岗位管理] 菜单，查看 idea 控制台，可以看到 system_post 表的查询自动拼接了 and updater = 1 的查询条件。\n\n\n\n\n# 5. 如何忽略数据权限\n\n可以使用 datapermissionutils 的 #executeignore(...) 方法，设置忽略数据权限。\n\n具体的案例，可以通过 idea 查找下项目里，哪些地方调用了这个方法噢！\n\n\n# 6. 社区贡献的数据权限规则\n\n * 数据权限组件改进建议：改成更通用的，取消内置的部门数据权限\n * 推荐：通用的数据权限的具体实现及示例说明',
            charsets: {
                cjk: !0
            }
        }, {
            title: "功能权限",
            frontmatter: {
                title: "功能权限",
                date: "2022-03-07T12:37:38.000Z",
                permalink: "/resource-permission"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/02.%E5%90%8E%E7%AB%AF%E6%89%8B%E5%86%8C/07.%E5%8A%9F%E8%83%BD%E6%9D%83%E9%99%90.html",
            relativePath: "01.开发指南/02.后端手册/07.功能权限.md",
            key: "v-6bf342bf",
            path: "/resource-permission/",
            headers: [{
                level: 2,
                title: "👍 相关视频教程",
                slug: "👍-相关视频教程",
                normalizedTitle: "👍 相关视频教程",
                charIndex: 2
            }, {
                level: 2,
                title: "1. RBAC 权限模型",
                slug: "_1-rbac-权限模型",
                normalizedTitle: "1. rbac 权限模型",
                charIndex: 231
            }, {
                level: 2,
                title: "2. Token 认证机制",
                slug: "_2-token-认证机制",
                normalizedTitle: "2. token 认证机制",
                charIndex: 418
            }, {
                level: 2,
                title: "3. 权限注解",
                slug: "_3-权限注解",
                normalizedTitle: "3. 权限注解",
                charIndex: 1649
            }, {
                level: 3,
                title: "3.1 @PreAuthorize 注解",
                slug: "_3-1-preauthorize-注解",
                normalizedTitle: "3.1 @preauthorize 注解",
                charIndex: 1661
            }, {
                level: 2,
                title: "4. 自定义权限配置",
                slug: "_4-自定义权限配置",
                normalizedTitle: "4. 自定义权限配置",
                charIndex: 2632
            }, {
                level: 3,
                title: "4.1 方式一：自定义 AuthorizeRequestsCustomizer 实现",
                slug: "_4-1-方式一-自定义-authorizerequestscustomizer-实现",
                normalizedTitle: "4.1 方式一：自定义 authorizerequestscustomizer 实现",
                charIndex: 2784
            }, {
                level: 3,
                title: "4.2 方式二：@PermitAll 注解",
                slug: "_4-2-方式二-permitall-注解",
                normalizedTitle: "4.2 方式二：@permitall 注解",
                charIndex: 4793
            }, {
                level: 3,
                title: "4.3 方式三：yudao.security.permit-all-urls 配置项",
                slug: "_4-3-方式三-yudao-security-permit-all-urls-配置项",
                normalizedTitle: "4.3 方式三：yudao.security.permit-all-urls 配置项",
                charIndex: 5145
            }],
            headersStr: "👍 相关视频教程 1. RBAC 权限模型 2. Token 认证机制 3. 权限注解 3.1 @PreAuthorize 注解 4. 自定义权限配置 4.1 方式一：自定义 AuthorizeRequestsCustomizer 实现 4.2 方式二：@PermitAll 注解 4.3 方式三：yudao.security.permit-all-urls 配置项",
            content: '# 👍 相关视频教程\n\n * 功能权限 01：如何设计一套权限系统？\n * 功能权限 02：如何实现菜单的创建？\n * 功能权限 03：如何实现角色的创建？\n * 功能权限 04：如何给用户分配权限 —— 将菜单赋予角色？\n * 功能权限 05：如何给用户分配权限 —— 将角色赋予用户？\n * 功能权限 06：后端如何实现 URL 权限的校验？\n * 功能权限 07：前端如何实现菜单的动态加载？\n * 功能权限 08：前端如何实现按钮的权限校验？\n\n\n# 1. RBAC 权限模型\n\n系统采用 RBAC 权限模型，全称是 Role-Based Access Control 基于角色的访问控制。\n\n\n\n简单来说，每个用户拥有若干角色，每个角色拥有若干个菜单，菜单中存在菜单权限、按钮权限。这样，就形成了 “用户<->角色<->菜单” 的授权模型。 在这种模型中，用户与角色、角色与菜单之间构成了多对多的关系，如下图：\n\n\n\n\n# 2. Token 认证机制\n\n安全框架使用的是 Spring Security + Token 方案，整体流程如下图所示：\n\n\n\n① 前端调用登录接口，使用账号密码获得到认证 Token。响应示例如下：\n\n{\n  "code":0,\n  "msg":"",\n  "data":{\n    "token":"d2a3cdbc6c53470db67a582bd115103f"\n  }\n}\n\n\n * 管理后台的登录实现，可见 代码\n * 用户 App 的登录实现，可见 代码\n\n疑问：为什么不使用 Spring Security 内置的表单登录？\n\nSpring Security 的登录拓展起来不方便，例如说验证码、三方登录等等。\n\nToken 存储在数据库中，对应 system_oauth2_access_token 访问令牌表的 id 字段。考虑到访问的性能，缓存在 Redis 的 oauth2_access_token:%s 键中。\n\n疑问：为什么不使用 JWT(JSON Web Token)？\n\nJWT 是无状态的，无法实现 Token 的作废，例如说用户登出系统、修改密码等等场景。\n\n推荐阅读 《还分不清 Cookie、Session、Token、JWT？》 文章。\n\n默认配置下，Token 有效期为 30 天，可通过 system_oauth2_client 表中 client_id = default 的记录进行自定义：\n\n\n\n * 修改 access_token_validity_seconds 字段，设置访问令牌的过期时间，默认 1800 秒 = 30 分钟\n * 修改 refresh_token_validity_seconds 字段，设置刷新令牌的过期时间，默认 2592000 秒 = 30 天\n\n② 前端调用其它接口，需要在请求头带上 Token 进行访问。请求头格式如下：\n\n### Authorization: Bearer 登录时返回的 Token\nAuthorization: Bearer d2a3cdbc6c53470db67a582bd115103f\n\n\n * 具体的代码实现，可见 TokenAuthenticationFilter 过滤器\n\n考虑到使用 Postman、Swagger 调试接口方便，提供了 Token 的模拟机制。请求头格式如下：\n\n### Authorization: Bearer test用户编号\nAuthorization: Bearer test1\n\n\n其中 "test" 可自定义，配置项如下：\n\n### application-local.yaml\n\nyudao:\n  security:\n    mock-enable: true # 是否开启 Token 的模拟机制\n    mock-secret: test # Token 模拟机制的 Token 前缀\n\n\n\n# 3. 权限注解\n\n\n# 3.1 @PreAuthorize 注解\n\n@PreAuthorize 是 Spring Security 内置的前置权限注解，添加在接口方法上，声明需要的权限，实现访问权限的控制。\n\n① 基于【权限标识】的权限控制\n\n权限标识，对应 system_menu 表的 permission 字段，推荐格式为 ${系统}:${模块}:${操作}，例如说 system:admin:add 标识 system 服务的添加管理员。\n\n使用示例如下：\n\n// 符合 system:user:list 权限要求\n@PreAuthorize("@ss.hasPermission(\'system:user:list\')")\n\n// 符合 system:user:add 或 system:user:edit 权限要求即可\n@PreAuthorize("@ss.hasAnyPermissions(\'system:user:add\', \'system:user:edit\')")\n\n\n② 基于【角色标识】的权限控制\n\n权限标识，对应 system_role 表的 code 字段， 例如说 super_admin 超级管理员、tenant_admin 租户管理员。\n\n使用示例如下：\n\n// 属于 user 角色\n@PreAuthorize("@ss.hasRole(\'user\')")\n\n// 属于 user 或者 admin 之一\n@PreAuthorize("@ss.hasAnyRoles(\'user\', \'admin\')")\n\n\n实现原理是什么？\n\n当 @PreAuthorize 注解里的 Spring EL 表达式返回 false 时，表示没有权限。\n\n而 @PreAuthorize("@ss.hasPermission(\'system:user:list\')") 表示调用 Bean 名字为 ss 的 #hasPermission(...) 方法，方法参数为 "system:user:list" 字符串。ss 对应的 Bean 是 PermissionServiceImpl 类，所以你只需要去看该方法的实现代码。\n\n注意，一般情况下，只有管理后台的接口才会使用 @PreAuthorize 注解，用户 App 的接口不会使用。\n\n\n# 4. 自定义权限配置\n\n默认配置下，所有接口都需要登录后才能访问，不限于管理后台的 /admin-api/** 所有 API 接口、用户 App 的 /app-api/** 所有 API 接口。\n\n如下想要自定义权限配置，设置定义 API 接口可以匿名（不登录）进行访问，可以通过下面三种方式：\n\n\n# 4.1 方式一：自定义 AuthorizeRequestsCustomizer 实现\n\n每个 Maven Module 可以实现自定义的 AuthorizeRequestsCustomizer Bean，额外定义每个 Module 的 API 接口的访问规则。例如说 yudao-module-infra 模块的 SecurityConfiguration 类，代码如下：\n\n@Configuration(proxyBeanMethods = false, value = "infraSecurityConfiguration")\npublic class SecurityConfiguration {\n\n    @Value("${spring.boot.admin.context-path:\'\'}")\n    private String adminSeverContextPath;\n\n    @Bean("infraAuthorizeRequestsCustomizer")\n    public AuthorizeRequestsCustomizer authorizeRequestsCustomizer() {\n        return new AuthorizeRequestsCustomizer() {\n\n            @Override\n            public void customize(AuthorizeHttpRequestsConfigurer<HttpSecurity>.AuthorizationManagerRequestMatcherRegistry registry) {\n                // Swagger 接口文档\n                registry.requestMatchers("/v3/api-docs/**").permitAll()\n                        .requestMatchers("/swagger-ui.html").permitAll()\n                        .requestMatchers("/swagger-ui/**").permitAll()\n                        .requestMatchers("/swagger-resources/**").permitAll()\n                        .requestMatchers("/webjars/**").permitAll()\n                        .requestMatchers("/*/api-docs").permitAll();\n                // Spring Boot Actuator 的安全配置\n                registry.requestMatchers("/actuator").permitAll()\n                        .requestMatchers("/actuator/**").permitAll();\n                // Druid 监控\n                registry.requestMatchers("/druid/**").permitAll();\n                // Spring Boot Admin Server 的安全配置\n                registry.requestMatchers(adminSeverContextPath).permitAll()\n                        .requestMatchers(adminSeverContextPath + "/**").permitAll();\n                // 文件读取\n                registry.requestMatchers(buildAdminApi("/infra/file/*/get/**")).permitAll();\n            }\n\n        };\n    }\n\n}\n\n\n友情提示\n\n * permitAll() 方法：所有用户可以任意访问，包括带上 Token 访问\n * anonymous() 方法：匿名用户可以任意访问，带上 Token 访问会报错\n\n如果你对 Spring Security 了解不多，可以阅读艿艿写的 《芋道 Spring Boot 安全框架 Spring Security 入门 》 文章。\n\n\n# 4.2 方式二：@PermitAll 注解\n\n在 API 接口上添加 @PermitAll 注解，示例如下：\n\n// FileController.java\n@GetMapping("/{configId}/get/{path}")\n@PermitAll\npublic void getFileContent(HttpServletResponse response,\n                           @PathVariable("configId") Long configId,\n                           @PathVariable("path") String path) throws Exception {\n    // ...\n}\n\n\n\n# 4.3 方式三：yudao.security.permit-all-urls 配置项\n\n在 application.yaml 配置文件，通过 yudao.security.permit-all-urls 配置项设置，示例如下：\n\nyudao:\n  security:\n    permit-all-urls:\n      - /admin-ui/** # /resources/admin-ui 目录下的静态资源\n      - /admin-api/xxx/yyy\n',
            normalizedContent: '# 👍 相关视频教程\n\n * 功能权限 01：如何设计一套权限系统？\n * 功能权限 02：如何实现菜单的创建？\n * 功能权限 03：如何实现角色的创建？\n * 功能权限 04：如何给用户分配权限 —— 将菜单赋予角色？\n * 功能权限 05：如何给用户分配权限 —— 将角色赋予用户？\n * 功能权限 06：后端如何实现 url 权限的校验？\n * 功能权限 07：前端如何实现菜单的动态加载？\n * 功能权限 08：前端如何实现按钮的权限校验？\n\n\n# 1. rbac 权限模型\n\n系统采用 rbac 权限模型，全称是 role-based access control 基于角色的访问控制。\n\n\n\n简单来说，每个用户拥有若干角色，每个角色拥有若干个菜单，菜单中存在菜单权限、按钮权限。这样，就形成了 “用户<->角色<->菜单” 的授权模型。 在这种模型中，用户与角色、角色与菜单之间构成了多对多的关系，如下图：\n\n\n\n\n# 2. token 认证机制\n\n安全框架使用的是 spring security + token 方案，整体流程如下图所示：\n\n\n\n① 前端调用登录接口，使用账号密码获得到认证 token。响应示例如下：\n\n{\n  "code":0,\n  "msg":"",\n  "data":{\n    "token":"d2a3cdbc6c53470db67a582bd115103f"\n  }\n}\n\n\n * 管理后台的登录实现，可见 代码\n * 用户 app 的登录实现，可见 代码\n\n疑问：为什么不使用 spring security 内置的表单登录？\n\nspring security 的登录拓展起来不方便，例如说验证码、三方登录等等。\n\ntoken 存储在数据库中，对应 system_oauth2_access_token 访问令牌表的 id 字段。考虑到访问的性能，缓存在 redis 的 oauth2_access_token:%s 键中。\n\n疑问：为什么不使用 jwt(json web token)？\n\njwt 是无状态的，无法实现 token 的作废，例如说用户登出系统、修改密码等等场景。\n\n推荐阅读 《还分不清 cookie、session、token、jwt？》 文章。\n\n默认配置下，token 有效期为 30 天，可通过 system_oauth2_client 表中 client_id = default 的记录进行自定义：\n\n\n\n * 修改 access_token_validity_seconds 字段，设置访问令牌的过期时间，默认 1800 秒 = 30 分钟\n * 修改 refresh_token_validity_seconds 字段，设置刷新令牌的过期时间，默认 2592000 秒 = 30 天\n\n② 前端调用其它接口，需要在请求头带上 token 进行访问。请求头格式如下：\n\n### authorization: bearer 登录时返回的 token\nauthorization: bearer d2a3cdbc6c53470db67a582bd115103f\n\n\n * 具体的代码实现，可见 tokenauthenticationfilter 过滤器\n\n考虑到使用 postman、swagger 调试接口方便，提供了 token 的模拟机制。请求头格式如下：\n\n### authorization: bearer test用户编号\nauthorization: bearer test1\n\n\n其中 "test" 可自定义，配置项如下：\n\n### application-local.yaml\n\nyudao:\n  security:\n    mock-enable: true # 是否开启 token 的模拟机制\n    mock-secret: test # token 模拟机制的 token 前缀\n\n\n\n# 3. 权限注解\n\n\n# 3.1 @preauthorize 注解\n\n@preauthorize 是 spring security 内置的前置权限注解，添加在接口方法上，声明需要的权限，实现访问权限的控制。\n\n① 基于【权限标识】的权限控制\n\n权限标识，对应 system_menu 表的 permission 字段，推荐格式为 ${系统}:${模块}:${操作}，例如说 system:admin:add 标识 system 服务的添加管理员。\n\n使用示例如下：\n\n// 符合 system:user:list 权限要求\n@preauthorize("@ss.haspermission(\'system:user:list\')")\n\n// 符合 system:user:add 或 system:user:edit 权限要求即可\n@preauthorize("@ss.hasanypermissions(\'system:user:add\', \'system:user:edit\')")\n\n\n② 基于【角色标识】的权限控制\n\n权限标识，对应 system_role 表的 code 字段， 例如说 super_admin 超级管理员、tenant_admin 租户管理员。\n\n使用示例如下：\n\n// 属于 user 角色\n@preauthorize("@ss.hasrole(\'user\')")\n\n// 属于 user 或者 admin 之一\n@preauthorize("@ss.hasanyroles(\'user\', \'admin\')")\n\n\n实现原理是什么？\n\n当 @preauthorize 注解里的 spring el 表达式返回 false 时，表示没有权限。\n\n而 @preauthorize("@ss.haspermission(\'system:user:list\')") 表示调用 bean 名字为 ss 的 #haspermission(...) 方法，方法参数为 "system:user:list" 字符串。ss 对应的 bean 是 permissionserviceimpl 类，所以你只需要去看该方法的实现代码。\n\n注意，一般情况下，只有管理后台的接口才会使用 @preauthorize 注解，用户 app 的接口不会使用。\n\n\n# 4. 自定义权限配置\n\n默认配置下，所有接口都需要登录后才能访问，不限于管理后台的 /admin-api/** 所有 api 接口、用户 app 的 /app-api/** 所有 api 接口。\n\n如下想要自定义权限配置，设置定义 api 接口可以匿名（不登录）进行访问，可以通过下面三种方式：\n\n\n# 4.1 方式一：自定义 authorizerequestscustomizer 实现\n\n每个 maven module 可以实现自定义的 authorizerequestscustomizer bean，额外定义每个 module 的 api 接口的访问规则。例如说 yudao-module-infra 模块的 securityconfiguration 类，代码如下：\n\n@configuration(proxybeanmethods = false, value = "infrasecurityconfiguration")\npublic class securityconfiguration {\n\n    @value("${spring.boot.admin.context-path:\'\'}")\n    private string adminsevercontextpath;\n\n    @bean("infraauthorizerequestscustomizer")\n    public authorizerequestscustomizer authorizerequestscustomizer() {\n        return new authorizerequestscustomizer() {\n\n            @override\n            public void customize(authorizehttprequestsconfigurer<httpsecurity>.authorizationmanagerrequestmatcherregistry registry) {\n                // swagger 接口文档\n                registry.requestmatchers("/v3/api-docs/**").permitall()\n                        .requestmatchers("/swagger-ui.html").permitall()\n                        .requestmatchers("/swagger-ui/**").permitall()\n                        .requestmatchers("/swagger-resources/**").permitall()\n                        .requestmatchers("/webjars/**").permitall()\n                        .requestmatchers("/*/api-docs").permitall();\n                // spring boot actuator 的安全配置\n                registry.requestmatchers("/actuator").permitall()\n                        .requestmatchers("/actuator/**").permitall();\n                // druid 监控\n                registry.requestmatchers("/druid/**").permitall();\n                // spring boot admin server 的安全配置\n                registry.requestmatchers(adminsevercontextpath).permitall()\n                        .requestmatchers(adminsevercontextpath + "/**").permitall();\n                // 文件读取\n                registry.requestmatchers(buildadminapi("/infra/file/*/get/**")).permitall();\n            }\n\n        };\n    }\n\n}\n\n\n友情提示\n\n * permitall() 方法：所有用户可以任意访问，包括带上 token 访问\n * anonymous() 方法：匿名用户可以任意访问，带上 token 访问会报错\n\n如果你对 spring security 了解不多，可以阅读艿艿写的 《芋道 spring boot 安全框架 spring security 入门 》 文章。\n\n\n# 4.2 方式二：@permitall 注解\n\n在 api 接口上添加 @permitall 注解，示例如下：\n\n// filecontroller.java\n@getmapping("/{configid}/get/{path}")\n@permitall\npublic void getfilecontent(httpservletresponse response,\n                           @pathvariable("configid") long configid,\n                           @pathvariable("path") string path) throws exception {\n    // ...\n}\n\n\n\n# 4.3 方式三：yudao.security.permit-all-urls 配置项\n\n在 application.yaml 配置文件，通过 yudao.security.permit-all-urls 配置项设置，示例如下：\n\nyudao:\n  security:\n    permit-all-urls:\n      - /admin-ui/** # /resources/admin-ui 目录下的静态资源\n      - /admin-api/xxx/yyy\n',
            charsets: {
                cjk: !0
            }
        }, {
            title: "三方登录",
            frontmatter: {
                title: "三方登录",
                date: "2022-03-28T21:23:06.000Z",
                permalink: "/social-user"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/02.%E5%90%8E%E7%AB%AF%E6%89%8B%E5%86%8C/10.%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95.html",
            relativePath: "01.开发指南/02.后端手册/10.三方登录.md",
            key: "v-29a135b6",
            path: "/social-user/",
            headers: [{
                level: 2,
                title: "1. 表结构",
                slug: "_1-表结构",
                normalizedTitle: "1. 表结构",
                charIndex: 138
            }, {
                level: 2,
                title: "2. 绑定登录",
                slug: "_2-绑定登录",
                normalizedTitle: "2. 绑定登录",
                charIndex: 346
            }, {
                level: 2,
                title: "3. 快捷登录",
                slug: "_3-快捷登录",
                normalizedTitle: "3. 快捷登录",
                charIndex: 847
            }, {
                level: 2,
                title: "4. 绑定与解绑",
                slug: "_4-绑定与解绑",
                normalizedTitle: "4. 绑定与解绑",
                charIndex: 1184
            }, {
                level: 2,
                title: "5. 配置管理",
                slug: "_5-配置管理",
                normalizedTitle: "5. 配置管理",
                charIndex: 1268
            }, {
                level: 3,
                title: "5.1 配置文件",
                slug: "_5-1-配置文件",
                normalizedTitle: "5.1 配置文件",
                charIndex: 1280
            }, {
                level: 3,
                title: "5.2 数据库配置",
                slug: "_5-2-数据库配置",
                normalizedTitle: "5.2 数据库配置",
                charIndex: 1405
            }, {
                level: 2,
                title: "6. 第三方平台的申请",
                slug: "_6-第三方平台的申请",
                normalizedTitle: "6. 第三方平台的申请",
                charIndex: 2916
            }],
            headersStr: "1. 表结构 2. 绑定登录 3. 快捷登录 4. 绑定与解绑 5. 配置管理 5.1 配置文件 5.2 数据库配置 6. 第三方平台的申请",
            content: "系统对接国内多个第三方平台，实现三方登录的功能。例如说：\n\n * 管理后台：企业微信、阿里钉钉\n * 用户 App：微信公众号、微信小程序\n\n\n\n友情提示：为了表述方便，本文主要使用管理后台的三方登录作为示例。\n\n用户 App 也是支持该功能，你可以自己去体验一下。\n\n\n# 1. 表结构\n\n\n\n① 三方登录完成时，系统会将三方用户存储到 system_social_user 表中，通过 type 标记对应的第三方平台。\n\n② 【未】关联本系统 User 的三方用户，需要在三方登录完成后，使用账号密码进行「绑定登录」，成功后记录到 system_social_user_bind 表中。\n\n【已】关联本系统 User 的三方用户，在三方登录完成后，直接进入系统，即「快捷登录」。\n\n\n# 2. 绑定登录\n\n① 使用浏览器访问 http://127.0.0.1:1024/login 地址，点击 [钉钉] 或者 [企业微信] 进行三方登录。此时，会调用 /admin-api/system/auth/social-auth-redirect 接口，获得第三方平台的登录地址，并进行跳转。\n\n\n\n然后，使用 [钉钉] 或者 [企业微信] 进行扫码，完成三方登录。\n\n② 三方登录成功后，跳转回 http://127.0.0.1:1024/social-login 地址。此时，会调用 /admin-api/system/auth/social-login 接口，尝试「快捷登录」。由于该三方用户【未】关联管理后台的 AdminUser 用户，所以会看到 “未绑定账号，需要进行绑定” 报错。\n\n\n\n③ 输入账号密码，点击 [提交] 按钮，进行「绑定登录」。此时，会调用 /admin-api/system/auth/login 接口（在账号密码登录的基础上，额外带上 socialType + socialCode + socialState 参数）。成功后，即可进入系统的首页。\n\n\n\n\n# 3. 快捷登录\n\n退出系统，再进行一次三方登录的流程。\n\n【相同】① 使用浏览器访问 http://127.0.0.1:1024/login 地址，点击 [钉钉] 或者 [企业微信] 进行三方登录。此时，会调用 /admin-api/system/auth/social-auth-redirect 接口，获得第三方平台的登录地址，并进行跳转。\n\n\n\n【不同】② 三方登录成功后，跳转回 http://127.0.0.1:1024/social-login 地址。此时，会调用 /admin-api/system/auth/social-login 接口，尝试「快捷登录」。由于该三方用户【已】关联管理后台的 AdminUser 用户，所以直接进入系统的首页。\n\n\n\n\n# 4. 绑定与解绑\n\n访问 http://127.0.0.1:1024/user/profile 地址，选择 [社交信息] 选项，可以三方用户的绑定与解绑。\n\n\n\n\n# 5. 配置管理\n\n\n# 5.1 配置文件\n\n在 application-{env}.yaml 配置文件中，对应 justauth 配置项，填写你的第三方平台的配置信息。\n\n\n\n系统使用 JustAuth 组件，想要对接其它第三方平台，只需要新增对应的配置信息即可。\n\n\n# 5.2 数据库配置\n\n① system_social_client 表，它本质上是 JustAuth 配置的 DB 存储。\n\n主要实现两个目的：\n\nCREATE TABLE `system_social_client` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '应用名',\n  `status` tinyint NOT NULL COMMENT '状态',\n  // JustAuth 配置项\n  `social_type` tinyint NOT NULL COMMENT '社交平台的类型',\n  `client_id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '客户端编号',\n  `client_secret` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '客户端密钥',\n  `agent_id` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '代理编号',\n  // 目的 1\n  `tenant_id` bigint NOT NULL DEFAULT '0' COMMENT '租户编号',\n  // 目的 2\n  `user_type` tinyint NOT NULL COMMENT '用户类型',\n  // ... 省略其它非关键字段\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=44 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='社交客户端表';\n\n\n 1. 在需要 SaaS 多租户的项目中，通过 tenant_id 字段隔离，实现不同租户对应不同第三方平台的配置\n 2. 在多用户类型的项目中，通过 user_type 字段区分，实现不同用户类型对应不同第三方平台的配置\n\n注意，system_social_client 表的优先级，比 application-{env}.yaml 配置文件高！具体逻辑，可见 SocialClientServiceImpl 类的 #buildAuthRequest(...) 方法。\n\n疑问：系统目前支持指定租户 + 用户类型 + 社交平台，对应多套配置吗？\n\n不支持，需要自己改造。总体思路是：\n\n 1. system_social_client 额外再增加一个 application 应用字段，存储应用名，进行一步隔离\n 2. 前端调用三方登录时，额外传递 application 应用字段，用于查询对应应用的配置\n\n② 在 [系统管理 -> 三方登录 -> 三方应用] 菜单下，可以进行当前租户的 system_social_client 表的配置管理。如下图所示：\n\n\n\n另外，在 [系统管理 -> 三方登录 -> 三方用户] 菜单下，可以进行当前租户的 system_social_user 三方用户表的查询。如下图所示：\n\n\n\n\n# 6. 第三方平台的申请\n\n * 阿里钉钉\n * 企业微信扫码登录\n * 微信开放平台\n\n注意，如果第三方平台如果需要配置具体的授信地址，需要添加 /social-login 用于三方登录回调页、/user/profile 用于三方用户的绑定与解绑。",
            normalizedContent: "系统对接国内多个第三方平台，实现三方登录的功能。例如说：\n\n * 管理后台：企业微信、阿里钉钉\n * 用户 app：微信公众号、微信小程序\n\n\n\n友情提示：为了表述方便，本文主要使用管理后台的三方登录作为示例。\n\n用户 app 也是支持该功能，你可以自己去体验一下。\n\n\n# 1. 表结构\n\n\n\n① 三方登录完成时，系统会将三方用户存储到 system_social_user 表中，通过 type 标记对应的第三方平台。\n\n② 【未】关联本系统 user 的三方用户，需要在三方登录完成后，使用账号密码进行「绑定登录」，成功后记录到 system_social_user_bind 表中。\n\n【已】关联本系统 user 的三方用户，在三方登录完成后，直接进入系统，即「快捷登录」。\n\n\n# 2. 绑定登录\n\n① 使用浏览器访问 http://127.0.0.1:1024/login 地址，点击 [钉钉] 或者 [企业微信] 进行三方登录。此时，会调用 /admin-api/system/auth/social-auth-redirect 接口，获得第三方平台的登录地址，并进行跳转。\n\n\n\n然后，使用 [钉钉] 或者 [企业微信] 进行扫码，完成三方登录。\n\n② 三方登录成功后，跳转回 http://127.0.0.1:1024/social-login 地址。此时，会调用 /admin-api/system/auth/social-login 接口，尝试「快捷登录」。由于该三方用户【未】关联管理后台的 adminuser 用户，所以会看到 “未绑定账号，需要进行绑定” 报错。\n\n\n\n③ 输入账号密码，点击 [提交] 按钮，进行「绑定登录」。此时，会调用 /admin-api/system/auth/login 接口（在账号密码登录的基础上，额外带上 socialtype + socialcode + socialstate 参数）。成功后，即可进入系统的首页。\n\n\n\n\n# 3. 快捷登录\n\n退出系统，再进行一次三方登录的流程。\n\n【相同】① 使用浏览器访问 http://127.0.0.1:1024/login 地址，点击 [钉钉] 或者 [企业微信] 进行三方登录。此时，会调用 /admin-api/system/auth/social-auth-redirect 接口，获得第三方平台的登录地址，并进行跳转。\n\n\n\n【不同】② 三方登录成功后，跳转回 http://127.0.0.1:1024/social-login 地址。此时，会调用 /admin-api/system/auth/social-login 接口，尝试「快捷登录」。由于该三方用户【已】关联管理后台的 adminuser 用户，所以直接进入系统的首页。\n\n\n\n\n# 4. 绑定与解绑\n\n访问 http://127.0.0.1:1024/user/profile 地址，选择 [社交信息] 选项，可以三方用户的绑定与解绑。\n\n\n\n\n# 5. 配置管理\n\n\n# 5.1 配置文件\n\n在 application-{env}.yaml 配置文件中，对应 justauth 配置项，填写你的第三方平台的配置信息。\n\n\n\n系统使用 justauth 组件，想要对接其它第三方平台，只需要新增对应的配置信息即可。\n\n\n# 5.2 数据库配置\n\n① system_social_client 表，它本质上是 justauth 配置的 db 存储。\n\n主要实现两个目的：\n\ncreate table `system_social_client` (\n  `id` bigint not null auto_increment comment '编号',\n  `name` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '应用名',\n  `status` tinyint not null comment '状态',\n  // justauth 配置项\n  `social_type` tinyint not null comment '社交平台的类型',\n  `client_id` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '客户端编号',\n  `client_secret` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '客户端密钥',\n  `agent_id` varchar(255) collate utf8mb4_unicode_ci default null comment '代理编号',\n  // 目的 1\n  `tenant_id` bigint not null default '0' comment '租户编号',\n  // 目的 2\n  `user_type` tinyint not null comment '用户类型',\n  // ... 省略其它非关键字段\n  primary key (`id`) using btree\n) engine=innodb auto_increment=44 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='社交客户端表';\n\n\n 1. 在需要 saas 多租户的项目中，通过 tenant_id 字段隔离，实现不同租户对应不同第三方平台的配置\n 2. 在多用户类型的项目中，通过 user_type 字段区分，实现不同用户类型对应不同第三方平台的配置\n\n注意，system_social_client 表的优先级，比 application-{env}.yaml 配置文件高！具体逻辑，可见 socialclientserviceimpl 类的 #buildauthrequest(...) 方法。\n\n疑问：系统目前支持指定租户 + 用户类型 + 社交平台，对应多套配置吗？\n\n不支持，需要自己改造。总体思路是：\n\n 1. system_social_client 额外再增加一个 application 应用字段，存储应用名，进行一步隔离\n 2. 前端调用三方登录时，额外传递 application 应用字段，用于查询对应应用的配置\n\n② 在 [系统管理 -> 三方登录 -> 三方应用] 菜单下，可以进行当前租户的 system_social_client 表的配置管理。如下图所示：\n\n\n\n另外，在 [系统管理 -> 三方登录 -> 三方用户] 菜单下，可以进行当前租户的 system_social_user 三方用户表的查询。如下图所示：\n\n\n\n\n# 6. 第三方平台的申请\n\n * 阿里钉钉\n * 企业微信扫码登录\n * 微信开放平台\n\n注意，如果第三方平台如果需要配置具体的授信地址，需要添加 /social-login 用于三方登录回调页、/user/profile 用于三方用户的绑定与解绑。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "用户体系",
            frontmatter: {
                title: "用户体系",
                date: "2022-03-28T21:19:28.000Z",
                permalink: "/user-center"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/02.%E5%90%8E%E7%AB%AF%E6%89%8B%E5%86%8C/09.%E7%94%A8%E6%88%B7%E4%BD%93%E7%B3%BB.html",
            relativePath: "01.开发指南/02.后端手册/09.用户体系.md",
            key: "v-06acd369",
            path: "/user-center/",
            headers: [{
                level: 2,
                title: "1. 表结构",
                slug: "_1-表结构",
                normalizedTitle: "1. 表结构",
                charIndex: 280
            }, {
                level: 2,
                title: "2. 如何获取当前登录的用户？",
                slug: "_2-如何获取当前登录的用户",
                normalizedTitle: "2. 如何获取当前登录的用户？",
                charIndex: 654
            }, {
                level: 3,
                title: "2.1 获取当前用户信息",
                slug: "_2-1-获取当前用户信息",
                normalizedTitle: "2.1 获取当前用户信息",
                charIndex: 724
            }, {
                level: 3,
                title: "2.2 获取当前用户编号（最常用）",
                slug: "_2-2-获取当前用户编号-最常用",
                normalizedTitle: "2.2 获取当前用户编号（最常用）",
                charIndex: 782
            }, {
                level: 3,
                title: "2.3 获取当前用户昵称",
                slug: "_2-3-获取当前用户昵称",
                normalizedTitle: "2.3 获取当前用户昵称",
                charIndex: 842
            }, {
                level: 3,
                title: "2.4 获取当前用户部门",
                slug: "_2-4-获取当前用户部门",
                normalizedTitle: "2.4 获取当前用户部门",
                charIndex: 933
            }, {
                level: 3,
                title: "2.5 获取更多信息",
                slug: "_2-5-获取更多信息",
                normalizedTitle: "2.5 获取更多信息",
                charIndex: 1017
            }, {
                level: 2,
                title: "3. 账号密码登录",
                slug: "_3-账号密码登录",
                normalizedTitle: "3. 账号密码登录",
                charIndex: 1184
            }, {
                level: 3,
                title: "3.1 管理后台的实现",
                slug: "_3-1-管理后台的实现",
                normalizedTitle: "3.1 管理后台的实现",
                charIndex: 1198
            }, {
                level: 3,
                title: "3.2 用户 App 的实现",
                slug: "_3-2-用户-app-的实现",
                normalizedTitle: "3.2 用户 app 的实现",
                charIndex: 1641
            }, {
                level: 2,
                title: "4. 手机验证码登录",
                slug: "_4-手机验证码登录",
                normalizedTitle: "4. 手机验证码登录",
                charIndex: 2066
            }, {
                level: 3,
                title: "4.1 管理后台的实现",
                slug: "_4-1-管理后台的实现",
                normalizedTitle: "4.1 管理后台的实现",
                charIndex: 2081
            }, {
                level: 3,
                title: "4.2 用户 App 的实现",
                slug: "_4-2-用户-app-的实现",
                normalizedTitle: "4.2 用户 app 的实现",
                charIndex: 2832
            }, {
                level: 2,
                title: "5. 三方登录",
                slug: "_5-三方登录",
                normalizedTitle: "5. 三方登录",
                charIndex: 3675
            }, {
                level: 3,
                title: "5.1 管理后台的实现",
                slug: "_5-1-管理后台的实现",
                normalizedTitle: "5.1 管理后台的实现",
                charIndex: 3712
            }, {
                level: 3,
                title: "5.2 用户 App 的实现",
                slug: "_5-2-用户-app-的实现",
                normalizedTitle: "5.2 用户 app 的实现",
                charIndex: 4899
            }, {
                level: 2,
                title: "6. 注册",
                slug: "_6-注册",
                normalizedTitle: "6. 注册",
                charIndex: 6473
            }, {
                level: 3,
                title: "6.1 管理后台的实现",
                slug: "_6-1-管理后台的实现",
                normalizedTitle: "6.1 管理后台的实现",
                charIndex: 6483
            }, {
                level: 3,
                title: "6.2 用户 App 的实现",
                slug: "_6-2-用户-app-的实现",
                normalizedTitle: "6.2 用户 app 的实现",
                charIndex: 6868
            }, {
                level: 2,
                title: "7. 用户登出",
                slug: "_7-用户登出",
                normalizedTitle: "7. 用户登出",
                charIndex: 6971
            }, {
                level: 2,
                title: "8. 社区贡献的权限相关",
                slug: "_8-社区贡献的权限相关",
                normalizedTitle: "8. 社区贡献的权限相关",
                charIndex: 7126
            }],
            headersStr: "1. 表结构 2. 如何获取当前登录的用户？ 2.1 获取当前用户信息 2.2 获取当前用户编号（最常用） 2.3 获取当前用户昵称 2.4 获取当前用户部门 2.5 获取更多信息 3. 账号密码登录 3.1 管理后台的实现 3.2 用户 App 的实现 4. 手机验证码登录 4.1 管理后台的实现 4.2 用户 App 的实现 5. 三方登录 5.1 管理后台的实现 5.2 用户 App 的实现 6. 注册 6.1 管理后台的实现 6.2 用户 App 的实现 7. 用户登出 8. 社区贡献的权限相关",
            content: '系统提供了 2 种类型的用户，分别满足对应的管理后台、用户 App 场景。\n\n\n\n * AdminUser 管理员用户，前端访问 yudao-ui-admin-vue3 管理后台，后端访问 /admin-api/** RESTful API 接口。\n * MemberUser 会员用户，前端访问 yudao-mall-uniapp 用户 App，后端访问 /app-api/** RESTful API 接口。\n\n虽然是不同类型的用户，他们访问 RESTful API 接口时，都通过 Token 认证机制，具体可见 《开发指南 —— 功能权限》。\n\n\n# 1. 表结构\n\n2 种类型的时候，采用不同数据库的表进行存储，管理员用户对应 system_users 表，会员用户对应 member_user 表。如下图所示：\n\n\n\n为什么不使用统一的用户表？\n\n确实可以采用这样的方案，新增 type 字段区分用户类型。不同用户类型的信息字段，例如说上图的 dept_id、post_ids 等等，可以增加拓展表，或者就干脆“冗余”在用户表中。\n\n不过实际项目中，不同类型的用户往往是不同的团队维护，并且这也是绝大多团队的实践，所以我们采用了多个用户表的方案。\n\n如果表需要关联多种类型的用户，例如说上述的 system_oauth2_access_token 访问令牌表，可以通过 user_type 字段进行区分。并且 user_type 对应 UserTypeEnum 全局枚举，代码如下：\n\n\n\n\n# 2. 如何获取当前登录的用户？\n\n使用 SecurityFrameworkUtils 提供的如下方法，可以获得当前登录用户的信息：\n\n\n# 2.1 获取当前用户信息\n\npublic static LoginUser getLoginUser()\n\n\n\n# 2.2 获取当前用户编号（最常用）\n\npublic static Long getLoginUserId()\n\n\n\n# 2.3 获取当前用户昵称\n\npublic static LoginUser getLoginUserNickname()\n\n\n注意，仅适合 AdminUser 管理员用户！\n\n\n# 2.4 获取当前用户部门\n\npublic static Long getLoginUserDeptId()\n\n\n注意，仅适合 AdminUser 管理员用户！\n\n\n# 2.5 获取更多信息\n\n① 在 OAuth2TokenServiceImpl 的 #buildUserInfo(...) 方法中，补充读取更多的用户信息，例如说 mobile、sex 等等。如下图所示：\n\n\n\n② 在 SecurityFrameworkUtils 新增对应的 getXXX() 静态方法，参考如下图所示：\n\n\n\n\n# 3. 账号密码登录\n\n\n# 3.1 管理后台的实现\n\n使用 username 账号 + password 密码进行登录，由 AuthController 提供 /admin-api/system/auth/login 接口。代码如下：\n\n@PostMapping("/login")\n@Operation(summary = "使用账号密码登录")\npublic CommonResult<AuthLoginRespVO> login(@RequestBody @Valid AuthLoginReqVO reqVO) {\n    String token = authService.login(reqVO, getClientIP(), getUserAgent());\n    // 返回结果\n    return success(AuthLoginRespVO.builder().token(token).build());\n}\n\n\n如何关闭验证码？\n\n参见 《后端手册 —— 验证码》 文档。\n\n\n# 3.2 用户 App 的实现\n\n使用 mobile 手机 + password 密码进行登录，由 AppAuthController 提供 /app-api/member/auth/login 接口。代码如下：\n\n@PostMapping("/login")\n@Operation(summary = "使用手机 + 密码登录")\npublic CommonResult<AppAuthLoginRespVO> login(@RequestBody @Valid AppAuthLoginReqVO reqVO) {\n    String token = authService.login(reqVO, getClientIP(), getUserAgent());\n    // 返回结果\n    return success(AppAuthLoginRespVO.builder().token(token).build());\n}\n\n\n\n# 4. 手机验证码登录\n\n\n# 4.1 管理后台的实现\n\n① 使用 mobile 手机号获得验证码，由 AuthController 提供 /admin-api/system/auth/send-sms-code 接口。代码如下：\n\n@PostMapping("/send-sms-code")\n@Operation(summary = "发送手机验证码")\npublic CommonResult<Boolean> sendSmsCode(@RequestBody @Valid AuthSendSmsReqVO reqVO) {\n    authService.sendSmsCode(getLoginUserId(), reqVO);\n    return success(true);\n}\n\n\n② 使用 mobile 手机 + code 验证码进行登录，由 AppAuthController 提供 /admin-api/system/auth/sms-login 接口。代码如下：\n\n@PostMapping("/sms-login")\n@Operation(summary = "使用短信验证码登录")\npublic CommonResult<AuthLoginRespVO> smsLogin(@RequestBody @Valid AuthSmsLoginReqVO reqVO) {\n    String token = authService.smsLogin(reqVO, getClientIP(), getUserAgent());\n    // 返回结果\n    return success(AuthLoginRespVO.builder().token(token).build());\n}\n\n\n\n# 4.2 用户 App 的实现\n\n① 使用 mobile 手机号获得验证码，由 AppAuthController 提供 /app-api/member/auth/send-sms-code 接口。代码如下：\n\n@PostMapping("/send-sms-code")\n@Operation(summary = "发送手机验证码")\npublic CommonResult<Boolean> sendSmsCode(@RequestBody @Valid AppAuthSendSmsReqVO reqVO) {\n    authService.sendSmsCode(getLoginUserId(), reqVO);\n    return success(true);\n}\n\n\n② 使用 mobile 手机 + code 验证码进行登录，由 AppAuthController 提供 /app-api/member/auth/sms-login 接口。代码如下：\n\n@PostMapping("/sms-login")\n@Operation(summary = "使用手机 + 验证码登录")\npublic CommonResult<AppAuthLoginRespVO> smsLogin(@RequestBody @Valid AppAuthSmsLoginReqVO reqVO) {\n    String token = authService.smsLogin(reqVO, getClientIP(), getUserAgent());\n    // 返回结果\n    return success(AppAuthLoginRespVO.builder().token(token).build());\n}\n\n\n如果用户未注册，会自动使用手机号进行注册会员用户。所以，/app-api/member/user/sms-login 接口也提供了用户注册的功能。\n\n\n# 5. 三方登录\n\n详细参见 《开发指南 —— 三方登录》 文章。\n\n\n# 5.1 管理后台的实现\n\n① 跳转第三方平台，来获得三方授权码，由 AuthController 提供 /admin-api/system/auth/social-auth-redirect 接口。代码如下：\n\n@GetMapping("/social-auth-redirect")\n@Operation(summary = "社交授权的跳转")\n@Parameters({\n        @Parameter(name = "type", description = "社交类型", required = true),\n        @Parameter(name = "redirectUri", description = "回调路径")\n})\npublic CommonResult<String> socialAuthRedirect(@RequestParam("type") Integer type,\n                                                @RequestParam("redirectUri") String redirectUri) {\n    return CommonResult.success(socialUserService.getAuthorizeUrl(type, redirectUri));\n}\n\n\n② 使用 code 三方授权码进行快登录，由 AuthController 提供 /admin-api/system/auth/social-login 接口。代码如下：\n\n@PostMapping("/social-login")\n@Operation(summary = "社交快捷登录，使用 code 授权码")\npublic CommonResult<AuthLoginRespVO> socialQuickLogin(@RequestBody @Valid AuthSocialQuickLoginReqVO reqVO) {\n    String token = authService.socialLogin(reqVO, getClientIP(), getUserAgent());\n    // 返回结果\n    return success(AuthLoginRespVO.builder().token(token).build());\n}\n\n\n③ 使用 socialCode 三方授权码 + username + password 进行绑定登录，直接使用 /admin-api/system/auth/login 账号密码登录的接口，区别在于额外带上 socialType + socialCode + socialState 参数。\n\n\n# 5.2 用户 App 的实现\n\n① 跳转第三方平台，来获得三方授权码，由 AppAuthController 提供 /app-api/member/auth/social-auth-redirect 接口。代码如下：\n\n@GetMapping("/social-auth-redirect")\n@Operation(summary = "社交授权的跳转")\n@Parameters({\n        @Parameter(name = "type", description = "社交类型", required = true),\n        @Parameter(name = "redirectUri", description = "回调路径")\n})\npublic CommonResult<String> socialAuthRedirect(@RequestParam("type") Integer type,\n                                               @RequestParam("redirectUri") String redirectUri) {\n    return CommonResult.success(socialUserService.getAuthorizeUrl(type, redirectUri));\n}\n\n\n② 使用 code 三方授权码进行快登录，由 AppAuthController 提供 /app-api/member/auth/social-login 接口。代码如下：\n\n@PostMapping("/social-login")\n@Operation(summary = "社交快捷登录，使用 code 授权码")\npublic CommonResult<AppAuthLoginRespVO> socialQuickLogin(@RequestBody @Valid AuthSocialQuickLoginReqVO reqVO) {\n    String token = authService.socialLogin(reqVO, getClientIP(), getUserAgent());\n    // 返回结果\n    return success(AuthLoginRespVO.builder().token(token).build());\n}\n\n\n③ 使用 socialCode 三方授权码 + username + password 进行绑定登录，直接使用 /app-api/system/auth/login 手机验证码登录的接口，区别在于额外带上 socialType + socialCode + socialState 参数。\n\n④ 【微信小程序特有】使用 phoneCode + loginCode 实现获取手机号并一键登录，由 AppAuthController 提供 /app-api/member/auth/weixin-mini-app-login 接口。代码如下：\n\n@PostMapping("/weixin-mini-app-login")\n@Operation(summary = "微信小程序的一键登录")\npublic CommonResult<AppAuthLoginRespVO> weixinMiniAppLogin(@RequestBody @Valid AppAuthWeixinMiniAppLoginReqVO reqVO) {\n    return success(authService.weixinMiniAppLogin(reqVO));\n}\n\n\n\n# 6. 注册\n\n\n# 6.1 管理后台的实现\n\n管理后台暂不支持用户注册，而是通过在 [系统管理 -> 用户管理] 菜单，进行添加用户，由 UserController 提供 /admin-api/system/user/create 接口。代码如下：\n\n@PostMapping("/create")\n@Operation(summary = "新增用户")\n@PreAuthorize("@ss.hasPermission(\'system:user:create\')")\npublic CommonResult<Long> createUser(@Valid @RequestBody UserCreateReqVO reqVO) {\n    Long id = userService.createUser(reqVO);\n    return success(id);\n}\n\n\n\n# 6.2 用户 App 的实现\n\n手机验证码登录时，如果用户未注册，会自动使用手机号进行注册会员用户。所以，/app-api/system/user/sms-login 接口也提供了用户注册的功能。\n\n\n# 7. 用户登出\n\n用户登出的功能，统一使用 Spring Security 框架，通过删除用户 Token 的方式来实现。代码如下：\n\n\n\n差别在于使用的 API 接口不同，管理员用户使用 /admin-api/system/logout，会员用户使用 /app-api/member/logout。\n\n\n# 8. 社区贡献的权限相关\n\n * 新增是否允许账号多设备登录的配置\n * 同一账号同时登录多台设备的个数配置',
            normalizedContent: '系统提供了 2 种类型的用户，分别满足对应的管理后台、用户 app 场景。\n\n\n\n * adminuser 管理员用户，前端访问 yudao-ui-admin-vue3 管理后台，后端访问 /admin-api/** restful api 接口。\n * memberuser 会员用户，前端访问 yudao-mall-uniapp 用户 app，后端访问 /app-api/** restful api 接口。\n\n虽然是不同类型的用户，他们访问 restful api 接口时，都通过 token 认证机制，具体可见 《开发指南 —— 功能权限》。\n\n\n# 1. 表结构\n\n2 种类型的时候，采用不同数据库的表进行存储，管理员用户对应 system_users 表，会员用户对应 member_user 表。如下图所示：\n\n\n\n为什么不使用统一的用户表？\n\n确实可以采用这样的方案，新增 type 字段区分用户类型。不同用户类型的信息字段，例如说上图的 dept_id、post_ids 等等，可以增加拓展表，或者就干脆“冗余”在用户表中。\n\n不过实际项目中，不同类型的用户往往是不同的团队维护，并且这也是绝大多团队的实践，所以我们采用了多个用户表的方案。\n\n如果表需要关联多种类型的用户，例如说上述的 system_oauth2_access_token 访问令牌表，可以通过 user_type 字段进行区分。并且 user_type 对应 usertypeenum 全局枚举，代码如下：\n\n\n\n\n# 2. 如何获取当前登录的用户？\n\n使用 securityframeworkutils 提供的如下方法，可以获得当前登录用户的信息：\n\n\n# 2.1 获取当前用户信息\n\npublic static loginuser getloginuser()\n\n\n\n# 2.2 获取当前用户编号（最常用）\n\npublic static long getloginuserid()\n\n\n\n# 2.3 获取当前用户昵称\n\npublic static loginuser getloginusernickname()\n\n\n注意，仅适合 adminuser 管理员用户！\n\n\n# 2.4 获取当前用户部门\n\npublic static long getloginuserdeptid()\n\n\n注意，仅适合 adminuser 管理员用户！\n\n\n# 2.5 获取更多信息\n\n① 在 oauth2tokenserviceimpl 的 #builduserinfo(...) 方法中，补充读取更多的用户信息，例如说 mobile、sex 等等。如下图所示：\n\n\n\n② 在 securityframeworkutils 新增对应的 getxxx() 静态方法，参考如下图所示：\n\n\n\n\n# 3. 账号密码登录\n\n\n# 3.1 管理后台的实现\n\n使用 username 账号 + password 密码进行登录，由 authcontroller 提供 /admin-api/system/auth/login 接口。代码如下：\n\n@postmapping("/login")\n@operation(summary = "使用账号密码登录")\npublic commonresult<authloginrespvo> login(@requestbody @valid authloginreqvo reqvo) {\n    string token = authservice.login(reqvo, getclientip(), getuseragent());\n    // 返回结果\n    return success(authloginrespvo.builder().token(token).build());\n}\n\n\n如何关闭验证码？\n\n参见 《后端手册 —— 验证码》 文档。\n\n\n# 3.2 用户 app 的实现\n\n使用 mobile 手机 + password 密码进行登录，由 appauthcontroller 提供 /app-api/member/auth/login 接口。代码如下：\n\n@postmapping("/login")\n@operation(summary = "使用手机 + 密码登录")\npublic commonresult<appauthloginrespvo> login(@requestbody @valid appauthloginreqvo reqvo) {\n    string token = authservice.login(reqvo, getclientip(), getuseragent());\n    // 返回结果\n    return success(appauthloginrespvo.builder().token(token).build());\n}\n\n\n\n# 4. 手机验证码登录\n\n\n# 4.1 管理后台的实现\n\n① 使用 mobile 手机号获得验证码，由 authcontroller 提供 /admin-api/system/auth/send-sms-code 接口。代码如下：\n\n@postmapping("/send-sms-code")\n@operation(summary = "发送手机验证码")\npublic commonresult<boolean> sendsmscode(@requestbody @valid authsendsmsreqvo reqvo) {\n    authservice.sendsmscode(getloginuserid(), reqvo);\n    return success(true);\n}\n\n\n② 使用 mobile 手机 + code 验证码进行登录，由 appauthcontroller 提供 /admin-api/system/auth/sms-login 接口。代码如下：\n\n@postmapping("/sms-login")\n@operation(summary = "使用短信验证码登录")\npublic commonresult<authloginrespvo> smslogin(@requestbody @valid authsmsloginreqvo reqvo) {\n    string token = authservice.smslogin(reqvo, getclientip(), getuseragent());\n    // 返回结果\n    return success(authloginrespvo.builder().token(token).build());\n}\n\n\n\n# 4.2 用户 app 的实现\n\n① 使用 mobile 手机号获得验证码，由 appauthcontroller 提供 /app-api/member/auth/send-sms-code 接口。代码如下：\n\n@postmapping("/send-sms-code")\n@operation(summary = "发送手机验证码")\npublic commonresult<boolean> sendsmscode(@requestbody @valid appauthsendsmsreqvo reqvo) {\n    authservice.sendsmscode(getloginuserid(), reqvo);\n    return success(true);\n}\n\n\n② 使用 mobile 手机 + code 验证码进行登录，由 appauthcontroller 提供 /app-api/member/auth/sms-login 接口。代码如下：\n\n@postmapping("/sms-login")\n@operation(summary = "使用手机 + 验证码登录")\npublic commonresult<appauthloginrespvo> smslogin(@requestbody @valid appauthsmsloginreqvo reqvo) {\n    string token = authservice.smslogin(reqvo, getclientip(), getuseragent());\n    // 返回结果\n    return success(appauthloginrespvo.builder().token(token).build());\n}\n\n\n如果用户未注册，会自动使用手机号进行注册会员用户。所以，/app-api/member/user/sms-login 接口也提供了用户注册的功能。\n\n\n# 5. 三方登录\n\n详细参见 《开发指南 —— 三方登录》 文章。\n\n\n# 5.1 管理后台的实现\n\n① 跳转第三方平台，来获得三方授权码，由 authcontroller 提供 /admin-api/system/auth/social-auth-redirect 接口。代码如下：\n\n@getmapping("/social-auth-redirect")\n@operation(summary = "社交授权的跳转")\n@parameters({\n        @parameter(name = "type", description = "社交类型", required = true),\n        @parameter(name = "redirecturi", description = "回调路径")\n})\npublic commonresult<string> socialauthredirect(@requestparam("type") integer type,\n                                                @requestparam("redirecturi") string redirecturi) {\n    return commonresult.success(socialuserservice.getauthorizeurl(type, redirecturi));\n}\n\n\n② 使用 code 三方授权码进行快登录，由 authcontroller 提供 /admin-api/system/auth/social-login 接口。代码如下：\n\n@postmapping("/social-login")\n@operation(summary = "社交快捷登录，使用 code 授权码")\npublic commonresult<authloginrespvo> socialquicklogin(@requestbody @valid authsocialquickloginreqvo reqvo) {\n    string token = authservice.sociallogin(reqvo, getclientip(), getuseragent());\n    // 返回结果\n    return success(authloginrespvo.builder().token(token).build());\n}\n\n\n③ 使用 socialcode 三方授权码 + username + password 进行绑定登录，直接使用 /admin-api/system/auth/login 账号密码登录的接口，区别在于额外带上 socialtype + socialcode + socialstate 参数。\n\n\n# 5.2 用户 app 的实现\n\n① 跳转第三方平台，来获得三方授权码，由 appauthcontroller 提供 /app-api/member/auth/social-auth-redirect 接口。代码如下：\n\n@getmapping("/social-auth-redirect")\n@operation(summary = "社交授权的跳转")\n@parameters({\n        @parameter(name = "type", description = "社交类型", required = true),\n        @parameter(name = "redirecturi", description = "回调路径")\n})\npublic commonresult<string> socialauthredirect(@requestparam("type") integer type,\n                                               @requestparam("redirecturi") string redirecturi) {\n    return commonresult.success(socialuserservice.getauthorizeurl(type, redirecturi));\n}\n\n\n② 使用 code 三方授权码进行快登录，由 appauthcontroller 提供 /app-api/member/auth/social-login 接口。代码如下：\n\n@postmapping("/social-login")\n@operation(summary = "社交快捷登录，使用 code 授权码")\npublic commonresult<appauthloginrespvo> socialquicklogin(@requestbody @valid authsocialquickloginreqvo reqvo) {\n    string token = authservice.sociallogin(reqvo, getclientip(), getuseragent());\n    // 返回结果\n    return success(authloginrespvo.builder().token(token).build());\n}\n\n\n③ 使用 socialcode 三方授权码 + username + password 进行绑定登录，直接使用 /app-api/system/auth/login 手机验证码登录的接口，区别在于额外带上 socialtype + socialcode + socialstate 参数。\n\n④ 【微信小程序特有】使用 phonecode + logincode 实现获取手机号并一键登录，由 appauthcontroller 提供 /app-api/member/auth/weixin-mini-app-login 接口。代码如下：\n\n@postmapping("/weixin-mini-app-login")\n@operation(summary = "微信小程序的一键登录")\npublic commonresult<appauthloginrespvo> weixinminiapplogin(@requestbody @valid appauthweixinminiapploginreqvo reqvo) {\n    return success(authservice.weixinminiapplogin(reqvo));\n}\n\n\n\n# 6. 注册\n\n\n# 6.1 管理后台的实现\n\n管理后台暂不支持用户注册，而是通过在 [系统管理 -> 用户管理] 菜单，进行添加用户，由 usercontroller 提供 /admin-api/system/user/create 接口。代码如下：\n\n@postmapping("/create")\n@operation(summary = "新增用户")\n@preauthorize("@ss.haspermission(\'system:user:create\')")\npublic commonresult<long> createuser(@valid @requestbody usercreatereqvo reqvo) {\n    long id = userservice.createuser(reqvo);\n    return success(id);\n}\n\n\n\n# 6.2 用户 app 的实现\n\n手机验证码登录时，如果用户未注册，会自动使用手机号进行注册会员用户。所以，/app-api/system/user/sms-login 接口也提供了用户注册的功能。\n\n\n# 7. 用户登出\n\n用户登出的功能，统一使用 spring security 框架，通过删除用户 token 的方式来实现。代码如下：\n\n\n\n差别在于使用的 api 接口不同，管理员用户使用 /admin-api/system/logout，会员用户使用 /app-api/member/logout。\n\n\n# 8. 社区贡献的权限相关\n\n * 新增是否允许账号多设备登录的配置\n * 同一账号同时登录多台设备的个数配置',
            charsets: {
                cjk: !0
            }
        }, {
            title: "OAuth 2.0（SSO 单点登录)",
            frontmatter: {
                title: "OAuth 2.0（SSO 单点登录)",
                date: "2022-09-27T21:23:06.000Z",
                permalink: "/oauth2"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/02.%E5%90%8E%E7%AB%AF%E6%89%8B%E5%86%8C/11.OAuth2x0.html",
            relativePath: "01.开发指南/02.后端手册/11.OAuth2x0.md",
            key: "v-016743b8",
            path: "/oauth2/",
            headers: [{
                level: 2,
                title: "OAuth 2.0 是什么？",
                slug: "oauth-2-0-是什么",
                normalizedTitle: "oauth 2.0 是什么？",
                charIndex: 2
            }, {
                level: 2,
                title: "OAuth 2.0 授权模式的选择？",
                slug: "oauth-2-0-授权模式的选择",
                normalizedTitle: "oauth 2.0 授权模式的选择？",
                charIndex: 176
            }, {
                level: 2,
                title: "OAuth 2.0 技术选型？",
                slug: "oauth-2-0-技术选型",
                normalizedTitle: "oauth 2.0 技术选型？",
                charIndex: 1577
            }, {
                level: 2,
                title: "如何实现 SSO 单点登录？",
                slug: "如何实现-sso-单点登录",
                normalizedTitle: "如何实现 sso 单点登录？",
                charIndex: 2160
            }, {
                level: 3,
                title: "实战一：基于授权码模式，实现 SSO 单点登录",
                slug: "实战一-基于授权码模式-实现-sso-单点登录",
                normalizedTitle: "实战一：基于授权码模式，实现 sso 单点登录",
                charIndex: 2179
            }, {
                level: 3,
                title: "实战二：基于密码模式，实现 SSO 登录",
                slug: "实战二-基于密码模式-实现-sso-登录",
                normalizedTitle: "实战二：基于密码模式，实现 sso 登录",
                charIndex: 3899
            }, {
                level: 2,
                title: "OAuth 2.0 表结构",
                slug: "oauth-2-0-表结构",
                normalizedTitle: "oauth 2.0 表结构",
                charIndex: 4951
            }],
            headersStr: "OAuth 2.0 是什么？ OAuth 2.0 授权模式的选择？ OAuth 2.0 技术选型？ 如何实现 SSO 单点登录？ 实战一：基于授权码模式，实现 SSO 单点登录 实战二：基于密码模式，实现 SSO 登录 OAuth 2.0 表结构",
            content: "# OAuth 2.0 是什么？\n\nOAuth 2.0 的概念讲解，可以阅读如下三篇文章：\n\n * 《理解 OAuth 2.0》\n * 《OAuth 2.0 的一个简单解释》\n * 《OAuth 2.0 的四种方式》\n\n重点是理解 授权码模式 和 密码模式，它们是最常用的两种授权模式。\n\n本文，我们也会基于它们，分别实现 SSO 单点登录。\n\n\n# OAuth 2.0 授权模式的选择？\n\n授权模式的选择，其实非常简单，总结起来就是一张图：\n\n\n\n问题一：什么场景下，使用客户端模式（Client Credentials）？\n\n如果令牌拥有者是机器的情况下，那就使用客户端模式。 例如说：\n\n * 开发了一个开放平台，提供给其它外部服务调用\n * 开发了一个 RPC 服务，提供给其它内部服务调用\n\n实际的案例，我们接入微信公众号时，会使用 appid 和 secret 参数，获取 Access token 访问令牌。\n\n问题二：什么场景下，使用密码模式（Resource Owner Password Credentials）？\n\n接入的 Client 客户端，是属于自己的情况下，可以使用密码模式。 例如说：\n\n * 客户端是你自己公司的 App 或网页，然后授权服务也是你公司的\n\n不过，如果客户端是第三方的情况下，使用密码模式的话，该客户端是可以拿到用户的账号、密码，存在安全的风险，此时可以考虑使用授权码或简化模式。\n\n问题三：什么场景下，使用授权码模式（Authorization Code）？\n\n接入的 Client 客户端，是属于第三方的情况下，可以使用授权码模式。例如说：\n\n * 客户端是你自己公司的 App 或网页，作为第三方，接入 微信、QQ、钉钉 等等进行 OAuth 2.0 登录\n\n当然，如果客户端是自己的情况下，也可以采用授权码模式。例如说：\n\n * 客户端是腾讯旗下的各种游戏，可使用微信、QQ，接入 微信、QQ 等等进行 OAuth 2.0 登录\n * 客户端是公司内的各种管理后台（ERP、OA、CRM 等），跳转到统一的 SSO 单点登录，使用授权码模式进行授权\n\n问题四：什么场景下，使用简化模式（Implicit）？\n\n简化模式，简化 的是授权码模式的流程的 第二步，差异在于：\n\n * 授权码模式：授权完成后，获得的是 code 授权码，需要 Server Side 服务端使用该授权码，再向授权服务器获取 Access Token 访问令牌\n * 简化模式：授权完成后，Client Side 客户端直接获得 Access Token 访问令牌\n\n暂时没有特别好的案例，感兴趣可以看看如下文档，也可以不看：\n\n * 《QQ OAuth 2.0 开发指定 —— 开发攻略_Client-side》\n * 《百度 OAuth —— Implicit Grant 授权》\n\n问题五：该项目中，使用了哪些授权模式？\n\n\n\n如上图所示，分成 外部授权 和 内部登录 两种方式。\n\n① 红色的“外部授权”：基于【授权码模式】，实现 SSO 单点登录，将用户授权给接入的客户端。客户端可以是内部的其它管理系统，也可以是外部的第三方。\n\n② 绿色的“内部登录”：管理后台的登录接口，还是采用传统的 /admin-api/system/auth/login 账号密码登录，并没有使用【密码模式】，主要考虑降低大家的学习成本，如果没有将用户授权给其它系统的情况下，这样做已经可以很好的满足业务的需要。当然，这里也可以将管理后台作为一个客户端，使用【密码模式】进行授权。\n\n另外，考虑到 OAuth 2.0 使用的访问令牌 + 刷新令牌可以提供更好的安全性，所以即使是传统的账号密码登录，也复用了它作为令牌的实现。\n\n\n# OAuth 2.0 技术选型？\n\n实现 OAuth 2.0 的功能，一般采用 Spring Security OAuth 或 Spring Authorization Server(SAS) 框架，前者已废弃，被后者所替代。但是使用它们，会面临三大问题：\n\n * 学习成本大：SAS 是新出的框架，入门容易精通难，引入项目中需要花费 1-2 周深入学习\n * 排查问题难：使用碰到问题时，往往需要调试到源码层面，团队只有个别人具备这种能力\n * 定制成本高：根据业务需要，想要在 SAS 上定制功能，对源码要有不错的掌控力，难度可能过大\n\n⚔ 因此，项目参考多个 OAuth 2.0 框架，自研实现 OAuth 2.0 的功能，具备学习成本小、排查问题容易、定制成本低的优点，支持多种授权模式，并内置 SSO 单点登录的功能。\n\n友情提示：具备一定规模的互联网公司，基本不会直接采用 Spring Security OAuth 或 Spring Authorization Server 框架，也是采用自研的方式，更好的满足自身的业务需求与技术拓展。\n\n🙂 另外，通过学习项目的 OAuth 2.0 实现，可以进一步加深对 OAuth 2.0 的理解，知其然、知其所以然！\n\n最终实现的整体架构，如下图所示：\n\n\n\n详细的代码实现，我们在视频中进行讲解。\n\n\n# 如何实现 SSO 单点登录？\n\n\n# 实战一：基于授权码模式，实现 SSO 单点登录\n\n示例代码见 https://gitee.com/yudaocode/yudao-demo/tree/master/yudao-sso-demo-by-code 地址，整体流程如下图所示：\n\n\n\n具体的使用流程如下：\n\n① 第一步，分别启动 ruoyi-vue-pro 项目的前端和后端。\n\n② 第二步，访问 系统管理 -> OAuth 2.0 -> 应用管理 菜单，新增一个应用（客户端），信息如下图：\n\n\n\n * 客户端编号：yudao-sso-demo-by-code\n * 客户端密钥：test\n * 应用名：基于授权码模式，如何实现 SSO 单点登录？\n * 授权类型：authorization_code、refresh_token\n * 授权范围：user.read、user.write\n * 可重定向的 URI 地址：http://127.0.0.1:18080\n\nps：如果已经有这个客户端，可以不用新增。\n\n③ 第三步，运行 SSODemoApplication 类，启动接入方的项目，它已经包含前端和后端部分。启动成功的日志如下：\n\n友情提示：如果你使用的是 Vue3 + element-plus 的前端项目，一定要操作！！！\n\n需要把 yudao-sso-demo-by-code 的 index.html 文件中的 http://127.0.0.1:1024 改成 http://127.0.0.1:8080！！！否则在后续的“授权回调”时，会跳转失败噢！！！\n\n2022-10-01 21:24:35.572  INFO 60265 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 18080 (http) with context path ''\n\n\n④ 第四步，浏览器访问 http://127.0.0.1:18080/index.html 地址，进入接入方的 index.html 首页。因为暂未登录，可以点击「跳转」按钮，跳转到 ruoyi-vue-pro 项目的 SSO 单点登录页。\n\n\n\n疑问：为什么没有跳转到 SSO 单点登录页，而是跳转到 ruoyi-vue-pro 项目的登录页？\n\n因为在 ruoyi-vue-pro 项目也未登录，所以先跳转到该项目的登录页，使用账号密码进行登录。登录完成后，会跳转回 SSO 单点登录页，继续完成 OAuth 2.0 的授权流程。\n\n⑤ 第五步，勾选 \"访问你的个人信息\" 和 \"修改你的个人信息\"，点击「同意授权」按钮，完成 code 授权码的申请。\n\n\n\n⑥ 第六步，完成授权后，会跳转到接入方的 callback.html 回调页，并在 URL 上可以看到 code 授权码。\n\n\n\n⑦ 第七步，点击「确认」按钮，接入方的前端会使用 code 授权码，向接入方的后端获取 accessToken 访问令牌。\n\n而接入方的后端，使用接收到的 code 授权码，通过调用 ruoyi-vue-pro 项目的后端，获取到 accessToken 访问令牌，并最终返回给接入方的前端。\n\n⑧ 第八步，在接入方的前端拿到 accessToken 访问令牌后，跳转回自己的 index.html 首页，并进一步从 ruoyi-vue-pro 项目获取到该用户的昵称等个人信息。后续，你可以执行「修改昵称」、「刷新令牌」、「退出登录」等操作。\n\n\n\n----------------------------------------\n\n示例代码的具体实现，与详细的解析，可以观看如下视频：\n\n * 02、基于授权码模式，如何实现 SSO 单点登录？\n * 03、请求时，如何校验 accessToken 访问令牌？\n * 04、访问令牌过期时，如何刷新 Token 令牌？\n * 05、登录成功后，如何获得用户信息？\n * 06、退出时，如何删除 Token 令牌？\n\n\n# 实战二：基于密码模式，实现 SSO 登录\n\n示例代码见 https://gitee.com/yudaocode/yudao-demo/tree/master/yudao-sso-demo-by-password 地址，整体流程如下图所示：\n\n\n\n具体的使用流程如下：\n\n① 第一步，分别启动 ruoyi-vue-pro 项目的前端和后端。\n\n② 第二步，访问 系统管理 -> OAuth 2.0 -> 应用管理 菜单，新增一个应用（客户端），信息如下图：\n\n\n\n * 客户端编号：yudao-sso-demo-by-password\n * 客户端密钥：test\n * 应用名：基于密码模式，如何实现 SSO 单点登录？\n * 授权类型：password、refresh_token\n * 授权范围：user.read、user.write\n * 可重定向的 URI 地址：http://127.0.0.1:18080\n\nps：如果已经有这个客户端，可以不用新增。\n\n③ 第三步，运行 SSODemoApplication 类，启动接入方的项目，它已经包含前端和后端部分。启动成功的日志如下：\n\n2022-10-04 21:24:35.572  INFO 60265 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 18080 (http) with context path ''\n\n\n④ 第四步，浏览器访问 http://127.0.0.1:18080/index.html 地址，进入接入方的 index.html 首页。因为暂未登录，可以点击「跳转」按钮，跳转到 login.html 登录页。\n\n\n\n\n\n⑤ 第五步，点击「登录」按钮，调用 ruoyi-vue-pro 项目的后端，获取到 accessToken 访问令牌，完成登录操作。\n\n\n\n⑥ 第六步，登录完成后，跳转回自己的 index.html 首页，并进一步从 ruoyi-vue-pro 项目获取到该用户的昵称等个人信息。后续，你可以执行「修改昵称」、「刷新令牌」、「退出登录」等操作。\n\n\n\n----------------------------------------\n\n示例代码的具体实现，与详细的解析，可以观看如下视频：\n\n * 07、基于密码模式，如何实现 SSO 单点登录？\n\n\n# OAuth 2.0 表结构\n\n\n\n每个表的具体设计，与详细的解析，可以观看如下视频：\n\n * 08、如何实现客户端的管理？\n * 09、单点登录界面，如何进行初始化？\n * 10、单点登录界面，如何进行【手动】授权？\n * 11、单点登录界面，如何进行【自动】授权？\n * 12、基于【授权码】模式，如何获得 Token 令牌？\n * 13、基于【密码】模式，如何获得 Token 令牌？\n * 14、如何校验、刷新、删除访问令牌？",
            normalizedContent: "# oauth 2.0 是什么？\n\noauth 2.0 的概念讲解，可以阅读如下三篇文章：\n\n * 《理解 oauth 2.0》\n * 《oauth 2.0 的一个简单解释》\n * 《oauth 2.0 的四种方式》\n\n重点是理解 授权码模式 和 密码模式，它们是最常用的两种授权模式。\n\n本文，我们也会基于它们，分别实现 sso 单点登录。\n\n\n# oauth 2.0 授权模式的选择？\n\n授权模式的选择，其实非常简单，总结起来就是一张图：\n\n\n\n问题一：什么场景下，使用客户端模式（client credentials）？\n\n如果令牌拥有者是机器的情况下，那就使用客户端模式。 例如说：\n\n * 开发了一个开放平台，提供给其它外部服务调用\n * 开发了一个 rpc 服务，提供给其它内部服务调用\n\n实际的案例，我们接入微信公众号时，会使用 appid 和 secret 参数，获取 access token 访问令牌。\n\n问题二：什么场景下，使用密码模式（resource owner password credentials）？\n\n接入的 client 客户端，是属于自己的情况下，可以使用密码模式。 例如说：\n\n * 客户端是你自己公司的 app 或网页，然后授权服务也是你公司的\n\n不过，如果客户端是第三方的情况下，使用密码模式的话，该客户端是可以拿到用户的账号、密码，存在安全的风险，此时可以考虑使用授权码或简化模式。\n\n问题三：什么场景下，使用授权码模式（authorization code）？\n\n接入的 client 客户端，是属于第三方的情况下，可以使用授权码模式。例如说：\n\n * 客户端是你自己公司的 app 或网页，作为第三方，接入 微信、qq、钉钉 等等进行 oauth 2.0 登录\n\n当然，如果客户端是自己的情况下，也可以采用授权码模式。例如说：\n\n * 客户端是腾讯旗下的各种游戏，可使用微信、qq，接入 微信、qq 等等进行 oauth 2.0 登录\n * 客户端是公司内的各种管理后台（erp、oa、crm 等），跳转到统一的 sso 单点登录，使用授权码模式进行授权\n\n问题四：什么场景下，使用简化模式（implicit）？\n\n简化模式，简化 的是授权码模式的流程的 第二步，差异在于：\n\n * 授权码模式：授权完成后，获得的是 code 授权码，需要 server side 服务端使用该授权码，再向授权服务器获取 access token 访问令牌\n * 简化模式：授权完成后，client side 客户端直接获得 access token 访问令牌\n\n暂时没有特别好的案例，感兴趣可以看看如下文档，也可以不看：\n\n * 《qq oauth 2.0 开发指定 —— 开发攻略_client-side》\n * 《百度 oauth —— implicit grant 授权》\n\n问题五：该项目中，使用了哪些授权模式？\n\n\n\n如上图所示，分成 外部授权 和 内部登录 两种方式。\n\n① 红色的“外部授权”：基于【授权码模式】，实现 sso 单点登录，将用户授权给接入的客户端。客户端可以是内部的其它管理系统，也可以是外部的第三方。\n\n② 绿色的“内部登录”：管理后台的登录接口，还是采用传统的 /admin-api/system/auth/login 账号密码登录，并没有使用【密码模式】，主要考虑降低大家的学习成本，如果没有将用户授权给其它系统的情况下，这样做已经可以很好的满足业务的需要。当然，这里也可以将管理后台作为一个客户端，使用【密码模式】进行授权。\n\n另外，考虑到 oauth 2.0 使用的访问令牌 + 刷新令牌可以提供更好的安全性，所以即使是传统的账号密码登录，也复用了它作为令牌的实现。\n\n\n# oauth 2.0 技术选型？\n\n实现 oauth 2.0 的功能，一般采用 spring security oauth 或 spring authorization server(sas) 框架，前者已废弃，被后者所替代。但是使用它们，会面临三大问题：\n\n * 学习成本大：sas 是新出的框架，入门容易精通难，引入项目中需要花费 1-2 周深入学习\n * 排查问题难：使用碰到问题时，往往需要调试到源码层面，团队只有个别人具备这种能力\n * 定制成本高：根据业务需要，想要在 sas 上定制功能，对源码要有不错的掌控力，难度可能过大\n\n⚔ 因此，项目参考多个 oauth 2.0 框架，自研实现 oauth 2.0 的功能，具备学习成本小、排查问题容易、定制成本低的优点，支持多种授权模式，并内置 sso 单点登录的功能。\n\n友情提示：具备一定规模的互联网公司，基本不会直接采用 spring security oauth 或 spring authorization server 框架，也是采用自研的方式，更好的满足自身的业务需求与技术拓展。\n\n🙂 另外，通过学习项目的 oauth 2.0 实现，可以进一步加深对 oauth 2.0 的理解，知其然、知其所以然！\n\n最终实现的整体架构，如下图所示：\n\n\n\n详细的代码实现，我们在视频中进行讲解。\n\n\n# 如何实现 sso 单点登录？\n\n\n# 实战一：基于授权码模式，实现 sso 单点登录\n\n示例代码见 https://gitee.com/yudaocode/yudao-demo/tree/master/yudao-sso-demo-by-code 地址，整体流程如下图所示：\n\n\n\n具体的使用流程如下：\n\n① 第一步，分别启动 ruoyi-vue-pro 项目的前端和后端。\n\n② 第二步，访问 系统管理 -> oauth 2.0 -> 应用管理 菜单，新增一个应用（客户端），信息如下图：\n\n\n\n * 客户端编号：yudao-sso-demo-by-code\n * 客户端密钥：test\n * 应用名：基于授权码模式，如何实现 sso 单点登录？\n * 授权类型：authorization_code、refresh_token\n * 授权范围：user.read、user.write\n * 可重定向的 uri 地址：http://127.0.0.1:18080\n\nps：如果已经有这个客户端，可以不用新增。\n\n③ 第三步，运行 ssodemoapplication 类，启动接入方的项目，它已经包含前端和后端部分。启动成功的日志如下：\n\n友情提示：如果你使用的是 vue3 + element-plus 的前端项目，一定要操作！！！\n\n需要把 yudao-sso-demo-by-code 的 index.html 文件中的 http://127.0.0.1:1024 改成 http://127.0.0.1:8080！！！否则在后续的“授权回调”时，会跳转失败噢！！！\n\n2022-10-01 21:24:35.572  info 60265 --- [           main] o.s.b.w.embedded.tomcat.tomcatwebserver  : tomcat started on port(s): 18080 (http) with context path ''\n\n\n④ 第四步，浏览器访问 http://127.0.0.1:18080/index.html 地址，进入接入方的 index.html 首页。因为暂未登录，可以点击「跳转」按钮，跳转到 ruoyi-vue-pro 项目的 sso 单点登录页。\n\n\n\n疑问：为什么没有跳转到 sso 单点登录页，而是跳转到 ruoyi-vue-pro 项目的登录页？\n\n因为在 ruoyi-vue-pro 项目也未登录，所以先跳转到该项目的登录页，使用账号密码进行登录。登录完成后，会跳转回 sso 单点登录页，继续完成 oauth 2.0 的授权流程。\n\n⑤ 第五步，勾选 \"访问你的个人信息\" 和 \"修改你的个人信息\"，点击「同意授权」按钮，完成 code 授权码的申请。\n\n\n\n⑥ 第六步，完成授权后，会跳转到接入方的 callback.html 回调页，并在 url 上可以看到 code 授权码。\n\n\n\n⑦ 第七步，点击「确认」按钮，接入方的前端会使用 code 授权码，向接入方的后端获取 accesstoken 访问令牌。\n\n而接入方的后端，使用接收到的 code 授权码，通过调用 ruoyi-vue-pro 项目的后端，获取到 accesstoken 访问令牌，并最终返回给接入方的前端。\n\n⑧ 第八步，在接入方的前端拿到 accesstoken 访问令牌后，跳转回自己的 index.html 首页，并进一步从 ruoyi-vue-pro 项目获取到该用户的昵称等个人信息。后续，你可以执行「修改昵称」、「刷新令牌」、「退出登录」等操作。\n\n\n\n----------------------------------------\n\n示例代码的具体实现，与详细的解析，可以观看如下视频：\n\n * 02、基于授权码模式，如何实现 sso 单点登录？\n * 03、请求时，如何校验 accesstoken 访问令牌？\n * 04、访问令牌过期时，如何刷新 token 令牌？\n * 05、登录成功后，如何获得用户信息？\n * 06、退出时，如何删除 token 令牌？\n\n\n# 实战二：基于密码模式，实现 sso 登录\n\n示例代码见 https://gitee.com/yudaocode/yudao-demo/tree/master/yudao-sso-demo-by-password 地址，整体流程如下图所示：\n\n\n\n具体的使用流程如下：\n\n① 第一步，分别启动 ruoyi-vue-pro 项目的前端和后端。\n\n② 第二步，访问 系统管理 -> oauth 2.0 -> 应用管理 菜单，新增一个应用（客户端），信息如下图：\n\n\n\n * 客户端编号：yudao-sso-demo-by-password\n * 客户端密钥：test\n * 应用名：基于密码模式，如何实现 sso 单点登录？\n * 授权类型：password、refresh_token\n * 授权范围：user.read、user.write\n * 可重定向的 uri 地址：http://127.0.0.1:18080\n\nps：如果已经有这个客户端，可以不用新增。\n\n③ 第三步，运行 ssodemoapplication 类，启动接入方的项目，它已经包含前端和后端部分。启动成功的日志如下：\n\n2022-10-04 21:24:35.572  info 60265 --- [           main] o.s.b.w.embedded.tomcat.tomcatwebserver  : tomcat started on port(s): 18080 (http) with context path ''\n\n\n④ 第四步，浏览器访问 http://127.0.0.1:18080/index.html 地址，进入接入方的 index.html 首页。因为暂未登录，可以点击「跳转」按钮，跳转到 login.html 登录页。\n\n\n\n\n\n⑤ 第五步，点击「登录」按钮，调用 ruoyi-vue-pro 项目的后端，获取到 accesstoken 访问令牌，完成登录操作。\n\n\n\n⑥ 第六步，登录完成后，跳转回自己的 index.html 首页，并进一步从 ruoyi-vue-pro 项目获取到该用户的昵称等个人信息。后续，你可以执行「修改昵称」、「刷新令牌」、「退出登录」等操作。\n\n\n\n----------------------------------------\n\n示例代码的具体实现，与详细的解析，可以观看如下视频：\n\n * 07、基于密码模式，如何实现 sso 单点登录？\n\n\n# oauth 2.0 表结构\n\n\n\n每个表的具体设计，与详细的解析，可以观看如下视频：\n\n * 08、如何实现客户端的管理？\n * 09、单点登录界面，如何进行初始化？\n * 10、单点登录界面，如何进行【手动】授权？\n * 11、单点登录界面，如何进行【自动】授权？\n * 12、基于【授权码】模式，如何获得 token 令牌？\n * 13、基于【密码】模式，如何获得 token 令牌？\n * 14、如何校验、刷新、删除访问令牌？",
            charsets: {
                cjk: !0
            }
        }, {
            title: "WebSocket 实时通信",
            frontmatter: {
                title: "WebSocket 实时通信",
                date: "2023-11-23T19:55:04.000Z",
                permalink: "/websocket/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/02.%E5%90%8E%E7%AB%AF%E6%89%8B%E5%86%8C/14.WebSocket.html",
            relativePath: "01.开发指南/02.后端手册/14.WebSocket.md",
            key: "v-72c78798",
            path: "/websocket/",
            headers: [{
                level: 2,
                title: "1. 功能简介",
                slug: "_1-功能简介",
                normalizedTitle: "1. 功能简介",
                charIndex: 2
            }, {
                level: 3,
                title: "1.1 Token 身份认证",
                slug: "_1-1-token-身份认证",
                normalizedTitle: "1.1 token 身份认证",
                charIndex: 244
            }, {
                level: 3,
                title: "1.2 Session 会话管理",
                slug: "_1-2-session-会话管理",
                normalizedTitle: "1.2 session 会话管理",
                charIndex: 984
            }, {
                level: 3,
                title: "1.3 Message 消息格式",
                slug: "_1-3-message-消息格式",
                normalizedTitle: "1.3 message 消息格式",
                charIndex: 1641
            }, {
                level: 3,
                title: "1.4 Message 消息接收",
                slug: "_1-4-message-消息接收",
                normalizedTitle: "1.4 message 消息接收",
                charIndex: 2103
            }, {
                level: 3,
                title: "1.5 Message 消息推送",
                slug: "_1-5-message-消息推送",
                normalizedTitle: "1.5 message 消息推送",
                charIndex: 2391
            }, {
                level: 2,
                title: "2. 使用方案",
                slug: "_2-使用方案",
                normalizedTitle: "2. 使用方案",
                charIndex: 4927
            }, {
                level: 3,
                title: "2.1 方案一：纯 WebSocket",
                slug: "_2-1-方案一-纯-websocket",
                normalizedTitle: "2.1 方案一：纯 websocket",
                charIndex: 5246
            }, {
                level: 3,
                title: "2.2 方案二：WebSocket + HTTP",
                slug: "_2-2-方案二-websocket-http",
                normalizedTitle: "2.2 方案二：websocket + http",
                charIndex: 5899
            }, {
                level: 3,
                title: "2.3 如何选择？",
                slug: "_2-3-如何选择",
                normalizedTitle: "2.3 如何选择？",
                charIndex: 7108
            }, {
                level: 2,
                title: "3. 实战案例",
                slug: "_3-实战案例",
                normalizedTitle: "3. 实战案例",
                charIndex: 7749
            }],
            headersStr: "1. 功能简介 1.1 Token 身份认证 1.2 Session 会话管理 1.3 Message 消息格式 1.4 Message 消息接收 1.5 Message 消息推送 2. 使用方案 2.1 方案一：纯 WebSocket 2.2 方案二：WebSocket + HTTP 2.3 如何选择？ 3. 实战案例",
            content: "# 1. 功能简介\n\n项目的 yudao-spring-boot-starter-websocket 组件，基于 Spring WebSocket 进行二次封装，实现了更加简单的使用方式。例如说，WebSocket 的认证、Session 的管理、WebSocket 集群的消息广播等等。\n\n疑问：为什么不使用 Netty 实现 WebSocket？\n\nNetty 的学习和使用门槛较高，对大家可能不够友好，而 Spring WebSocket 足够满足 99.99% 的场景。\n\n\n# 1.1 Token 身份认证\n\n① 在 WebSocket 连接建立时，通过 QueryString 的 token 参数，进行认证。例如说：ws://127.0.0.1:48080/ws?token=xxx。\n\n由于 WebSocket 是基于 HTTP 建立连接，所以它的认证可以复用项目的 TokenAuthenticationFilter 实现。\n\n为什么 token 不使用 Header 传递？\n\nWebSocket 不支持 Header 传递，所以只能使用 QueryString 传递。\n\n② 认证完成后，会通过 LoginUserHandshakeInterceptor 拦截器，将用户信息存储到 WebSocket Session 的 attributes 中。\n\n这样，后续可以使用 WebSocketFrameworkUtils 获取用户信息，例如说：\n\n// WebSocketFrameworkUtils.java\n\n// ① 获取当前用户\npublic static LoginUser getLoginUser(WebSocketSession session)\n\n// ② 获得当前用户的类型\npublic static Integer getLoginUserType(WebSocketSession session)\n\n// ③ 获得当前用户的编号\npublic static Integer getLoginUserType(WebSocketSession session)\n\n// ④ 获得当前用户的租户编号\npublic static Long getTenantId(WebSocketSession session)\n\n\n\n# 1.2 Session 会话管理\n\n每个前端和后端建立的 WebSocket 连接，对应后端的一个 WebSocketSession 会话对象。由于后续需要对 WebSocketSession 进行消息的发送，所以需要进行管理。\n\n① WebSocketSession 的管理，由 WebSocketSessionManager 定义接口，由 WebSocketSessionManagerImpl 具体实现。\n\n// 添加和移除 Session\nvoid addSession(WebSocketSession session);\nvoid removeSession(WebSocketSession session);\n\n// 获得 Session，多种维度\nWebSocketSession getSession(String id); // Session 编号\nCollection<WebSocketSession> getSessionList(Integer userType); // 用户类型\nCollection<WebSocketSession> getSessionList(Integer userType, Long userId); // 用户编号\n\n\n② WebSocket 建立和关闭连接时，通过 WebSocketSessionHandlerDecorator 处理器，分别调用 WebSocketSessionManager 进行 Session 的添加和移除。\n\n\n# 1.3 Message 消息格式\n\nWebSocket 默认使用“文本”进行通信，而业务需要按照不同类型的消息，进行不同的处理。因此，项目定义了 JsonWebSocketMessage 消息对象，包含 type 消息类型 + content 消息内容。\n\n和 Spring MVC 对比，可以理解为：\n\n               标识               方法                             参数\nSpring MVC     URL + Method 等   Controller 的 Method 方法         QueryString 或 RequestBody 等\n项目 WebSocket   type 消息类型        WebSocketMessageListener 实现类   解析 content 消息内容后的 Message 对象\n\n具体 JsonWebSocketMessage 和 WebSocketMessageListener 详细说明，参见「1.4 Message 消息接收」小节。\n\n\n# 1.4 Message 消息接收\n\n① WebSocket 接收到项目后，会先交给 JsonWebSocketMessageHandler 消息处理器，将消息解析成 JsonWebSocketMessage 对象。\n\n之后，根据 type 消息类型，获得到 WebSocketMessageListener 实现类，并将 content 消息内容进一步解析成 Message 对象，交给它进行处理。\n\n② 具体案例，可见 DemoWebSocketMessageListener、DemoSendMessage 类。\n\n\n# 1.5 Message 消息推送\n\n① 项目的 WebSocketMessageSender 接口，定义了给 Session 发送消息的方法。如下所示：\n\n// WebSocketMessageSender.java\n\n// ① 发送消息给指定用户\nvoid send(Integer userType, Long userId, String messageType, String messageContent);\ndefault void sendObject(Integer userType, Long userId, String messageType, Object messageContent) {\n    send(userType, userId, messageType, JsonUtils.toJsonString(messageContent));\n}\n\n// ② 发送消息给指定用户类型\nvoid send(Integer userType, String messageType, String messageContent);\ndefault void sendObject(Integer userType, String messageType, Object messageContent) {\n    send(userType, messageType, JsonUtils.toJsonString(messageContent));\n}\n\n// ③ 发送消息给指定 Session\nvoid send(String sessionId, String messageType, String messageContent);\ndefault void sendObject(String sessionId, String messageType, Object messageContent) {\n    send(sessionId, messageType, JsonUtils.toJsonString(messageContent));\n}\n\n\n② WebSocketMessageSender 有多种实现类，如下：\n\n实现类                              是否支持 WEBSOCKET 集群   前置要求\nLocalWebSocketMessageSender      ❌                   无\nRedisWebSocketMessageSender      ✅                   开启 《消息队列（Redis）》\nRocketMQWebSocketMessageSender   ✅                   开启 《消息队列（RocketMQ）》\nKafkaWebSocketMessageSender      ✅                   开启 《消息队列（Kafka）》\nRabbitMQWebSocketMessageSender   ✅                   开启 《消息队列（RabbitMQ）》\n\n疑问：什么是 WebSocket 集群？\n\n在后端部署多个 Java 进程时，会形成 WebSocket 集群。此时，就会存在跨进程的消息推送问题。例如说，连接 A 进程的 WebSocket 的用户，想要发送消息给连接 B 进程的 WebSocket 用户。\n\n😁 如何解决呢？消息不直接发送给用户 WebSocketSession，而是先发给 Redis、RocketMQ 等消息队列，再由每个 Java 进程监听该消息，分别判断判断该用户 WebSocket 是否连接的是自己，如果是，则进行消息推送。\n\n默认配置下，使用 LocalWebSocketMessageSender 本地发送消息，不支持 WebSocket 集群。可通过修改 application.yaml 配置文件的 yudao.websocket.sender-type 来切换，如下：\n\nyudao:\n  websocket:\n    enable: true # websocket的开关\n    path: /infra/ws # 路径\n    sender-type: redis # 消息发送的类型，可选值为 local、redis、rocketmq、kafka、rabbitmq\n    sender-rocketmq:\n      topic: ${spring.application.name}-websocket # 消息发送的 RocketMQ Topic\n      consumer-group: ${spring.application.name}-websocket-consumer # 消息发送的 RocketMQ Consumer Group\n    sender-rabbitmq:\n      exchange: ${spring.application.name}-websocket-exchange # 消息发送的 RabbitMQ Exchange\n      queue: ${spring.application.name}-websocket-queue # 消息发送的 RabbitMQ Queue\n    sender-kafka:\n      topic: ${spring.application.name}-websocket # 消息发送的 Kafka Topic\n      consumer-group: ${spring.application.name}-websocket-consumer # 消息发送的 Kafka Consumer Group\n\n\n另外，默认的 WebSocket 连接地址是 ws://127.0.0.1:48080/infra/ws，可通过 yudao.websocket.path 配置项进行修改。\n\n\n# 2. 使用方案\n\n目前有 2 种使用方案，分别是：\n\n方案名                    上行          下行\n方案一：纯 WebSocket        WebSocket   WebSocket\n方案二：WebSocket + HTTP   HTTP        WebSocket\n\n疑问：什么是上行？什么是下行？\n\n * 上行：指的是“前端”发送消息给“后端”，WebSocket 和 HTTP 都可以。\n * 下行：指的是“后端”发送消息给“前端”，只能使用 WebSocket。\n\n友情提示：下文中提到的所有配置，项目都已经配置好。你只需要按照下文的步骤，进行调试即可，了解每个配置的作用即可。\n\n\n# 2.1 方案一：纯 WebSocket\n\n\n\n * 前端：见 [基础设施 -> WebSocket 测试] 菜单，对应 /views/infra/websocket/index.vue 界面\n * 后端：见 yudao-module-infra-biz 模块，对应 DemoWebSocketMessageListener 监听器\n\n基于 WebSocket 实现的单聊和群聊，暂时不支持消息的持久化（刷新后，消息会消息）。建议，多多调试，更好的理解 WebSocket 流程。\n\n# 2.1.1 后端代码\n\n① 在 yudao-module-infra-biz 模块的 pom.xml 文件中，引入 yudao-spring-boot-starter-websocket 依赖。如下所示：\n\n    <dependency>\n        <groupId>cn.iocoder.boot</groupId>\n        <artifactId>yudao-spring-boot-starter-websocket</artifactId>\n    </dependency>\n\n\n② 新建 DemoWebSocketMessageListener 类，实现对应消息的处理。如下图所示：\n\n\n\n# 2.1.2 前端代码\n\n① 建立 WebSocket 连接，如下图所示：\n\n\n\n② 发送 WebSocket 消息，如下图所示：\n\n\n\n③ 接收 WebSocket 消息。如下图所示：\n\n\n\n\n# 2.2 方案二：WebSocket + HTTP\n\n\n\n * 前端：见 [系统管理 -> 消息中心 -> 通知公告] 菜单，对应 /views/system/notice/index.vue 界面的【推送】按钮\n * 后端：见 yudao-module-system-biz 模块，对应 DemoWebSocketMessageListener 监听器\n\n点击某条公告的【推送】按钮，仅仅推送给所有在线用户。由于 WebSocket 目前暂时没全局建立，所以还是使用 [基础设施 -> WebSocket 测试] 菜单演示。如下图所示：\n\n\n\n# 2.2.1 后端代码\n\n【相同】① 在 yudao-module-infra-biz 模块的 pom.xml 文件中，引入 yudao-spring-boot-starter-websocket 依赖。\n\n【不同】② 在 yudao-module-system-biz 模块的 pom.xml 文件中，引入 yudao-module-infra-api 依赖。如下所示：\n\n    <dependency>\n        <groupId>cn.iocoder.boot</groupId>\n        <artifactId>yudao-module-infra-api</artifactId>\n        <version>${revision}</version>\n    </dependency>\n\n\n【不同】③ 在 yudao-module-system-biz 模块，在 NoticeController 类中，新建 #push(...) 方法，用于推送公告消息。如下图所示：\n\n\n\n本质上，它替代了方案一的 DemoWebSocketMessageListener 类，走 HTTP 上行消息，替代 WebSocket 上行消息。\n\n疑问：WebSocketSenderApi 是什么？\n\n它是由 yudao-module-infra-biz 对 WebSocketMessageSender 的封装，因为只有它（yudao-module-infra-biz）可以访问到 WebSocketMessageSender 的实现类，所以需要通过 API 的方式，暴露给其它模块使用。\n\n这也是为什么 yudao-module-system-biz 模块，需要引入 yudao-module-infra-api 依赖的原因。\n\n# 2.2.2 前端代码\n\n【相同】① 建立 WebSocket 连接，和方案一相同，不重复截图。\n\n【不同】② 发送 HTTP 消息，如下图所示：\n\n\n\n本质上，它替代了方案一的 WebSocket 上行消息，走 HTTP 上行消息。\n\n【相同】③ 接收 WebSocket 消息，和方案一相同，不重复截图。\n\n\n# 2.3 如何选择？\n\n我个人是倾向于方案二的，使用 HTTP 上行消息，使用 WebSocket 下行消息。原因如下：\n\n① yudao-module-infra-biz 扮演一个 WebSocket 服务的角色，可以通过它来主动发送（下行）消息给前端。这样，未来如果使用 MQTT 中间件（例如说，EMQX、阿里云 MQTT、腾讯云 MQTT 等）替换现有 WebSocket 也比较方便。\n\n② HTTP 上行消息，相比 WebSocket 上行消息来说，更加方便，也比较符合我们的编码习惯。\n\n③ 在微服务架构下，多个服务是拆分开的，无法提供相同的 WebSocket 连接。例如说，yudao-module-infra-biz 和 yudao-module-system-biz 两个服务都需要有 WebSocket 推送能力时，需要前端分别连接它们两个服务。\n\n考虑到 ruoyi-vue-pro 和 yudao-cloud 架构的统一性，还是只让 yudao-module-infra-biz 提供 WebSocket 服务：\n\n * 前端连接 yudao-module-infra-biz 的 WebSocket 服务，其它服务通过 yudao-module-infra-biz 下行消息。\n * 前端 HTTP 上行消息时，还是通过 HTTP 调用各个服务。\n\nps：如果你只用 ruoyi-vue-pro 单体架构，不会存在 ③ 的困扰，方案一也没问题。\n\n\n# 3. 实战案例\n\n① 《商城 —— 在线客服》\n\none more thing~ 后续我们会使用 WebSocket 实现 IM 即时通信功能，敬请期待。",
            normalizedContent: "# 1. 功能简介\n\n项目的 yudao-spring-boot-starter-websocket 组件，基于 spring websocket 进行二次封装，实现了更加简单的使用方式。例如说，websocket 的认证、session 的管理、websocket 集群的消息广播等等。\n\n疑问：为什么不使用 netty 实现 websocket？\n\nnetty 的学习和使用门槛较高，对大家可能不够友好，而 spring websocket 足够满足 99.99% 的场景。\n\n\n# 1.1 token 身份认证\n\n① 在 websocket 连接建立时，通过 querystring 的 token 参数，进行认证。例如说：ws://127.0.0.1:48080/ws?token=xxx。\n\n由于 websocket 是基于 http 建立连接，所以它的认证可以复用项目的 tokenauthenticationfilter 实现。\n\n为什么 token 不使用 header 传递？\n\nwebsocket 不支持 header 传递，所以只能使用 querystring 传递。\n\n② 认证完成后，会通过 loginuserhandshakeinterceptor 拦截器，将用户信息存储到 websocket session 的 attributes 中。\n\n这样，后续可以使用 websocketframeworkutils 获取用户信息，例如说：\n\n// websocketframeworkutils.java\n\n// ① 获取当前用户\npublic static loginuser getloginuser(websocketsession session)\n\n// ② 获得当前用户的类型\npublic static integer getloginusertype(websocketsession session)\n\n// ③ 获得当前用户的编号\npublic static integer getloginusertype(websocketsession session)\n\n// ④ 获得当前用户的租户编号\npublic static long gettenantid(websocketsession session)\n\n\n\n# 1.2 session 会话管理\n\n每个前端和后端建立的 websocket 连接，对应后端的一个 websocketsession 会话对象。由于后续需要对 websocketsession 进行消息的发送，所以需要进行管理。\n\n① websocketsession 的管理，由 websocketsessionmanager 定义接口，由 websocketsessionmanagerimpl 具体实现。\n\n// 添加和移除 session\nvoid addsession(websocketsession session);\nvoid removesession(websocketsession session);\n\n// 获得 session，多种维度\nwebsocketsession getsession(string id); // session 编号\ncollection<websocketsession> getsessionlist(integer usertype); // 用户类型\ncollection<websocketsession> getsessionlist(integer usertype, long userid); // 用户编号\n\n\n② websocket 建立和关闭连接时，通过 websocketsessionhandlerdecorator 处理器，分别调用 websocketsessionmanager 进行 session 的添加和移除。\n\n\n# 1.3 message 消息格式\n\nwebsocket 默认使用“文本”进行通信，而业务需要按照不同类型的消息，进行不同的处理。因此，项目定义了 jsonwebsocketmessage 消息对象，包含 type 消息类型 + content 消息内容。\n\n和 spring mvc 对比，可以理解为：\n\n               标识               方法                             参数\nspring mvc     url + method 等   controller 的 method 方法         querystring 或 requestbody 等\n项目 websocket   type 消息类型        websocketmessagelistener 实现类   解析 content 消息内容后的 message 对象\n\n具体 jsonwebsocketmessage 和 websocketmessagelistener 详细说明，参见「1.4 message 消息接收」小节。\n\n\n# 1.4 message 消息接收\n\n① websocket 接收到项目后，会先交给 jsonwebsocketmessagehandler 消息处理器，将消息解析成 jsonwebsocketmessage 对象。\n\n之后，根据 type 消息类型，获得到 websocketmessagelistener 实现类，并将 content 消息内容进一步解析成 message 对象，交给它进行处理。\n\n② 具体案例，可见 demowebsocketmessagelistener、demosendmessage 类。\n\n\n# 1.5 message 消息推送\n\n① 项目的 websocketmessagesender 接口，定义了给 session 发送消息的方法。如下所示：\n\n// websocketmessagesender.java\n\n// ① 发送消息给指定用户\nvoid send(integer usertype, long userid, string messagetype, string messagecontent);\ndefault void sendobject(integer usertype, long userid, string messagetype, object messagecontent) {\n    send(usertype, userid, messagetype, jsonutils.tojsonstring(messagecontent));\n}\n\n// ② 发送消息给指定用户类型\nvoid send(integer usertype, string messagetype, string messagecontent);\ndefault void sendobject(integer usertype, string messagetype, object messagecontent) {\n    send(usertype, messagetype, jsonutils.tojsonstring(messagecontent));\n}\n\n// ③ 发送消息给指定 session\nvoid send(string sessionid, string messagetype, string messagecontent);\ndefault void sendobject(string sessionid, string messagetype, object messagecontent) {\n    send(sessionid, messagetype, jsonutils.tojsonstring(messagecontent));\n}\n\n\n② websocketmessagesender 有多种实现类，如下：\n\n实现类                              是否支持 websocket 集群   前置要求\nlocalwebsocketmessagesender      ❌                   无\nrediswebsocketmessagesender      ✅                   开启 《消息队列（redis）》\nrocketmqwebsocketmessagesender   ✅                   开启 《消息队列（rocketmq）》\nkafkawebsocketmessagesender      ✅                   开启 《消息队列（kafka）》\nrabbitmqwebsocketmessagesender   ✅                   开启 《消息队列（rabbitmq）》\n\n疑问：什么是 websocket 集群？\n\n在后端部署多个 java 进程时，会形成 websocket 集群。此时，就会存在跨进程的消息推送问题。例如说，连接 a 进程的 websocket 的用户，想要发送消息给连接 b 进程的 websocket 用户。\n\n😁 如何解决呢？消息不直接发送给用户 websocketsession，而是先发给 redis、rocketmq 等消息队列，再由每个 java 进程监听该消息，分别判断判断该用户 websocket 是否连接的是自己，如果是，则进行消息推送。\n\n默认配置下，使用 localwebsocketmessagesender 本地发送消息，不支持 websocket 集群。可通过修改 application.yaml 配置文件的 yudao.websocket.sender-type 来切换，如下：\n\nyudao:\n  websocket:\n    enable: true # websocket的开关\n    path: /infra/ws # 路径\n    sender-type: redis # 消息发送的类型，可选值为 local、redis、rocketmq、kafka、rabbitmq\n    sender-rocketmq:\n      topic: ${spring.application.name}-websocket # 消息发送的 rocketmq topic\n      consumer-group: ${spring.application.name}-websocket-consumer # 消息发送的 rocketmq consumer group\n    sender-rabbitmq:\n      exchange: ${spring.application.name}-websocket-exchange # 消息发送的 rabbitmq exchange\n      queue: ${spring.application.name}-websocket-queue # 消息发送的 rabbitmq queue\n    sender-kafka:\n      topic: ${spring.application.name}-websocket # 消息发送的 kafka topic\n      consumer-group: ${spring.application.name}-websocket-consumer # 消息发送的 kafka consumer group\n\n\n另外，默认的 websocket 连接地址是 ws://127.0.0.1:48080/infra/ws，可通过 yudao.websocket.path 配置项进行修改。\n\n\n# 2. 使用方案\n\n目前有 2 种使用方案，分别是：\n\n方案名                    上行          下行\n方案一：纯 websocket        websocket   websocket\n方案二：websocket + http   http        websocket\n\n疑问：什么是上行？什么是下行？\n\n * 上行：指的是“前端”发送消息给“后端”，websocket 和 http 都可以。\n * 下行：指的是“后端”发送消息给“前端”，只能使用 websocket。\n\n友情提示：下文中提到的所有配置，项目都已经配置好。你只需要按照下文的步骤，进行调试即可，了解每个配置的作用即可。\n\n\n# 2.1 方案一：纯 websocket\n\n\n\n * 前端：见 [基础设施 -> websocket 测试] 菜单，对应 /views/infra/websocket/index.vue 界面\n * 后端：见 yudao-module-infra-biz 模块，对应 demowebsocketmessagelistener 监听器\n\n基于 websocket 实现的单聊和群聊，暂时不支持消息的持久化（刷新后，消息会消息）。建议，多多调试，更好的理解 websocket 流程。\n\n# 2.1.1 后端代码\n\n① 在 yudao-module-infra-biz 模块的 pom.xml 文件中，引入 yudao-spring-boot-starter-websocket 依赖。如下所示：\n\n    <dependency>\n        <groupid>cn.iocoder.boot</groupid>\n        <artifactid>yudao-spring-boot-starter-websocket</artifactid>\n    </dependency>\n\n\n② 新建 demowebsocketmessagelistener 类，实现对应消息的处理。如下图所示：\n\n\n\n# 2.1.2 前端代码\n\n① 建立 websocket 连接，如下图所示：\n\n\n\n② 发送 websocket 消息，如下图所示：\n\n\n\n③ 接收 websocket 消息。如下图所示：\n\n\n\n\n# 2.2 方案二：websocket + http\n\n\n\n * 前端：见 [系统管理 -> 消息中心 -> 通知公告] 菜单，对应 /views/system/notice/index.vue 界面的【推送】按钮\n * 后端：见 yudao-module-system-biz 模块，对应 demowebsocketmessagelistener 监听器\n\n点击某条公告的【推送】按钮，仅仅推送给所有在线用户。由于 websocket 目前暂时没全局建立，所以还是使用 [基础设施 -> websocket 测试] 菜单演示。如下图所示：\n\n\n\n# 2.2.1 后端代码\n\n【相同】① 在 yudao-module-infra-biz 模块的 pom.xml 文件中，引入 yudao-spring-boot-starter-websocket 依赖。\n\n【不同】② 在 yudao-module-system-biz 模块的 pom.xml 文件中，引入 yudao-module-infra-api 依赖。如下所示：\n\n    <dependency>\n        <groupid>cn.iocoder.boot</groupid>\n        <artifactid>yudao-module-infra-api</artifactid>\n        <version>${revision}</version>\n    </dependency>\n\n\n【不同】③ 在 yudao-module-system-biz 模块，在 noticecontroller 类中，新建 #push(...) 方法，用于推送公告消息。如下图所示：\n\n\n\n本质上，它替代了方案一的 demowebsocketmessagelistener 类，走 http 上行消息，替代 websocket 上行消息。\n\n疑问：websocketsenderapi 是什么？\n\n它是由 yudao-module-infra-biz 对 websocketmessagesender 的封装，因为只有它（yudao-module-infra-biz）可以访问到 websocketmessagesender 的实现类，所以需要通过 api 的方式，暴露给其它模块使用。\n\n这也是为什么 yudao-module-system-biz 模块，需要引入 yudao-module-infra-api 依赖的原因。\n\n# 2.2.2 前端代码\n\n【相同】① 建立 websocket 连接，和方案一相同，不重复截图。\n\n【不同】② 发送 http 消息，如下图所示：\n\n\n\n本质上，它替代了方案一的 websocket 上行消息，走 http 上行消息。\n\n【相同】③ 接收 websocket 消息，和方案一相同，不重复截图。\n\n\n# 2.3 如何选择？\n\n我个人是倾向于方案二的，使用 http 上行消息，使用 websocket 下行消息。原因如下：\n\n① yudao-module-infra-biz 扮演一个 websocket 服务的角色，可以通过它来主动发送（下行）消息给前端。这样，未来如果使用 mqtt 中间件（例如说，emqx、阿里云 mqtt、腾讯云 mqtt 等）替换现有 websocket 也比较方便。\n\n② http 上行消息，相比 websocket 上行消息来说，更加方便，也比较符合我们的编码习惯。\n\n③ 在微服务架构下，多个服务是拆分开的，无法提供相同的 websocket 连接。例如说，yudao-module-infra-biz 和 yudao-module-system-biz 两个服务都需要有 websocket 推送能力时，需要前端分别连接它们两个服务。\n\n考虑到 ruoyi-vue-pro 和 yudao-cloud 架构的统一性，还是只让 yudao-module-infra-biz 提供 websocket 服务：\n\n * 前端连接 yudao-module-infra-biz 的 websocket 服务，其它服务通过 yudao-module-infra-biz 下行消息。\n * 前端 http 上行消息时，还是通过 http 调用各个服务。\n\nps：如果你只用 ruoyi-vue-pro 单体架构，不会存在 ③ 的困扰，方案一也没问题。\n\n\n# 3. 实战案例\n\n① 《商城 —— 在线客服》\n\none more thing~ 后续我们会使用 websocket 实现 im 即时通信功能，敬请期待。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "SaaS 多租户【字段隔离】",
            frontmatter: {
                title: "SaaS 多租户【字段隔离】",
                date: "2022-03-07T12:38:53.000Z",
                permalink: "/saas-tenant"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/02.%E5%90%8E%E7%AB%AF%E6%89%8B%E5%86%8C/12.SaaS%20%E5%A4%9A%E7%A7%9F%E6%88%B7%EF%BC%88%E5%AD%97%E6%AE%B5%E9%9A%94%E7%A6%BB%EF%BC%89.html",
            relativePath: "01.开发指南/02.后端手册/12.SaaS 多租户（字段隔离）.md",
            key: "v-a715ae90",
            path: "/saas-tenant/",
            headers: [{
                level: 2,
                title: "1. 多租户是什么？",
                slug: "_1-多租户是什么",
                normalizedTitle: "1. 多租户是什么？",
                charIndex: 245
            }, {
                level: 2,
                title: "2. 数据隔离方案",
                slug: "_2-数据隔离方案",
                normalizedTitle: "2. 数据隔离方案",
                charIndex: 412
            }, {
                level: 3,
                title: "2.1 DATASOURCE 模式",
                slug: "_2-1-datasource-模式",
                normalizedTitle: "2.1 datasource 模式",
                charIndex: 539
            }, {
                level: 3,
                title: "2.2 SCHEMA 模式",
                slug: "_2-2-schema-模式",
                normalizedTitle: "2.2 schema 模式",
                charIndex: 705
            }, {
                level: 3,
                title: "2.3 COLUMN 模式",
                slug: "_2-3-column-模式",
                normalizedTitle: "2.3 column 模式",
                charIndex: 870
            }, {
                level: 3,
                title: "2.4 方案选择",
                slug: "_2-4-方案选择",
                normalizedTitle: "2.4 方案选择",
                charIndex: 1063
            }, {
                level: 2,
                title: "3. 多租户的开关",
                slug: "_3-多租户的开关",
                normalizedTitle: "3. 多租户的开关",
                charIndex: 1442
            }, {
                level: 2,
                title: "4. 多租户的业务功能",
                slug: "_4-多租户的业务功能",
                normalizedTitle: "4. 多租户的业务功能",
                charIndex: 1677
            }, {
                level: 2,
                title: "5. 多租户的技术组件",
                slug: "_5-多租户的技术组件",
                normalizedTitle: "5. 多租户的技术组件",
                charIndex: 1995
            }, {
                level: 3,
                title: "5.1 租户上下文",
                slug: "_5-1-租户上下文",
                normalizedTitle: "5.1 租户上下文",
                charIndex: 2119
            }, {
                level: 3,
                title: "5.2 Web 层【重要】",
                slug: "_5-2-web-层【重要】",
                normalizedTitle: "5.2 web 层【重要】",
                charIndex: 2264
            }, {
                level: 3,
                title: "5.3 Security 层",
                slug: "_5-3-security-层",
                normalizedTitle: "5.3 security 层",
                charIndex: 2463
            }, {
                level: 3,
                title: "5.4 DB 层【重要】",
                slug: "_5-4-db-层【重要】",
                normalizedTitle: "5.4 db 层【重要】",
                charIndex: 2535
            }, {
                level: 3,
                title: "5.5 Redis 层【重要】",
                slug: "_5-5-redis-层【重要】",
                normalizedTitle: "5.5 redis 层【重要】",
                charIndex: 3659
            }, {
                level: 3,
                title: "5.6 AOP【重要】",
                slug: "_5-6-aop【重要】",
                normalizedTitle: "5.6 aop【重要】",
                charIndex: 4473
            }, {
                level: 3,
                title: "5.7 Job【重要】",
                slug: "_5-7-job【重要】",
                normalizedTitle: "5.7 job【重要】",
                charIndex: 5467
            }, {
                level: 3,
                title: "5.8 MQ",
                slug: "_5-8-mq",
                normalizedTitle: "5.8 mq",
                charIndex: 5547
            }, {
                level: 3,
                title: "5.9 Async",
                slug: "_5-9-async",
                normalizedTitle: "5.9 async",
                charIndex: 5736
            }, {
                level: 2,
                title: "6. 租户独立域名",
                slug: "_6-租户独立域名",
                normalizedTitle: "6. 租户独立域名",
                charIndex: 5873
            }],
            headersStr: "1. 多租户是什么？ 2. 数据隔离方案 2.1 DATASOURCE 模式 2.2 SCHEMA 模式 2.3 COLUMN 模式 2.4 方案选择 3. 多租户的开关 4. 多租户的业务功能 5. 多租户的技术组件 5.1 租户上下文 5.2 Web 层【重要】 5.3 Security 层 5.4 DB 层【重要】 5.5 Redis 层【重要】 5.6 AOP【重要】 5.7 Job【重要】 5.8 MQ 5.9 Async 6. 租户独立域名",
            content: "本章节，将介绍多租户的基础知识、以及怎样使用多租户的功能。\n\n相关的视频教程：\n\n * 01、如何实现多租户的 DB 封装？\n * 02、如何实现多租户的 Redis 封装？\n * 03、如何实现多租户的 Web 与 Security 封装？\n * 04、如何实现多租户的 Job 封装？\n * 05、如何实现多租户的 MQ 与 Async 封装？\n * 06、如何实现多租户的 AOP 与 Util 封装？\n * 07、如何实现多租户的管理？\n * 08、如何实现多租户的套餐？\n\n\n# 1. 多租户是什么？\n\n多租户，简单来说是指一个业务系统，可以为多个组织服务，并且组织之间的数据是隔离的。\n\n例如说，在服务上部署了一个 ruoyi-vue-pro 系统，可以支持多个不同的公司使用。这里的一个公司就是一个租户，每个用户必然属于某个租户。因此，用户也只能看见自己租户下面的内容，其它租户的内容对他是不可见的。\n\n\n# 2. 数据隔离方案\n\n多租户的数据隔离方案，可以分成分成三种：\n\n 1. DATASOURCE 模式：独立数据库\n 2. SCHEMA 模式：共享数据库，独立 Schema\n 3. COLUMN 模式：共享数据库，共享 Schema，共享数据表\n\n\n# 2.1 DATASOURCE 模式\n\n一个租户一个数据库，这种方案的用户数据隔离级别最高，安全性最好，但成本也高。\n\n\n\n * 优点：为不同的租户提供独立的数据库，有助于简化数据模型的扩展设计，满足不同租户的独特需求；如果出现故障，恢复数据比较简单。\n * 缺点：增大了数据库的安装数量，随之带来维护成本和购置成本的增加。\n\n\n# 2.2 SCHEMA 模式\n\n多个或所有租户共享数据库，但一个租户一个表。\n\n\n\n * 优点：为安全性要求较高的租户提供了一定程度的逻辑数据隔离，并不是完全隔离；每个数据库可以支持更多的租户数量。\n * 缺点：如果出现故障，数据恢复比较困难，因为恢复数据库将牵扯到其他租户的数据； 如果需要跨租户统计数据，存在一定困难。\n\n\n# 2.3 COLUMN 模式\n\n共享数据库，共享数据架构。租户共享同一个数据库、同一个表，但在表中通过 tenant_id 字段区分租户的数据。这是共享程度最高、隔离级别最低的模式。\n\n\n\n * 优点：维护和购置成本最低，允许每个数据库支持的租户数量最多。\n * 缺点：隔离级别最低，安全性最低，需要在设计开发时加大对安全的开发量；数据备份和恢复最困难，需要逐表逐条备份和还原。\n\n\n# 2.4 方案选择\n\n\n\n * 一般情况下，可以考虑采用 COLUMN 模式，开发、运维简单，以最少的服务器为最多的租户提供服务。\n * 租户规模比较大，或者一些租户对安全性要求较高，可以考虑采用 DATASOURCE 模式，当然它也相对复杂的多。\n * 不推荐采用 SCHEMA 模式，因为它的优点并不明显，而且它的缺点也很明显，同时对复杂 SQL 支持一般。\n\n提问：项目支持哪些模式？\n\n目前支持最主流的 DATASOURCE 和 COLUMN 两种模式。而 SCHEMA 模式不推荐使用，所以暂时不考虑实现。\n\n考虑到让大家更好的理解 DATASOURCE 和 COLUMN 模式，拆成了两篇文章：\n\n * 《SaaS 多租户【字段隔离】》：讲解 COLUMN 模式\n * 《SaaS 多租户【数据库隔离】》：讲解 DATASOURCE 模式\n\n\n# 3. 多租户的开关\n\n系统有两个配置项，设置为 true 时开启多租户，设置为 false 时关闭多租户。\n\n注意，两者需要保持一致，否则会报错！\n\n配置项                     说明     配置文件\nyudao.server.tenant     后端开关   \nVUE_APP_TENANT_ENABLE   前端开关   \n\n疑问：为什么要设置两个配置项？\n\n前端登录界面需要使用到多租户的配置项，从后端加载配置项的话，体验会比较差。\n\n\n# 4. 多租户的业务功能\n\n多租户主要有两个业务功能：\n\n业务功能   说明                          界面   代码\n租户管理   配置系统租户，创建对应的租户管理员                后端 前端\n租户套餐   配置租户套餐，自定每个租户的菜单、操作、按钮的权限        后端 前端\n\n下面，我们来新增一个租户，它使用 COLUMN 模式。\n\n① 点击 [租户管理] 菜单，点击 [新增] 按钮，填写租户的信息。\n\n\n\n② 点击 [确认] 按钮，完成租户的创建，它会自动创建对应的租户管理员、角色等信息。\n\n\n\n③ 退出系统，登录刚创建的租户。\n\n\n\n至此，我们已经完成了租户的创建。\n\n\n# 5. 多租户的技术组件\n\n技术组件 yudao-spring-boot-starter-biz-tenant，实现透明化的多租户能力，针对 Web、Security、DB、Redis、AOP、Job、MQ、Async 等多个层面进行封装。\n\n\n# 5.1 租户上下文\n\nTenantContextHolder 是租户上下文，通过 ThreadLocal 实现租户编号的共享与传递。\n\n通过调用 TenantContextHolder 的 #getTenantId() 静态方法，获得当前的租户编号。绝绝绝大多数情况下，并不需要。\n\n\n# 5.2 Web 层【重要】\n\n> 实现可见 web 包。\n\n默认情况下，前端的每个请求 Header 必须带上 tenant-id，值为租户编号，即 system_tenant 表的主键编号。\n\n\n\n如果不带该请求头，会报“租户的请求未传递，请进行排查”错误提示。\n\n😜 通过 yudao.tenant.ignore-urls 配置项，可以设置哪些 URL 无需带该请求头。例如说：\n\n\n\n\n# 5.3 Security 层\n\n> 实现可见 security 包。\n\n主要是校验登录的用户，校验是否有权限访问该租户，避免越权问题。\n\n\n# 5.4 DB 层【重要】\n\n> 实现可见 db 包。\n\nCOLUMN 模式，基于 MyBatis Plus 自带的多租户功能实现。\n\n核心：每次对数据库操作时，它会自动拼接 WHERE tenant_id = ? 条件来进行租户的过滤，并且基本支持所有的 SQL 场景。\n\n如下是具体方式：\n\n① 需要开启多租户的表，必须添加 tenant_id 字段。例如说 system_users、system_role 等表。\n\nCREATE TABLE `system_role` (\n   `id` bigint NOT NULL AUTO_INCREMENT COMMENT '角色ID',\n   `name` varchar(30) CHARACTER NOT NULL COMMENT '角色名称',\n   `tenant_id` bigint NOT NULL DEFAULT '0' COMMENT '租户编号',\n   PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=1 COMMENT='角色信息表';\n\n\n并且该表对应的 DO 需要使用到 tenantId 属性时，建议继承 TenantBaseDO 类。\n\n② 无需开启多租户的表，需要添加表名到 yudao.tenant.ignore-tables 配置项目。例如说：\n\n\n\n如果不配置的话，MyBatis Plus 会自动拼接 WHERE tenant_id = ? 条件，导致报 tenant_id 字段不存在的错误。\n\n友情提示：MyBatis Plus 的多租户方案，在我们在 MyBatis XML 手写 SQL 时，是不生效的，即不会拼接 `tenant_id` 字段！！！\n\n解决方案：需要手动自己拼接，可见 ErpPurchaseStatisticsMapper.xml 案例，如下所示：\n\ntenant_id = ${@cn.iocoder.yudao.framework.tenant.core.context.TenantContextHolder@getRequiredTenantId()}\n\n\n * 其中，后面 ${@...} 一串，是 MyBatis 调用静态方法的方式，即使用 TenantContextHolder 的 #getRequiredTenantId() 方法，获得当前的租户编号。\n\n补充说明：后续和球友沟通下来，部分简单 SQL 情况下，MyBatis Plus 还是会拼接。可见 https://t.zsxq.com/O8ys4 帖子，欢迎讨论！\n\n\n# 5.5 Redis 层【重要】\n\n> 实现可见 redis 包。\n\n由于 Redis 不同于 DB 有 tenant_id 字段，无法通过类似 WHERE tenant_id = ? 的方式过滤，所以需要通过在 Redis Key 上增加 :t{tenantId} 后缀的方式，进行租户之间的隔离。\n\n例如说，假设 Redis Key 是 user:%d，示例是 user:1024；对应到多租户 1 的 Redis Key 是 user:t1:1024。\n\n为什么 Redis Key 要多租户隔离呢？\n\n * ① 在使用 DATASOURCE 模式时，不同库的相同表的 id 可能相同，例如说 A 库的用户，和 B 库的用户都是 1024，直接缓存会存在 Redis Key 的冲突。\n * ② 在所有模式下，跨租户可能存在相同的需要唯一的数据，例如说用户的手机号，直接缓存会存在 Redis Key 的冲突。\n\n# 使用方式一：基于 Spring Cache + Redis【推荐】\n\n只需要一步，在方法上添加 Spring Cache 注解，例如说 @Cachable、@CachePut、@CacheEvict。\n\n具体的实现原理，可见 TenantRedisCacheManager 的源码。\n\n注意！！！默认配置下，Spring Cache 都开启 Redis Key 的多租户隔离。如果不需要，可以将 Key 添加到 yudao.tenant.ignore-caches 配置项中。如下图所示：\n\n\n\n# 使用方式二：基于 RedisTemplate + TenantRedisKeyDefine\n\n暂时没有合适的封装，需要在自己 format Redis Key 的时候，手动将 :t{tenantId} 后缀拼接上。\n\n这也是为什么，我推荐你使用 Spring Cache + Redis 的原因！\n\n\n# 5.6 AOP【重要】\n\n> 实现可见 aop 包。\n\n① 声明 @TenantIgnore 注解在方法上，标记指定方法不进行租户的自动过滤，避免自动拼接 WHERE tenant_id = ? 条件等等。\n\n例如说：RoleServiceImpl 的 #initLocalCache() 方法，加载所有租户的角色到内存进行缓存，如果不声明 @TenantIgnore 注解，会导致租户的自动过滤，只加载了某个租户的角色。\n\n// RoleServiceImpl.java\npublic class RoleServiceImpl implements RoleService {\n\n    @Resource\n    @Lazy // 注入自己，所以延迟加载\n    private RoleService self;\n    \n    @Override\n    @PostConstruct\n    @TenantIgnore // 忽略自动多租户，全局初始化缓存\n    public void initLocalCache() {\n        // ... 从数据库中，加载角色\n    }\n\n    @Scheduled(fixedDelay = SCHEDULER_PERIOD, initialDelay = SCHEDULER_PERIOD)\n    public void schedulePeriodicRefresh() {\n        self.initLocalCache(); // <x> 通过 self 引用到 Spring 代理对象\n    }\n}\n\n\n有一点要格外注意，由于 @TenantIgnore 注解是基于 Spring AOP 实现，如果是方法内部的调用，避免使用 this 导致不生效，可以采用上述示例的 <x> 处的 self 方式。\n\n② 使用 TenantUtils 的 #execute(Long tenantId, Runnable runnable) 方法，模拟指定租户( tenantId )，执行某段业务逻辑( runnable )。\n\n例如说：在 TenantServiceImpl 的 #createTenant(...) 方法，在创建完租户时，需要模拟该租户，进行用户和角色的创建。如下图所示：\n\n\n\n\n# 5.7 Job【重要】\n\n> 实现可见 job 包。\n\n声明 @TenantJob 注解在 Job 方法上，实现并行遍历每个租户，执行定时任务的逻辑。\n\n\n# 5.8 MQ\n\n> 实现可见 mq 包。\n\n通过租户对 MQ 层面的封装，实现租户上下文，可以继续传递到 MQ 消费的逻辑中，避免丢失的问题。实现原理是：\n\n * 发送消息时，MQ 会将租户上下文的租户编号，记录到 Message 消息头 tenant-id 上。\n * 消费消息时，MQ 会将 Message 消息头 tenant-id，设置到租户上下文的租户编号。\n\n\n# 5.9 Async\n\n> 实现可见 YudaoAsyncAutoConfiguration 类。\n\n通过使用阿里开源的 TransmittableThreadLocal 组件，实现 Spring Async 执行异步逻辑时，租户上下文可以继续传递，避免丢失的问题。\n\n\n# 6. 租户独立域名\n\n在我们使用 SaaS 云产品的时候，每个租户会拥有 独立的子域名，例如说：租户 A 对应 a.iocoder.cn，租户 B 对应 b.iocoder.cn。\n\n目前管理后台已经提供类似的能力，更多大家可以基于它去拓展。实现方式：\n\n 1. 在 system_tenant 表里，有个 website 字段为该租户的独立域名，你可以填写你希望分配给它的子域名。\n 2. 在 Nginx 上做 泛域名解析 到你的前端项目，例如说 Nginx 的 server_name *.iocoder.cn 解析到 Vue3 管理后台。\n\n这样用户在访问管理后台的登录界面，会自动根据当前访问域名的 host，向后端获得对应的 tenant-id 编号，后续请求都带上它！\n\nps：商城 uniapp 暂时还没做，感兴趣可以 pull request 贡献下噢！",
            normalizedContent: "本章节，将介绍多租户的基础知识、以及怎样使用多租户的功能。\n\n相关的视频教程：\n\n * 01、如何实现多租户的 db 封装？\n * 02、如何实现多租户的 redis 封装？\n * 03、如何实现多租户的 web 与 security 封装？\n * 04、如何实现多租户的 job 封装？\n * 05、如何实现多租户的 mq 与 async 封装？\n * 06、如何实现多租户的 aop 与 util 封装？\n * 07、如何实现多租户的管理？\n * 08、如何实现多租户的套餐？\n\n\n# 1. 多租户是什么？\n\n多租户，简单来说是指一个业务系统，可以为多个组织服务，并且组织之间的数据是隔离的。\n\n例如说，在服务上部署了一个 ruoyi-vue-pro 系统，可以支持多个不同的公司使用。这里的一个公司就是一个租户，每个用户必然属于某个租户。因此，用户也只能看见自己租户下面的内容，其它租户的内容对他是不可见的。\n\n\n# 2. 数据隔离方案\n\n多租户的数据隔离方案，可以分成分成三种：\n\n 1. datasource 模式：独立数据库\n 2. schema 模式：共享数据库，独立 schema\n 3. column 模式：共享数据库，共享 schema，共享数据表\n\n\n# 2.1 datasource 模式\n\n一个租户一个数据库，这种方案的用户数据隔离级别最高，安全性最好，但成本也高。\n\n\n\n * 优点：为不同的租户提供独立的数据库，有助于简化数据模型的扩展设计，满足不同租户的独特需求；如果出现故障，恢复数据比较简单。\n * 缺点：增大了数据库的安装数量，随之带来维护成本和购置成本的增加。\n\n\n# 2.2 schema 模式\n\n多个或所有租户共享数据库，但一个租户一个表。\n\n\n\n * 优点：为安全性要求较高的租户提供了一定程度的逻辑数据隔离，并不是完全隔离；每个数据库可以支持更多的租户数量。\n * 缺点：如果出现故障，数据恢复比较困难，因为恢复数据库将牵扯到其他租户的数据； 如果需要跨租户统计数据，存在一定困难。\n\n\n# 2.3 column 模式\n\n共享数据库，共享数据架构。租户共享同一个数据库、同一个表，但在表中通过 tenant_id 字段区分租户的数据。这是共享程度最高、隔离级别最低的模式。\n\n\n\n * 优点：维护和购置成本最低，允许每个数据库支持的租户数量最多。\n * 缺点：隔离级别最低，安全性最低，需要在设计开发时加大对安全的开发量；数据备份和恢复最困难，需要逐表逐条备份和还原。\n\n\n# 2.4 方案选择\n\n\n\n * 一般情况下，可以考虑采用 column 模式，开发、运维简单，以最少的服务器为最多的租户提供服务。\n * 租户规模比较大，或者一些租户对安全性要求较高，可以考虑采用 datasource 模式，当然它也相对复杂的多。\n * 不推荐采用 schema 模式，因为它的优点并不明显，而且它的缺点也很明显，同时对复杂 sql 支持一般。\n\n提问：项目支持哪些模式？\n\n目前支持最主流的 datasource 和 column 两种模式。而 schema 模式不推荐使用，所以暂时不考虑实现。\n\n考虑到让大家更好的理解 datasource 和 column 模式，拆成了两篇文章：\n\n * 《saas 多租户【字段隔离】》：讲解 column 模式\n * 《saas 多租户【数据库隔离】》：讲解 datasource 模式\n\n\n# 3. 多租户的开关\n\n系统有两个配置项，设置为 true 时开启多租户，设置为 false 时关闭多租户。\n\n注意，两者需要保持一致，否则会报错！\n\n配置项                     说明     配置文件\nyudao.server.tenant     后端开关   \nvue_app_tenant_enable   前端开关   \n\n疑问：为什么要设置两个配置项？\n\n前端登录界面需要使用到多租户的配置项，从后端加载配置项的话，体验会比较差。\n\n\n# 4. 多租户的业务功能\n\n多租户主要有两个业务功能：\n\n业务功能   说明                          界面   代码\n租户管理   配置系统租户，创建对应的租户管理员                后端 前端\n租户套餐   配置租户套餐，自定每个租户的菜单、操作、按钮的权限        后端 前端\n\n下面，我们来新增一个租户，它使用 column 模式。\n\n① 点击 [租户管理] 菜单，点击 [新增] 按钮，填写租户的信息。\n\n\n\n② 点击 [确认] 按钮，完成租户的创建，它会自动创建对应的租户管理员、角色等信息。\n\n\n\n③ 退出系统，登录刚创建的租户。\n\n\n\n至此，我们已经完成了租户的创建。\n\n\n# 5. 多租户的技术组件\n\n技术组件 yudao-spring-boot-starter-biz-tenant，实现透明化的多租户能力，针对 web、security、db、redis、aop、job、mq、async 等多个层面进行封装。\n\n\n# 5.1 租户上下文\n\ntenantcontextholder 是租户上下文，通过 threadlocal 实现租户编号的共享与传递。\n\n通过调用 tenantcontextholder 的 #gettenantid() 静态方法，获得当前的租户编号。绝绝绝大多数情况下，并不需要。\n\n\n# 5.2 web 层【重要】\n\n> 实现可见 web 包。\n\n默认情况下，前端的每个请求 header 必须带上 tenant-id，值为租户编号，即 system_tenant 表的主键编号。\n\n\n\n如果不带该请求头，会报“租户的请求未传递，请进行排查”错误提示。\n\n😜 通过 yudao.tenant.ignore-urls 配置项，可以设置哪些 url 无需带该请求头。例如说：\n\n\n\n\n# 5.3 security 层\n\n> 实现可见 security 包。\n\n主要是校验登录的用户，校验是否有权限访问该租户，避免越权问题。\n\n\n# 5.4 db 层【重要】\n\n> 实现可见 db 包。\n\ncolumn 模式，基于 mybatis plus 自带的多租户功能实现。\n\n核心：每次对数据库操作时，它会自动拼接 where tenant_id = ? 条件来进行租户的过滤，并且基本支持所有的 sql 场景。\n\n如下是具体方式：\n\n① 需要开启多租户的表，必须添加 tenant_id 字段。例如说 system_users、system_role 等表。\n\ncreate table `system_role` (\n   `id` bigint not null auto_increment comment '角色id',\n   `name` varchar(30) character not null comment '角色名称',\n   `tenant_id` bigint not null default '0' comment '租户编号',\n   primary key (`id`) using btree\n) engine=innodb auto_increment=1 comment='角色信息表';\n\n\n并且该表对应的 do 需要使用到 tenantid 属性时，建议继承 tenantbasedo 类。\n\n② 无需开启多租户的表，需要添加表名到 yudao.tenant.ignore-tables 配置项目。例如说：\n\n\n\n如果不配置的话，mybatis plus 会自动拼接 where tenant_id = ? 条件，导致报 tenant_id 字段不存在的错误。\n\n友情提示：mybatis plus 的多租户方案，在我们在 mybatis xml 手写 sql 时，是不生效的，即不会拼接 `tenant_id` 字段！！！\n\n解决方案：需要手动自己拼接，可见 erppurchasestatisticsmapper.xml 案例，如下所示：\n\ntenant_id = ${@cn.iocoder.yudao.framework.tenant.core.context.tenantcontextholder@getrequiredtenantid()}\n\n\n * 其中，后面 ${@...} 一串，是 mybatis 调用静态方法的方式，即使用 tenantcontextholder 的 #getrequiredtenantid() 方法，获得当前的租户编号。\n\n补充说明：后续和球友沟通下来，部分简单 sql 情况下，mybatis plus 还是会拼接。可见 https://t.zsxq.com/o8ys4 帖子，欢迎讨论！\n\n\n# 5.5 redis 层【重要】\n\n> 实现可见 redis 包。\n\n由于 redis 不同于 db 有 tenant_id 字段，无法通过类似 where tenant_id = ? 的方式过滤，所以需要通过在 redis key 上增加 :t{tenantid} 后缀的方式，进行租户之间的隔离。\n\n例如说，假设 redis key 是 user:%d，示例是 user:1024；对应到多租户 1 的 redis key 是 user:t1:1024。\n\n为什么 redis key 要多租户隔离呢？\n\n * ① 在使用 datasource 模式时，不同库的相同表的 id 可能相同，例如说 a 库的用户，和 b 库的用户都是 1024，直接缓存会存在 redis key 的冲突。\n * ② 在所有模式下，跨租户可能存在相同的需要唯一的数据，例如说用户的手机号，直接缓存会存在 redis key 的冲突。\n\n# 使用方式一：基于 spring cache + redis【推荐】\n\n只需要一步，在方法上添加 spring cache 注解，例如说 @cachable、@cacheput、@cacheevict。\n\n具体的实现原理，可见 tenantrediscachemanager 的源码。\n\n注意！！！默认配置下，spring cache 都开启 redis key 的多租户隔离。如果不需要，可以将 key 添加到 yudao.tenant.ignore-caches 配置项中。如下图所示：\n\n\n\n# 使用方式二：基于 redistemplate + tenantrediskeydefine\n\n暂时没有合适的封装，需要在自己 format redis key 的时候，手动将 :t{tenantid} 后缀拼接上。\n\n这也是为什么，我推荐你使用 spring cache + redis 的原因！\n\n\n# 5.6 aop【重要】\n\n> 实现可见 aop 包。\n\n① 声明 @tenantignore 注解在方法上，标记指定方法不进行租户的自动过滤，避免自动拼接 where tenant_id = ? 条件等等。\n\n例如说：roleserviceimpl 的 #initlocalcache() 方法，加载所有租户的角色到内存进行缓存，如果不声明 @tenantignore 注解，会导致租户的自动过滤，只加载了某个租户的角色。\n\n// roleserviceimpl.java\npublic class roleserviceimpl implements roleservice {\n\n    @resource\n    @lazy // 注入自己，所以延迟加载\n    private roleservice self;\n    \n    @override\n    @postconstruct\n    @tenantignore // 忽略自动多租户，全局初始化缓存\n    public void initlocalcache() {\n        // ... 从数据库中，加载角色\n    }\n\n    @scheduled(fixeddelay = scheduler_period, initialdelay = scheduler_period)\n    public void scheduleperiodicrefresh() {\n        self.initlocalcache(); // <x> 通过 self 引用到 spring 代理对象\n    }\n}\n\n\n有一点要格外注意，由于 @tenantignore 注解是基于 spring aop 实现，如果是方法内部的调用，避免使用 this 导致不生效，可以采用上述示例的 <x> 处的 self 方式。\n\n② 使用 tenantutils 的 #execute(long tenantid, runnable runnable) 方法，模拟指定租户( tenantid )，执行某段业务逻辑( runnable )。\n\n例如说：在 tenantserviceimpl 的 #createtenant(...) 方法，在创建完租户时，需要模拟该租户，进行用户和角色的创建。如下图所示：\n\n\n\n\n# 5.7 job【重要】\n\n> 实现可见 job 包。\n\n声明 @tenantjob 注解在 job 方法上，实现并行遍历每个租户，执行定时任务的逻辑。\n\n\n# 5.8 mq\n\n> 实现可见 mq 包。\n\n通过租户对 mq 层面的封装，实现租户上下文，可以继续传递到 mq 消费的逻辑中，避免丢失的问题。实现原理是：\n\n * 发送消息时，mq 会将租户上下文的租户编号，记录到 message 消息头 tenant-id 上。\n * 消费消息时，mq 会将 message 消息头 tenant-id，设置到租户上下文的租户编号。\n\n\n# 5.9 async\n\n> 实现可见 yudaoasyncautoconfiguration 类。\n\n通过使用阿里开源的 transmittablethreadlocal 组件，实现 spring async 执行异步逻辑时，租户上下文可以继续传递，避免丢失的问题。\n\n\n# 6. 租户独立域名\n\n在我们使用 saas 云产品的时候，每个租户会拥有 独立的子域名，例如说：租户 a 对应 a.iocoder.cn，租户 b 对应 b.iocoder.cn。\n\n目前管理后台已经提供类似的能力，更多大家可以基于它去拓展。实现方式：\n\n 1. 在 system_tenant 表里，有个 website 字段为该租户的独立域名，你可以填写你希望分配给它的子域名。\n 2. 在 nginx 上做 泛域名解析 到你的前端项目，例如说 nginx 的 server_name *.iocoder.cn 解析到 vue3 管理后台。\n\n这样用户在访问管理后台的登录界面，会自动根据当前访问域名的 host，向后端获得对应的 tenant-id 编号，后续请求都带上它！\n\nps：商城 uniapp 暂时还没做，感兴趣可以 pull request 贡献下噢！",
            charsets: {
                cjk: !0
            }
        }, {
            title: "SaaS 多租户【数据库隔离】",
            frontmatter: {
                title: "SaaS 多租户【数据库隔离】",
                date: "2023-03-01T09:38:04.000Z",
                permalink: "/saas-tenant/dynamic"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/02.%E5%90%8E%E7%AB%AF%E6%89%8B%E5%86%8C/13.SaaS%20%E5%A4%9A%E7%A7%9F%E6%88%B7%EF%BC%88%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%EF%BC%89.html",
            relativePath: "01.开发指南/02.后端手册/13.SaaS 多租户（数据库隔离）.md",
            key: "v-7c41859a",
            path: "/saas-tenant/dynamic/",
            headers: [{
                level: 2,
                title: "0. 极速体验",
                slug: "_0-极速体验",
                normalizedTitle: "0. 极速体验",
                charIndex: 78
            }, {
                level: 2,
                title: "1. 实现原理",
                slug: "_1-实现原理",
                normalizedTitle: "1. 实现原理",
                charIndex: 360
            }, {
                level: 2,
                title: "2. 功能演示",
                slug: "_2-功能演示",
                normalizedTitle: "2. 功能演示",
                charIndex: 459
            }, {
                level: 2,
                title: "3. 创建表",
                slug: "_3-创建表",
                normalizedTitle: "3. 创建表",
                charIndex: 1168
            }, {
                level: 3,
                title: "3.1 主库",
                slug: "_3-1-主库",
                normalizedTitle: "3.1 主库",
                charIndex: 1217
            }, {
                level: 3,
                title: "3.2 租户库",
                slug: "_3-2-租户库",
                normalizedTitle: "3.2 租户库",
                charIndex: 1366
            }, {
                level: 3,
                title: "3.3 租户字段",
                slug: "_3-3-租户字段",
                normalizedTitle: "3.3 租户字段",
                charIndex: 1480
            }, {
                level: 2,
                title: "4. 多数据源事务",
                slug: "_4-多数据源事务",
                normalizedTitle: "4. 多数据源事务",
                charIndex: 1937
            }, {
                level: 3,
                title: "4.1 本地事务",
                slug: "_4-1-本地事务",
                normalizedTitle: "4.1 本地事务",
                charIndex: 2266
            }, {
                level: 3,
                title: "4.2 使用示例",
                slug: "_4-2-使用示例",
                normalizedTitle: "4.2 使用示例",
                charIndex: 2632
            }],
            headersStr: "0. 极速体验 1. 实现原理 2. 功能演示 3. 创建表 3.1 主库 3.2 租户库 3.3 租户字段 4. 多数据源事务 4.1 本地事务 4.2 使用示例",
            content: "本章节，讲解 SaaS 租户的 DATASOURCE 模式，实现数据库级别的隔离。\n\n注意，需要前置阅读 《SaaS 多租户【字段隔离】》 文档。\n\n\n# 0. 极速体验\n\n① 克隆 https://gitee.com/zhijiantianya/ruoyi-vue-pro 仓库，并切换到 feature/dev-yunai 分支。\n\n② 创建 ruoyi-vue-pro-master、ruoyi-vue-pro-tenant-a、ruoyi-vue-pro-tenant-b 三个数据库。\n\n③ 下载 多租户多db.zip 并解压，将 SQL 导入到对应的数据库中。\n\n友情提示：\n\n随着版本的迭代，SQL 脚本可能过期。如果碰到问题，可以在星球给我反馈下。\n\n④ 启动前端和后端项目，即可愉快的体验了。\n\n\n# 1. 实现原理\n\nDATASOURCE 模式，基于 dynamic-datasource 进行拓展实现。\n\n核心：每次对数据库操作时，动态切换到该租户所在的数据源，然后执行 SQL 语句。\n\n\n# 2. 功能演示\n\n我们来新增一个租户，使用 DATASOURCE 模式。\n\n① 点击 [基础设施 -> 数据源配置] 菜单，点击 [新增] 按钮，新增一个名字为 tenant-a 数据源。\n\n\n\n然后，手动将如下表拷贝到 ruoyi-vue-pro 主库中的如下表，拷贝到 ruoyi-vue-pro-tenant-a 库中。如下图所示：\n\n\n\nsystem_dept\nsystem_login_log\nsystem_notice\nsystem_notify_message\nsystem_operate_log\nsystem_post\nsystem_role\nsystem_role_menu\nsystem_social_user\nsystem_social_user_bind\nsystem_user_post\nsystem_user_role\nsystem_users\n\n\n友情提示：\n\n随着版本的迭代，可能需要拷贝更多的表。如果碰到问题，可以在星球给我反馈下。\n\n② 点击 [基础设施 -> 租户管理] 菜单，点击 [新增] 按钮，新增一个名字为 土豆租户 的租户，并使用 tenant-a 数据源。如下图所示：\n\n\n\n此时，在 ruoyi-vue-pro-tenant-a 库中，可以查询到对应的租户管理员、角色等信息。如下图所示：\n\n\n\n③ 退出系统，登录刚创建的租户。\n\n\n\n至此，我们已经完成了租户的创建。\n\n补充说明：\n\n后续在使用时，建议把拷贝到其它租户数据库的表，从 ruoyi-vue-pro 主库中进行删除。\n\n目的是，主库只保留所有租户共享的全局表。例如说，菜单表、定时任表等等。\n\n\n# 3. 创建表\n\n在使用 DATASOURCE 模式时，数据库可以分为两种：主库、租户库。\n\n\n# 3.1 主库\n\n① 存放所有租户共享的表。例如说：菜单表、定时任务表等等。如下图所示：\n\n\n\n② 对应 master 数据源，配置在 application-{env}.yaml 配置文件。如下图所示：\n\n\n\n③ 每个主库对应的 Mapper，必须添加 @Master 注解。例如说：\n\n\n\n\n# 3.2 租户库\n\n① 存放每个租户的表。例如说：用户表、角色表等等。\n\n② 在 [基础设施 -> 数据源配置] 菜单中，配置数据源。\n\n③ 每个主库对应的 Mapper，必须添加 @TenantDS 注解。例如说：\n\n\n\n\n# 3.3 租户字段\n\n① 考虑到拓展性，在使用 DATASOURCE 模式时，默认会叠加 COLUMN 模式，即还有 tenant_id 租户字段：\n\n * 在 INSERT 操作时，会自动记录租户编号到 tenant_id 字段。\n * 在 SELECT 操作时，会自动添加 WHERE tenant_id = ? 查询条件。\n\n如果你不需要，可以直接删除 TenantDatabaseInterceptor 类，以及它的 Bean 自动配置。\n\n拓展性，指的是部分【大】租户独立数据库，部分【小】租户共享数据。\n\n② 也因为叠加了 COLUMN 模式，主库的表需要根据情况添加 tenant_id 字段。\n\n * 情况一：不需要添加 tenant_id 字段。例如说：菜单表、定时任务表等等。注意，需要把表名添加到 yudao.tenant.ignore-tables 配置项中。\n * 情况二：需要 tenant_id 字段。例如说：访问日志表、异常日志表等等。目的，排查是哪个租户的系统级别的日志。\n\n\n# 4. 多数据源事务\n\n使用 DATASOURCE 模式后，可能一个操作涉及到多个数据源。例如说：创建租户时，即需要操作主库，也需要操作租户库。\n\n考虑到多数据的数据一致性，我们会采用事务的方式，而使用 Spring 事务时，会存在多数据库无法切换的问题。不了解的胖友，可以阅读 《MyBatis Plus 的多数据源 @DS 切换不起作用了，谁的锅 》 文章。\n\n多数据源的事务方案，是一个老生常谈的问题。比较主流的，有如下两种，都是相对重量级的方案：\n\n 1. 使用 Atomikos 实现 JTA 分布式事务，配置复杂，性能较差。\n 2. 使用 Seata 实现分布式事务，使用简单，性能不错，但是需要额外引入 Seata Server 服务。\n\n\n# 4.1 本地事务\n\n考虑到项目是单体架构，不适合采用重量级的事务，因此采用 dynamic-datasource 提供的 “本地事务” 轻量级方案。\n\n它的实现原理是：自定义 @DSTransactional 事务注解，替代 Spring @Transactional 事务注解。\n\n * 在逻辑执行成功时，循环提交每个数据源的事务。\n * 在逻辑执行失败时，循环回滚每个数据源的事务。\n\n但是它存在一个风险点，如果数据库发生异常（例如说宕机），那么本地事务就可能会存在数据不一致的问题。例如说：\n\n * ① 主库的事务提交\n * ② 租户库发生异常，租户的事务提交失败\n * 结果：主库的数据已经提交，而租户库的数据没有提交，就会导致数据不一致。\n\n因此，如果你的系统对数据一致性要求很高，那么请使用 Seata 方案。\n\n\n# 4.2 使用示例\n\n在最外层的 Service 方法上，添加 @DSTransactional 注解。例如说，创建租户的 Service 方法：\n\n\n\n注意，里面不能嵌套有 Spring 自带的事务，就是上图中【黄圈】的 Service 方法不能使用 Spring @Transactional 注解，否则会导致数据源无法切换。\n\n如果【黄圈】的 Service 自身还需要事务，那么可以使用 @DSTransactional 注解。",
            normalizedContent: "本章节，讲解 saas 租户的 datasource 模式，实现数据库级别的隔离。\n\n注意，需要前置阅读 《saas 多租户【字段隔离】》 文档。\n\n\n# 0. 极速体验\n\n① 克隆 https://gitee.com/zhijiantianya/ruoyi-vue-pro 仓库，并切换到 feature/dev-yunai 分支。\n\n② 创建 ruoyi-vue-pro-master、ruoyi-vue-pro-tenant-a、ruoyi-vue-pro-tenant-b 三个数据库。\n\n③ 下载 多租户多db.zip 并解压，将 sql 导入到对应的数据库中。\n\n友情提示：\n\n随着版本的迭代，sql 脚本可能过期。如果碰到问题，可以在星球给我反馈下。\n\n④ 启动前端和后端项目，即可愉快的体验了。\n\n\n# 1. 实现原理\n\ndatasource 模式，基于 dynamic-datasource 进行拓展实现。\n\n核心：每次对数据库操作时，动态切换到该租户所在的数据源，然后执行 sql 语句。\n\n\n# 2. 功能演示\n\n我们来新增一个租户，使用 datasource 模式。\n\n① 点击 [基础设施 -> 数据源配置] 菜单，点击 [新增] 按钮，新增一个名字为 tenant-a 数据源。\n\n\n\n然后，手动将如下表拷贝到 ruoyi-vue-pro 主库中的如下表，拷贝到 ruoyi-vue-pro-tenant-a 库中。如下图所示：\n\n\n\nsystem_dept\nsystem_login_log\nsystem_notice\nsystem_notify_message\nsystem_operate_log\nsystem_post\nsystem_role\nsystem_role_menu\nsystem_social_user\nsystem_social_user_bind\nsystem_user_post\nsystem_user_role\nsystem_users\n\n\n友情提示：\n\n随着版本的迭代，可能需要拷贝更多的表。如果碰到问题，可以在星球给我反馈下。\n\n② 点击 [基础设施 -> 租户管理] 菜单，点击 [新增] 按钮，新增一个名字为 土豆租户 的租户，并使用 tenant-a 数据源。如下图所示：\n\n\n\n此时，在 ruoyi-vue-pro-tenant-a 库中，可以查询到对应的租户管理员、角色等信息。如下图所示：\n\n\n\n③ 退出系统，登录刚创建的租户。\n\n\n\n至此，我们已经完成了租户的创建。\n\n补充说明：\n\n后续在使用时，建议把拷贝到其它租户数据库的表，从 ruoyi-vue-pro 主库中进行删除。\n\n目的是，主库只保留所有租户共享的全局表。例如说，菜单表、定时任表等等。\n\n\n# 3. 创建表\n\n在使用 datasource 模式时，数据库可以分为两种：主库、租户库。\n\n\n# 3.1 主库\n\n① 存放所有租户共享的表。例如说：菜单表、定时任务表等等。如下图所示：\n\n\n\n② 对应 master 数据源，配置在 application-{env}.yaml 配置文件。如下图所示：\n\n\n\n③ 每个主库对应的 mapper，必须添加 @master 注解。例如说：\n\n\n\n\n# 3.2 租户库\n\n① 存放每个租户的表。例如说：用户表、角色表等等。\n\n② 在 [基础设施 -> 数据源配置] 菜单中，配置数据源。\n\n③ 每个主库对应的 mapper，必须添加 @tenantds 注解。例如说：\n\n\n\n\n# 3.3 租户字段\n\n① 考虑到拓展性，在使用 datasource 模式时，默认会叠加 column 模式，即还有 tenant_id 租户字段：\n\n * 在 insert 操作时，会自动记录租户编号到 tenant_id 字段。\n * 在 select 操作时，会自动添加 where tenant_id = ? 查询条件。\n\n如果你不需要，可以直接删除 tenantdatabaseinterceptor 类，以及它的 bean 自动配置。\n\n拓展性，指的是部分【大】租户独立数据库，部分【小】租户共享数据。\n\n② 也因为叠加了 column 模式，主库的表需要根据情况添加 tenant_id 字段。\n\n * 情况一：不需要添加 tenant_id 字段。例如说：菜单表、定时任务表等等。注意，需要把表名添加到 yudao.tenant.ignore-tables 配置项中。\n * 情况二：需要 tenant_id 字段。例如说：访问日志表、异常日志表等等。目的，排查是哪个租户的系统级别的日志。\n\n\n# 4. 多数据源事务\n\n使用 datasource 模式后，可能一个操作涉及到多个数据源。例如说：创建租户时，即需要操作主库，也需要操作租户库。\n\n考虑到多数据的数据一致性，我们会采用事务的方式，而使用 spring 事务时，会存在多数据库无法切换的问题。不了解的胖友，可以阅读 《mybatis plus 的多数据源 @ds 切换不起作用了，谁的锅 》 文章。\n\n多数据源的事务方案，是一个老生常谈的问题。比较主流的，有如下两种，都是相对重量级的方案：\n\n 1. 使用 atomikos 实现 jta 分布式事务，配置复杂，性能较差。\n 2. 使用 seata 实现分布式事务，使用简单，性能不错，但是需要额外引入 seata server 服务。\n\n\n# 4.1 本地事务\n\n考虑到项目是单体架构，不适合采用重量级的事务，因此采用 dynamic-datasource 提供的 “本地事务” 轻量级方案。\n\n它的实现原理是：自定义 @dstransactional 事务注解，替代 spring @transactional 事务注解。\n\n * 在逻辑执行成功时，循环提交每个数据源的事务。\n * 在逻辑执行失败时，循环回滚每个数据源的事务。\n\n但是它存在一个风险点，如果数据库发生异常（例如说宕机），那么本地事务就可能会存在数据不一致的问题。例如说：\n\n * ① 主库的事务提交\n * ② 租户库发生异常，租户的事务提交失败\n * 结果：主库的数据已经提交，而租户库的数据没有提交，就会导致数据不一致。\n\n因此，如果你的系统对数据一致性要求很高，那么请使用 seata 方案。\n\n\n# 4.2 使用示例\n\n在最外层的 service 方法上，添加 @dstransactional 注解。例如说，创建租户的 service 方法：\n\n\n\n注意，里面不能嵌套有 spring 自带的事务，就是上图中【黄圈】的 service 方法不能使用 spring @transactional 注解，否则会导致数据源无法切换。\n\n如果【黄圈】的 service 自身还需要事务，那么可以使用 @dstransactional 注解。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "异常处理（错误码）",
            frontmatter: {
                title: "异常处理（错误码）",
                date: "2022-03-25T09:09:00.000Z",
                permalink: "/exception"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/02.%E5%90%8E%E7%AB%AF%E6%89%8B%E5%86%8C/15.%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html",
            relativePath: "01.开发指南/02.后端手册/15.异常处理.md",
            key: "v-bee4c996",
            path: "/exception/",
            headers: [{
                level: 2,
                title: "1. 统一响应",
                slug: "_1-统一响应",
                normalizedTitle: "1. 统一响应",
                charIndex: 44
            }, {
                level: 3,
                title: "1.1 CommonResult",
                slug: "_1-1-commonresult",
                normalizedTitle: "1.1 commonresult",
                charIndex: 441
            }, {
                level: 3,
                title: "1.2 使用 @ControllerAdvice ？",
                slug: "_1-2-使用-controlleradvice",
                normalizedTitle: "1.2 使用 @controlleradvice ？",
                charIndex: 1048
            }, {
                level: 2,
                title: "2. 异常处理",
                slug: "_2-异常处理",
                normalizedTitle: "2. 异常处理",
                charIndex: 1031
            }, {
                level: 3,
                title: "2.1 Spring MVC 的异常",
                slug: "_2-1-spring-mvc-的异常",
                normalizedTitle: "2.1 spring mvc 的异常",
                charIndex: 1506
            }, {
                level: 3,
                title: "2.2 Filter 的异常",
                slug: "_2-2-filter-的异常",
                normalizedTitle: "2.2 filter 的异常",
                charIndex: 1665
            }, {
                level: 2,
                title: "3. 业务异常",
                slug: "_3-业务异常",
                normalizedTitle: "3. 业务异常",
                charIndex: 1791
            }, {
                level: 3,
                title: "3.1 ServiceException",
                slug: "_3-1-serviceexception",
                normalizedTitle: "3.1 serviceexception",
                charIndex: 2179
            }, {
                level: 3,
                title: "3.2 ServiceExceptionUtil",
                slug: "_3-2-serviceexceptionutil",
                normalizedTitle: "3.2 serviceexceptionutil",
                charIndex: 2461
            }, {
                level: 2,
                title: "4. 错误码",
                slug: "_4-错误码",
                normalizedTitle: "4. 错误码",
                charIndex: 824
            }, {
                level: 3,
                title: "4.1 错误码分类",
                slug: "_4-1-错误码分类",
                normalizedTitle: "4.1 错误码分类",
                charIndex: 3021
            }, {
                level: 3,
                title: "4.2 错误码管理（已删除）",
                slug: "_4-2-错误码管理-已删除",
                normalizedTitle: "4.2 错误码管理（已删除）",
                charIndex: 3400
            }],
            headersStr: "1. 统一响应 1.1 CommonResult 1.2 使用 @ControllerAdvice ？ 2. 异常处理 2.1 Spring MVC 的异常 2.2 Filter 的异常 3. 业务异常 3.1 ServiceException 3.2 ServiceExceptionUtil 4. 错误码 4.1 错误码分类 4.2 错误码管理（已删除）",
            content: '本章节，将讲解异常相关的统一响应、异常处理、业务异常、错误码这 4 块的内容。\n\n\n# 1. 统一响应\n\n后端提供 RESTful API 给前端时，需要响应前端 API 调用是否成功：\n\n * 如果成功，成功的数据是什么。后续，前端会将数据渲染到页面上\n * 如果失败，失败的原因是什么。一般，前端会将原因弹出提示给用户\n\n因此，需要有统一响应，而不能是每个接口定义自己的风格。一般来说，统一响应返回信息如下：\n\n * 成功时，返回成功的状态码 + 数据\n * 失败时，返回失败的状态码 + 错误提示\n\n在标准的 RESTful API 的定义，是推荐使用 HTTP 响应状态码 作为状态码。一般来说，我们实践很少这么去做，主要原因如下：\n\n * 业务返回的错误状态码很多，HTTP 响应状态码无法很好的映射。例如说，活动还未开始、订单已取消等等\n * 学习成本高，开发者对 HTTP 响应状态码不是很了解。例如说，可能只知道 200、403、404、500 几种常见的\n\n\n# 1.1 CommonResult\n\nruoyi-vue-pro 项目在实践时，将状态码放在 Response Body 响应内容中返回。一共有 3 个字段，通过 CommonResult 定义如下：\n\n\n\n// 成功响应\n{\n    code: 0,\n    data: {\n        id: 1,\n        username: "yudaoyuanma"\n    }\n}\n\n// 失败响应\n{\n    code: 233666,\n    message: "徐妈太丑了"\n}\n\n\n可以增加 success 字段吗？\n\n有些团队在实践时，会增加了 success 字段，通过 true 和 false 表示成功还是失败。\n这个看每个团队的习惯吧。艿艿的话，还是偏好基于约定，返回 0 时表示成功。\n\n失败时的 code 字段，使用全局的错误码，稍后在 「4. 错误码」 小节来讲解。\n\n① 在 RESTful API 成功时，定义 Controller 对应方法的返回类型为 CommonResult，并调用 #success(T data) 方法来返回。代码如下图：\n\n\n\nCommonResult 的 data 字段是泛型，建议定义对应的 VO 类，而不是使用 Map 类。\n\n② 在 RESTful API 失败时，通过抛出 Exception 异常，具体在 「2. 异常处理」 小节。\n\n\n# 1.2 使用 @ControllerAdvice ？\n\n在 Spring MVC 中，可以使用 @ControllerAdvice 注解，通过 Spring AOP 拦截修改 Controller 方法的返回结果，从而实现全局的统一返回。\n\n使用 @ControllerAdvice 注解的实战案例？\n\n如果你感兴趣的话，可以阅读 《芋道 Spring Boot SpringMVC 入门 》 文章的「4. 全局统一返回 」小节。\n\n为什么项目不采用这种方式呢？主要原因是，这样的方式“破坏”了方法的定义，导致一些隐性的问题。例如说，Swagger 接口定义错误，展示的响应结果不是 CommonResult。\n\n还有个原因，部分 RESTful API 不需要自动包装 CommonResult 结果。例如说，第三方支付回调只需要返回 "success" 字符串。\n\n\n# 2. 异常处理\n\nRESTful API 发生异常时，需要拦截 Exception 异常，转换成统一响应的格式，否则前端无法处理。\n\n\n# 2.1 Spring MVC 的异常\n\n在 Spring MVC 中，通过 @ControllerAdvice + @ExceptionHandler 注解，声明将指定类型的异常，转换成对应的 CommonResult 响应。实现的代码，可见 GlobalExceptionHandler 类，代码如下：\n\n\n\n\n# 2.2 Filter 的异常\n\n在请求被 Spring MVC 处理之前，是先经过 Filter 处理的，此时发生异常时，是无法通过 @ExceptionHandler 注解来处理的。只能通过 try catch 的方式来实现，代码如下：\n\n\n\n\n# 3. 业务异常\n\n在 Service 发生业务异常时，如果进行返回呢？例如说，用户名已经存在，商品库存不足等。常用的方案选择，主要有两种：\n\n * 方案一，使用 CommonResult 统一响应结果，里面有错误码和错误提示，然后进行 return 返回\n * 方案二，使用 ServiceException 统一业务异常，里面有错误码和错误提示，然后进行 throw 抛出\n\n选择方案一 CommonResult 会存在两个问题：\n\n * 因为 Spring @Transactional 声明式事务，是基于异常进行回滚的，如果使用 CommonResult 返回，则事务回滚会非常麻烦\n * 当调用别的方法时，如果别人返回的是 CommonResult 对象，还需要不断的进行判断，写起来挺麻烦的\n\n因此，项目采用方案二 ServiceException 异常。\n\n\n# 3.1 ServiceException\n\n定义 ServiceException 异常类，继承 RuntimeException 异常类（非受检），用于定义业务异常。代码如下：\n\n\n\n为什么继承 RuntimeException 异常？\n\n大多数业务场景下，我们无需处理 ServiceException 业务异常，而是通过 GlobalExceptionHandler 统一处理，转换成对应的 CommonResult 对象，进而提示给前端即可。\n如果真的需要处理 ServiceException 时，通过 try catch 的方式进行主动捕获。\n\n\n# 3.2 ServiceExceptionUtil\n\n在 Service 需抛出业务异常时，通过调用 ServiceExceptionUtil 的 #exception(ErrorCode errorCode, Object... params) 方法来构建 ServiceException 异常，然后使用 throw 进行抛出。代码如下：\n\n// ServiceExceptionUtil.java\n\npublic static ServiceException exception(ErrorCode errorCode) { /** 省略参数 */ }\npublic static ServiceException exception(ErrorCode errorCode, Object... params) { /** 省略参数 */ }\n\n\n\n\n为什么使用 ServiceExceptionUtil 来构建 ServiceException 异常？\n\n错误提示的内容，支持使用管理后台进行动态配置，所以通过 ServiceExceptionUtil 获取内容的配置与格式化。\n\n\n# 4. 错误码\n\n错误码，对应 ErrorCode 类，枚举项目中的错误，全局唯一，方便定位是谁的错、错在哪。\n\n\n\n\n# 4.1 错误码分类\n\n错误码分成两类：全局的系统错误码、模块的业务错误码。\n\n# 4.1.1 系统错误码\n\n全局的系统错误码，使用 0-999 错误码段，和 HTTP 响应状态码 对应。虽然说，HTTP 响应状态码作为业务使用表达能力偏弱，但是使用在系统层面还是非常不错的。\n\n系统错误码定义在 GlobalErrorCodeConstants 类，代码如下：\n\n\n\n# 4.1.2 业务错误码\n\n模块的业务错误码，按照模块分配错误码的区间，避免模块之间的错误码冲突。\n\n① 业务错误码一共 10 位，分成 4 段，在 ServiceErrorCodeRange 分配，规则与代码如下图：\n\n\n\n② 每个业务模块，定义自己的 ErrorCodeConstants 错误码枚举类。以 yudao-module-system 模块举例子，代码如下：\n\n\n\n\n# 4.2 错误码管理（已删除）\n\n友情提示：\n\n最新版本的代码，已经移除“错误码管理”功能。原因是，该功能比较小众，可能只有极少数的用户需要~\n\n如果你系统里需要，可以参考 8093ef3（后端）、98bf5a1（前端） 把代码复制、粘贴回来。\n\n在管理后台的 [系统管理 -> 错误码管理] 菜单，可以进行错误码的管理。\n\n\n\n启动中的项目会每 60 秒，加载最新的错误码配置。所以，我们在修改完错误码的提示后，无需重启项目。\n\n# 4.2.1 手动添加\n\n点击 [新增] 按钮，进行错误码的手动添加。如下图所示：\n\n\n\n# 4.2.2 自动添加\n\n通过 yudao.error-code.constants-class-list 配置项，设置需要自动添加的 ErrorCodeConstants 错误码枚举类。如下图所示：\n\n\n\n项目启动时，会自动扫描对应的 ErrorCodeConstants 中的错误码，自动添加或修改错误码的配置。\n\n注意，自动添加的错误码的类型为【自动生成】，一旦在管理后台手动 [编辑] 后，该错误码就不再支持自动修改。\n\n自动添加是如何实现的？\n\n参见 system/framework/errorcode 包的代码。',
            normalizedContent: '本章节，将讲解异常相关的统一响应、异常处理、业务异常、错误码这 4 块的内容。\n\n\n# 1. 统一响应\n\n后端提供 restful api 给前端时，需要响应前端 api 调用是否成功：\n\n * 如果成功，成功的数据是什么。后续，前端会将数据渲染到页面上\n * 如果失败，失败的原因是什么。一般，前端会将原因弹出提示给用户\n\n因此，需要有统一响应，而不能是每个接口定义自己的风格。一般来说，统一响应返回信息如下：\n\n * 成功时，返回成功的状态码 + 数据\n * 失败时，返回失败的状态码 + 错误提示\n\n在标准的 restful api 的定义，是推荐使用 http 响应状态码 作为状态码。一般来说，我们实践很少这么去做，主要原因如下：\n\n * 业务返回的错误状态码很多，http 响应状态码无法很好的映射。例如说，活动还未开始、订单已取消等等\n * 学习成本高，开发者对 http 响应状态码不是很了解。例如说，可能只知道 200、403、404、500 几种常见的\n\n\n# 1.1 commonresult\n\nruoyi-vue-pro 项目在实践时，将状态码放在 response body 响应内容中返回。一共有 3 个字段，通过 commonresult 定义如下：\n\n\n\n// 成功响应\n{\n    code: 0,\n    data: {\n        id: 1,\n        username: "yudaoyuanma"\n    }\n}\n\n// 失败响应\n{\n    code: 233666,\n    message: "徐妈太丑了"\n}\n\n\n可以增加 success 字段吗？\n\n有些团队在实践时，会增加了 success 字段，通过 true 和 false 表示成功还是失败。\n这个看每个团队的习惯吧。艿艿的话，还是偏好基于约定，返回 0 时表示成功。\n\n失败时的 code 字段，使用全局的错误码，稍后在 「4. 错误码」 小节来讲解。\n\n① 在 restful api 成功时，定义 controller 对应方法的返回类型为 commonresult，并调用 #success(t data) 方法来返回。代码如下图：\n\n\n\ncommonresult 的 data 字段是泛型，建议定义对应的 vo 类，而不是使用 map 类。\n\n② 在 restful api 失败时，通过抛出 exception 异常，具体在 「2. 异常处理」 小节。\n\n\n# 1.2 使用 @controlleradvice ？\n\n在 spring mvc 中，可以使用 @controlleradvice 注解，通过 spring aop 拦截修改 controller 方法的返回结果，从而实现全局的统一返回。\n\n使用 @controlleradvice 注解的实战案例？\n\n如果你感兴趣的话，可以阅读 《芋道 spring boot springmvc 入门 》 文章的「4. 全局统一返回 」小节。\n\n为什么项目不采用这种方式呢？主要原因是，这样的方式“破坏”了方法的定义，导致一些隐性的问题。例如说，swagger 接口定义错误，展示的响应结果不是 commonresult。\n\n还有个原因，部分 restful api 不需要自动包装 commonresult 结果。例如说，第三方支付回调只需要返回 "success" 字符串。\n\n\n# 2. 异常处理\n\nrestful api 发生异常时，需要拦截 exception 异常，转换成统一响应的格式，否则前端无法处理。\n\n\n# 2.1 spring mvc 的异常\n\n在 spring mvc 中，通过 @controlleradvice + @exceptionhandler 注解，声明将指定类型的异常，转换成对应的 commonresult 响应。实现的代码，可见 globalexceptionhandler 类，代码如下：\n\n\n\n\n# 2.2 filter 的异常\n\n在请求被 spring mvc 处理之前，是先经过 filter 处理的，此时发生异常时，是无法通过 @exceptionhandler 注解来处理的。只能通过 try catch 的方式来实现，代码如下：\n\n\n\n\n# 3. 业务异常\n\n在 service 发生业务异常时，如果进行返回呢？例如说，用户名已经存在，商品库存不足等。常用的方案选择，主要有两种：\n\n * 方案一，使用 commonresult 统一响应结果，里面有错误码和错误提示，然后进行 return 返回\n * 方案二，使用 serviceexception 统一业务异常，里面有错误码和错误提示，然后进行 throw 抛出\n\n选择方案一 commonresult 会存在两个问题：\n\n * 因为 spring @transactional 声明式事务，是基于异常进行回滚的，如果使用 commonresult 返回，则事务回滚会非常麻烦\n * 当调用别的方法时，如果别人返回的是 commonresult 对象，还需要不断的进行判断，写起来挺麻烦的\n\n因此，项目采用方案二 serviceexception 异常。\n\n\n# 3.1 serviceexception\n\n定义 serviceexception 异常类，继承 runtimeexception 异常类（非受检），用于定义业务异常。代码如下：\n\n\n\n为什么继承 runtimeexception 异常？\n\n大多数业务场景下，我们无需处理 serviceexception 业务异常，而是通过 globalexceptionhandler 统一处理，转换成对应的 commonresult 对象，进而提示给前端即可。\n如果真的需要处理 serviceexception 时，通过 try catch 的方式进行主动捕获。\n\n\n# 3.2 serviceexceptionutil\n\n在 service 需抛出业务异常时，通过调用 serviceexceptionutil 的 #exception(errorcode errorcode, object... params) 方法来构建 serviceexception 异常，然后使用 throw 进行抛出。代码如下：\n\n// serviceexceptionutil.java\n\npublic static serviceexception exception(errorcode errorcode) { /** 省略参数 */ }\npublic static serviceexception exception(errorcode errorcode, object... params) { /** 省略参数 */ }\n\n\n\n\n为什么使用 serviceexceptionutil 来构建 serviceexception 异常？\n\n错误提示的内容，支持使用管理后台进行动态配置，所以通过 serviceexceptionutil 获取内容的配置与格式化。\n\n\n# 4. 错误码\n\n错误码，对应 errorcode 类，枚举项目中的错误，全局唯一，方便定位是谁的错、错在哪。\n\n\n\n\n# 4.1 错误码分类\n\n错误码分成两类：全局的系统错误码、模块的业务错误码。\n\n# 4.1.1 系统错误码\n\n全局的系统错误码，使用 0-999 错误码段，和 http 响应状态码 对应。虽然说，http 响应状态码作为业务使用表达能力偏弱，但是使用在系统层面还是非常不错的。\n\n系统错误码定义在 globalerrorcodeconstants 类，代码如下：\n\n\n\n# 4.1.2 业务错误码\n\n模块的业务错误码，按照模块分配错误码的区间，避免模块之间的错误码冲突。\n\n① 业务错误码一共 10 位，分成 4 段，在 serviceerrorcoderange 分配，规则与代码如下图：\n\n\n\n② 每个业务模块，定义自己的 errorcodeconstants 错误码枚举类。以 yudao-module-system 模块举例子，代码如下：\n\n\n\n\n# 4.2 错误码管理（已删除）\n\n友情提示：\n\n最新版本的代码，已经移除“错误码管理”功能。原因是，该功能比较小众，可能只有极少数的用户需要~\n\n如果你系统里需要，可以参考 8093ef3（后端）、98bf5a1（前端） 把代码复制、粘贴回来。\n\n在管理后台的 [系统管理 -> 错误码管理] 菜单，可以进行错误码的管理。\n\n\n\n启动中的项目会每 60 秒，加载最新的错误码配置。所以，我们在修改完错误码的提示后，无需重启项目。\n\n# 4.2.1 手动添加\n\n点击 [新增] 按钮，进行错误码的手动添加。如下图所示：\n\n\n\n# 4.2.2 自动添加\n\n通过 yudao.error-code.constants-class-list 配置项，设置需要自动添加的 errorcodeconstants 错误码枚举类。如下图所示：\n\n\n\n项目启动时，会自动扫描对应的 errorcodeconstants 中的错误码，自动添加或修改错误码的配置。\n\n注意，自动添加的错误码的类型为【自动生成】，一旦在管理后台手动 [编辑] 后，该错误码就不再支持自动修改。\n\n自动添加是如何实现的？\n\n参见 system/framework/errorcode 包的代码。',
            charsets: {
                cjk: !0
            }
        }, {
            title: "参数校验、时间传参",
            frontmatter: {
                title: "参数校验、时间传参",
                date: "2022-03-26T09:09:00.000Z",
                permalink: "/validator"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/02.%E5%90%8E%E7%AB%AF%E6%89%8B%E5%86%8C/16.%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C.html",
            relativePath: "01.开发指南/02.后端手册/16.参数校验.md",
            key: "v-01a3c3ae",
            path: "/validator/",
            headers: [{
                level: 2,
                title: "1. 参数校验注解",
                slug: "_1-参数校验注解",
                normalizedTitle: "1. 参数校验注解",
                charIndex: 242
            }, {
                level: 3,
                title: "1.1 常用注解",
                slug: "_1-1-常用注解",
                normalizedTitle: "1.1 常用注解",
                charIndex: 297
            }, {
                level: 3,
                title: "1.2 不常用注解",
                slug: "_1-2-不常用注解",
                normalizedTitle: "1.2 不常用注解",
                charIndex: 1237
            }, {
                level: 2,
                title: "2. 参数校验使用",
                slug: "_2-参数校验使用",
                normalizedTitle: "2. 参数校验使用",
                charIndex: 1882
            }, {
                level: 2,
                title: "3. 自定义注解",
                slug: "_3-自定义注解",
                normalizedTitle: "3. 自定义注解",
                charIndex: 3576
            }, {
                level: 2,
                title: "4. 更多使用文档",
                slug: "_4-更多使用文档",
                normalizedTitle: "4. 更多使用文档",
                charIndex: 4874
            }, {
                level: 2,
                title: "5. 时间传参",
                slug: "_5-时间传参",
                normalizedTitle: "5. 时间传参",
                charIndex: 4986
            }, {
                level: 3,
                title: "5.1 Query 时间传参",
                slug: "_5-1-query-时间传参",
                normalizedTitle: "5.1 query 时间传参",
                charIndex: 4998
            }, {
                level: 3,
                title: "5.2 Request Body 时间传参",
                slug: "_5-2-request-body-时间传参",
                normalizedTitle: "5.2 request body 时间传参",
                charIndex: 5610
            }, {
                level: 3,
                title: "5.3 Response Body 时间响应",
                slug: "_5-3-response-body-时间响应",
                normalizedTitle: "5.3 response body 时间响应",
                charIndex: 5853
            }, {
                level: 3,
                title: "5.4 如何自定义 JSON 时间格式？",
                slug: "_5-4-如何自定义-json-时间格式",
                normalizedTitle: "5.4 如何自定义 json 时间格式？",
                charIndex: 5978
            }],
            headersStr: "1. 参数校验注解 1.1 常用注解 1.2 不常用注解 2. 参数校验使用 3. 自定义注解 4. 更多使用文档 5. 时间传参 5.1 Query 时间传参 5.2 Request Body 时间传参 5.3 Response Body 时间响应 5.4 如何自定义 JSON 时间格式？",
            content: '项目使用 Hibernate Validator 框架，对 RESTful API 接口进行参数的校验，以保证最终数据入库的正确性。例如说，用户注册时，会校验手机格式的正确性，密码非弱密码。\n\n如果参数校验不通过，会抛出 ConstraintViolationException 异常，被全局的异常处理捕获，返回“请求参数不正确”的响应。示例如下：\n\n{\n  "code": 400,\n  "data": null,\n  "msg": "请求参数不正确:密码不能为空"\n}\n\n\n\n# 1. 参数校验注解\n\nValidator 内置了 20+ 个参数校验注解，整理成常用与不常用的注解。\n\n\n# 1.1 常用注解\n\n注解                                           功能\n@NotBlank                                    只能用于字符串不为 null ，并且字符串 #trim() 以后 length 要大于 0\n@NotEmpty                                    集合对象的元素不为 0 ，即集合不为空，也可以用于字符串不为 null\n@NotNull                                     不能为 null\n@Pattern(value)                              被注释的元素必须符合指定的正则表达式\n@Max(value)                                  该字段的值只能小于或等于该值\n@Min(value)                                  该字段的值只能大于或等于该值\n@Range(min=, max=)                           检被注释的元素必须在合适的范围内\n@Size(max, min)                              检查该字段的 size 是否在 min 和 max 之间，可以是字符串、数组、集合、Map 等\n@Length(max, min)                            被注释的字符串的大小必须在指定的范围内。\n@AssertFalse                                 被注释的元素必须为 true\n@AssertTrue                                  被注释的元素必须为 false\n@Email                                       被注释的元素必须是电子邮箱地址\n@URL(protocol=,host=,port=,regexp=,flags=)   被注释的字符串必须是一个有效的 URL\n\n\n# 1.2 不常用注解\n\n注解                           功能\n@Null                        必须为 null\n@DecimalMax(value)           被注释的元素必须是一个数字，其值必须小于等于指定的最大值\n@DecimalMin(value)           被注释的元素必须是一个数字，其值必须大于等于指定的最小值\n@Digits(integer, fraction)   被注释的元素必须是一个数字，其值必须在可接受的范围内\n@Positive                    判断正数\n@PositiveOrZero              判断正数或 0\n@Negative                    判断负数\n@NegativeOrZero              判断负数或 0\n@Future                      被注释的元素必须是一个将来的日期\n@FutureOrPresent             判断日期是否是将来或现在日期\n@Past                        检查该字段的日期是在过去\n@PastOrPresent               判断日期是否是过去或现在日期\n@SafeHtml                    判断提交的 HTML 是否安全。例如说，不能包含 JavaScript 脚本等等\n\n\n# 2. 参数校验使用\n\n只需要三步，即可开启参数校验的功能。\n\n〇 第零步，引入参数校验的 spring-boot-starter-validation 依赖。一般不需要做，项目默认已经引入。\n\n① 第一步，在需要参数校验的类上，添加 @Validated 注解，例如说 Controller、Service 类。代码如下：\n\n// Controller 示例\n@Validated\npublic class AuthController {}\n\n// Service 示例，一般放在实现类上\n@Service\n@Validated\npublic class AdminAuthServiceImpl implements AdminAuthService {}\n\n\n② 第二步（情况一）如果方法的参数是 Bean 类型，则在方法参数上添加 @Valid 注解，并在 Bean 类上添加参数校验的注解。代码如下：\n\n// Controller 示例\n@Validated\npublic class AuthController {\n\n    @PostMapping("/login")\n    public CommonResult<AuthLoginRespVO> login(@RequestBody @Valid AuthLoginReqVO reqVO) {}\n    \n}\n// Service 示例，一般放在接口上\npublic interface AdminAuthService {\n    \n    String login(@Valid AuthLoginReqVO reqVO, String userIp, String userAgent);\n}\n\n// Bean 类的示例。一般建议添加参数注解到属性上。原因：采用 Lombok 后，很少使用 getter 方法\npublic class AuthLoginReqVO {\n\n    @NotEmpty(message = "登录账号不能为空")\n    @Length(min = 4, max = 16, message = "账号长度为 4-16 位")\n    @Pattern(regexp = "^[A-Za-z0-9]+$", message = "账号格式为数字以及字母")\n    private String username;\n\n    @NotEmpty(message = "密码不能为空")\n    @Length(min = 4, max = 16, message = "密码长度为 4-16 位")\n    private String password;\n    \n}\n\n\n② 第二步（情况二）如果方法的参数是普通类型，则在方法参数上直接添加参数校验的注解。代码如下：\n\n// Controller 示例\n@Validated\npublic class DictDataController {\n\n    @GetMapping(value = "/get")\n    public CommonResult<DictDataRespVO> getDictData(@RequestParam("id") @NotNull(message = "编号不能为空") Long id) {}\n    \n}\n\n// Service 示例，一般放在接口上\npublic interface DictDataService {\n\n    DictDataDO getDictData(@NotNull(message = "编号不能为空") Long id);\n    \n}\n\n\n③ 启动项目，模拟调用 RESTful API 接口，少填写几个参数，看看参数校验是否生效。\n\n疑问：Controller 做了参数校验后，Service 是否需要做参数校验？\n\n是需要的。Service 可能会被别的 Service 进行调用，也会存在参数不正确的情况，所以必须进行参数校验。\n\n\n# 3. 自定义注解\n\n如果 Validator 内置的参数校验注解不满足需求时，我们也可以自定义参数校验的注解。\n\n在项目的 yudao-common 的 validation 包下，就自定义了多个参数校验的注解，以 @Mobile 注解来举例，它提供了手机格式的校验。\n\n① 第一步，新建 @Mobile 注解，并设置自定义校验器为 MobileValidator 类。代码如下：\n\n@Target({\n        ElementType.METHOD,\n        ElementType.FIELD,\n        ElementType.ANNOTATION_TYPE,\n        ElementType.CONSTRUCTOR,\n        ElementType.PARAMETER,\n        ElementType.TYPE_USE\n})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Constraint(\n        validatedBy = MobileValidator.class // 设置校验器\n)\npublic @interface Mobile {\n\n    String message() default "手机号格式不正确";\n\n    Class<?>[] groups() default {};\n\n    Class<? extends Payload>[] payload() default {};\n\n}\n\n\n② 第二步，新建 MobileValidator 校验器。代码如下：\n\npublic class MobileValidator implements ConstraintValidator<Mobile, String> {\n\n    @Override\n    public void initialize(Mobile annotation) {\n    }\n\n    @Override\n    public boolean isValid(String value, ConstraintValidatorContext context) {\n        // 如果手机号为空，默认不校验，即校验通过\n        if (StrUtil.isEmpty(value)) {\n            return true;\n        }\n        // 校验手机\n        return ValidationUtils.isMobile(value);\n    }\n\n}\n\n\n③ 第三步，在需要手机格式校验的参数上添加 @Mobile 注解。示例代码如下：\n\npublic class AppAuthLoginReqVO {\n\n    @NotEmpty(message = "手机号不能为空")\n    @Mobile // <=== here\n    private String mobile;\n\n}\n\n\n\n# 4. 更多使用文档\n\n更多关于 Validator 的使用，可以系统阅读 《芋道 Spring Boot 参数校验 Validation 入门 》 文章。\n\n例如说，手动参数校验、分组校验、国际化 i18n 等等。\n\n\n# 5. 时间传参\n\n\n# 5.1 Query 时间传参\n\nQuery 时间传参，指的是 GET 请求、或者 POST 的 form-data 请求。\n\n① 后端接收时间参数时，需要添加 SpringMVC 的 @DateTimeFormat 注解，并设置时间格式。例如说：\n\n// JobLogPageReqVO.java\n@DateTimeFormat(pattern = FORMAT_YEAR_MONTH_DAY_HOUR_MINUTE_SECOND)\nprivate LocalDateTime beginTime;\n\n// UserPageReqVO.java\n@DateTimeFormat(pattern = FORMAT_YEAR_MONTH_DAY_HOUR_MINUTE_SECOND)\nprivate LocalDateTime[] createTime;\n\n\n② 前端传递时间参数时，需要时间格式为 yyyy-MM-dd HH:mm:ss，和上面的 FORMAT_YEAR_MONTH_DAY_HOUR_MINUTE_SECOND 对应。例如说前端 yudao-ui-admin-vue3 项目：\n\n * views/infra/job/logger/index.vue 的 beginTime 或 endTime 参数\n\n * views/system/user/index.vue 的 createTime 参数\n\n\n# 5.2 Request Body 时间传参\n\nRequest Body 时间传参，指的是 Post、PUT 等请求，通过 JSON 格式。\n\n① 后端接收时间参数时，需要添加 SpringMVC 的 @RequestBody 注解，使用 LocalDateTime 属性进行接收。例如说：\n\n\n\n② 前端传递时间参数时，需要时间格式为 Long 时间戳。例如说：\n\n * views/system/tenant/TenantForm.vue 的 expireTime 参数\n\n\n\n\n# 5.3 Response Body 时间响应\n\nJSON 返回的时间，使用 LocalDateTime 定义属性，会被序列化为 Long 时间戳进行相应。\n\n例如说 TenantRespVO 的 createTime 属性，效果如下图：\n\n\n\n\n# 5.4 如何自定义 JSON 时间格式？\n\n# 5.4.1 为什么使用 Long 时间戳呢？\n\n每个项目希望展示的时间格式可能不同，有希望 yyyy-MM-dd HH:mm:ss，也有希望 yyyy/MM/dd HH:mm:ss，又或者是其它。\n\n而 Long 时间戳是比较标准的，没有任何“产品需求”的味道，所以使用它。 至于业务希望展示成什么样子，可以通过前端封装统一的 format 方法去实现，更加规范。\n\n它是通过 LocalDateTime 自定义的 TimestampLocalDateTimeSerializer 和 TimestampLocalDateTimeDeserializer 实现，之后进行如下配置：\n\n\n\n# 5.4.1 全局配置时间格式\n\n如果你想 JSON 全局配置成 yyyy-MM-dd HH:mm:ss 或其它时间格式，通过使用 Jackson 内置的 LocalDateTimeSerializer 和 LocalDateTimeDeserializer 即可，如下图所示：\n\n\n\n# 5.4.2 局部配置时间格式\n\n如果只是部分 VO 的字段想自定义 yyyy-MM-dd HH:mm:ss 或其它时间格式，可通过 Jackson 内置的 @JsonFormat 注解，如下所示：\n\n// UserRespVO.java\n\n@JsonSerialize(using = LocalDateTimeSerializer.class) // 序列化（响应）\n@JsonDeserialize(using = LocalDateDeserializer.class) // 反序列化（请求）\n@JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")\nprivate LocalDateTime createTime;\n',
            normalizedContent: '项目使用 hibernate validator 框架，对 restful api 接口进行参数的校验，以保证最终数据入库的正确性。例如说，用户注册时，会校验手机格式的正确性，密码非弱密码。\n\n如果参数校验不通过，会抛出 constraintviolationexception 异常，被全局的异常处理捕获，返回“请求参数不正确”的响应。示例如下：\n\n{\n  "code": 400,\n  "data": null,\n  "msg": "请求参数不正确:密码不能为空"\n}\n\n\n\n# 1. 参数校验注解\n\nvalidator 内置了 20+ 个参数校验注解，整理成常用与不常用的注解。\n\n\n# 1.1 常用注解\n\n注解                                           功能\n@notblank                                    只能用于字符串不为 null ，并且字符串 #trim() 以后 length 要大于 0\n@notempty                                    集合对象的元素不为 0 ，即集合不为空，也可以用于字符串不为 null\n@notnull                                     不能为 null\n@pattern(value)                              被注释的元素必须符合指定的正则表达式\n@max(value)                                  该字段的值只能小于或等于该值\n@min(value)                                  该字段的值只能大于或等于该值\n@range(min=, max=)                           检被注释的元素必须在合适的范围内\n@size(max, min)                              检查该字段的 size 是否在 min 和 max 之间，可以是字符串、数组、集合、map 等\n@length(max, min)                            被注释的字符串的大小必须在指定的范围内。\n@assertfalse                                 被注释的元素必须为 true\n@asserttrue                                  被注释的元素必须为 false\n@email                                       被注释的元素必须是电子邮箱地址\n@url(protocol=,host=,port=,regexp=,flags=)   被注释的字符串必须是一个有效的 url\n\n\n# 1.2 不常用注解\n\n注解                           功能\n@null                        必须为 null\n@decimalmax(value)           被注释的元素必须是一个数字，其值必须小于等于指定的最大值\n@decimalmin(value)           被注释的元素必须是一个数字，其值必须大于等于指定的最小值\n@digits(integer, fraction)   被注释的元素必须是一个数字，其值必须在可接受的范围内\n@positive                    判断正数\n@positiveorzero              判断正数或 0\n@negative                    判断负数\n@negativeorzero              判断负数或 0\n@future                      被注释的元素必须是一个将来的日期\n@futureorpresent             判断日期是否是将来或现在日期\n@past                        检查该字段的日期是在过去\n@pastorpresent               判断日期是否是过去或现在日期\n@safehtml                    判断提交的 html 是否安全。例如说，不能包含 javascript 脚本等等\n\n\n# 2. 参数校验使用\n\n只需要三步，即可开启参数校验的功能。\n\n〇 第零步，引入参数校验的 spring-boot-starter-validation 依赖。一般不需要做，项目默认已经引入。\n\n① 第一步，在需要参数校验的类上，添加 @validated 注解，例如说 controller、service 类。代码如下：\n\n// controller 示例\n@validated\npublic class authcontroller {}\n\n// service 示例，一般放在实现类上\n@service\n@validated\npublic class adminauthserviceimpl implements adminauthservice {}\n\n\n② 第二步（情况一）如果方法的参数是 bean 类型，则在方法参数上添加 @valid 注解，并在 bean 类上添加参数校验的注解。代码如下：\n\n// controller 示例\n@validated\npublic class authcontroller {\n\n    @postmapping("/login")\n    public commonresult<authloginrespvo> login(@requestbody @valid authloginreqvo reqvo) {}\n    \n}\n// service 示例，一般放在接口上\npublic interface adminauthservice {\n    \n    string login(@valid authloginreqvo reqvo, string userip, string useragent);\n}\n\n// bean 类的示例。一般建议添加参数注解到属性上。原因：采用 lombok 后，很少使用 getter 方法\npublic class authloginreqvo {\n\n    @notempty(message = "登录账号不能为空")\n    @length(min = 4, max = 16, message = "账号长度为 4-16 位")\n    @pattern(regexp = "^[a-za-z0-9]+$", message = "账号格式为数字以及字母")\n    private string username;\n\n    @notempty(message = "密码不能为空")\n    @length(min = 4, max = 16, message = "密码长度为 4-16 位")\n    private string password;\n    \n}\n\n\n② 第二步（情况二）如果方法的参数是普通类型，则在方法参数上直接添加参数校验的注解。代码如下：\n\n// controller 示例\n@validated\npublic class dictdatacontroller {\n\n    @getmapping(value = "/get")\n    public commonresult<dictdatarespvo> getdictdata(@requestparam("id") @notnull(message = "编号不能为空") long id) {}\n    \n}\n\n// service 示例，一般放在接口上\npublic interface dictdataservice {\n\n    dictdatado getdictdata(@notnull(message = "编号不能为空") long id);\n    \n}\n\n\n③ 启动项目，模拟调用 restful api 接口，少填写几个参数，看看参数校验是否生效。\n\n疑问：controller 做了参数校验后，service 是否需要做参数校验？\n\n是需要的。service 可能会被别的 service 进行调用，也会存在参数不正确的情况，所以必须进行参数校验。\n\n\n# 3. 自定义注解\n\n如果 validator 内置的参数校验注解不满足需求时，我们也可以自定义参数校验的注解。\n\n在项目的 yudao-common 的 validation 包下，就自定义了多个参数校验的注解，以 @mobile 注解来举例，它提供了手机格式的校验。\n\n① 第一步，新建 @mobile 注解，并设置自定义校验器为 mobilevalidator 类。代码如下：\n\n@target({\n        elementtype.method,\n        elementtype.field,\n        elementtype.annotation_type,\n        elementtype.constructor,\n        elementtype.parameter,\n        elementtype.type_use\n})\n@retention(retentionpolicy.runtime)\n@documented\n@constraint(\n        validatedby = mobilevalidator.class // 设置校验器\n)\npublic @interface mobile {\n\n    string message() default "手机号格式不正确";\n\n    class<?>[] groups() default {};\n\n    class<? extends payload>[] payload() default {};\n\n}\n\n\n② 第二步，新建 mobilevalidator 校验器。代码如下：\n\npublic class mobilevalidator implements constraintvalidator<mobile, string> {\n\n    @override\n    public void initialize(mobile annotation) {\n    }\n\n    @override\n    public boolean isvalid(string value, constraintvalidatorcontext context) {\n        // 如果手机号为空，默认不校验，即校验通过\n        if (strutil.isempty(value)) {\n            return true;\n        }\n        // 校验手机\n        return validationutils.ismobile(value);\n    }\n\n}\n\n\n③ 第三步，在需要手机格式校验的参数上添加 @mobile 注解。示例代码如下：\n\npublic class appauthloginreqvo {\n\n    @notempty(message = "手机号不能为空")\n    @mobile // <=== here\n    private string mobile;\n\n}\n\n\n\n# 4. 更多使用文档\n\n更多关于 validator 的使用，可以系统阅读 《芋道 spring boot 参数校验 validation 入门 》 文章。\n\n例如说，手动参数校验、分组校验、国际化 i18n 等等。\n\n\n# 5. 时间传参\n\n\n# 5.1 query 时间传参\n\nquery 时间传参，指的是 get 请求、或者 post 的 form-data 请求。\n\n① 后端接收时间参数时，需要添加 springmvc 的 @datetimeformat 注解，并设置时间格式。例如说：\n\n// joblogpagereqvo.java\n@datetimeformat(pattern = format_year_month_day_hour_minute_second)\nprivate localdatetime begintime;\n\n// userpagereqvo.java\n@datetimeformat(pattern = format_year_month_day_hour_minute_second)\nprivate localdatetime[] createtime;\n\n\n② 前端传递时间参数时，需要时间格式为 yyyy-mm-dd hh:mm:ss，和上面的 format_year_month_day_hour_minute_second 对应。例如说前端 yudao-ui-admin-vue3 项目：\n\n * views/infra/job/logger/index.vue 的 begintime 或 endtime 参数\n\n * views/system/user/index.vue 的 createtime 参数\n\n\n# 5.2 request body 时间传参\n\nrequest body 时间传参，指的是 post、put 等请求，通过 json 格式。\n\n① 后端接收时间参数时，需要添加 springmvc 的 @requestbody 注解，使用 localdatetime 属性进行接收。例如说：\n\n\n\n② 前端传递时间参数时，需要时间格式为 long 时间戳。例如说：\n\n * views/system/tenant/tenantform.vue 的 expiretime 参数\n\n\n\n\n# 5.3 response body 时间响应\n\njson 返回的时间，使用 localdatetime 定义属性，会被序列化为 long 时间戳进行相应。\n\n例如说 tenantrespvo 的 createtime 属性，效果如下图：\n\n\n\n\n# 5.4 如何自定义 json 时间格式？\n\n# 5.4.1 为什么使用 long 时间戳呢？\n\n每个项目希望展示的时间格式可能不同，有希望 yyyy-mm-dd hh:mm:ss，也有希望 yyyy/mm/dd hh:mm:ss，又或者是其它。\n\n而 long 时间戳是比较标准的，没有任何“产品需求”的味道，所以使用它。 至于业务希望展示成什么样子，可以通过前端封装统一的 format 方法去实现，更加规范。\n\n它是通过 localdatetime 自定义的 timestamplocaldatetimeserializer 和 timestamplocaldatetimedeserializer 实现，之后进行如下配置：\n\n\n\n# 5.4.1 全局配置时间格式\n\n如果你想 json 全局配置成 yyyy-mm-dd hh:mm:ss 或其它时间格式，通过使用 jackson 内置的 localdatetimeserializer 和 localdatetimedeserializer 即可，如下图所示：\n\n\n\n# 5.4.2 局部配置时间格式\n\n如果只是部分 vo 的字段想自定义 yyyy-mm-dd hh:mm:ss 或其它时间格式，可通过 jackson 内置的 @jsonformat 注解，如下所示：\n\n// userrespvo.java\n\n@jsonserialize(using = localdatetimeserializer.class) // 序列化（响应）\n@jsondeserialize(using = localdatedeserializer.class) // 反序列化（请求）\n@jsonformat(pattern = "yyyy-mm-dd hh:mm:ss")\nprivate localdatetime createtime;\n',
            charsets: {
                cjk: !0
            }
        }, {
            title: "分页实现",
            frontmatter: {
                title: "分页实现",
                date: "2022-03-26T17:25:47.000Z",
                permalink: "/page-feature"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/02.%E5%90%8E%E7%AB%AF%E6%89%8B%E5%86%8C/17.%E5%88%86%E9%A1%B5%E5%AE%9E%E7%8E%B0.html",
            relativePath: "01.开发指南/02.后端手册/17.分页实现.md",
            key: "v-4e5e44e1",
            path: "/page-feature/",
            headers: [{
                level: 2,
                title: "1. 前端分页实现",
                slug: "_1-前端分页实现",
                normalizedTitle: "1. 前端分页实现",
                charIndex: 120
            }, {
                level: 3,
                title: "1.1 Vue 界面",
                slug: "_1-1-vue-界面",
                normalizedTitle: "1.1 vue 界面",
                charIndex: 134
            }, {
                level: 3,
                title: "1.2 API 请求",
                slug: "_1-2-api-请求",
                normalizedTitle: "1.2 api 请求",
                charIndex: 2880
            }, {
                level: 2,
                title: "2. 后端分页实现",
                slug: "_2-后端分页实现",
                normalizedTitle: "2. 后端分页实现",
                charIndex: 3110
            }, {
                level: 3,
                title: "2.1 Controller 接口",
                slug: "_2-1-controller-接口",
                normalizedTitle: "2.1 controller 接口",
                charIndex: 3124
            }, {
                level: 3,
                title: "2.2 Mapper 查询",
                slug: "_2-2-mapper-查询",
                normalizedTitle: "2.2 mapper 查询",
                charIndex: 5589
            }],
            headersStr: "1. 前端分页实现 1.1 Vue 界面 1.2 API 请求 2. 后端分页实现 2.1 Controller 接口 2.2 Mapper 查询",
            content: ' * 前端：基于 Element UI 分页组件 Pagination\n * 后端：基于 MyBatis Plus 分页功能，二次封装\n\n以 [系统管理 -> 租户管理 -> 租户列表] 菜单为例子，讲解它的分页 + 搜索的实现。\n\n\n# 1. 前端分页实现\n\n\n# 1.1 Vue 界面\n\n界面 tenant/index.vue 相关的代码如下：\n\n<template>\n    \x3c!-- 搜索工作栏 --\x3e\n    <el-form :model="queryParams" ref="queryForm" size="small" :inline="true" v-show="showSearch" label-width="68px">\n      <el-form-item label="租户名" prop="name">\n        <el-input v-model="queryParams.name" placeholder="请输入租户名" clearable @keyup.enter.native="handleQuery"/>\n      </el-form-item>\n      <el-form-item label="联系人" prop="contactName">\n        <el-input v-model="queryParams.contactName" placeholder="请输入联系人" clearable @keyup.enter.native="handleQuery"/>\n      </el-form-item>\n      <el-form-item label="联系手机" prop="contactMobile">\n        <el-input v-model="queryParams.contactMobile" placeholder="请输入联系手机" clearable @keyup.enter.native="handleQuery"/>\n      </el-form-item>\n      <el-form-item label="租户状态" prop="status">\n        <el-select v-model="queryParams.status" placeholder="请选择租户状态" clearable>\n          <el-option v-for="dict in this.getDictDatas(DICT_TYPE.COMMON_STATUS)"\n                       :key="dict.value" :label="dict.label" :value="dict.value"/>\n        </el-select>\n      </el-form-item>\n      <el-form-item>\n        <el-button type="primary" icon="el-icon-search" @click="handleQuery">搜索</el-button>\n        <el-button icon="el-icon-refresh" @click="resetQuery">重置</el-button>\n      </el-form-item>\n    </el-form>\n    \n    \x3c!-- 列表 --\x3e\n    <el-table v-loading="loading" :data="list">\n        \x3c!-- 省略每一列... --\x3e\n    </el-table>\n    \n    \x3c!-- 分页组件 --\x3e\n    <pagination v-show="total > 0" :total="total" :page.sync="queryParams.pageNo" :limit.sync="queryParams.pageSize" \n                @pagination="getList"/>\n\n</template>\n\n<script>\nimport { getTenantPage } from "@/api/system/tenant";\n\nexport default {\n\tname: "Tenant",\n\tcomponents: {},\n\tdata() {\n      // 遮罩层\n      return {\n        // 遮罩层\n        loading: true,\n        // 显示搜索条件\n        showSearch: true,\n        // 总条数\n        total: 0,\n        // 租户列表\n        list: [],\n        // 查询参数\n        queryParams: {\n          pageNo: 1,\n          pageSize: 10,\n          // 搜索条件\n          name: null,\n          contactName: null,\n          contactMobile: null,\n          status: undefined,\n        },\n      }\n\t},\n\tcreated() {\n\t  this.getList();\n\t},\n\tmethods: {\n\t  /** 查询列表 */\n\t  getList() {\n\t    this.loading = true;\n\t    // 处理查询参数\n\t    let params = {...this.queryParams};\n\t\t// 执行查询\n\t    getTenantPage(params).then(response => {\n\t\t  this.list = response.data.list;\n\t\t  this.total = response.data.total;\n\t\t  this.loading = false;\n\t\t});\n      },\n      /** 搜索按钮操作 */\n      handleQuery() {\n        this.queryParams.pageNo = 1;\n        this.getList();\n      },\n      /** 重置按钮操作 */\n      resetQuery() {\n        this.resetForm("queryForm");\n        this.handleQuery();\n      }\n    }\n}\n<\/script>\n\n\n\n# 1.2 API 请求\n\n请求 system/tenant.js 相关的代码如下：\n\nimport request from \'@/utils/request\'\n\n// 获得租户分页\nexport function getTenantPage(query) {\n  return request({\n    url: \'/system/tenant/page\',\n    method: \'get\',\n    params: query\n  })\n}\n\n\n\n# 2. 后端分页实现\n\n\n# 2.1 Controller 接口\n\n在 TenantController 类中，定义 /admin-api/system/tenant/page 接口。代码如下：\n\n@Tag(name = "管理后台 - 租户")\n@RestController\n@RequestMapping("/system/tenant")\npublic class TenantController {\n\n    @Resource\n    private TenantService tenantService;\n\n    @GetMapping("/page")\n    @Operation(summary = "获得租户分页")\n    @PreAuthorize("@ss.hasPermission(\'system:tenant:query\')")\n    public CommonResult<PageResult<TenantRespVO>> getTenantPage(@Valid TenantPageReqVO pageVO) {\n        PageResult<TenantDO> pageResult = tenantService.getTenantPage(pageVO);\n        return success(TenantConvert.INSTANCE.convertPage(pageResult));\n    }\n    \n}\n\n\n * Request 分页请求，使用 TenantPageReqVO 类，它继承 PageParam 类\n * Response 分页结果，使用 PageResult 类，每一项是 TenantRespVO 类\n\n# 2.1.1 分页参数 PageParam\n\n分页请求，需要继承 PageParam 类。代码如下：\n\n@Schema(description="分页参数")\n@Data\npublic class PageParam implements Serializable {\n\n    private static final Integer PAGE_NO = 1;\n    private static final Integer PAGE_SIZE = 10;\n\n    @Schema(description = "页码，从 1 开始", required = true,example = "1")\n    @NotNull(message = "页码不能为空")\n    @Min(value = 1, message = "页码最小值为 1")\n    private Integer pageNo = PAGE_NO;\n\n    @Schema(description = "每页条数，最大值为 100", required = true, example = "10")\n    @NotNull(message = "每页条数不能为空")\n    @Min(value = 1, message = "每页条数最小值为 1")\n    @Max(value = 100, message = "每页条数最大值为 100")\n    private Integer pageSize = PAGE_SIZE;\n\n}\n\n\n分页条件，在子类中进行定义。以 TenantPageReqVO 举例子，代码如下：\n\n@Schema(description = "管理后台 - 租户分页 Request VO")\n@Data\n@EqualsAndHashCode(callSuper = true)\n@ToString(callSuper = true)\npublic class TenantPageReqVO extends PageParam {\n\n    @Schema(description = "租户名", example = "芋道")\n    private String name;\n\n    @Schema(description = "联系人", example = "芋艿")\n    private String contactName;\n\n    @Schema(description = "联系手机", example = "15601691300")\n    private String contactMobile;\n\n    @Schema(description = "租户状态（0正常 1停用）", example = "1")\n    private Integer status;\n\n    @DateTimeFormat(pattern = FORMAT_YEAR_MONTH_DAY_HOUR_MINUTE_SECOND)\n    @Schema(description = "创建时间")\n    private LocalDateTime[] createTime;\n\n}\n\n\n# 2.1.2 分页结果 PageResult\n\n分页结果 PageResult 类，代码如下：\n\n@Schema(description = "分页结果")\n@Data\npublic final class PageResult<T> implements Serializable {\n\n    @Schema(description = "数据", required = true)\n    private List<T> list;\n\n    @Schema(description = "总量", required = true)\n    private Long total;\n    \n}\n\n\n分页结果的数据 list 的每一项，通过自定义 VO 类，例如说 TenantRespVO 类。\n\n\n# 2.2 Mapper 查询\n\n在 TenantMapper 类中，定义 selectPage 查询方法。代码如下：\n\n@Mapper\npublic interface TenantMapper extends BaseMapperX<TenantDO> {\n\n    default PageResult<TenantDO> selectPage(TenantPageReqVO reqVO) {\n        return selectPage(reqVO, new LambdaQueryWrapperX<TenantDO>()\n                .likeIfPresent(TenantDO::getName, reqVO.getName()) // 如果 name 不为空，则进行 like 查询\n                .likeIfPresent(TenantDO::getContactName, reqVO.getContactName())\n                .likeIfPresent(TenantDO::getContactMobile, reqVO.getContactMobile())\n                .eqIfPresent(TenantDO::getStatus, reqVO.getStatus()) // 如果 status 不为空，则进行 = 查询\n                .betweenIfPresent(TenantDO::getCreateTime, reqVO.getBeginCreateTime(), reqVO.getEndCreateTime()) // 如果 create 不为空，则进行 between 查询\n                .orderByDesc(TenantDO::getId)); // 按照 id 倒序\n    }\n    \n}\n\n\n针对 MyBatis Plus 分页查询的二次分装，在 BaseMapperX 中实现，主要是将 MyBatis 的分页结果 IPage，转换成项目的分页结果 PageResult。代码如下图：\n\n',
            normalizedContent: ' * 前端：基于 element ui 分页组件 pagination\n * 后端：基于 mybatis plus 分页功能，二次封装\n\n以 [系统管理 -> 租户管理 -> 租户列表] 菜单为例子，讲解它的分页 + 搜索的实现。\n\n\n# 1. 前端分页实现\n\n\n# 1.1 vue 界面\n\n界面 tenant/index.vue 相关的代码如下：\n\n<template>\n    \x3c!-- 搜索工作栏 --\x3e\n    <el-form :model="queryparams" ref="queryform" size="small" :inline="true" v-show="showsearch" label-width="68px">\n      <el-form-item label="租户名" prop="name">\n        <el-input v-model="queryparams.name" placeholder="请输入租户名" clearable @keyup.enter.native="handlequery"/>\n      </el-form-item>\n      <el-form-item label="联系人" prop="contactname">\n        <el-input v-model="queryparams.contactname" placeholder="请输入联系人" clearable @keyup.enter.native="handlequery"/>\n      </el-form-item>\n      <el-form-item label="联系手机" prop="contactmobile">\n        <el-input v-model="queryparams.contactmobile" placeholder="请输入联系手机" clearable @keyup.enter.native="handlequery"/>\n      </el-form-item>\n      <el-form-item label="租户状态" prop="status">\n        <el-select v-model="queryparams.status" placeholder="请选择租户状态" clearable>\n          <el-option v-for="dict in this.getdictdatas(dict_type.common_status)"\n                       :key="dict.value" :label="dict.label" :value="dict.value"/>\n        </el-select>\n      </el-form-item>\n      <el-form-item>\n        <el-button type="primary" icon="el-icon-search" @click="handlequery">搜索</el-button>\n        <el-button icon="el-icon-refresh" @click="resetquery">重置</el-button>\n      </el-form-item>\n    </el-form>\n    \n    \x3c!-- 列表 --\x3e\n    <el-table v-loading="loading" :data="list">\n        \x3c!-- 省略每一列... --\x3e\n    </el-table>\n    \n    \x3c!-- 分页组件 --\x3e\n    <pagination v-show="total > 0" :total="total" :page.sync="queryparams.pageno" :limit.sync="queryparams.pagesize" \n                @pagination="getlist"/>\n\n</template>\n\n<script>\nimport { gettenantpage } from "@/api/system/tenant";\n\nexport default {\n\tname: "tenant",\n\tcomponents: {},\n\tdata() {\n      // 遮罩层\n      return {\n        // 遮罩层\n        loading: true,\n        // 显示搜索条件\n        showsearch: true,\n        // 总条数\n        total: 0,\n        // 租户列表\n        list: [],\n        // 查询参数\n        queryparams: {\n          pageno: 1,\n          pagesize: 10,\n          // 搜索条件\n          name: null,\n          contactname: null,\n          contactmobile: null,\n          status: undefined,\n        },\n      }\n\t},\n\tcreated() {\n\t  this.getlist();\n\t},\n\tmethods: {\n\t  /** 查询列表 */\n\t  getlist() {\n\t    this.loading = true;\n\t    // 处理查询参数\n\t    let params = {...this.queryparams};\n\t\t// 执行查询\n\t    gettenantpage(params).then(response => {\n\t\t  this.list = response.data.list;\n\t\t  this.total = response.data.total;\n\t\t  this.loading = false;\n\t\t});\n      },\n      /** 搜索按钮操作 */\n      handlequery() {\n        this.queryparams.pageno = 1;\n        this.getlist();\n      },\n      /** 重置按钮操作 */\n      resetquery() {\n        this.resetform("queryform");\n        this.handlequery();\n      }\n    }\n}\n<\/script>\n\n\n\n# 1.2 api 请求\n\n请求 system/tenant.js 相关的代码如下：\n\nimport request from \'@/utils/request\'\n\n// 获得租户分页\nexport function gettenantpage(query) {\n  return request({\n    url: \'/system/tenant/page\',\n    method: \'get\',\n    params: query\n  })\n}\n\n\n\n# 2. 后端分页实现\n\n\n# 2.1 controller 接口\n\n在 tenantcontroller 类中，定义 /admin-api/system/tenant/page 接口。代码如下：\n\n@tag(name = "管理后台 - 租户")\n@restcontroller\n@requestmapping("/system/tenant")\npublic class tenantcontroller {\n\n    @resource\n    private tenantservice tenantservice;\n\n    @getmapping("/page")\n    @operation(summary = "获得租户分页")\n    @preauthorize("@ss.haspermission(\'system:tenant:query\')")\n    public commonresult<pageresult<tenantrespvo>> gettenantpage(@valid tenantpagereqvo pagevo) {\n        pageresult<tenantdo> pageresult = tenantservice.gettenantpage(pagevo);\n        return success(tenantconvert.instance.convertpage(pageresult));\n    }\n    \n}\n\n\n * request 分页请求，使用 tenantpagereqvo 类，它继承 pageparam 类\n * response 分页结果，使用 pageresult 类，每一项是 tenantrespvo 类\n\n# 2.1.1 分页参数 pageparam\n\n分页请求，需要继承 pageparam 类。代码如下：\n\n@schema(description="分页参数")\n@data\npublic class pageparam implements serializable {\n\n    private static final integer page_no = 1;\n    private static final integer page_size = 10;\n\n    @schema(description = "页码，从 1 开始", required = true,example = "1")\n    @notnull(message = "页码不能为空")\n    @min(value = 1, message = "页码最小值为 1")\n    private integer pageno = page_no;\n\n    @schema(description = "每页条数，最大值为 100", required = true, example = "10")\n    @notnull(message = "每页条数不能为空")\n    @min(value = 1, message = "每页条数最小值为 1")\n    @max(value = 100, message = "每页条数最大值为 100")\n    private integer pagesize = page_size;\n\n}\n\n\n分页条件，在子类中进行定义。以 tenantpagereqvo 举例子，代码如下：\n\n@schema(description = "管理后台 - 租户分页 request vo")\n@data\n@equalsandhashcode(callsuper = true)\n@tostring(callsuper = true)\npublic class tenantpagereqvo extends pageparam {\n\n    @schema(description = "租户名", example = "芋道")\n    private string name;\n\n    @schema(description = "联系人", example = "芋艿")\n    private string contactname;\n\n    @schema(description = "联系手机", example = "15601691300")\n    private string contactmobile;\n\n    @schema(description = "租户状态（0正常 1停用）", example = "1")\n    private integer status;\n\n    @datetimeformat(pattern = format_year_month_day_hour_minute_second)\n    @schema(description = "创建时间")\n    private localdatetime[] createtime;\n\n}\n\n\n# 2.1.2 分页结果 pageresult\n\n分页结果 pageresult 类，代码如下：\n\n@schema(description = "分页结果")\n@data\npublic final class pageresult<t> implements serializable {\n\n    @schema(description = "数据", required = true)\n    private list<t> list;\n\n    @schema(description = "总量", required = true)\n    private long total;\n    \n}\n\n\n分页结果的数据 list 的每一项，通过自定义 vo 类，例如说 tenantrespvo 类。\n\n\n# 2.2 mapper 查询\n\n在 tenantmapper 类中，定义 selectpage 查询方法。代码如下：\n\n@mapper\npublic interface tenantmapper extends basemapperx<tenantdo> {\n\n    default pageresult<tenantdo> selectpage(tenantpagereqvo reqvo) {\n        return selectpage(reqvo, new lambdaquerywrapperx<tenantdo>()\n                .likeifpresent(tenantdo::getname, reqvo.getname()) // 如果 name 不为空，则进行 like 查询\n                .likeifpresent(tenantdo::getcontactname, reqvo.getcontactname())\n                .likeifpresent(tenantdo::getcontactmobile, reqvo.getcontactmobile())\n                .eqifpresent(tenantdo::getstatus, reqvo.getstatus()) // 如果 status 不为空，则进行 = 查询\n                .betweenifpresent(tenantdo::getcreatetime, reqvo.getbegincreatetime(), reqvo.getendcreatetime()) // 如果 create 不为空，则进行 between 查询\n                .orderbydesc(tenantdo::getid)); // 按照 id 倒序\n    }\n    \n}\n\n\n针对 mybatis plus 分页查询的二次分装，在 basemapperx 中实现，主要是将 mybatis 的分页结果 ipage，转换成项目的分页结果 pageresult。代码如下图：\n\n',
            charsets: {
                cjk: !0
            }
        }, {
            title: "VO 对象转换、数据翻译",
            frontmatter: {
                title: "VO 对象转换、数据翻译",
                date: "2024-04-01T13:11:48.000Z",
                permalink: "/vo/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/02.%E5%90%8E%E7%AB%AF%E6%89%8B%E5%86%8C/18.VO%20%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2%E3%80%81%E6%95%B0%E6%8D%AE%E7%BF%BB%E8%AF%91.html",
            relativePath: "01.开发指南/02.后端手册/18.VO 对象转换、数据翻译.md",
            key: "v-ea775c7e",
            path: "/vo/",
            headers: [{
                level: 2,
                title: "1. 对象转换",
                slug: "_1-对象转换",
                normalizedTitle: "1. 对象转换",
                charIndex: 74
            }, {
                level: 3,
                title: "1.1 MapStruct",
                slug: "_1-1-mapstruct",
                normalizedTitle: "1.1 mapstruct",
                charIndex: 351
            }, {
                level: 3,
                title: "1.2 BeanUtils",
                slug: "_1-2-beanutils",
                normalizedTitle: "1.2 beanutils",
                charIndex: 544
            }, {
                level: 2,
                title: "2. 数据翻译",
                slug: "_2-数据翻译",
                normalizedTitle: "2. 数据翻译",
                charIndex: 945
            }, {
                level: 3,
                title: "2.1 场景一：模块内翻译",
                slug: "_2-1-场景一-模块内翻译",
                normalizedTitle: "2.1 场景一：模块内翻译",
                charIndex: 1338
            }, {
                level: 3,
                title: "2.2 场景二：跨模块翻译",
                slug: "_2-2-场景二-跨模块翻译",
                normalizedTitle: "2.2 场景二：跨模块翻译",
                charIndex: 1822
            }, {
                level: 3,
                title: "2.3 场景三：Excel 导出翻译",
                slug: "_2-3-场景三-excel-导出翻译",
                normalizedTitle: "2.3 场景三：excel 导出翻译",
                charIndex: 2409
            }, {
                level: 3,
                title: "2.4 自动翻译的说明",
                slug: "_2-4-自动翻译的说明",
                normalizedTitle: "2.4 自动翻译的说明",
                charIndex: 2567
            }],
            headersStr: "1. 对象转换 1.1 MapStruct 1.2 BeanUtils 2. 数据翻译 2.1 场景一：模块内翻译 2.2 场景二：跨模块翻译 2.3 场景三：Excel 导出翻译 2.4 自动翻译的说明",
            content: "本小节，我们来讲解 VO 的对象转换、数据翻译的功能。注意，这里的 VO 是泛指 Java POJO 对象，也可以是 DTO、BO 等等。\n\n\n# 1. 对象转换\n\n对象转换，指的是 A 类型对象，转换成 B 类型对象。例如说，我们有一个 UserDO 类型对象，需要转换成 UserVO 或者 UserDTO 类型对象。\n\n市面上有很多的对象转换工具，例如说 MapStruct、Dozer、各种 BeanUtils、BeanCopier 等等。目前我们提供了 MapStruct、BeanUtils 两种解决方案。\n\n相比来说，MapStruct 性能会略好于 BeanUtils，但是相比数据库操作带来的耗时来说，基本可以忽略不计。因此，一般情况下，建议使用 BeanUtils 即可。\n\n\n# 1.1 MapStruct\n\n项目使用 MapStruct 实现 VO、DO、DTO 等对象之间的转换。\n\n如果你没有学习过 MapStruct，需要阅读下 《芋道 Spring Boot 对象转换 MapStruct 入门》 文章。\n\n在每个 yudao-module-xxx-biz 模块的 convert 包下，可以看到各个业务的 Convert 接口，如下图所示：\n\n\n\n\n# 1.2 BeanUtils\n\n项目提供了 BeanUtils 类，它是基于 Hutool 的 BeanUtil 封装一层。如下图所示：\n\n\n\n疑问：为什么不直接使用 Hutool BeanUtil，而是额外封装一层呢？\n\n① 方便替换实现。例如说，你想把 Hutool BeanUtil 换成 Spring BeanUtil、BeanCopier 等时，只需要修改它。\n\n② 特性增强。额外支持 List、Page 对象的转换，也支持 Consumer 进一步转化。\n\n1、在简单场景，直接使用 BeanUtils 的 #toBean(...) 方法，如下图所示：\n\n\n\n2、在复杂场景，可以通过 Consumer 进一步拼接，如下图所示：\n\n\n\n当然，如果 Consumer 的逻辑比较复杂，又希望 Controller 代码精简一点，可以放到对应的 Convert 类里，如下图所示：\n\n\n\n\n# 2. 数据翻译\n\n数据翻译，指的是将 A 类型对象的某个字段，“翻译”成 B 类型对象的某个字段。例如说，我们有一个 UserVO 的 deptId 字段，读取对应 DeptDO 的 name 字段，最终设置到 UserVO 的 deptName 字段。\n\n一般来说，目前有两种方案：\n\n * 方案一：数据库 SQL 联表查询，可见 《MyBatis 联表&分页查询》 文档\n * 方案二：数据库多次单表查询，然后在 Java 代码中进行数据拼接（翻译）。其实就是「1.2 BeanUtils」的“复杂场景”。如下图所示：\n\n\n\n项目里，大多数采用“方案二”，因为这样可以减少数据库的压力，避免 SQL 过于复杂，也方便后续维护。\n\n不过如果你觉得“方案二”比较麻烦，我们也集成了 easy-trans 框架，一个注解，搞定数据翻译。\n\n下面，我们来分场景，看看具体如何使用！\n\n\n# 2.1 场景一：模块内翻译\n\n模块内翻译，指的是在同一个模块内，进行数据翻译。例如说，OperateLogRespVO 属于 yudao-module-system 模块，需要读取模块内的 AdminUserDO 数据。\n\n① 第一步，给 OperateLogRespVO 实现 com.fhs.core.trans.vo.VO 接口。\n\n② 第二步，给 OperateLogRespVO 的 deptId 字段，添加 @Trans 注解，如下图所示：\n\n\n\n * type 属性：使用 TransType.SIMPLE 简单翻译，使用 MyBatis Plus\n * target 属性：目标 DO 实体的类，例如说 AdminUserDO.class\n * fields 属性：读取 DO 实体的字段，例如说 nickname。如果是多个字段，它也是个数组\n * ref 属性：设置 VO 类的字段，例如说 userNickname。如果是多个字段，可以使用 refs\n\n更多关于 @Trans 注解的讲解，可见 《Trans 注解详解(必读)》 文档。\n\n\n# 2.2 场景二：跨模块翻译\n\n跨模块翻译，指的是在不同模块，进行数据翻译。例如说，CrmProductRespVO 属于 yudao-module-crm 模块，需要读取 yudao-module-system 模块的 AdminUserDO 数据。\n\n① 第一步，给 CrmProductRespVO 实现 com.fhs.core.trans.vo.VO 接口。\n\n② 第二步，给 CrmProductRespVO 的 ownerUserId 字段，添加 @Trans 注解，如下图所示：\n\n\n\n * type 属性：使用 TransType.SIMPLE 跨模块翻译。不过实际上，因为多模块是在单个 Java 进程中，所以它底层还是走的 MyBatis Plus\n * targetClassName 属性：目标 DO 实体的类全路径，例如说 cn.iocoder.yudao.module.system.dal.dataobject.user.AdminUserDO\n * fields 和 ref 属性：同上，不重复解释\n\n友情提示：\n\n后续这个场景下，easy-trans 的作者，也会改成 TransType.SIMPLE 简单翻译。\n\n因此，“跨模块翻译”使用 targetClassName 属性的原因，是因为拿不到跨模块的 DO 实体类 = =\n\n\n# 2.3 场景三：Excel 导出翻译\n\n在 Excel 导出时，如果也有数据翻译的需求，需要调用 TranslateUtils 的 #translate(...) 方法，如下图所示：\n\n\n\n本质上，它就是 easy-trans 的手动翻译，可见 《Trans 基础使用(必读)》的“3、自动翻译和手动翻译”\n\n\n# 2.4 自动翻译的说明\n\n① 默认情况下，所有 Spring MVC 接口的 RespVO 实现了 com.fhs.core.trans.vo.VO 接口，因为项目配置了 easy-trans.is-enable-global 为 true 启动全局翻译。\n\n如果你希望某个接口不自动翻译，可以在方法上添加 @IgnoreTrans 注解。\n\n友情提示：\n\n如果一个 Spring MVC 接口的返回数据比较多，或者 RespVO 是个树形结构，建议添加 @IgnoreTrans 注解。 原因是，easy-trans 全局有递归推断，在数据规模较大的情况下，可能会导致性能问题。\n\n② 如果希望一个普通方法，也自动翻译，可以在方法上添加 @TransMethodResult 注解，框架会自动翻译方法 return 的值基于 Spring AOP 实现。例如说：\n\n",
            normalizedContent: "本小节，我们来讲解 vo 的对象转换、数据翻译的功能。注意，这里的 vo 是泛指 java pojo 对象，也可以是 dto、bo 等等。\n\n\n# 1. 对象转换\n\n对象转换，指的是 a 类型对象，转换成 b 类型对象。例如说，我们有一个 userdo 类型对象，需要转换成 uservo 或者 userdto 类型对象。\n\n市面上有很多的对象转换工具，例如说 mapstruct、dozer、各种 beanutils、beancopier 等等。目前我们提供了 mapstruct、beanutils 两种解决方案。\n\n相比来说，mapstruct 性能会略好于 beanutils，但是相比数据库操作带来的耗时来说，基本可以忽略不计。因此，一般情况下，建议使用 beanutils 即可。\n\n\n# 1.1 mapstruct\n\n项目使用 mapstruct 实现 vo、do、dto 等对象之间的转换。\n\n如果你没有学习过 mapstruct，需要阅读下 《芋道 spring boot 对象转换 mapstruct 入门》 文章。\n\n在每个 yudao-module-xxx-biz 模块的 convert 包下，可以看到各个业务的 convert 接口，如下图所示：\n\n\n\n\n# 1.2 beanutils\n\n项目提供了 beanutils 类，它是基于 hutool 的 beanutil 封装一层。如下图所示：\n\n\n\n疑问：为什么不直接使用 hutool beanutil，而是额外封装一层呢？\n\n① 方便替换实现。例如说，你想把 hutool beanutil 换成 spring beanutil、beancopier 等时，只需要修改它。\n\n② 特性增强。额外支持 list、page 对象的转换，也支持 consumer 进一步转化。\n\n1、在简单场景，直接使用 beanutils 的 #tobean(...) 方法，如下图所示：\n\n\n\n2、在复杂场景，可以通过 consumer 进一步拼接，如下图所示：\n\n\n\n当然，如果 consumer 的逻辑比较复杂，又希望 controller 代码精简一点，可以放到对应的 convert 类里，如下图所示：\n\n\n\n\n# 2. 数据翻译\n\n数据翻译，指的是将 a 类型对象的某个字段，“翻译”成 b 类型对象的某个字段。例如说，我们有一个 uservo 的 deptid 字段，读取对应 deptdo 的 name 字段，最终设置到 uservo 的 deptname 字段。\n\n一般来说，目前有两种方案：\n\n * 方案一：数据库 sql 联表查询，可见 《mybatis 联表&分页查询》 文档\n * 方案二：数据库多次单表查询，然后在 java 代码中进行数据拼接（翻译）。其实就是「1.2 beanutils」的“复杂场景”。如下图所示：\n\n\n\n项目里，大多数采用“方案二”，因为这样可以减少数据库的压力，避免 sql 过于复杂，也方便后续维护。\n\n不过如果你觉得“方案二”比较麻烦，我们也集成了 easy-trans 框架，一个注解，搞定数据翻译。\n\n下面，我们来分场景，看看具体如何使用！\n\n\n# 2.1 场景一：模块内翻译\n\n模块内翻译，指的是在同一个模块内，进行数据翻译。例如说，operatelogrespvo 属于 yudao-module-system 模块，需要读取模块内的 adminuserdo 数据。\n\n① 第一步，给 operatelogrespvo 实现 com.fhs.core.trans.vo.vo 接口。\n\n② 第二步，给 operatelogrespvo 的 deptid 字段，添加 @trans 注解，如下图所示：\n\n\n\n * type 属性：使用 transtype.simple 简单翻译，使用 mybatis plus\n * target 属性：目标 do 实体的类，例如说 adminuserdo.class\n * fields 属性：读取 do 实体的字段，例如说 nickname。如果是多个字段，它也是个数组\n * ref 属性：设置 vo 类的字段，例如说 usernickname。如果是多个字段，可以使用 refs\n\n更多关于 @trans 注解的讲解，可见 《trans 注解详解(必读)》 文档。\n\n\n# 2.2 场景二：跨模块翻译\n\n跨模块翻译，指的是在不同模块，进行数据翻译。例如说，crmproductrespvo 属于 yudao-module-crm 模块，需要读取 yudao-module-system 模块的 adminuserdo 数据。\n\n① 第一步，给 crmproductrespvo 实现 com.fhs.core.trans.vo.vo 接口。\n\n② 第二步，给 crmproductrespvo 的 owneruserid 字段，添加 @trans 注解，如下图所示：\n\n\n\n * type 属性：使用 transtype.simple 跨模块翻译。不过实际上，因为多模块是在单个 java 进程中，所以它底层还是走的 mybatis plus\n * targetclassname 属性：目标 do 实体的类全路径，例如说 cn.iocoder.yudao.module.system.dal.dataobject.user.adminuserdo\n * fields 和 ref 属性：同上，不重复解释\n\n友情提示：\n\n后续这个场景下，easy-trans 的作者，也会改成 transtype.simple 简单翻译。\n\n因此，“跨模块翻译”使用 targetclassname 属性的原因，是因为拿不到跨模块的 do 实体类 = =\n\n\n# 2.3 场景三：excel 导出翻译\n\n在 excel 导出时，如果也有数据翻译的需求，需要调用 translateutils 的 #translate(...) 方法，如下图所示：\n\n\n\n本质上，它就是 easy-trans 的手动翻译，可见 《trans 基础使用(必读)》的“3、自动翻译和手动翻译”\n\n\n# 2.4 自动翻译的说明\n\n① 默认情况下，所有 spring mvc 接口的 respvo 实现了 com.fhs.core.trans.vo.vo 接口，因为项目配置了 easy-trans.is-enable-global 为 true 启动全局翻译。\n\n如果你希望某个接口不自动翻译，可以在方法上添加 @ignoretrans 注解。\n\n友情提示：\n\n如果一个 spring mvc 接口的返回数据比较多，或者 respvo 是个树形结构，建议添加 @ignoretrans 注解。 原因是，easy-trans 全局有递归推断，在数据规模较大的情况下，可能会导致性能问题。\n\n② 如果希望一个普通方法，也自动翻译，可以在方法上添加 @transmethodresult 注解，框架会自动翻译方法 return 的值基于 spring aop 实现。例如说：\n\n",
            charsets: {
                cjk: !0
            }
        }, {
            title: "文件存储（上传下载）",
            frontmatter: {
                title: "文件存储（上传下载）",
                date: "2022-03-17T13:27:15.000Z",
                permalink: "/file"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/02.%E5%90%8E%E7%AB%AF%E6%89%8B%E5%86%8C/19.%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD.html",
            relativePath: "01.开发指南/02.后端手册/19.上传下载.md",
            key: "v-0a50e53e",
            path: "/file/",
            headers: [{
                level: 2,
                title: "1. 快速入门",
                slug: "_1-快速入门",
                normalizedTitle: "1. 快速入门",
                charIndex: 339
            }, {
                level: 3,
                title: "1.1 新增配置",
                slug: "_1-1-新增配置",
                normalizedTitle: "1.1 新增配置",
                charIndex: 379
            }, {
                level: 3,
                title: "1.2 上传文件",
                slug: "_1-2-上传文件",
                normalizedTitle: "1.2 上传文件",
                charIndex: 956
            }, {
                level: 2,
                title: "2. 文件上传",
                slug: "_2-文件上传",
                normalizedTitle: "2. 文件上传",
                charIndex: 1080
            }, {
                level: 3,
                title: "2.1 方式一：前端上传",
                slug: "_2-1-方式一-前端上传",
                normalizedTitle: "2.1 方式一：前端上传",
                charIndex: 1123
            }, {
                level: 3,
                title: "2.2 方式二：后端上传",
                slug: "_2-2-方式二-后端上传",
                normalizedTitle: "2.2 方式二：后端上传",
                charIndex: 1668
            }, {
                level: 2,
                title: "3. 文件下载",
                slug: "_3-文件下载",
                normalizedTitle: "3. 文件下载",
                charIndex: 2203
            }, {
                level: 2,
                title: "4. 文件客户端",
                slug: "_4-文件客户端",
                normalizedTitle: "4. 文件客户端",
                charIndex: 3413
            }, {
                level: 2,
                title: "5. S3 对象存储的配置",
                slug: "_5-s3-对象存储的配置",
                normalizedTitle: "5. s3 对象存储的配置",
                charIndex: 4081
            }, {
                level: 2,
                title: "6. 前端直传 S3 存储【推荐】",
                slug: "_6-前端直传-s3-存储【推荐】",
                normalizedTitle: "6. 前端直传 s3 存储【推荐】",
                charIndex: 4244
            }, {
                level: 3,
                title: "6.1 新增 S3 配置",
                slug: "_6-1-新增-s3-配置",
                normalizedTitle: "6.1 新增 s3 配置",
                charIndex: 4650
            }, {
                level: 3,
                title: "6.2 配置 S3 跨域",
                slug: "_6-2-配置-s3-跨域",
                normalizedTitle: "6.2 配置 s3 跨域",
                charIndex: 4771
            }, {
                level: 3,
                title: "6.3 配置前端直传",
                slug: "_6-3-配置前端直传",
                normalizedTitle: "6.3 配置前端直传",
                charIndex: 4924
            }, {
                level: 3,
                title: "6.4 测试上传文件",
                slug: "_6-4-测试上传文件",
                normalizedTitle: "6.4 测试上传文件",
                charIndex: 5045
            }],
            headersStr: "1. 快速入门 1.1 新增配置 1.2 上传文件 2. 文件上传 2.1 方式一：前端上传 2.2 方式二：后端上传 3. 文件下载 4. 文件客户端 5. S3 对象存储的配置 6. 前端直传 S3 存储【推荐】 6.1 新增 S3 配置 6.2 配置 S3 跨域 6.3 配置前端直传 6.4 测试上传文件",
            content: '项目支持将文件上传到三类存储器：\n\n 1. 兼容 S3 协议的对象存储：支持 MinIO、腾讯云 COS、七牛云 Kodo、华为云 OBS、亚马逊 S3 等等。\n 2. 磁盘存储：本地、FTP 服务器、SFTP 服务器。\n 3. 数据库存储：MySQL、Oracle、PostgreSQL、SQL Server 等等。\n\n技术选型？\n\n * 优先，✔ 推荐方案 1。如果无法使用云服务，可以自己搭建一个 MinIO 服务。参见 《芋道 Spring Boot 对象存储 MinIO 入门 》 文章。\n * 其次，推荐方案 3。数据库的主从机制可以实现高可用，备份也方便，少量小文件问题不大。\n * 最后，× 不推荐方案 2。主要是实现高可用比较困难，无法实现故障转移。\n\n\n# 1. 快速入门\n\n本小节，我们来添加个文件配置，并使用它上传下载文件。\n\n\n# 1.1 新增配置\n\n① 打开 [基础设施 -> 文件管理 -> 文件配置] 菜单，进入文件配置的界面。\n\n\n\n② 点击 [新增] 按钮，选择存储器为【S3 对象存储器】，并填写七牛云的配置。如下图：\n\n\n\n * 节点地址：s3.cn-south-1.qiniucs.com\n * 存储 bucket：ruoyi-vue-pro\n * accessKey：3TvrJ70gl2Gt6IBe7_IZT1F6i_k0iMuRtyEv4EyS\n * accessSecret：wd0tbVBYlp0S-ihA8Qg2hPLncoP83wyrIq24OZuY\n * 自定义域名：http://test.yudao.iocoder.cn\n\n友善的眼神！\n\n上述七牛云的配置，是艿艿为了大家方便体验，请勿在测试或生产环境体验。\n\n也就是说，测试或生产环境下，请换成自己的七牛、阿里云、腾讯云等等的配置！！！\n\n疑问：MinIO 做了 Nginx 反向代理（提供了独立域名），需要怎么配置？\n\n可见 https://t.zsxq.com/wKmMW 帖子，有 2 种解决方案。\n\n③ 添加完后，点击该配置所在行的 [测试] 按钮，测试配置是否正确。\n\n\n\n④ 测试通过后，点击该配置所在行的 [主配置] 按钮，设置它为默认的配置，后续使用它进行文件的上传。\n\n\n\n\n# 1.2 上传文件\n\n① 点击 [基础设施 -> 文件管理 -> 文件列表] 菜单，进入文件列表的界面。\n\n\n\n② 点击 [上传文件] 按钮，选择要上传的文件。\n\n\n\n③ 上传完成后，如果想要删除，可点击该文件所在行的 [删除] 按钮。\n\n\n\n\n# 2. 文件上传\n\n项目提供了 2 种文件上传的方式，分别适合前端、后端使用。\n\n\n# 2.1 方式一：前端上传\n\nFileController 提供了 /admin-api/infra/file/upload RESTful API，用于前端直接上传文件。\n\n// FileController.java\n\n@PostMapping("/upload")\n@Operation(summary = "上传文件")\npublic CommonResult<String> uploadFile(FileUploadReqVO uploadReqVO) throws Exception {\n    MultipartFile file = uploadReqVO.getFile();\n    String path = uploadReqVO.getPath();\n    return success(fileService.createFile(file.getOriginalFilename(), path,\n        IoUtil.readBytes(file.getInputStream())));\n}\n\n\n前端上传文件的代码如何实现，可见：\n\n * 文件列表，文件上传 index.vue\n * 个人中心，头像修改 userAvatar.vue\n\n\n# 2.2 方式二：后端上传\n\nyudao-module-infra 的 FileApi 提供了 #createFile(...) 方法，用于后端需要上传文件的逻辑。\n\n// FileApi.java\n\n/**\n * 保存文件，并返回文件的访问路径\n *\n * @param path 文件路径\n * @param content 文件内容\n * @return 文件路径\n */\nString createFile(String path, byte[] content);\n\n\n例如说，个人中心修改头像时，需要进行头像的上传。如下图所示：\n\n\n\n注意，需要使用到后端上传的 Maven 模块，需要引入 yudao-module-infra-api 依赖。例如说 yudao-module-system-biz 模块的 pom.xml 文件，引用如下：\n\n<dependency>\n    <groupId>cn.iocoder.boot</groupId>\n    <artifactId>yudao-module-infra-api</artifactId>\n    <version>${revision}</version>\n</dependency>\n\n\n\n# 3. 文件下载\n\n文件上传成功后，返回的是完整的 URL 访问路径，例如说 http://test.yudao.iocoder.cn/822aebded6e6414e912534c6091771a4.jpg 。\n\n不同的文件存储器，返回的 URL 路径的规则是不同的：\n\n① 当存储器是【S3 对象存储】时，支持 HTTP 访问，所以直接使用 S3 对象存储返回的 URL 路径即可。\n\n② 当存储器是【数据库】【本地磁盘】等时，它们只支持存储，所以需要 FileController 提供的 /admin-api/infra/file/{configId}/get/{path} RESTful API，读取文件内容后返回。\n\n// FileController.java\n\n@GetMapping("/{configId}/get/**")\n@PermitAll\n@Operation(summary = "下载文件")\n@Parameter(name = "configId", description = "配置编号",  required = true)\npublic void getFileContent(HttpServletRequest request,\n                           HttpServletResponse response,\n                           @PathVariable("configId") Long configId) throws Exception {\n    // 获取请求的路径\n    String path = StrUtil.subAfter(request.getRequestURI(), "/get/", false);\n    if (StrUtil.isEmpty(path)) {\n        throw new IllegalArgumentException("结尾的 path 路径必须传递");\n    }\n\n    // 读取内容\n    byte[] content = fileService.getFileContent(configId, path);\n    if (content == null) {\n        log.warn("[getFileContent][configId({}) path({}) 文件不存在]", configId, path);\n        response.setStatus(HttpStatus.NOT_FOUND.value());\n        return;\n    }\n    ServletUtils.writeAttachment(response, path, content);\n}\n\n\n\n# 4. 文件客户端\n\n在 yudao-module-infra-biz 模块中，它的 framework/file 包下，定义了 FileClient 接口，抽象了文件客户端的方法。代码如下所示：\n\npublic interface FileClient {\n\n    /**\n     * 获得客户端编号\n     *\n     * @return 客户端编号\n     */\n    Long getId();\n\n    /**\n     * 上传文件\n     *\n     * @param content 文件流\n     * @param path 相对路径\n     * @return 完整路径，即 HTTP 访问地址\n     */\n    String upload(byte[] content, String path);\n\n    /**\n     * 删除文件\n     *\n     * @param path 相对路径\n     */\n    void delete(String path);\n\n    /**\n     * 获得文件的内容\n     *\n     * @param path 相对路径\n     * @return 文件的内容\n     */\n    byte[] getContent(String path);\n\n}\n\n\nFileClient 有 5 个实现类，使用不同存储器进行文件的上传与下载。UML 类图如所示：\n\n\n\n文件上传的调用的 UML 时序图如下所示：\n\n\n\n\n# 5. S3 对象存储的配置\n\n做的不错的云存储服务，都是兼容 S3 协议的。如何获取对应的 S3 配置，艿艿整理到了 S3FileClientConfig 配置类。\n\n有一点要注意，云存储服务的 Bucket 需要设置为公共读，不然 URL 无法访问到文件。\n\n并且，最好使用自定义域名，方便迁移到不同的云存储服务。\n\n\n# 6. 前端直传 S3 存储【推荐】\n\n友情提示：目前仅 yudao-ui-admin-vue3 前端项目支持，Vue3 + Element Plus 版本\n\n前面小节的文件上传，都是 前端 => 后端 => S3 存储器 的方式。这种方式，有一个问题，就是文件的流量会经过后端，如果后端的服务器带宽不够，就会影响文件的上传速度。例如说：上传文件有 10MB，后端服务器带宽只有 1MB，那么上传文件就需要 10 秒。如果多个人上传文件，就会导致后端服务器的带宽被占满。\n\n因此，更加推荐采用 前端 => S3 存储器 的方式，即前端直传 S3 存储器。这样，文件的流量不会经过后端，上传速度会更快。例如说：上传文件有 10MB，用户的带宽有 100MB，那么上传文件就需要 0.1 秒。\n\n下面，我们以七牛云的配置为例，演示如何在前端直传 S3 存储器。当然，其它阿里云、腾讯云、华为云等等都是类似的。\n\n\n# 6.1 新增 S3 配置\n\n在 [基础设施 -> 文件管理 -> 文件配置] 菜单，新增一个 S3 对象存储器的配置，填写七牛云的配置，并设置它为默认的配置。结果如下图所示：\n\n\n\n实际上，这个步骤和「2.1 新增步骤」是一样的哈！\n\n\n# 6.2 配置 S3 跨域\n\n友情提示：这个步骤，是为了解决前端直传 S3 存储器的跨域问题。\n\n * 七牛云的跨域配置：参见 《设置跨域资源共享 》\n * 阿里云的跨域配置：参见 《阿里云 OSS 设置跨域访问》\n * 腾讯云的跨域配置：参见 《设置跨域访问》\n\n如下是七牛云的跨域配置截图：\n\n\n\n\n# 6.3 配置前端直传\n\n修改 yudao-ui-admin-vue3 前端项目的配置文件的 VITE_UPLOAD_TYPE 为 client 前端直传模式。例如说，你是本地环境，则修改 .env.local 文件，如下图所示：\n\n\n\n\n# 6.4 测试上传文件\n\n点击 [基础设施 -> 文件管理 -> 文件列表] 菜单，测试上传文件。结果如下图所示：\n\n\n\n具体的代码实现：\n\n * 前端：src/components/UploadFile/src/useUpload.ts 文件\n * 后端：FileController 的 /presigned-url RESTful API',
            normalizedContent: '项目支持将文件上传到三类存储器：\n\n 1. 兼容 s3 协议的对象存储：支持 minio、腾讯云 cos、七牛云 kodo、华为云 obs、亚马逊 s3 等等。\n 2. 磁盘存储：本地、ftp 服务器、sftp 服务器。\n 3. 数据库存储：mysql、oracle、postgresql、sql server 等等。\n\n技术选型？\n\n * 优先，✔ 推荐方案 1。如果无法使用云服务，可以自己搭建一个 minio 服务。参见 《芋道 spring boot 对象存储 minio 入门 》 文章。\n * 其次，推荐方案 3。数据库的主从机制可以实现高可用，备份也方便，少量小文件问题不大。\n * 最后，× 不推荐方案 2。主要是实现高可用比较困难，无法实现故障转移。\n\n\n# 1. 快速入门\n\n本小节，我们来添加个文件配置，并使用它上传下载文件。\n\n\n# 1.1 新增配置\n\n① 打开 [基础设施 -> 文件管理 -> 文件配置] 菜单，进入文件配置的界面。\n\n\n\n② 点击 [新增] 按钮，选择存储器为【s3 对象存储器】，并填写七牛云的配置。如下图：\n\n\n\n * 节点地址：s3.cn-south-1.qiniucs.com\n * 存储 bucket：ruoyi-vue-pro\n * accesskey：3tvrj70gl2gt6ibe7_izt1f6i_k0imurtyev4eys\n * accesssecret：wd0tbvbylp0s-iha8qg2hplncop83wyriq24ozuy\n * 自定义域名：http://test.yudao.iocoder.cn\n\n友善的眼神！\n\n上述七牛云的配置，是艿艿为了大家方便体验，请勿在测试或生产环境体验。\n\n也就是说，测试或生产环境下，请换成自己的七牛、阿里云、腾讯云等等的配置！！！\n\n疑问：minio 做了 nginx 反向代理（提供了独立域名），需要怎么配置？\n\n可见 https://t.zsxq.com/wkmmw 帖子，有 2 种解决方案。\n\n③ 添加完后，点击该配置所在行的 [测试] 按钮，测试配置是否正确。\n\n\n\n④ 测试通过后，点击该配置所在行的 [主配置] 按钮，设置它为默认的配置，后续使用它进行文件的上传。\n\n\n\n\n# 1.2 上传文件\n\n① 点击 [基础设施 -> 文件管理 -> 文件列表] 菜单，进入文件列表的界面。\n\n\n\n② 点击 [上传文件] 按钮，选择要上传的文件。\n\n\n\n③ 上传完成后，如果想要删除，可点击该文件所在行的 [删除] 按钮。\n\n\n\n\n# 2. 文件上传\n\n项目提供了 2 种文件上传的方式，分别适合前端、后端使用。\n\n\n# 2.1 方式一：前端上传\n\nfilecontroller 提供了 /admin-api/infra/file/upload restful api，用于前端直接上传文件。\n\n// filecontroller.java\n\n@postmapping("/upload")\n@operation(summary = "上传文件")\npublic commonresult<string> uploadfile(fileuploadreqvo uploadreqvo) throws exception {\n    multipartfile file = uploadreqvo.getfile();\n    string path = uploadreqvo.getpath();\n    return success(fileservice.createfile(file.getoriginalfilename(), path,\n        ioutil.readbytes(file.getinputstream())));\n}\n\n\n前端上传文件的代码如何实现，可见：\n\n * 文件列表，文件上传 index.vue\n * 个人中心，头像修改 useravatar.vue\n\n\n# 2.2 方式二：后端上传\n\nyudao-module-infra 的 fileapi 提供了 #createfile(...) 方法，用于后端需要上传文件的逻辑。\n\n// fileapi.java\n\n/**\n * 保存文件，并返回文件的访问路径\n *\n * @param path 文件路径\n * @param content 文件内容\n * @return 文件路径\n */\nstring createfile(string path, byte[] content);\n\n\n例如说，个人中心修改头像时，需要进行头像的上传。如下图所示：\n\n\n\n注意，需要使用到后端上传的 maven 模块，需要引入 yudao-module-infra-api 依赖。例如说 yudao-module-system-biz 模块的 pom.xml 文件，引用如下：\n\n<dependency>\n    <groupid>cn.iocoder.boot</groupid>\n    <artifactid>yudao-module-infra-api</artifactid>\n    <version>${revision}</version>\n</dependency>\n\n\n\n# 3. 文件下载\n\n文件上传成功后，返回的是完整的 url 访问路径，例如说 http://test.yudao.iocoder.cn/822aebded6e6414e912534c6091771a4.jpg 。\n\n不同的文件存储器，返回的 url 路径的规则是不同的：\n\n① 当存储器是【s3 对象存储】时，支持 http 访问，所以直接使用 s3 对象存储返回的 url 路径即可。\n\n② 当存储器是【数据库】【本地磁盘】等时，它们只支持存储，所以需要 filecontroller 提供的 /admin-api/infra/file/{configid}/get/{path} restful api，读取文件内容后返回。\n\n// filecontroller.java\n\n@getmapping("/{configid}/get/**")\n@permitall\n@operation(summary = "下载文件")\n@parameter(name = "configid", description = "配置编号",  required = true)\npublic void getfilecontent(httpservletrequest request,\n                           httpservletresponse response,\n                           @pathvariable("configid") long configid) throws exception {\n    // 获取请求的路径\n    string path = strutil.subafter(request.getrequesturi(), "/get/", false);\n    if (strutil.isempty(path)) {\n        throw new illegalargumentexception("结尾的 path 路径必须传递");\n    }\n\n    // 读取内容\n    byte[] content = fileservice.getfilecontent(configid, path);\n    if (content == null) {\n        log.warn("[getfilecontent][configid({}) path({}) 文件不存在]", configid, path);\n        response.setstatus(httpstatus.not_found.value());\n        return;\n    }\n    servletutils.writeattachment(response, path, content);\n}\n\n\n\n# 4. 文件客户端\n\n在 yudao-module-infra-biz 模块中，它的 framework/file 包下，定义了 fileclient 接口，抽象了文件客户端的方法。代码如下所示：\n\npublic interface fileclient {\n\n    /**\n     * 获得客户端编号\n     *\n     * @return 客户端编号\n     */\n    long getid();\n\n    /**\n     * 上传文件\n     *\n     * @param content 文件流\n     * @param path 相对路径\n     * @return 完整路径，即 http 访问地址\n     */\n    string upload(byte[] content, string path);\n\n    /**\n     * 删除文件\n     *\n     * @param path 相对路径\n     */\n    void delete(string path);\n\n    /**\n     * 获得文件的内容\n     *\n     * @param path 相对路径\n     * @return 文件的内容\n     */\n    byte[] getcontent(string path);\n\n}\n\n\nfileclient 有 5 个实现类，使用不同存储器进行文件的上传与下载。uml 类图如所示：\n\n\n\n文件上传的调用的 uml 时序图如下所示：\n\n\n\n\n# 5. s3 对象存储的配置\n\n做的不错的云存储服务，都是兼容 s3 协议的。如何获取对应的 s3 配置，艿艿整理到了 s3fileclientconfig 配置类。\n\n有一点要注意，云存储服务的 bucket 需要设置为公共读，不然 url 无法访问到文件。\n\n并且，最好使用自定义域名，方便迁移到不同的云存储服务。\n\n\n# 6. 前端直传 s3 存储【推荐】\n\n友情提示：目前仅 yudao-ui-admin-vue3 前端项目支持，vue3 + element plus 版本\n\n前面小节的文件上传，都是 前端 => 后端 => s3 存储器 的方式。这种方式，有一个问题，就是文件的流量会经过后端，如果后端的服务器带宽不够，就会影响文件的上传速度。例如说：上传文件有 10mb，后端服务器带宽只有 1mb，那么上传文件就需要 10 秒。如果多个人上传文件，就会导致后端服务器的带宽被占满。\n\n因此，更加推荐采用 前端 => s3 存储器 的方式，即前端直传 s3 存储器。这样，文件的流量不会经过后端，上传速度会更快。例如说：上传文件有 10mb，用户的带宽有 100mb，那么上传文件就需要 0.1 秒。\n\n下面，我们以七牛云的配置为例，演示如何在前端直传 s3 存储器。当然，其它阿里云、腾讯云、华为云等等都是类似的。\n\n\n# 6.1 新增 s3 配置\n\n在 [基础设施 -> 文件管理 -> 文件配置] 菜单，新增一个 s3 对象存储器的配置，填写七牛云的配置，并设置它为默认的配置。结果如下图所示：\n\n\n\n实际上，这个步骤和「2.1 新增步骤」是一样的哈！\n\n\n# 6.2 配置 s3 跨域\n\n友情提示：这个步骤，是为了解决前端直传 s3 存储器的跨域问题。\n\n * 七牛云的跨域配置：参见 《设置跨域资源共享 》\n * 阿里云的跨域配置：参见 《阿里云 oss 设置跨域访问》\n * 腾讯云的跨域配置：参见 《设置跨域访问》\n\n如下是七牛云的跨域配置截图：\n\n\n\n\n# 6.3 配置前端直传\n\n修改 yudao-ui-admin-vue3 前端项目的配置文件的 vite_upload_type 为 client 前端直传模式。例如说，你是本地环境，则修改 .env.local 文件，如下图所示：\n\n\n\n\n# 6.4 测试上传文件\n\n点击 [基础设施 -> 文件管理 -> 文件列表] 菜单，测试上传文件。结果如下图所示：\n\n\n\n具体的代码实现：\n\n * 前端：src/components/uploadfile/src/useupload.ts 文件\n * 后端：filecontroller 的 /presigned-url restful api',
            charsets: {
                cjk: !0
            }
        }, {
            title: "Excel 导入导出",
            frontmatter: {
                title: "Excel 导入导出",
                date: "2022-03-27T22:17:53.000Z",
                permalink: "/excel-import-and-export"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/02.%E5%90%8E%E7%AB%AF%E6%89%8B%E5%86%8C/20.Excel%20%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA.html",
            relativePath: "01.开发指南/02.后端手册/20.Excel 导入导出.md",
            key: "v-34c1d3ae",
            path: "/excel-import-and-export/",
            headers: [{
                level: 2,
                title: "1. Excel 导出",
                slug: "_1-excel-导出",
                normalizedTitle: "1. excel 导出",
                charIndex: 273
            }, {
                level: 3,
                title: "1.1 后端导入实现",
                slug: "_1-1-后端导入实现",
                normalizedTitle: "1.1 后端导入实现",
                charIndex: 332
            }, {
                level: 3,
                title: "1.2 前端导入实现",
                slug: "_1-2-前端导入实现",
                normalizedTitle: "1.2 前端导入实现",
                charIndex: 2784
            }, {
                level: 2,
                title: "2. Excel 导入",
                slug: "_2-excel-导入",
                normalizedTitle: "2. excel 导入",
                charIndex: 2851
            }, {
                level: 3,
                title: "2.1 后端导入实现",
                slug: "_2-1-后端导入实现",
                normalizedTitle: "2.1 后端导入实现",
                charIndex: 2910
            }, {
                level: 3,
                title: "2.2 前端导入实现",
                slug: "_2-2-前端导入实现",
                normalizedTitle: "2.2 前端导入实现",
                charIndex: 3231
            }, {
                level: 2,
                title: "3. 字段转换器",
                slug: "_3-字段转换器",
                normalizedTitle: "3. 字段转换器",
                charIndex: 2588
            }, {
                level: 3,
                title: "3.1 DictConvert 实现",
                slug: "_3-1-dictconvert-实现",
                normalizedTitle: "3.1 dictconvert 实现",
                charIndex: 3605
            }, {
                level: 3,
                title: "3.1 DictConvert 使用示例",
                slug: "_3-1-dictconvert-使用示例",
                normalizedTitle: "3.1 dictconvert 使用示例",
                charIndex: 3710
            }, {
                level: 2,
                title: "4. 更多 EasyExcel 注解",
                slug: "_4-更多-easyexcel-注解",
                normalizedTitle: "4. 更多 easyexcel 注解",
                charIndex: 3833
            }, {
                level: 3,
                title: "4.1 @ExcelProperty",
                slug: "_4-1-excelproperty",
                normalizedTitle: "4.1 @excelproperty",
                charIndex: 3889
            }, {
                level: 3,
                title: "4.2 @ColumnWidth",
                slug: "_4-2-columnwidth",
                normalizedTitle: "4.2 @columnwidth",
                charIndex: 4113
            }, {
                level: 3,
                title: "4.3 @ContentFontStyle",
                slug: "_4-3-contentfontstyle",
                normalizedTitle: "4.3 @contentfontstyle",
                charIndex: 4326
            }, {
                level: 3,
                title: "4.4 @ContentLoopMerge",
                slug: "_4-4-contentloopmerge",
                normalizedTitle: "4.4 @contentloopmerge",
                charIndex: 4638
            }, {
                level: 3,
                title: "4.5 @ContentRowHeight",
                slug: "_4-5-contentrowheight",
                normalizedTitle: "4.5 @contentrowheight",
                charIndex: 4735
            }, {
                level: 3,
                title: "4.6 @ContentStyle",
                slug: "_4-6-contentstyle",
                normalizedTitle: "4.6 @contentstyle",
                charIndex: 4807
            }, {
                level: 3,
                title: "4.7 @HeadFontStyle",
                slug: "_4-7-headfontstyle",
                normalizedTitle: "4.7 @headfontstyle",
                charIndex: 5626
            }, {
                level: 3,
                title: "4.8 @HeadRowHeight",
                slug: "_4-8-headrowheight",
                normalizedTitle: "4.8 @headrowheight",
                charIndex: 5947
            }, {
                level: 3,
                title: "4.9 @HeadStyle",
                slug: "_4-9-headstyle",
                normalizedTitle: "4.9 @headstyle",
                charIndex: 6019
            }, {
                level: 3,
                title: "4.11 @ExcelIgnoreUnannotated",
                slug: "_4-11-excelignoreunannotated",
                normalizedTitle: "4.11 @excelignoreunannotated",
                charIndex: 6871
            }],
            headersStr: "1. Excel 导出 1.1 后端导入实现 1.2 前端导入实现 2. Excel 导入 2.1 后端导入实现 2.2 前端导入实现 3. 字段转换器 3.1 DictConvert 实现 3.1 DictConvert 使用示例 4. 更多 EasyExcel 注解 4.1 @ExcelProperty 4.2 @ColumnWidth 4.3 @ContentFontStyle 4.4 @ContentLoopMerge 4.5 @ContentRowHeight 4.6 @ContentStyle 4.7 @HeadFontStyle 4.8 @HeadRowHeight 4.9 @HeadStyle 4.11 @ExcelIgnoreUnannotated",
            content: '项目的 yudao-spring-boot-starter-excel 技术组件，基于 EasyExcel 实现 Excel 的读写操作，可用于实现最常见的 Excel 导入导出等功能。\n\nEasyExcel 的介绍？\n\nEasyExcel 是阿里开源的 Excel 工具库，具有简单易用、低内存、高性能的特点。\n\n在尽可用节约内存的情况下，支持百万行的 Excel 读写操作。例如说，仅使用 64M 内存，20 秒完成 75M（46 万行 25 列）Excel 的读取。并且，还有极速模式能更快，但是内存占用会在100M 多一点。\n\n\n\n\n# 1. Excel 导出\n\n以 [系统管理 -> 岗位管理] 菜单为例子，讲解它 Excel 导出的实现。\n\n\n\n\n# 1.1 后端导入实现\n\n在 PostController 类中，定义 /admin-api/system/post/export 导出接口。代码如下：\n\n    @GetMapping("/export")\n    @Operation(summary = "岗位管理")\n    @PreAuthorize("@ss.hasPermission(\'system:post:export\')")\n    @ApiAccessLog(operateType = EXPORT)\n    public void export(HttpServletResponse response, @Validated PostPageReqVO reqVO) throws IOException {\n         // ① 查询数据\n        reqVO.setPageSize(PageParam.PAGE_SIZE_NONE);\n        List<PostDO> list = postService.getPostPage(reqVO).getList();\n        // ② 导出 Excel\n        ExcelUtils.write(response, "岗位数据.xls", "岗位列表", PostRespVO.class,\n                BeanUtils.toBean(list, PostRespVO.class));\n    }\n\n\n * ① 将从数据库中查询出来的列表，一般可以复用分页接口，需要设置 .setPageSize(PageParam.PAGE_SIZE_NONE) 不过滤分页。\n * ② 将 PostDO 列表，转换成 PostRespVO 列表，之后通过 ExcelUtils 转换成 Excel 文件，返回给前端。\n\n# 1.1.1 PostExcelVO 类\n\n复用 PostRespVO 类，实现 岗位 Excel 导出的 VO 类。代码如下：\n\n@Schema(description = "管理后台 - 岗位信息 Response VO")\n@Data\n@ExcelIgnoreUnannotated // ③\npublic class PostRespVO {\n\n    @Schema(description = "岗位序号", requiredMode = Schema.RequiredMode.REQUIRED, example = "1024")\n    @ExcelProperty("岗位序号") // ①\n    private Long id;\n\n    @Schema(description = "岗位名称", requiredMode = Schema.RequiredMode.REQUIRED, example = "小土豆")\n    @ExcelProperty("岗位名称")\n    private String name;\n\n    @Schema(description = "岗位编码", requiredMode = Schema.RequiredMode.REQUIRED, example = "yudao")\n    @ExcelProperty("岗位编码")\n    private String code;\n\n    @Schema(description = "显示顺序不能为空", requiredMode = Schema.RequiredMode.REQUIRED, example = "1024")\n    @ExcelProperty("岗位排序")\n    private Integer sort;\n\n    @Schema(description = "状态，参见 CommonStatusEnum 枚举类", requiredMode = Schema.RequiredMode.REQUIRED, example = "1")\n    // ②\n    @ExcelProperty(value = "状态", converter = DictConvert.class)\n    @DictFormat(DictTypeConstants.COMMON_STATUS)\n    private Integer status;\n\n    @Schema(description = "备注", example = "快乐的备注")\n    private String remark;\n\n    @Schema(description = "创建时间", requiredMode = Schema.RequiredMode.REQUIRED)\n    private LocalDateTime createTime;\n\n}\n\n\n * ① 每个字段上，添加 @ExcelProperty 注解，声明 Excel Head 头部的名字。每个字段的值，就是它对应的 Excel Row 行的数据值。\n * ② 如果字段的的注解 converter 属性是 DictConvert 转换器，用于字典的转换。例如说，通过 status 字段，将 status = 1 转换成“开启”列，status = 0 转换成”禁用”列。稍后，我们会在 「3. 字段转换器」 小节来详细讲讲。\n * ③ 在类上，添加 @ExcelIgnoreUnannotated 注解，表示未添加 @ExcelProperty 的字段，不进行导出。\n\n因此，最终 Excel 导出的效果如下：\n\n\n\n# 1.1.2 ExcelUtils 写入\n\nExcelUtils 的 #write(...) 方法，将列表以 Excel 响应给前端。代码如下图：\n\n\n\n\n# 1.2 前端导入实现\n\n在 post/index.vue 界面，定义 #handleExport() 操作，代码如下图：\n\n\n\n\n# 2. Excel 导入\n\n以 [系统管理 -> 用户管理] 菜单为例子，讲解它 Excel 导出的实现。\n\n\n\n\n# 2.1 后端导入实现\n\n在 UserController 类中，定义 /admin-api/system/user/import 导入接口。代码如下：\n\n\n\n将前端上传的 Excel 文件，读取成 UserImportExcelVO 列表。\n\n# 2.1.1 UserImportExcelVO 类\n\n创建 UserImportExcelVO 类，用户 Excel 导入的 VO 类。它的作用和 Excel 导入是一样的，代码如下：\n\n\n\n对应使用的 Excel 导入文件如下：\n\n\n\n# 2.1.2 ExcelUtils 读取\n\nExcelUtils 的 #read(...) 方法，读取 Excel 文件成列表。代码如下图：\n\n\n\n\n# 2.2 前端导入实现\n\n在 user/index.vue 界面，定义 Excel 导入的功能，代码如下图：\n\n\n\n\n# 3. 字段转换器\n\nEasyExcel 定义了 Converter 接口，用于实现字段的转换。它有两个核心方法：\n\n① #convertToJavaData(...) 方法：将 Excel Row 对应表格的值，转换成 Java 内存中的值。例如说，Excel 的“状态”列，将“状态”列转换成 status = 1，”禁用”列转换成 status = 0。\n\n② #convertToExcelData(...) 方法：恰好相反，将 Java 内存中的值，转换成 Excel Row 对应表格的值。例如说，Excel 的“状态”列，将 status = 1 转换成“开启”列，status = 0 转换成”禁用”列。\n\n\n# 3.1 DictConvert 实现\n\n以项目中提供的 DictConvert 举例子，它实现 Converter 接口，提供字典数据的转换。代码如下：\n\n\n\n实现的代码比较简单，自己看看就可以明白。\n\n\n# 3.1 DictConvert 使用示例\n\n在需要转换的字段上，声明注解 @ExcelProperty 的 converter 属性是 DictConvert 转换器，注解 @DictFormat 为对应的字典数据的类型。示例如下：\n\n\n\n\n# 4. 更多 EasyExcel 注解\n\n基于 《EasyExcel 中的注解 》 文章，整理相关注解。\n\n\n# 4.1 @ExcelProperty\n\n这是最常用的一个注解，注解中有三个参数 value、index、converter 分别代表列明、列序号、数据转换方式。value 和 index 只能二选一，通常不用设置 converter。\n\n最佳实践\n\npublic class ImeiEncrypt {\n    \n    @ExcelProperty(value = "imei")\n    private String imei;\n}\n\n\n\n# 4.2 @ColumnWidth\n\n用于设置列宽度的注解，注解中只有一个参数 value。value 的单位是字符长度，最大可以设置 255 个字符，因为一个 Excel 单元格最大可以写入的字符个数，就是 255 个字符。\n\n最佳实践\n\npublic class ImeiEncrypt {\n    \n    @ColumnWidth(value = 18)\n    private String imei;\n}\n\n\n\n# 4.3 @ContentFontStyle\n\n用于设置单元格内容字体格式的注解。参数如下：\n\n参数                   含义\nfontName             字体名称\nfontHeightInPoints   字体高度\nitalic               是否斜体\nstrikeout            是否设置删除水平线\ncolor                字体颜色\ntypeOffset           偏移量\nunderline            下划线\nbold                 是否加粗\ncharset              编码格式\n\n\n# 4.4 @ContentLoopMerge\n\n用于设置合并单元格的注解。参数如下：\n\n参数             含义\neachRow        \ncolumnExtend   \n\n\n# 4.5 @ContentRowHeight\n\n用于设置行高。参数如下：\n\n参数      含义\nvalue   行高，-1代表自动行高\n\n\n# 4.6 @ContentStyle\n\n设置内容格式注解。参数如下：\n\n参数                    含义\ndataFormat            日期格式\nhidden                设置单元格使用此样式隐藏\nlocked                设置单元格使用此样式锁定\nquotePrefix           在单元格前面增加`符号，数字或公式将以字符串形式展示\nhorizontalAlignment   设置是否水平居中\nwrapped               设置文本是否应换行。将此标志设置为true通过在多行上显示使单元格中的所有内容可见\nverticalAlignment     设置是否垂直居中\nrotation              设置单元格中文本旋转角度。03版本的Excel旋转角度区间为-90°~90°，07版本的Excel旋转角度区间为0°~180°\nindent                设置单元格中缩进文本的空格数\nborderLeft            设置左边框的样式\nborderRight           设置右边框样式\nborderTop             设置上边框样式\nborderBottom          设置下边框样式\nleftBorderColor       设置左边框颜色\nrightBorderColor      设置右边框颜色\ntopBorderColor        设置上边框颜色\nbottomBorderColor     设置下边框颜色\nfillPatternType       设置填充类型\nfillBackgroundColor   设置背景色\nfillForegroundColor   设置前景色\nshrinkToFit           设置自动单元格自动大小\n\n\n# 4.7 @HeadFontStyle\n\n用于定制标题字体格式。参数如下：\n\n参数                   含义\nfontName             设置字体名称\nfontHeightInPoints   设置字体高度\nitalic               设置字体是否斜体\nstrikeout            是否设置删除线\ncolor                设置字体颜色\ntypeOffset           设置偏移量\nunderline            设置下划线\ncharset              设置字体编码\nbold                 设置字体是否家畜\n\n\n# 4.8 @HeadRowHeight\n\n设置标题行行高。参数如下：\n\n参数      含义\nvalue   设置行高，-1代表自动行高\n\n\n# 4.9 @HeadStyle\n\n设置标题样式。参数如下：\n\n参数                    含义\ndataFormat            日期格式\nhidden                设置单元格使用此样式隐藏\nlocked                设置单元格使用此样式锁定\nquotePrefix           在单元格前面增加`符号，数字或公式将以字符串形式展示\nhorizontalAlignment   设置是否水平居中\nwrapped               设置文本是否应换行。将此标志设置为true通过在多行上显示使单元格中的所有内容可见\nverticalAlignment     设置是否垂直居中\nrotation              设置单元格中文本旋转角度。03版本的Excel旋转角度区间为-90°~90°，07版本的Excel旋转角度区间为0°~180°\nindent                设置单元格中缩进文本的空格数\nborderLeft            设置左边框的样式\nborderRight           设置右边框样式\nborderTop             设置上边框样式\nborderBottom          设置下边框样式\nleftBorderColor       设置左边框颜色\nrightBorderColor      设置右边框颜色\ntopBorderColor        设置上边框颜色\nbottomBorderColor     设置下边框颜色\nfillPatternType       设置填充类型\nfillBackgroundColor   设置背景色\nfillForegroundColor   设置前景色\nshrinkToFit           设置自动单元格自动大小\n\n# 4.10 @ExcelIgnore\n\n不将该字段转换成 Excel。\n\n\n# 4.11 @ExcelIgnoreUnannotated\n\n没有注解的字段都不转换',
            normalizedContent: '项目的 yudao-spring-boot-starter-excel 技术组件，基于 easyexcel 实现 excel 的读写操作，可用于实现最常见的 excel 导入导出等功能。\n\neasyexcel 的介绍？\n\neasyexcel 是阿里开源的 excel 工具库，具有简单易用、低内存、高性能的特点。\n\n在尽可用节约内存的情况下，支持百万行的 excel 读写操作。例如说，仅使用 64m 内存，20 秒完成 75m（46 万行 25 列）excel 的读取。并且，还有极速模式能更快，但是内存占用会在100m 多一点。\n\n\n\n\n# 1. excel 导出\n\n以 [系统管理 -> 岗位管理] 菜单为例子，讲解它 excel 导出的实现。\n\n\n\n\n# 1.1 后端导入实现\n\n在 postcontroller 类中，定义 /admin-api/system/post/export 导出接口。代码如下：\n\n    @getmapping("/export")\n    @operation(summary = "岗位管理")\n    @preauthorize("@ss.haspermission(\'system:post:export\')")\n    @apiaccesslog(operatetype = export)\n    public void export(httpservletresponse response, @validated postpagereqvo reqvo) throws ioexception {\n         // ① 查询数据\n        reqvo.setpagesize(pageparam.page_size_none);\n        list<postdo> list = postservice.getpostpage(reqvo).getlist();\n        // ② 导出 excel\n        excelutils.write(response, "岗位数据.xls", "岗位列表", postrespvo.class,\n                beanutils.tobean(list, postrespvo.class));\n    }\n\n\n * ① 将从数据库中查询出来的列表，一般可以复用分页接口，需要设置 .setpagesize(pageparam.page_size_none) 不过滤分页。\n * ② 将 postdo 列表，转换成 postrespvo 列表，之后通过 excelutils 转换成 excel 文件，返回给前端。\n\n# 1.1.1 postexcelvo 类\n\n复用 postrespvo 类，实现 岗位 excel 导出的 vo 类。代码如下：\n\n@schema(description = "管理后台 - 岗位信息 response vo")\n@data\n@excelignoreunannotated // ③\npublic class postrespvo {\n\n    @schema(description = "岗位序号", requiredmode = schema.requiredmode.required, example = "1024")\n    @excelproperty("岗位序号") // ①\n    private long id;\n\n    @schema(description = "岗位名称", requiredmode = schema.requiredmode.required, example = "小土豆")\n    @excelproperty("岗位名称")\n    private string name;\n\n    @schema(description = "岗位编码", requiredmode = schema.requiredmode.required, example = "yudao")\n    @excelproperty("岗位编码")\n    private string code;\n\n    @schema(description = "显示顺序不能为空", requiredmode = schema.requiredmode.required, example = "1024")\n    @excelproperty("岗位排序")\n    private integer sort;\n\n    @schema(description = "状态，参见 commonstatusenum 枚举类", requiredmode = schema.requiredmode.required, example = "1")\n    // ②\n    @excelproperty(value = "状态", converter = dictconvert.class)\n    @dictformat(dicttypeconstants.common_status)\n    private integer status;\n\n    @schema(description = "备注", example = "快乐的备注")\n    private string remark;\n\n    @schema(description = "创建时间", requiredmode = schema.requiredmode.required)\n    private localdatetime createtime;\n\n}\n\n\n * ① 每个字段上，添加 @excelproperty 注解，声明 excel head 头部的名字。每个字段的值，就是它对应的 excel row 行的数据值。\n * ② 如果字段的的注解 converter 属性是 dictconvert 转换器，用于字典的转换。例如说，通过 status 字段，将 status = 1 转换成“开启”列，status = 0 转换成”禁用”列。稍后，我们会在 「3. 字段转换器」 小节来详细讲讲。\n * ③ 在类上，添加 @excelignoreunannotated 注解，表示未添加 @excelproperty 的字段，不进行导出。\n\n因此，最终 excel 导出的效果如下：\n\n\n\n# 1.1.2 excelutils 写入\n\nexcelutils 的 #write(...) 方法，将列表以 excel 响应给前端。代码如下图：\n\n\n\n\n# 1.2 前端导入实现\n\n在 post/index.vue 界面，定义 #handleexport() 操作，代码如下图：\n\n\n\n\n# 2. excel 导入\n\n以 [系统管理 -> 用户管理] 菜单为例子，讲解它 excel 导出的实现。\n\n\n\n\n# 2.1 后端导入实现\n\n在 usercontroller 类中，定义 /admin-api/system/user/import 导入接口。代码如下：\n\n\n\n将前端上传的 excel 文件，读取成 userimportexcelvo 列表。\n\n# 2.1.1 userimportexcelvo 类\n\n创建 userimportexcelvo 类，用户 excel 导入的 vo 类。它的作用和 excel 导入是一样的，代码如下：\n\n\n\n对应使用的 excel 导入文件如下：\n\n\n\n# 2.1.2 excelutils 读取\n\nexcelutils 的 #read(...) 方法，读取 excel 文件成列表。代码如下图：\n\n\n\n\n# 2.2 前端导入实现\n\n在 user/index.vue 界面，定义 excel 导入的功能，代码如下图：\n\n\n\n\n# 3. 字段转换器\n\neasyexcel 定义了 converter 接口，用于实现字段的转换。它有两个核心方法：\n\n① #converttojavadata(...) 方法：将 excel row 对应表格的值，转换成 java 内存中的值。例如说，excel 的“状态”列，将“状态”列转换成 status = 1，”禁用”列转换成 status = 0。\n\n② #converttoexceldata(...) 方法：恰好相反，将 java 内存中的值，转换成 excel row 对应表格的值。例如说，excel 的“状态”列，将 status = 1 转换成“开启”列，status = 0 转换成”禁用”列。\n\n\n# 3.1 dictconvert 实现\n\n以项目中提供的 dictconvert 举例子，它实现 converter 接口，提供字典数据的转换。代码如下：\n\n\n\n实现的代码比较简单，自己看看就可以明白。\n\n\n# 3.1 dictconvert 使用示例\n\n在需要转换的字段上，声明注解 @excelproperty 的 converter 属性是 dictconvert 转换器，注解 @dictformat 为对应的字典数据的类型。示例如下：\n\n\n\n\n# 4. 更多 easyexcel 注解\n\n基于 《easyexcel 中的注解 》 文章，整理相关注解。\n\n\n# 4.1 @excelproperty\n\n这是最常用的一个注解，注解中有三个参数 value、index、converter 分别代表列明、列序号、数据转换方式。value 和 index 只能二选一，通常不用设置 converter。\n\n最佳实践\n\npublic class imeiencrypt {\n    \n    @excelproperty(value = "imei")\n    private string imei;\n}\n\n\n\n# 4.2 @columnwidth\n\n用于设置列宽度的注解，注解中只有一个参数 value。value 的单位是字符长度，最大可以设置 255 个字符，因为一个 excel 单元格最大可以写入的字符个数，就是 255 个字符。\n\n最佳实践\n\npublic class imeiencrypt {\n    \n    @columnwidth(value = 18)\n    private string imei;\n}\n\n\n\n# 4.3 @contentfontstyle\n\n用于设置单元格内容字体格式的注解。参数如下：\n\n参数                   含义\nfontname             字体名称\nfontheightinpoints   字体高度\nitalic               是否斜体\nstrikeout            是否设置删除水平线\ncolor                字体颜色\ntypeoffset           偏移量\nunderline            下划线\nbold                 是否加粗\ncharset              编码格式\n\n\n# 4.4 @contentloopmerge\n\n用于设置合并单元格的注解。参数如下：\n\n参数             含义\neachrow        \ncolumnextend   \n\n\n# 4.5 @contentrowheight\n\n用于设置行高。参数如下：\n\n参数      含义\nvalue   行高，-1代表自动行高\n\n\n# 4.6 @contentstyle\n\n设置内容格式注解。参数如下：\n\n参数                    含义\ndataformat            日期格式\nhidden                设置单元格使用此样式隐藏\nlocked                设置单元格使用此样式锁定\nquoteprefix           在单元格前面增加`符号，数字或公式将以字符串形式展示\nhorizontalalignment   设置是否水平居中\nwrapped               设置文本是否应换行。将此标志设置为true通过在多行上显示使单元格中的所有内容可见\nverticalalignment     设置是否垂直居中\nrotation              设置单元格中文本旋转角度。03版本的excel旋转角度区间为-90°~90°，07版本的excel旋转角度区间为0°~180°\nindent                设置单元格中缩进文本的空格数\nborderleft            设置左边框的样式\nborderright           设置右边框样式\nbordertop             设置上边框样式\nborderbottom          设置下边框样式\nleftbordercolor       设置左边框颜色\nrightbordercolor      设置右边框颜色\ntopbordercolor        设置上边框颜色\nbottombordercolor     设置下边框颜色\nfillpatterntype       设置填充类型\nfillbackgroundcolor   设置背景色\nfillforegroundcolor   设置前景色\nshrinktofit           设置自动单元格自动大小\n\n\n# 4.7 @headfontstyle\n\n用于定制标题字体格式。参数如下：\n\n参数                   含义\nfontname             设置字体名称\nfontheightinpoints   设置字体高度\nitalic               设置字体是否斜体\nstrikeout            是否设置删除线\ncolor                设置字体颜色\ntypeoffset           设置偏移量\nunderline            设置下划线\ncharset              设置字体编码\nbold                 设置字体是否家畜\n\n\n# 4.8 @headrowheight\n\n设置标题行行高。参数如下：\n\n参数      含义\nvalue   设置行高，-1代表自动行高\n\n\n# 4.9 @headstyle\n\n设置标题样式。参数如下：\n\n参数                    含义\ndataformat            日期格式\nhidden                设置单元格使用此样式隐藏\nlocked                设置单元格使用此样式锁定\nquoteprefix           在单元格前面增加`符号，数字或公式将以字符串形式展示\nhorizontalalignment   设置是否水平居中\nwrapped               设置文本是否应换行。将此标志设置为true通过在多行上显示使单元格中的所有内容可见\nverticalalignment     设置是否垂直居中\nrotation              设置单元格中文本旋转角度。03版本的excel旋转角度区间为-90°~90°，07版本的excel旋转角度区间为0°~180°\nindent                设置单元格中缩进文本的空格数\nborderleft            设置左边框的样式\nborderright           设置右边框样式\nbordertop             设置上边框样式\nborderbottom          设置下边框样式\nleftbordercolor       设置左边框颜色\nrightbordercolor      设置右边框颜色\ntopbordercolor        设置上边框颜色\nbottombordercolor     设置下边框颜色\nfillpatterntype       设置填充类型\nfillbackgroundcolor   设置背景色\nfillforegroundcolor   设置前景色\nshrinktofit           设置自动单元格自动大小\n\n# 4.10 @excelignore\n\n不将该字段转换成 excel。\n\n\n# 4.11 @excelignoreunannotated\n\n没有注解的字段都不转换',
            charsets: {
                cjk: !0
            }
        }, {
            title: "操作日志、访问日志、异常日志",
            frontmatter: {
                title: "操作日志、访问日志、异常日志",
                date: "2022-03-28T21:33:03.000Z",
                permalink: "/system-log"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/02.%E5%90%8E%E7%AB%AF%E6%89%8B%E5%86%8C/21.%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%BF%97.html",
            relativePath: "01.开发指南/02.后端手册/21.系统日志.md",
            key: "v-f31a1c8e",
            path: "/system-log/",
            headers: [{
                level: 2,
                title: "1. 操作日志",
                slug: "_1-操作日志",
                normalizedTitle: "1. 操作日志",
                charIndex: 77
            }, {
                level: 3,
                title: "1.1 操作日志组件",
                slug: "_1-1-操作日志组件",
                normalizedTitle: "1.1 操作日志组件",
                charIndex: 173
            }, {
                level: 3,
                title: "1.2 场景一：创建用户",
                slug: "_1-2-场景一-创建用户",
                normalizedTitle: "1.2 场景一：创建用户",
                charIndex: 877
            }, {
                level: 3,
                title: "1.3 场景二：修改用户信息",
                slug: "_1-3-场景二-修改用户信息",
                normalizedTitle: "1.3 场景二：修改用户信息",
                charIndex: 1187
            }, {
                level: 3,
                title: "1.4 更多场景",
                slug: "_1-4-更多场景",
                normalizedTitle: "1.4 更多场景",
                charIndex: 1617
            }, {
                level: 2,
                title: "2. 登录日志",
                slug: "_2-登录日志",
                normalizedTitle: "2. 登录日志",
                charIndex: 1742
            }, {
                level: 2,
                title: "3. API 访问日志",
                slug: "_3-api-访问日志",
                normalizedTitle: "3. api 访问日志",
                charIndex: 1976
            }, {
                level: 3,
                title: "3.1 数据库记录",
                slug: "_3-1-数据库记录",
                normalizedTitle: "3.1 数据库记录",
                charIndex: 1992
            }, {
                level: 3,
                title: "3.2 文件记录",
                slug: "_3-2-文件记录",
                normalizedTitle: "3.2 文件记录",
                charIndex: 3406
            }, {
                level: 2,
                title: "4. API 错误日志",
                slug: "_4-api-错误日志",
                normalizedTitle: "4. api 错误日志",
                charIndex: 3645
            }],
            headersStr: "1. 操作日志 1.1 操作日志组件 1.2 场景一：创建用户 1.3 场景二：修改用户信息 1.4 更多场景 2. 登录日志 3. API 访问日志 3.1 数据库记录 3.2 文件记录 4. API 错误日志",
            content: "项目提供 2 类 4 种系统日志：\n\n * 审计日志：用户的操作日志、登录日志\n * API 日志：RESTful API 的访问日志、错误日志\n\n\n# 1. 操作日志\n\n操作日志，记录「谁」在「什么时间」对「什么对象」做了「什么事情」。\n\n打开 [系统管理 -> 审计日志 -> 操作日志] 菜单，可以看到对应的列表，如下图所示：\n\n\n\n\n# 1.1 操作日志组件\n\n① 操作日志的记录，由 yudao-spring-boot-starter-security 技术组件的 operatelog 包提供，基于我老友开源的 https://github.com/mouzt/mzt-biz-log 实现，只需要添加 @LogRecord 注解，即可实现操作日志的记录。\n\n\n\n * 【新增】2021-09-16 10:00 订单创建，订单号：NO.11089999，其中涉及变量订单号 “NO.11089999”\n * 【修改】2021-09-16 10:00 用户小明修改了订单的配送地址：从 “金灿灿小区” 修改到 “银盏盏小区”\n\n疑问：为什么不独立一个 `yudao-spring-boot-starter-operatelog` 组件呢？\n\n早期，项目确实有 operatelog 组件，和 mzt-biz-log 组件一样，也是基于 Spring AOP + 注解实现。\n\n随着我老友开源了 mzt-biz-log 组件，再加上希望减少项目的 starter 数量，所以决定直接使用 mzt-biz-log 组件，放到 security 组件中，而不是自己再造一个轮子。\n\n② 操作日志的存储，由 yudao-module-system 的 OperateLog 模块实现，记录到数据库的 system_operate_log 表。\n\n----------------------------------------\n\n下面，我们来看项目中的几个使用案例。在开始之前，希望你先简单通读下 《mzt-biz-log 使用指南》 文档。\n\n\n# 1.2 场景一：创建用户\n\n① 在 LogRecordConstants 类中，定义 SYSTEM_USER_CREATE_SUB_TYPE、SYSTEM_USER_CREATE_SUCCESS 变量。如下图所示：\n\n\n\n疑问：为什么要在 LogRecordConstants 定义？\n\n这个并非强制，只是一个使用建议。每个 yudao-module-xxx 模块下，建议都搞一个 LogRecordConstants 类，方便大家统一管理操作日志的常量，这样方便大家查找。\n\n② 在 Service 方法上，添加 @LogRecord 注解，如下图所示：\n\n\n\n最终，我们记录操作日志的内容，如下图所示：\n\n\n\n\n# 1.3 场景二：修改用户信息\n\n① 在 LogRecordConstants 类中，定义 SYSTEM_USER_UPDATE_SUB_TYPE、SYSTEM_USER_UPDATE_SUCCESS 变量。如下图所示：\n\n\n\n这里我们使用了 _DIFF 函数，实现对象 diff 功能，即“【备注】从【132】修改为【1324】”。因此，我们需要在 UserSaveReqVO 类上添加 @DiffLogField 注解，如下图所示：\n\n\n\n * 注解的 name 字段：字段的中文名，例如说：“【备注】”\n * 注解的 function 字段：自定义函数，用于字段的值翻译，例如说：PostParseFunction 岗位名、DeptParseFunction 部门名、SexParseFunction 性别等等\n\n② 在 Service 方法上，添加 @LogRecord 注解，如下图所示：\n\n\n\n最终，我们记录操作日志的内容，如下图所示：\n\n\n\n\n# 1.4 更多场景\n\n由于操作日志需要手动记录，再加上是新改造的，所以目前只有少数几个地方使用了。后续，我们会逐步完善，让操作日志更加完善。\n\n目前，CRM 模块的操作日志是最全的，应该有大几十个使用案例，大家碰到不会使用的地方，可以参考下。\n\n\n# 2. 登录日志\n\n登录日志，记录用户的登录、登出行为，包括成功的、失败的。\n\n打开 [系统管理 -> 审计日志 -> 登录日志] 菜单，可以看对应的列表，如下图所示：\n\n\n\n登录日志的存储，由 yudao-module-system 的 LoginLog 模块实现，记录到数据库的 system_login_log 表。\n\n登录类型通过 LoginLogTypeEnum 枚举，登录结果通过 LoginResultEnum 枚举，都可以自定义。代码如下：\n\n\n\n\n# 3. API 访问日志\n\n\n# 3.1 数据库记录\n\nAPI 访问日志，记录 API 的每次调用，包括 HTTP 请求、用户、开始时间、时长等等信息。\n\n打开 [基础设施 -> API 日志 -> 访问日志] 菜单，可以看对应的列表，如下图所示：\n\n\n\n① 访问日志的记录，由 yudao-spring-boot-starter-web 技术组件实现，通过 ApiAccessLogFilter 过滤 RESTful API 请求，异步记录日志。\n\n② 访问日志的存储，由 yudao-module-infra 的 AccessLog 模块实现，记录到数据库的 infra_api_access_log 表。\n\n③ 可以通过 @ApiAccessLog 注解，自定义 API 访问日志的记录。如下图所示：\n\n\n\n * enable 字段：是否记录日志，默认为 true 记录日志。如果你想某个接口不记录日志，可以设置为 false，例如说 NotifyMessageController 的 #getUnreadNotifyMessageCount() 接口\n * requestEnable 字段：默认为 true 记录请求参数，主要考虑请求参数一般不大。如果你想某个接口不记录请求参数，可以设置为 false\n * sanitizeKeys 字段：脱敏字段，例如说：密码、访问令牌等等。如果你想某个接口脱敏某个字段，可以设置为 password、mobile 等等。另外，ApiAccessLogFilter 默认有 SANITIZE_KEYS 全局配置，包括 password、accessToken、refreshToken 等，避免大家忘记~\n * responseEnable 字段：默认为 false 不记录响应参数，主要考虑响应参数一般比较大，特别是 GET 列表请求。如果你想某个接口记录响应参数，可以设置为 true\n * operateModule 字段：操作模块，例如说：用户、岗位、部门等等。为空时，默认会读取类上的 Swagger @Tag 注解的 name 属性\n * operateName 字段：操作名，例如说：新增用户、修改用户等等。为空时，默认会读取方法的 Swagger @Operation 注解的 summary 属性\n * operateType 字段：操作类型，操作类型，在 OperateTypeEnum 枚举。目前有 GET 查询、CREATE 新增、UPDATE 修改、DELETE 删除、EXPORT 导出、IMPORT 导入、OTHER 其它，可进行自定义\n\n疑问：为什么要增加 `operateModule`、`operateName`、`operateType` 字段呢？\n\n从感受上来说，它们应该属于“操作日志”，不应该记录到“访问日志”中。但是考虑到“操作日志”需要手动记录，可能大家会“偷懒”不想记录，但是业务人员（例如说：产品、运行）等看不懂“访问日志”，所以增加了这些字段，方便大家查看。\n\n④ 我们在 local 本地环境下，一般做一些日常开发，使用不到“访问日志”，所以默认在 application-local.yaml 配置文件里，我们设置 yudao.access-log.enable 为 false 默认不记录，大家如果有需要，可以设置为 true 打开进行记录。\n\n\n# 3.2 文件记录\n\n项目还提供了 ApiAccessLogInterceptor 拦截器，打印 HTTP 请求、参数、耗时到文件（IDEA 控制台）中，方便大家进行调试。如下图所示：\n\n\n\n每次请求有两条：一条 request 【开始请求】包括请求 URL、请求参数；一条 response 【结束请求】只包括耗时。\n\n另外，考虑到 ApiAccessLogInterceptor 的定位是开发调试，所以 prod 生产环境默认不开启噢，当然你也可以按照自己需要修改。\n\n\n# 4. API 错误日志\n\nAPI 错误日志，记录每次 API 的异常调用，包括 HTTP 请求、用户、异常的堆栈等等信息。\n\n打开 [基础设施 -> API 日志 -> 错误日志] 菜单，可以看对应的列表，如下图所示：\n\n\n\n错误日志的记录，由 yudao-spring-boot-starter-web 技术组件实现，通过 GlobalExceptionHandler 拦截每次 RESTful API 的系统异常，异步记录日志。\n\n\n\n错误日志的存储，由 yudao-module-infra 的 ErrorLog 模块实现，记录到数据库的 infra_api_error_log 表。",
            normalizedContent: "项目提供 2 类 4 种系统日志：\n\n * 审计日志：用户的操作日志、登录日志\n * api 日志：restful api 的访问日志、错误日志\n\n\n# 1. 操作日志\n\n操作日志，记录「谁」在「什么时间」对「什么对象」做了「什么事情」。\n\n打开 [系统管理 -> 审计日志 -> 操作日志] 菜单，可以看到对应的列表，如下图所示：\n\n\n\n\n# 1.1 操作日志组件\n\n① 操作日志的记录，由 yudao-spring-boot-starter-security 技术组件的 operatelog 包提供，基于我老友开源的 https://github.com/mouzt/mzt-biz-log 实现，只需要添加 @logrecord 注解，即可实现操作日志的记录。\n\n\n\n * 【新增】2021-09-16 10:00 订单创建，订单号：no.11089999，其中涉及变量订单号 “no.11089999”\n * 【修改】2021-09-16 10:00 用户小明修改了订单的配送地址：从 “金灿灿小区” 修改到 “银盏盏小区”\n\n疑问：为什么不独立一个 `yudao-spring-boot-starter-operatelog` 组件呢？\n\n早期，项目确实有 operatelog 组件，和 mzt-biz-log 组件一样，也是基于 spring aop + 注解实现。\n\n随着我老友开源了 mzt-biz-log 组件，再加上希望减少项目的 starter 数量，所以决定直接使用 mzt-biz-log 组件，放到 security 组件中，而不是自己再造一个轮子。\n\n② 操作日志的存储，由 yudao-module-system 的 operatelog 模块实现，记录到数据库的 system_operate_log 表。\n\n----------------------------------------\n\n下面，我们来看项目中的几个使用案例。在开始之前，希望你先简单通读下 《mzt-biz-log 使用指南》 文档。\n\n\n# 1.2 场景一：创建用户\n\n① 在 logrecordconstants 类中，定义 system_user_create_sub_type、system_user_create_success 变量。如下图所示：\n\n\n\n疑问：为什么要在 logrecordconstants 定义？\n\n这个并非强制，只是一个使用建议。每个 yudao-module-xxx 模块下，建议都搞一个 logrecordconstants 类，方便大家统一管理操作日志的常量，这样方便大家查找。\n\n② 在 service 方法上，添加 @logrecord 注解，如下图所示：\n\n\n\n最终，我们记录操作日志的内容，如下图所示：\n\n\n\n\n# 1.3 场景二：修改用户信息\n\n① 在 logrecordconstants 类中，定义 system_user_update_sub_type、system_user_update_success 变量。如下图所示：\n\n\n\n这里我们使用了 _diff 函数，实现对象 diff 功能，即“【备注】从【132】修改为【1324】”。因此，我们需要在 usersavereqvo 类上添加 @difflogfield 注解，如下图所示：\n\n\n\n * 注解的 name 字段：字段的中文名，例如说：“【备注】”\n * 注解的 function 字段：自定义函数，用于字段的值翻译，例如说：postparsefunction 岗位名、deptparsefunction 部门名、sexparsefunction 性别等等\n\n② 在 service 方法上，添加 @logrecord 注解，如下图所示：\n\n\n\n最终，我们记录操作日志的内容，如下图所示：\n\n\n\n\n# 1.4 更多场景\n\n由于操作日志需要手动记录，再加上是新改造的，所以目前只有少数几个地方使用了。后续，我们会逐步完善，让操作日志更加完善。\n\n目前，crm 模块的操作日志是最全的，应该有大几十个使用案例，大家碰到不会使用的地方，可以参考下。\n\n\n# 2. 登录日志\n\n登录日志，记录用户的登录、登出行为，包括成功的、失败的。\n\n打开 [系统管理 -> 审计日志 -> 登录日志] 菜单，可以看对应的列表，如下图所示：\n\n\n\n登录日志的存储，由 yudao-module-system 的 loginlog 模块实现，记录到数据库的 system_login_log 表。\n\n登录类型通过 loginlogtypeenum 枚举，登录结果通过 loginresultenum 枚举，都可以自定义。代码如下：\n\n\n\n\n# 3. api 访问日志\n\n\n# 3.1 数据库记录\n\napi 访问日志，记录 api 的每次调用，包括 http 请求、用户、开始时间、时长等等信息。\n\n打开 [基础设施 -> api 日志 -> 访问日志] 菜单，可以看对应的列表，如下图所示：\n\n\n\n① 访问日志的记录，由 yudao-spring-boot-starter-web 技术组件实现，通过 apiaccesslogfilter 过滤 restful api 请求，异步记录日志。\n\n② 访问日志的存储，由 yudao-module-infra 的 accesslog 模块实现，记录到数据库的 infra_api_access_log 表。\n\n③ 可以通过 @apiaccesslog 注解，自定义 api 访问日志的记录。如下图所示：\n\n\n\n * enable 字段：是否记录日志，默认为 true 记录日志。如果你想某个接口不记录日志，可以设置为 false，例如说 notifymessagecontroller 的 #getunreadnotifymessagecount() 接口\n * requestenable 字段：默认为 true 记录请求参数，主要考虑请求参数一般不大。如果你想某个接口不记录请求参数，可以设置为 false\n * sanitizekeys 字段：脱敏字段，例如说：密码、访问令牌等等。如果你想某个接口脱敏某个字段，可以设置为 password、mobile 等等。另外，apiaccesslogfilter 默认有 sanitize_keys 全局配置，包括 password、accesstoken、refreshtoken 等，避免大家忘记~\n * responseenable 字段：默认为 false 不记录响应参数，主要考虑响应参数一般比较大，特别是 get 列表请求。如果你想某个接口记录响应参数，可以设置为 true\n * operatemodule 字段：操作模块，例如说：用户、岗位、部门等等。为空时，默认会读取类上的 swagger @tag 注解的 name 属性\n * operatename 字段：操作名，例如说：新增用户、修改用户等等。为空时，默认会读取方法的 swagger @operation 注解的 summary 属性\n * operatetype 字段：操作类型，操作类型，在 operatetypeenum 枚举。目前有 get 查询、create 新增、update 修改、delete 删除、export 导出、import 导入、other 其它，可进行自定义\n\n疑问：为什么要增加 `operatemodule`、`operatename`、`operatetype` 字段呢？\n\n从感受上来说，它们应该属于“操作日志”，不应该记录到“访问日志”中。但是考虑到“操作日志”需要手动记录，可能大家会“偷懒”不想记录，但是业务人员（例如说：产品、运行）等看不懂“访问日志”，所以增加了这些字段，方便大家查看。\n\n④ 我们在 local 本地环境下，一般做一些日常开发，使用不到“访问日志”，所以默认在 application-local.yaml 配置文件里，我们设置 yudao.access-log.enable 为 false 默认不记录，大家如果有需要，可以设置为 true 打开进行记录。\n\n\n# 3.2 文件记录\n\n项目还提供了 apiaccessloginterceptor 拦截器，打印 http 请求、参数、耗时到文件（idea 控制台）中，方便大家进行调试。如下图所示：\n\n\n\n每次请求有两条：一条 request 【开始请求】包括请求 url、请求参数；一条 response 【结束请求】只包括耗时。\n\n另外，考虑到 apiaccessloginterceptor 的定位是开发调试，所以 prod 生产环境默认不开启噢，当然你也可以按照自己需要修改。\n\n\n# 4. api 错误日志\n\napi 错误日志，记录每次 api 的异常调用，包括 http 请求、用户、异常的堆栈等等信息。\n\n打开 [基础设施 -> api 日志 -> 错误日志] 菜单，可以看对应的列表，如下图所示：\n\n\n\n错误日志的记录，由 yudao-spring-boot-starter-web 技术组件实现，通过 globalexceptionhandler 拦截每次 restful api 的系统异常，异步记录日志。\n\n\n\n错误日志的存储，由 yudao-module-infra 的 errorlog 模块实现，记录到数据库的 infra_api_error_log 表。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "MyBatis 联表&分页查询",
            frontmatter: {
                title: "MyBatis 联表&分页查询",
                date: "2023-09-09T23:00:34.000Z",
                permalink: "/mybatis-pro/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/02.%E5%90%8E%E7%AB%AF%E6%89%8B%E5%86%8C/26.MyBatis%20%E8%81%94%E8%A1%A8x%E5%88%86%E9%A1%B5.html",
            relativePath: "01.开发指南/02.后端手册/26.MyBatis 联表x分页.md",
            key: "v-a9ac9b64",
            path: "/mybatis-pro/",
            headers: [{
                level: 2,
                title: "1. 分页查询",
                slug: "_1-分页查询",
                normalizedTitle: "1. 分页查询",
                charIndex: 41
            }, {
                level: 3,
                title: "1.1 方案一：MyBatis XML",
                slug: "_1-1-方案一-mybatis-xml",
                normalizedTitle: "1.1 方案一：mybatis xml",
                charIndex: 187
            }, {
                level: 3,
                title: "1.2 方案二：MyBatis Plus XML",
                slug: "_1-2-方案二-mybatis-plus-xml",
                normalizedTitle: "1.2 方案二：mybatis plus xml",
                charIndex: 2562
            }, {
                level: 2,
                title: "2. 联表查询",
                slug: "_2-联表查询",
                normalizedTitle: "2. 联表查询",
                charIndex: 4543
            }, {
                level: 3,
                title: "2.1 案例一：字段平铺",
                slug: "_2-1-案例一-字段平铺",
                normalizedTitle: "2.1 案例一：字段平铺",
                charIndex: 4761
            }, {
                level: 3,
                title: "2.2 案例二：字段内嵌",
                slug: "_2-2-案例二-字段内嵌",
                normalizedTitle: "2.2 案例二：字段内嵌",
                charIndex: 5825
            }, {
                level: 3,
                title: "2.3 总结",
                slug: "_2-3-总结",
                normalizedTitle: "2.3 总结",
                charIndex: 6704
            }],
            headersStr: "1. 分页查询 1.1 方案一：MyBatis XML 1.2 方案二：MyBatis Plus XML 2. 联表查询 2.1 案例一：字段平铺 2.2 案例二：字段内嵌 2.3 总结",
            content: '本文，分享 MyBatis 各种常用操作，不限于链表查询、分页查询等等。\n\n\n# 1. 分页查询\n\n在 《MyBatis 数据库》 的「3.4 selectPage」小节，我们使用 MyBatis Plus 实现了分页查询。除了这种方式，我们也可以使用 XML 实现分页查询。\n\n这里，以查询 system_users 表为例，讲解如何使用 XML 实现分页查询。\n\n\n# 1.1 方案一：MyBatis XML\n\n这个是 MyBatis 内置的使用方式，步骤如下：\n\n\n\n① 创建 AdminUserMapper.xml 文件，编写两个 SQL 查询语句：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">\n<mapper namespace="cn.iocoder.yudao.module.system.dal.mysql.user.AdminUserMapper">\n\n    <select id="selectPage01List"\n            resultType="cn.iocoder.yudao.module.system.dal.dataobject.user.AdminUserDO" >\n        SELECT * FROM system_users\n        <where>\n            <if test="reqVO.username != null and reqVO.username !=\'\'">\n                AND username LIKE CONCAT(\'%\',#{reqVO.username},\'%\')\n            </if>\n            <if test="reqVO.createTime != null">\n                AND create_time BETWEEN #{reqVO.createTime[0]}, #{reqVO.createTime[1]},\n            </if>\n            <if test="reqVO.status != null">\n                AND status = #{reqVO.status}\n            </if>\n        </where>\n        ORDER BY id DESC\n        LIMIT #{reqVO.pageNo}, #{reqVO.pageSize}\n    </select>\n\n    <select id="selectPage01Count" resultType="Long" >\n        SELECT COUNT(1) FROM system_users\n        <where>\n            <if test="reqVO.username != null and reqVO.username !=\'\'">\n                AND username LIKE CONCAT(\'%\',#{reqVO.username},\'%\')\n            </if>\n            <if test="reqVO.createTime != null">\n                AND create_time BETWEEN #{reqVO.createTime[0]}, #{reqVO.createTime[1]},\n            </if>\n            <if test="reqVO.status != null">\n                AND status = #{reqVO.status}\n            </if>\n        </where>\n    </select>\n\n</mapper>\n\n\n② 在 AdminUserMapper 创建这两 SQL 对应的方法：\n\n@Mapper\npublic interface AdminUserMapper extends BaseMapperX<AdminUserDO> {\n\n    /**\n     * 查询分页的列表\n     */\n    List<AdminUserDO> selectPage01List(@Param("reqVO") UserPageReqVO reqVO);\n\n    /**\n     * 查询分页的条数\n     */\n    Long selectPage01Count(@Param("reqVO") UserPageReqVO reqVO);\n\n}\n\n\n其中 UserPageReqVO.java 是分页查询的请求 VO。\n\n③ 在 AdminUserServiceImplService 层，调用这两个方法，实现分页查询：\n\n@Service\n@Slf4j\npublic class AdminUserServiceImpl implements AdminUserService {\n\n    @Override\n    public PageResult<AdminUserDO> getUserPage(UserPageReqVO reqVO) {\n        return new PageResult<>(\n                userMapper.selectPage01List(reqVO),\n                userMapper.selectPage01Count(reqVO)\n        );\n    }\n}\n\n\n④ 简单调用下，可以在 IDEA 控制台看到 2 条 SQL：\n\n\n\n\n# 1.2 方案二：MyBatis Plus XML\n\n这个是 MyBatis Plus 拓展的使用方式，可以简化只需要写一条 SQL，步骤如下：\n\n\n\n① 创建 AdminUserMapper.xml 文件，只编写一个 SQL 查询语句：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">\n<mapper namespace="cn.iocoder.yudao.module.system.dal.mysql.user.AdminUserMapper">\n\n    <select id="selectPage02"\n            resultType="cn.iocoder.yudao.module.system.dal.dataobject.user.AdminUserDO" >\n        SELECT * FROM system_users\n        <where>\n            <if test="reqVO.username != null and reqVO.username !=\'\'">\n                AND username LIKE CONCAT(\'%\',#{reqVO.username},\'%\')\n            </if>\n            <if test="reqVO.createTime != null">\n                AND create_time BETWEEN #{reqVO.createTime[0]}, #{reqVO.createTime[1]},\n            </if>\n            <if test="reqVO.status != null">\n                AND status = #{reqVO.status}\n            </if>\n        </where>\n        ORDER BY id DESC\n    </select>\n\n</mapper>\n\n\n注意，不需要写 LIMIT 分页语句噢。\n\n② 在 AdminUserMapper 创建这一 SQL 对应的方法：\n\n@Mapper\npublic interface AdminUserMapper extends BaseMapperX<AdminUserDO> {\n\n    IPage<AdminUserDO> selectPage02(IPage<AdminUserDO> page, @Param("reqVO") UserPageReqVO reqVO);\n\n}\n\n\n第一个参数、返回结果必须都是 IPage 类型，第二个参数可以放查询条件。\n\n③ 在 AdminUserServiceImplService 层，调用这一个方法，实现分页查询：\n\n@Service\n@Slf4j\npublic class AdminUserServiceImpl implements AdminUserService {\n\n    @Override\n    public PageResult<AdminUserDO> getUserPage(UserPageReqVO reqVO) {\n        // 必须使用 MyBatis Plus 的分页对象\n        IPage<AdminUserDO> page = new Page<>(reqVO.getPageNo(), reqVO.getPageSize());\n        userMapper.selectPage02(page, reqVO);\n        return new PageResult<>(page.getRecords(), page.getTotal());\n    }\n}\n\n\n因为项目使用 PageParam 和 PageResult 作为分页对象，所以需要和 IPage 做下转换。\n\n④ 简单调用下，可以在 IDEA 控制台看到 2 条 SQL：\n\n\n\n本质上，MyBatis Plus 是基于我们在 XML 编写的这条 SQL，计算出获得分页数量的 SQL。\n\n一般情况下，建议采用方案二：MyBatis Plus XML，因为它开发效率更高，并且在分页数量为 0 时，就不多余查询分页的列表，一定程度上可以提升性能。\n\n\n# 2. 联表查询\n\n对于需要链表查询的场景，建议也是写 MyBatis XML，使用方法比较简单，可以看下 《MyBatis学习总结（三）—— 多表关联查询与动态 SQL》 文章。\n\n除了 XML 这种方式外，项目也集成了 MyBatis Plus Join 框架，通过 Java 代码实现联表查询。\n\n这里，以查询 system_users 和 system_dept 联表，查询部门名为 芋道源码、用户状态为开启的用户列表。\n\n\n# 2.1 案例一：字段平铺\n\n① 创建 AdminUserDetailDO 类，继承 AdminUserDO 类，并添加 deptName 平铺。代码如下：\n\n@Data\npublic class AdminUserDetailDO extends AdminUserDO {\n\n    private String deptName;\n\n}\n\n\n② 在 AdminUserMapper 创建 selectListByStatusAndDeptName 方法，代码如下：\n\n@Mapper\npublic interface AdminUserMapper extends BaseMapperX<AdminUserDO> {\n\n    default List<AdminUserDetailDO> selectList2ByStatusAndDeptName(Integer status, String deptName) {\n        return selectJoinList(AdminUserDetailDO.class, new MPJLambdaWrapper<AdminUserDO>() // 查询 List\n                .selectAll(AdminUserDO.class) // 查询 system_users 表的 all 所有字段\n                .selectAs(DeptDO::getName, AdminUserDetailDO::getDeptName) // 查询 system_dept 表的 name 字段，使用 deptName 字段“部分”返回\n                .eq(AdminUserDO::getStatus, status) // WHERE system_users.status = ? 【部门名为 `芋道源码`】\n                .leftJoin(DeptDO.class, DeptDO::getId, AdminUserDO::getDeptId) // 联表 WHERE system_users.dept_id = system_dept.id \n                .eq(DeptDO::getName, deptName) // WHERE system_dept.name = ? 【用户状态为开启】\n        );\n    }\n    \n}\n\n\n\n# 2.2 案例二：字段内嵌\n\n① 创建 AdminUserDetailDO 类，继承 AdminUserDO 类，并添加 dept 部门。代码如下：\n\n@Data\npublic class AdminUserDetail2DO extends AdminUserDO {\n\n    private DeptDO dept;\n\n}\n\n\n② 在 AdminUserMapper 创建 selectListByStatusAndDeptName 方法，代码如下：\n\n@Mapper\npublic interface AdminUserMapper extends BaseMapperX<AdminUserDO> {\n\n    default List<AdminUserDetail2DO> selectListByStatusAndDeptName(Integer status, String deptName) {\n        return selectJoinList(AdminUserDetail2DO.class, new MPJLambdaWrapper<AdminUserDO>()\n                .selectAll(AdminUserDO.class)\n                .selectAssociation(DeptDO.class, AdminUserDetail2DO::getDept) // 重点差异点：查询 system_dept 表的 name 字段，使用 dept 字段“整个”返回\n                .eq(AdminUserDO::getStatus, status)\n                .leftJoin(DeptDO.class, DeptDO::getId, AdminUserDO::getDeptId)\n                .eq(DeptDO::getName, deptName)\n        );\n    }\n\n}\n\n\n\n# 2.3 总结\n\nMyBatis Plus Join 相比 MyBatis XML 来说，一开始肯定是需要多看看它的文档。\n\n但是熟悉后，我还是更喜欢使用 MyBatis Plus Join 哈~',
            normalizedContent: '本文，分享 mybatis 各种常用操作，不限于链表查询、分页查询等等。\n\n\n# 1. 分页查询\n\n在 《mybatis 数据库》 的「3.4 selectpage」小节，我们使用 mybatis plus 实现了分页查询。除了这种方式，我们也可以使用 xml 实现分页查询。\n\n这里，以查询 system_users 表为例，讲解如何使用 xml 实现分页查询。\n\n\n# 1.1 方案一：mybatis xml\n\n这个是 mybatis 内置的使用方式，步骤如下：\n\n\n\n① 创建 adminusermapper.xml 文件，编写两个 sql 查询语句：\n\n<?xml version="1.0" encoding="utf-8"?>\n<!doctype mapper public "-//mybatis.org//dtd mapper 3.0//en" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">\n<mapper namespace="cn.iocoder.yudao.module.system.dal.mysql.user.adminusermapper">\n\n    <select id="selectpage01list"\n            resulttype="cn.iocoder.yudao.module.system.dal.dataobject.user.adminuserdo" >\n        select * from system_users\n        <where>\n            <if test="reqvo.username != null and reqvo.username !=\'\'">\n                and username like concat(\'%\',#{reqvo.username},\'%\')\n            </if>\n            <if test="reqvo.createtime != null">\n                and create_time between #{reqvo.createtime[0]}, #{reqvo.createtime[1]},\n            </if>\n            <if test="reqvo.status != null">\n                and status = #{reqvo.status}\n            </if>\n        </where>\n        order by id desc\n        limit #{reqvo.pageno}, #{reqvo.pagesize}\n    </select>\n\n    <select id="selectpage01count" resulttype="long" >\n        select count(1) from system_users\n        <where>\n            <if test="reqvo.username != null and reqvo.username !=\'\'">\n                and username like concat(\'%\',#{reqvo.username},\'%\')\n            </if>\n            <if test="reqvo.createtime != null">\n                and create_time between #{reqvo.createtime[0]}, #{reqvo.createtime[1]},\n            </if>\n            <if test="reqvo.status != null">\n                and status = #{reqvo.status}\n            </if>\n        </where>\n    </select>\n\n</mapper>\n\n\n② 在 adminusermapper 创建这两 sql 对应的方法：\n\n@mapper\npublic interface adminusermapper extends basemapperx<adminuserdo> {\n\n    /**\n     * 查询分页的列表\n     */\n    list<adminuserdo> selectpage01list(@param("reqvo") userpagereqvo reqvo);\n\n    /**\n     * 查询分页的条数\n     */\n    long selectpage01count(@param("reqvo") userpagereqvo reqvo);\n\n}\n\n\n其中 userpagereqvo.java 是分页查询的请求 vo。\n\n③ 在 adminuserserviceimplservice 层，调用这两个方法，实现分页查询：\n\n@service\n@slf4j\npublic class adminuserserviceimpl implements adminuserservice {\n\n    @override\n    public pageresult<adminuserdo> getuserpage(userpagereqvo reqvo) {\n        return new pageresult<>(\n                usermapper.selectpage01list(reqvo),\n                usermapper.selectpage01count(reqvo)\n        );\n    }\n}\n\n\n④ 简单调用下，可以在 idea 控制台看到 2 条 sql：\n\n\n\n\n# 1.2 方案二：mybatis plus xml\n\n这个是 mybatis plus 拓展的使用方式，可以简化只需要写一条 sql，步骤如下：\n\n\n\n① 创建 adminusermapper.xml 文件，只编写一个 sql 查询语句：\n\n<?xml version="1.0" encoding="utf-8"?>\n<!doctype mapper public "-//mybatis.org//dtd mapper 3.0//en" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">\n<mapper namespace="cn.iocoder.yudao.module.system.dal.mysql.user.adminusermapper">\n\n    <select id="selectpage02"\n            resulttype="cn.iocoder.yudao.module.system.dal.dataobject.user.adminuserdo" >\n        select * from system_users\n        <where>\n            <if test="reqvo.username != null and reqvo.username !=\'\'">\n                and username like concat(\'%\',#{reqvo.username},\'%\')\n            </if>\n            <if test="reqvo.createtime != null">\n                and create_time between #{reqvo.createtime[0]}, #{reqvo.createtime[1]},\n            </if>\n            <if test="reqvo.status != null">\n                and status = #{reqvo.status}\n            </if>\n        </where>\n        order by id desc\n    </select>\n\n</mapper>\n\n\n注意，不需要写 limit 分页语句噢。\n\n② 在 adminusermapper 创建这一 sql 对应的方法：\n\n@mapper\npublic interface adminusermapper extends basemapperx<adminuserdo> {\n\n    ipage<adminuserdo> selectpage02(ipage<adminuserdo> page, @param("reqvo") userpagereqvo reqvo);\n\n}\n\n\n第一个参数、返回结果必须都是 ipage 类型，第二个参数可以放查询条件。\n\n③ 在 adminuserserviceimplservice 层，调用这一个方法，实现分页查询：\n\n@service\n@slf4j\npublic class adminuserserviceimpl implements adminuserservice {\n\n    @override\n    public pageresult<adminuserdo> getuserpage(userpagereqvo reqvo) {\n        // 必须使用 mybatis plus 的分页对象\n        ipage<adminuserdo> page = new page<>(reqvo.getpageno(), reqvo.getpagesize());\n        usermapper.selectpage02(page, reqvo);\n        return new pageresult<>(page.getrecords(), page.gettotal());\n    }\n}\n\n\n因为项目使用 pageparam 和 pageresult 作为分页对象，所以需要和 ipage 做下转换。\n\n④ 简单调用下，可以在 idea 控制台看到 2 条 sql：\n\n\n\n本质上，mybatis plus 是基于我们在 xml 编写的这条 sql，计算出获得分页数量的 sql。\n\n一般情况下，建议采用方案二：mybatis plus xml，因为它开发效率更高，并且在分页数量为 0 时，就不多余查询分页的列表，一定程度上可以提升性能。\n\n\n# 2. 联表查询\n\n对于需要链表查询的场景，建议也是写 mybatis xml，使用方法比较简单，可以看下 《mybatis学习总结（三）—— 多表关联查询与动态 sql》 文章。\n\n除了 xml 这种方式外，项目也集成了 mybatis plus join 框架，通过 java 代码实现联表查询。\n\n这里，以查询 system_users 和 system_dept 联表，查询部门名为 芋道源码、用户状态为开启的用户列表。\n\n\n# 2.1 案例一：字段平铺\n\n① 创建 adminuserdetaildo 类，继承 adminuserdo 类，并添加 deptname 平铺。代码如下：\n\n@data\npublic class adminuserdetaildo extends adminuserdo {\n\n    private string deptname;\n\n}\n\n\n② 在 adminusermapper 创建 selectlistbystatusanddeptname 方法，代码如下：\n\n@mapper\npublic interface adminusermapper extends basemapperx<adminuserdo> {\n\n    default list<adminuserdetaildo> selectlist2bystatusanddeptname(integer status, string deptname) {\n        return selectjoinlist(adminuserdetaildo.class, new mpjlambdawrapper<adminuserdo>() // 查询 list\n                .selectall(adminuserdo.class) // 查询 system_users 表的 all 所有字段\n                .selectas(deptdo::getname, adminuserdetaildo::getdeptname) // 查询 system_dept 表的 name 字段，使用 deptname 字段“部分”返回\n                .eq(adminuserdo::getstatus, status) // where system_users.status = ? 【部门名为 `芋道源码`】\n                .leftjoin(deptdo.class, deptdo::getid, adminuserdo::getdeptid) // 联表 where system_users.dept_id = system_dept.id \n                .eq(deptdo::getname, deptname) // where system_dept.name = ? 【用户状态为开启】\n        );\n    }\n    \n}\n\n\n\n# 2.2 案例二：字段内嵌\n\n① 创建 adminuserdetaildo 类，继承 adminuserdo 类，并添加 dept 部门。代码如下：\n\n@data\npublic class adminuserdetail2do extends adminuserdo {\n\n    private deptdo dept;\n\n}\n\n\n② 在 adminusermapper 创建 selectlistbystatusanddeptname 方法，代码如下：\n\n@mapper\npublic interface adminusermapper extends basemapperx<adminuserdo> {\n\n    default list<adminuserdetail2do> selectlistbystatusanddeptname(integer status, string deptname) {\n        return selectjoinlist(adminuserdetail2do.class, new mpjlambdawrapper<adminuserdo>()\n                .selectall(adminuserdo.class)\n                .selectassociation(deptdo.class, adminuserdetail2do::getdept) // 重点差异点：查询 system_dept 表的 name 字段，使用 dept 字段“整个”返回\n                .eq(adminuserdo::getstatus, status)\n                .leftjoin(deptdo.class, deptdo::getid, adminuserdo::getdeptid)\n                .eq(deptdo::getname, deptname)\n        );\n    }\n\n}\n\n\n\n# 2.3 总结\n\nmybatis plus join 相比 mybatis xml 来说，一开始肯定是需要多看看它的文档。\n\n但是熟悉后，我还是更喜欢使用 mybatis plus join 哈~',
            charsets: {
                cjk: !0
            }
        }, {
            title: "MyBatis 数据库",
            frontmatter: {
                title: "MyBatis 数据库",
                date: "2022-04-01T23:00:34.000Z",
                permalink: "/mybatis"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/02.%E5%90%8E%E7%AB%AF%E6%89%8B%E5%86%8C/25.MyBatis%20%E6%95%B0%E6%8D%AE%E5%BA%93.html",
            relativePath: "01.开发指南/02.后端手册/25.MyBatis 数据库.md",
            key: "v-4a7d74a0",
            path: "/mybatis/",
            headers: [{
                level: 2,
                title: "1. 实体类",
                slug: "_1-实体类",
                normalizedTitle: "1. 实体类",
                charIndex: 214
            }, {
                level: 3,
                title: "1.1 主键编号",
                slug: "_1-1-主键编号",
                normalizedTitle: "1.1 主键编号",
                charIndex: 1514
            }, {
                level: 3,
                title: "1.2 逻辑删除",
                slug: "_1-2-逻辑删除",
                normalizedTitle: "1.2 逻辑删除",
                charIndex: 1822
            }, {
                level: 3,
                title: "1.3 自动填充",
                slug: "_1-3-自动填充",
                normalizedTitle: "1.3 自动填充",
                charIndex: 2359
            }, {
                level: 3,
                title: "1.4 “复杂”字段类型",
                slug: "_1-4-复杂-字段类型",
                normalizedTitle: "1.4 “复杂”字段类型",
                charIndex: 2442
            }, {
                level: 2,
                title: "2. 编码规范",
                slug: "_2-编码规范",
                normalizedTitle: "2. 编码规范",
                charIndex: 2823
            }, {
                level: 2,
                title: "3. CRUD 接口",
                slug: "_3-crud-接口",
                normalizedTitle: "3. crud 接口",
                charIndex: 3603
            }, {
                level: 3,
                title: "3.1 selectOne",
                slug: "_3-1-selectone",
                normalizedTitle: "3.1 selectone",
                charIndex: 3683
            }, {
                level: 3,
                title: "3.2 selectCount",
                slug: "_3-2-selectcount",
                normalizedTitle: "3.2 selectcount",
                charIndex: 3743
            }, {
                level: 3,
                title: "3.3 selectList",
                slug: "_3-3-selectlist",
                normalizedTitle: "3.3 selectlist",
                charIndex: 3808
            }, {
                level: 3,
                title: "3.4 selectPage",
                slug: "_3-4-selectpage",
                normalizedTitle: "3.4 selectpage",
                charIndex: 3870
            }, {
                level: 3,
                title: "3.5 insertBatch",
                slug: "_3-5-insertbatch",
                normalizedTitle: "3.5 insertbatch",
                charIndex: 4944
            }, {
                level: 2,
                title: "4. 批量插入",
                slug: "_4-批量插入",
                normalizedTitle: "4. 批量插入",
                charIndex: 5166
            }, {
                level: 2,
                title: "5. 条件构造器",
                slug: "_5-条件构造器",
                normalizedTitle: "5. 条件构造器",
                charIndex: 5267
            }, {
                level: 2,
                title: "6. Mapper XML",
                slug: "_6-mapper-xml",
                normalizedTitle: "6. mapper xml",
                charIndex: 5410
            }, {
                level: 2,
                title: "7. 字段加密",
                slug: "_7-字段加密",
                normalizedTitle: "7. 字段加密",
                charIndex: 5583
            }],
            headersStr: "1. 实体类 1.1 主键编号 1.2 逻辑删除 1.3 自动填充 1.4 “复杂”字段类型 2. 编码规范 3. CRUD 接口 3.1 selectOne 3.2 selectCount 3.3 selectList 3.4 selectPage 3.5 insertBatch 4. 批量插入 5. 条件构造器 6. Mapper XML 7. 字段加密",
            content: "yudao-spring-boot-starter-mybatis 技术组件，基于 MyBatis Plus 实现数据库的操作。如果你没有学习过 MyBatis Plus，建议先阅读 《芋道 Spring Boot MyBatis 入门 》 文章。\n\n友情提示\n\nMyBatis 是最容易读懂的 Java 框架之一，感兴趣的话，可以看看艿艿写的 《芋道 MyBatis 源码解析》 系列，已经有 18000 人学习过！\n\n\n# 1. 实体类\n\nBaseDO 是所有数据库实体的父类，代码如下：\n\n@Data\npublic abstract class BaseDO implements Serializable {\n\n    /**\n     * 创建时间\n     */\n    @TableField(fill = FieldFill.INSERT)\n    private Date createTime;\n    /**\n     * 最后更新时间\n     */\n    @TableField(fill = FieldFill.INSERT_UPDATE)\n    private Date updateTime;\n    /**\n     * 创建者，目前使用 AdminUserDO / MemberUserDO 的 id 编号\n     *\n     * 使用 String 类型的原因是，未来可能会存在非数值的情况，留好拓展性。\n     */\n    @TableField(fill = FieldFill.INSERT)\n    private String creator;\n    /**\n     * 更新者，目前使用 AdminUserDO / MemberUserDO 的 id 编号\n     *\n     * 使用 String 类型的原因是，未来可能会存在非数值的情况，留好拓展性。\n     */\n    @TableField(fill = FieldFill.INSERT_UPDATE)\n    private String updater;\n    /**\n     * 是否删除\n     */\n    @TableLogic\n    private Boolean deleted;\n\n}\n\n\n * createTime + creator 字段，创建人相关信息。\n * updater + updateTime 字段，创建人相关信息。\n * deleted 字段，逻辑删除。\n\n对应的 SQL 字段如下：\n\n`creator` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT '' COMMENT '创建者',\n`create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\n`updater` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT '' COMMENT '更新者',\n`update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',\n`deleted` bit(1) NOT NULL DEFAULT b'0' COMMENT '是否删除',\n\n\n\n# 1.1 主键编号\n\nid 主键编号，推荐使用 Long 型自增，原因是：\n\n * 自增，保证数据库是按顺序写入，性能更加优秀。\n * Long 型，避免未来业务增长，超过 Int 范围。\n\n对应的 SQL 字段如下：\n\n`id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n\n\n项目的 id 默认采用数据库自增的策略，如果希望使用 Snowflake 雪花算法，可以修改 application.yaml 配置文件，将配置项 mybatis-plus.global-config.db-config.id-type 修改为 ASSIGN_ID。如下图所示：\n\n\n\n\n# 1.2 逻辑删除\n\n所有表通过 deleted 字段来实现逻辑删除，值为 0 表示未删除，值为 1 表示已删除，可见 application.yaml 配置文件的 logic-delete-value 和 logic-not-delete-value 配置项。如下图所示：\n\n\n\n① 所有 SELECT 查询，都会自动拼接 WHERE deleted = 0 查询条件，过滤已经删除的记录。如果被删除的记录，只能通过在 XML 或者 @SELECT 来手写 SQL 语句。例如说：\n\n\n\n② 建立唯一索引时，需要额外增加 delete_time 字段，添加到唯一索引字段中，避免唯一索引冲突。例如说，system_users 使用 username 作为唯一索引：\n\n * 未添加前：先逻辑删除了一条 username = yudao 的记录，然后又插入了一条 username = yudao 的记录时，会报索引冲突的异常。\n * 已添加后：先逻辑删除了一条 username = yudao 的记录并更新 delete_time 为当前时间，然后又插入一条 username = yudao 并且 delete_time 为 0 的记录，不会导致唯一索引冲突。\n\n\n# 1.3 自动填充\n\nDefaultDBFieldHandler 基于 MyBatis 自动填充机制，实现 BaseDO 通用字段的自动设置。代码如下如：\n\n\n\n\n# 1.4 “复杂”字段类型\n\nMyBatis Plus 提供 TypeHandler 字段类型处理器，用于 JavaType 与 JdbcType 之间的转换。示例如下：\n\n\n\n常用的字段类型处理器有：\n\n * JacksonTypeHandler：通用的 Jackson 实现 JSON 字段类型处理器。\n * JsonLongSetTypeHandler：针对 Set<Long> 的 Jackson 实现 JSON 字段类型处理器。\n\n另外，如果你后续要拓展自定义的 TypeHandler 实现，可以添加到 cn.iocoder.yudao.framework.mybatis.core.type 包下。\n\n注意事项：\n\n使用 TypeHandler 时，需要设置实体的 @TableName 注解的 @autoResultMap = true。\n\n\n# 2. 编码规范\n\n① 数据库实体类放在 dal.dataobject 包下，以 DO 结尾；数据库访问类放在 dal.mysql 包下，以 Mapper 结尾。如下图所示：\n\n\n\n----------------------------------------\n\n② 数据库实体类的注释要完整，特别是哪些字段是关联（外键）、枚举、冗余等等。例如说：\n\n\n\n----------------------------------------\n\n③ 禁止在 Controller、Service 中，直接进行 MyBatis Plus 操作。原因是：大量 MyBatis 操作散落在 Service 中，会导致 Service 的代码越来乱，无法聚焦业务逻辑。\n\n     示例\n错误   \n正确   \n\n并且，通过只允许将 MyBatis Plus 操作编写 Mapper 层，更好的实现 SELECT 查询的复用，而不是 Service 会存在很多相同且重复的 SELECT 查询的逻辑。\n\n----------------------------------------\n\n④ Mapper 的 SELECT 查询方法的命名，采用 Spring Data 的 \"Query methods\" 策略，方法名使用 selectBy查询条件 规则。例如说：\n\n\n\n----------------------------------------\n\n⑤ 优先使用 LambdaQueryWrapper 条件构造器，使用方法获得字段名，避免手写 \"字段\" 可能写错的情况。例如说：\n\n\n\n----------------------------------------\n\n⑥ 简单的单表查询，优先在 Mapper 中通过 default 方法实现。例如说：\n\n\n\n\n# 3. CRUD 接口\n\nBaseMapperX 接口，继承 MyBatis Plus 的 BaseMapper 接口，提供更强的 CRUD 操作能力。\n\n\n# 3.1 selectOne\n\n#selectOne(...) 方法，使用指定条件，查询单条记录。示例如下：\n\n\n\n\n# 3.2 selectCount\n\n#selectCount(...) 方法，使用指定条件，查询记录的数量。示例如下：\n\n\n\n\n# 3.3 selectList\n\n#selectList(...) 方法，使用指定条件，查询多条记录。示例如下：\n\n\n\n\n# 3.4 selectPage\n\n针对 MyBatis Plus 分页查询的二次分装，在 BaseMapperX 中实现，目的是使用项目自己的分页封装：\n\n * 【入参】查询前，将项目的分页参数 PageParam，转换成 MyBatis Plus 的 IPage 对象。\n * 【出参】查询后，将 MyBatis Plus 的分页结果 IPage，转换成项目的分页结果 PageResult。代码如下图：\n\n\n\n具体的使用示例，可见 TenantMapper 类中，定义 selectPage 查询方法。代码如下：\n\n@Mapper\npublic interface TenantMapper extends BaseMapperX<TenantDO> {\n\n    default PageResult<TenantDO> selectPage(TenantPageReqVO reqVO) {\n        return selectPage(reqVO, new LambdaQueryWrapperX<TenantDO>()\n                .likeIfPresent(TenantDO::getName, reqVO.getName()) // 如果 name 不为空，则进行 like 查询\n                .likeIfPresent(TenantDO::getContactName, reqVO.getContactName())\n                .likeIfPresent(TenantDO::getContactMobile, reqVO.getContactMobile())\n                .eqIfPresent(TenantDO::getStatus, reqVO.getStatus()) // 如果 status 不为空，则进行 = 查询\n                .betweenIfPresent(TenantDO::getCreateTime, reqVO.getBeginCreateTime(), reqVO.getEndCreateTime()) // 如果 create 不为空，则进行 between 查询\n                .orderByDesc(TenantDO::getId)); // 按照 id 倒序\n    }\n    \n}\n\n\n完整实战，可见 《开发指南 —— 分页实现》 文档。\n\n\n# 3.5 insertBatch\n\n#insertBatch(...) 方法，遍历数组，逐条插入数据库中，适合少量数据插入，或者对性能要求不高的场景。 示例如下：\n\n\n\n为什么不使用 insertBatchSomeColumn 批量插入？\n\n * 只支持 MySQL 数据库。其它 Oracle 等数据库使用会报错，可见 InsertBatchSomeColumn 说明。\n * 未支持多租户。插入数据库时，多租户字段不会进行自动赋值。\n\n\n# 4. 批量插入\n\n绝大多数场景下，推荐使用 MyBatis Plus 提供的 IService 的 #saveBatch() 方法。示例 PermissionServiceImpl 如下：\n\n\n\n\n# 5. 条件构造器\n\n继承 MyBatis Plus 的条件构造器，拓展了 LambdaQueryWrapperX 和 QueryWrapperX 类，主要是增加 xxxIfPresent 方法，用于判断值不存在的时候，不要拼接到条件中。例如说：\n\n\n\n具体的使用示例如下：\n\n\n\n\n# 6. Mapper XML\n\n默认配置下，MyBatis Mapper XML 需要写在各 yudao-module-xxx-biz 模块的 resources/mapper 目录下。示例 TestDemoMapper.xml 如下：\n\n\n\n尽量避免数据库的连表（多表）查询，而是采用多次查询，Java 内存拼接的方式替代。例如说：\n\n\n\n\n# 7. 字段加密\n\nEncryptTypeHandler，基于 Hutool AES 实现字段的解密与解密。\n\n例如说，数据源配置的 password 密码需要实现加密存储，则只需要在该字段上添加 EncryptTypeHandler 处理器。示例代码如下：\n\n@TableName(value = \"infra_data_source_config\", autoResultMap = true) // ① 添加 autoResultMap = true\npublic class DataSourceConfigDO extends BaseDO {\n\n    // ... 省略其它字段\n    /**\n     * 密码\n     */\n    @TableField(typeHandler = EncryptTypeHandler.class) // ② 添加 EncryptTypeHandler 处理器\n    private String password;\n\n}\n\n\n另外，在 application.yaml 配置文件中，可使用 mybatis-plus.encryptor.password 设置加密密钥。\n\n字段加密后，只允许使用精准匹配，无法使用模糊匹配。示例代码如下：\n\n@Test // 测试使用 password 查询，可以查询到数据\npublic void testSelectPassword() {\n    // mock 数据\n    DataSourceConfigDO dbDataSourceConfig = randomPojo(DataSourceConfigDO.class);\n    dataSourceConfigMapper.insert(dbDataSourceConfig);// @Sql: 先插入出一条存在的数据\n\n    // 调用\n    DataSourceConfigDO result = dataSourceConfigMapper.selectOne(DataSourceConfigDO::getPassword,\n            EncryptTypeHandler.encrypt(dbDataSourceConfig.getPassword())); // 重点：需要使用 EncryptTypeHandler 去加密查询字段！！！\n}\n",
            normalizedContent: "yudao-spring-boot-starter-mybatis 技术组件，基于 mybatis plus 实现数据库的操作。如果你没有学习过 mybatis plus，建议先阅读 《芋道 spring boot mybatis 入门 》 文章。\n\n友情提示\n\nmybatis 是最容易读懂的 java 框架之一，感兴趣的话，可以看看艿艿写的 《芋道 mybatis 源码解析》 系列，已经有 18000 人学习过！\n\n\n# 1. 实体类\n\nbasedo 是所有数据库实体的父类，代码如下：\n\n@data\npublic abstract class basedo implements serializable {\n\n    /**\n     * 创建时间\n     */\n    @tablefield(fill = fieldfill.insert)\n    private date createtime;\n    /**\n     * 最后更新时间\n     */\n    @tablefield(fill = fieldfill.insert_update)\n    private date updatetime;\n    /**\n     * 创建者，目前使用 adminuserdo / memberuserdo 的 id 编号\n     *\n     * 使用 string 类型的原因是，未来可能会存在非数值的情况，留好拓展性。\n     */\n    @tablefield(fill = fieldfill.insert)\n    private string creator;\n    /**\n     * 更新者，目前使用 adminuserdo / memberuserdo 的 id 编号\n     *\n     * 使用 string 类型的原因是，未来可能会存在非数值的情况，留好拓展性。\n     */\n    @tablefield(fill = fieldfill.insert_update)\n    private string updater;\n    /**\n     * 是否删除\n     */\n    @tablelogic\n    private boolean deleted;\n\n}\n\n\n * createtime + creator 字段，创建人相关信息。\n * updater + updatetime 字段，创建人相关信息。\n * deleted 字段，逻辑删除。\n\n对应的 sql 字段如下：\n\n`creator` varchar(64) character set utf8mb4 collate utf8mb4_unicode_ci default '' comment '创建者',\n`create_time` datetime not null default current_timestamp comment '创建时间',\n`updater` varchar(64) character set utf8mb4 collate utf8mb4_unicode_ci default '' comment '更新者',\n`update_time` datetime not null default current_timestamp on update current_timestamp comment '更新时间',\n`deleted` bit(1) not null default b'0' comment '是否删除',\n\n\n\n# 1.1 主键编号\n\nid 主键编号，推荐使用 long 型自增，原因是：\n\n * 自增，保证数据库是按顺序写入，性能更加优秀。\n * long 型，避免未来业务增长，超过 int 范围。\n\n对应的 sql 字段如下：\n\n`id` bigint not null auto_increment comment '编号',\n\n\n项目的 id 默认采用数据库自增的策略，如果希望使用 snowflake 雪花算法，可以修改 application.yaml 配置文件，将配置项 mybatis-plus.global-config.db-config.id-type 修改为 assign_id。如下图所示：\n\n\n\n\n# 1.2 逻辑删除\n\n所有表通过 deleted 字段来实现逻辑删除，值为 0 表示未删除，值为 1 表示已删除，可见 application.yaml 配置文件的 logic-delete-value 和 logic-not-delete-value 配置项。如下图所示：\n\n\n\n① 所有 select 查询，都会自动拼接 where deleted = 0 查询条件，过滤已经删除的记录。如果被删除的记录，只能通过在 xml 或者 @select 来手写 sql 语句。例如说：\n\n\n\n② 建立唯一索引时，需要额外增加 delete_time 字段，添加到唯一索引字段中，避免唯一索引冲突。例如说，system_users 使用 username 作为唯一索引：\n\n * 未添加前：先逻辑删除了一条 username = yudao 的记录，然后又插入了一条 username = yudao 的记录时，会报索引冲突的异常。\n * 已添加后：先逻辑删除了一条 username = yudao 的记录并更新 delete_time 为当前时间，然后又插入一条 username = yudao 并且 delete_time 为 0 的记录，不会导致唯一索引冲突。\n\n\n# 1.3 自动填充\n\ndefaultdbfieldhandler 基于 mybatis 自动填充机制，实现 basedo 通用字段的自动设置。代码如下如：\n\n\n\n\n# 1.4 “复杂”字段类型\n\nmybatis plus 提供 typehandler 字段类型处理器，用于 javatype 与 jdbctype 之间的转换。示例如下：\n\n\n\n常用的字段类型处理器有：\n\n * jacksontypehandler：通用的 jackson 实现 json 字段类型处理器。\n * jsonlongsettypehandler：针对 set<long> 的 jackson 实现 json 字段类型处理器。\n\n另外，如果你后续要拓展自定义的 typehandler 实现，可以添加到 cn.iocoder.yudao.framework.mybatis.core.type 包下。\n\n注意事项：\n\n使用 typehandler 时，需要设置实体的 @tablename 注解的 @autoresultmap = true。\n\n\n# 2. 编码规范\n\n① 数据库实体类放在 dal.dataobject 包下，以 do 结尾；数据库访问类放在 dal.mysql 包下，以 mapper 结尾。如下图所示：\n\n\n\n----------------------------------------\n\n② 数据库实体类的注释要完整，特别是哪些字段是关联（外键）、枚举、冗余等等。例如说：\n\n\n\n----------------------------------------\n\n③ 禁止在 controller、service 中，直接进行 mybatis plus 操作。原因是：大量 mybatis 操作散落在 service 中，会导致 service 的代码越来乱，无法聚焦业务逻辑。\n\n     示例\n错误   \n正确   \n\n并且，通过只允许将 mybatis plus 操作编写 mapper 层，更好的实现 select 查询的复用，而不是 service 会存在很多相同且重复的 select 查询的逻辑。\n\n----------------------------------------\n\n④ mapper 的 select 查询方法的命名，采用 spring data 的 \"query methods\" 策略，方法名使用 selectby查询条件 规则。例如说：\n\n\n\n----------------------------------------\n\n⑤ 优先使用 lambdaquerywrapper 条件构造器，使用方法获得字段名，避免手写 \"字段\" 可能写错的情况。例如说：\n\n\n\n----------------------------------------\n\n⑥ 简单的单表查询，优先在 mapper 中通过 default 方法实现。例如说：\n\n\n\n\n# 3. crud 接口\n\nbasemapperx 接口，继承 mybatis plus 的 basemapper 接口，提供更强的 crud 操作能力。\n\n\n# 3.1 selectone\n\n#selectone(...) 方法，使用指定条件，查询单条记录。示例如下：\n\n\n\n\n# 3.2 selectcount\n\n#selectcount(...) 方法，使用指定条件，查询记录的数量。示例如下：\n\n\n\n\n# 3.3 selectlist\n\n#selectlist(...) 方法，使用指定条件，查询多条记录。示例如下：\n\n\n\n\n# 3.4 selectpage\n\n针对 mybatis plus 分页查询的二次分装，在 basemapperx 中实现，目的是使用项目自己的分页封装：\n\n * 【入参】查询前，将项目的分页参数 pageparam，转换成 mybatis plus 的 ipage 对象。\n * 【出参】查询后，将 mybatis plus 的分页结果 ipage，转换成项目的分页结果 pageresult。代码如下图：\n\n\n\n具体的使用示例，可见 tenantmapper 类中，定义 selectpage 查询方法。代码如下：\n\n@mapper\npublic interface tenantmapper extends basemapperx<tenantdo> {\n\n    default pageresult<tenantdo> selectpage(tenantpagereqvo reqvo) {\n        return selectpage(reqvo, new lambdaquerywrapperx<tenantdo>()\n                .likeifpresent(tenantdo::getname, reqvo.getname()) // 如果 name 不为空，则进行 like 查询\n                .likeifpresent(tenantdo::getcontactname, reqvo.getcontactname())\n                .likeifpresent(tenantdo::getcontactmobile, reqvo.getcontactmobile())\n                .eqifpresent(tenantdo::getstatus, reqvo.getstatus()) // 如果 status 不为空，则进行 = 查询\n                .betweenifpresent(tenantdo::getcreatetime, reqvo.getbegincreatetime(), reqvo.getendcreatetime()) // 如果 create 不为空，则进行 between 查询\n                .orderbydesc(tenantdo::getid)); // 按照 id 倒序\n    }\n    \n}\n\n\n完整实战，可见 《开发指南 —— 分页实现》 文档。\n\n\n# 3.5 insertbatch\n\n#insertbatch(...) 方法，遍历数组，逐条插入数据库中，适合少量数据插入，或者对性能要求不高的场景。 示例如下：\n\n\n\n为什么不使用 insertbatchsomecolumn 批量插入？\n\n * 只支持 mysql 数据库。其它 oracle 等数据库使用会报错，可见 insertbatchsomecolumn 说明。\n * 未支持多租户。插入数据库时，多租户字段不会进行自动赋值。\n\n\n# 4. 批量插入\n\n绝大多数场景下，推荐使用 mybatis plus 提供的 iservice 的 #savebatch() 方法。示例 permissionserviceimpl 如下：\n\n\n\n\n# 5. 条件构造器\n\n继承 mybatis plus 的条件构造器，拓展了 lambdaquerywrapperx 和 querywrapperx 类，主要是增加 xxxifpresent 方法，用于判断值不存在的时候，不要拼接到条件中。例如说：\n\n\n\n具体的使用示例如下：\n\n\n\n\n# 6. mapper xml\n\n默认配置下，mybatis mapper xml 需要写在各 yudao-module-xxx-biz 模块的 resources/mapper 目录下。示例 testdemomapper.xml 如下：\n\n\n\n尽量避免数据库的连表（多表）查询，而是采用多次查询，java 内存拼接的方式替代。例如说：\n\n\n\n\n# 7. 字段加密\n\nencrypttypehandler，基于 hutool aes 实现字段的解密与解密。\n\n例如说，数据源配置的 password 密码需要实现加密存储，则只需要在该字段上添加 encrypttypehandler 处理器。示例代码如下：\n\n@tablename(value = \"infra_data_source_config\", autoresultmap = true) // ① 添加 autoresultmap = true\npublic class datasourceconfigdo extends basedo {\n\n    // ... 省略其它字段\n    /**\n     * 密码\n     */\n    @tablefield(typehandler = encrypttypehandler.class) // ② 添加 encrypttypehandler 处理器\n    private string password;\n\n}\n\n\n另外，在 application.yaml 配置文件中，可使用 mybatis-plus.encryptor.password 设置加密密钥。\n\n字段加密后，只允许使用精准匹配，无法使用模糊匹配。示例代码如下：\n\n@test // 测试使用 password 查询，可以查询到数据\npublic void testselectpassword() {\n    // mock 数据\n    datasourceconfigdo dbdatasourceconfig = randompojo(datasourceconfigdo.class);\n    datasourceconfigmapper.insert(dbdatasourceconfig);// @sql: 先插入出一条存在的数据\n\n    // 调用\n    datasourceconfigdo result = datasourceconfigmapper.selectone(datasourceconfigdo::getpassword,\n            encrypttypehandler.encrypt(dbdatasourceconfig.getpassword())); // 重点：需要使用 encrypttypehandler 去加密查询字段！！！\n}\n",
            charsets: {
                cjk: !0
            }
        }, {
            title: "Redis 缓存",
            frontmatter: {
                title: "Redis 缓存",
                date: "2022-04-03T00:50:44.000Z",
                permalink: "/redis-cache"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/02.%E5%90%8E%E7%AB%AF%E6%89%8B%E5%86%8C/28.Redis%20%E7%BC%93%E5%AD%98.html",
            relativePath: "01.开发指南/02.后端手册/28.Redis 缓存.md",
            key: "v-b3cf38b6",
            path: "/redis-cache/",
            headers: [{
                level: 2,
                title: "1. 编程式缓存",
                slug: "_1-编程式缓存",
                normalizedTitle: "1. 编程式缓存",
                charIndex: 169
            }, {
                level: 3,
                title: "1.1 Spring Data Redis 配置",
                slug: "_1-1-spring-data-redis-配置",
                normalizedTitle: "1.1 spring data redis 配置",
                charIndex: 441
            }, {
                level: 3,
                title: "1.2 实战案例",
                slug: "_1-2-实战案例",
                normalizedTitle: "1.2 实战案例",
                charIndex: 614
            }, {
                level: 2,
                title: "2. 声明式缓存",
                slug: "_2-声明式缓存",
                normalizedTitle: "2. 声明式缓存",
                charIndex: 1720
            }, {
                level: 3,
                title: "2.1 Spring Cache 配置",
                slug: "_2-1-spring-cache-配置",
                normalizedTitle: "2.1 spring cache 配置",
                charIndex: 2097
            }, {
                level: 3,
                title: "2.2 常见注解",
                slug: "_2-2-常见注解",
                normalizedTitle: "2.2 常见注解",
                charIndex: 2259
            }, {
                level: 3,
                title: "2.3 实战案例",
                slug: "_2-3-实战案例",
                normalizedTitle: "2.3 实战案例",
                charIndex: 2675
            }, {
                level: 3,
                title: "2.4 过期时间",
                slug: "_2-4-过期时间",
                normalizedTitle: "2.4 过期时间",
                charIndex: 3200
            }, {
                level: 2,
                title: "3. Redis 监控",
                slug: "_3-redis-监控",
                normalizedTitle: "3. redis 监控",
                charIndex: 3413
            }],
            headersStr: "1. 编程式缓存 1.1 Spring Data Redis 配置 1.2 实战案例 2. 声明式缓存 2.1 Spring Cache 配置 2.2 常见注解 2.3 实战案例 2.4 过期时间 3. Redis 监控",
            content: 'yudao-spring-boot-starter-redis 技术组件，使用 Redis 实现缓存的功能，它有 2 种使用方式：\n\n * 编程式缓存：基于 Spring Data Redis 框架的 RedisTemplate 操作模板\n * 声明式缓存：基于 Spring Cache 框架的 @Cacheable 等等注解\n\n\n# 1. 编程式缓存\n\n友情提示：\n\n如果你未学习过 Spring Data Redis 框架，可以后续阅读 《芋道 Spring Boot Redis 入门》 文章。\n\n<dependency>\n    <groupId>org.redisson</groupId>\n    <artifactId>redisson-spring-boot-starter</artifactId>\n</dependency>\n\n\n由于 Redisson 提供了分布式锁、队列、限流等特性，所以使用它作为 Spring Data Redis 的客户端。\n\n\n# 1.1 Spring Data Redis 配置\n\n① 在 application-local.yaml 配置文件中，通过 spring.redis 配置项，设置 Redis 的配置。如下图所示：\n\n\n\n② 在 YudaoRedisAutoConfiguration 配置类，设置使用 JSON 序列化 value 值。如下图所示：\n\n\n\n\n# 1.2 实战案例\n\n以访问令牌 Access Token 的缓存来举例子，讲解项目中是如何使用 Spring Data Redis 框架的。\n\n\n\n# 1.2.1 引入依赖\n\n在 yudao-module-system-biz 模块中，引入 yudao-spring-boot-starter-redis 技术组件。如下所示：\n\n<dependency>\n    <groupId>cn.iocoder.boot</groupId>\n    <artifactId>yudao-spring-boot-starter-redis</artifactId>\n</dependency>\n\n\n# 1.2.2 OAuth2AccessTokenDO\n\n新建 OAuth2AccessTokenDO 类，访问令牌 Access Token 类。代码如下：\n\n\n\n友情提示：\n\n * ① 如果值是【简单】的 String 或者 Integer 等类型，无需创建数据实体。\n * ② 如果值是【复杂对象】时，建议在 dal/dataobject 包下，创建对应的数据实体。\n\n# 1.2.3 RedisKeyConstants\n\n为什么要定义 Redis Key 常量？\n\n每个 yudao-module-xxx 模块，都有一个 RedisKeyConstants 类，定义该模块的 Redis Key 的信息。目的是，避免 Redis Key 散落在 Service 业务代码中，像对待数据库的表一样，对待每个 Redis Key。通过这样的方式，如果我们想要了解一个模块的 Redis 的使用情况，只需要查看 RedisKeyConstants 类即可。\n\n在 yudao-module-system 模块的 RedisKeyConstants 类中，新建 OAuth2AccessTokenDO 对应的 Redis Key 定义 OAUTH2_ACCESS_TOKEN。如下图所示：\n\n\n\n# 1.2.4 OAuth2AccessTokenRedisDAO\n\n新建 OAuth2AccessTokenRedisDAO 类，是 OAuth2AccessTokenDO 的 RedisDAO 实现。代码如下：\n\n\n\n# 1.2.5 OAuth2TokenServiceImpl\n\n在 OAuth2TokenServiceImpl 中，只要注入 OAuth2AccessTokenRedisDAO Bean，非常简洁干净的进行 OAuth2AccessTokenDO 的缓存操作，无需关心具体的实现。代码如下：\n\n\n\n\n# 2. 声明式缓存\n\n友情提示：\n\n如果你未学习过 Spring Cache 框架，可以后续阅读 《芋道 Spring Boot Cache 入门》 文章。\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-cache</artifactId>\n</dependency>\n\n\n相比来说 Spring Data Redis 编程式缓存，Spring Cache 声明式缓存的使用更加便利，一个 @Cacheable 注解即可实现缓存的功能。示例如下：\n\n@Cacheable(value = "users", key = "#id")\nUserDO getUserById(Integer id);\n\n\n\n# 2.1 Spring Cache 配置\n\n① 在 application.yaml 配置文件中，通过 spring.redis 配置项，设置 Redis 的配置。如下图所示：\n\n\n\n② 在 YudaoCacheAutoConfiguration 配置类，设置使用 JSON 序列化 value 值。如下图所示：\n\n\n\n\n# 2.2 常见注解\n\n# 2.2.1 @Cacheable 注解\n\n@Cacheable 注解：添加在方法上，缓存方法的执行结果。执行过程如下：\n\n * 1）首先，判断方法执行结果的缓存。如果有，则直接返回该缓存结果。\n * 2）然后，执行方法，获得方法结果。\n * 3）之后，根据是否满足缓存的条件。如果满足，则缓存方法结果到缓存。\n * 4）最后，返回方法结果。\n\n# 2.2.2 @CachePut 注解\n\n@CachePut 注解，添加在方法上，缓存方法的执行结果。不同于 @Cacheable 注解，它的执行过程如下：\n\n * 1）首先，执行方法，获得方法结果。也就是说，无论是否有缓存，都会执行方法。\n * 2）然后，根据是否满足缓存的条件。如果满足，则缓存方法结果到缓存。\n * 3）最后，返回方法结果。\n\n# 2.2.3 @CacheEvict 注解\n\n@CacheEvict 注解，添加在方法上，删除缓存。\n\n\n# 2.3 实战案例\n\n在 RoleServiceImpl 中，使用 Spring Cache 实现了 Role 角色缓存，采用【被动读】的方案。原因是：\n\n\n\n * 【被动读】相对能够保证 Redis 与 MySQL 的一致性\n * 绝大数数据不需要放到 Redis 缓存中，采用【主动写】会将非必要的数据进行缓存\n\n友情提示：\n\n如果你未学习过 MySQL 与 Redis 一致性的问题，可以后续阅读 《Redis 与 MySQL 双写一致性如何保证？ 》 文章。\n\n① 执行 #getRoleFromCache(...) 方法，从 MySQL 读取数据后，向 Redis 写入缓存。如下图所示：\n\n\n\n② 执行 #updateRole(...) 或 #deleteRole(...) 方法，在更新或者删除 MySQL 数据后，从 Redis 删除缓存。如下图所示：\n\n\n\n补充说明：\n\n如果你在多个项目里，使用了 Redis 想通 db 的话，可以通过 spring.cache.redis.key-prefix 解决，可见 https://gitee.com/zhijiantianya/ruoyi-vue-pro/pulls/998/\n\n\n# 2.4 过期时间\n\nSpring Cache 默认使用 spring.cache.redis.time-to-live 配置项，设置缓存的过期时间，项目默认为 1 小时。\n\n如果你想自定义过期时间，可以在 @Cacheable 注解中的 cacheNames 属性中，添加 #{过期时间} 后缀，单位是秒。如下图所示：\n\n\n\n实现的原来，参考 《Spring @Cacheable 扩展支持自定义过期时间 》 文章。\n\n\n# 3. Redis 监控\n\nyudao-module-infra 的 redis 模块，提供了 Redis 监控的功能。\n\n点击 [基础设施 -> 监控中心 -> Redis 监控] 菜单，可以查看到 Redis 的基础信息、命令统计、内存信息。如下图所示：\n\n',
            normalizedContent: 'yudao-spring-boot-starter-redis 技术组件，使用 redis 实现缓存的功能，它有 2 种使用方式：\n\n * 编程式缓存：基于 spring data redis 框架的 redistemplate 操作模板\n * 声明式缓存：基于 spring cache 框架的 @cacheable 等等注解\n\n\n# 1. 编程式缓存\n\n友情提示：\n\n如果你未学习过 spring data redis 框架，可以后续阅读 《芋道 spring boot redis 入门》 文章。\n\n<dependency>\n    <groupid>org.redisson</groupid>\n    <artifactid>redisson-spring-boot-starter</artifactid>\n</dependency>\n\n\n由于 redisson 提供了分布式锁、队列、限流等特性，所以使用它作为 spring data redis 的客户端。\n\n\n# 1.1 spring data redis 配置\n\n① 在 application-local.yaml 配置文件中，通过 spring.redis 配置项，设置 redis 的配置。如下图所示：\n\n\n\n② 在 yudaoredisautoconfiguration 配置类，设置使用 json 序列化 value 值。如下图所示：\n\n\n\n\n# 1.2 实战案例\n\n以访问令牌 access token 的缓存来举例子，讲解项目中是如何使用 spring data redis 框架的。\n\n\n\n# 1.2.1 引入依赖\n\n在 yudao-module-system-biz 模块中，引入 yudao-spring-boot-starter-redis 技术组件。如下所示：\n\n<dependency>\n    <groupid>cn.iocoder.boot</groupid>\n    <artifactid>yudao-spring-boot-starter-redis</artifactid>\n</dependency>\n\n\n# 1.2.2 oauth2accesstokendo\n\n新建 oauth2accesstokendo 类，访问令牌 access token 类。代码如下：\n\n\n\n友情提示：\n\n * ① 如果值是【简单】的 string 或者 integer 等类型，无需创建数据实体。\n * ② 如果值是【复杂对象】时，建议在 dal/dataobject 包下，创建对应的数据实体。\n\n# 1.2.3 rediskeyconstants\n\n为什么要定义 redis key 常量？\n\n每个 yudao-module-xxx 模块，都有一个 rediskeyconstants 类，定义该模块的 redis key 的信息。目的是，避免 redis key 散落在 service 业务代码中，像对待数据库的表一样，对待每个 redis key。通过这样的方式，如果我们想要了解一个模块的 redis 的使用情况，只需要查看 rediskeyconstants 类即可。\n\n在 yudao-module-system 模块的 rediskeyconstants 类中，新建 oauth2accesstokendo 对应的 redis key 定义 oauth2_access_token。如下图所示：\n\n\n\n# 1.2.4 oauth2accesstokenredisdao\n\n新建 oauth2accesstokenredisdao 类，是 oauth2accesstokendo 的 redisdao 实现。代码如下：\n\n\n\n# 1.2.5 oauth2tokenserviceimpl\n\n在 oauth2tokenserviceimpl 中，只要注入 oauth2accesstokenredisdao bean，非常简洁干净的进行 oauth2accesstokendo 的缓存操作，无需关心具体的实现。代码如下：\n\n\n\n\n# 2. 声明式缓存\n\n友情提示：\n\n如果你未学习过 spring cache 框架，可以后续阅读 《芋道 spring boot cache 入门》 文章。\n\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-cache</artifactid>\n</dependency>\n\n\n相比来说 spring data redis 编程式缓存，spring cache 声明式缓存的使用更加便利，一个 @cacheable 注解即可实现缓存的功能。示例如下：\n\n@cacheable(value = "users", key = "#id")\nuserdo getuserbyid(integer id);\n\n\n\n# 2.1 spring cache 配置\n\n① 在 application.yaml 配置文件中，通过 spring.redis 配置项，设置 redis 的配置。如下图所示：\n\n\n\n② 在 yudaocacheautoconfiguration 配置类，设置使用 json 序列化 value 值。如下图所示：\n\n\n\n\n# 2.2 常见注解\n\n# 2.2.1 @cacheable 注解\n\n@cacheable 注解：添加在方法上，缓存方法的执行结果。执行过程如下：\n\n * 1）首先，判断方法执行结果的缓存。如果有，则直接返回该缓存结果。\n * 2）然后，执行方法，获得方法结果。\n * 3）之后，根据是否满足缓存的条件。如果满足，则缓存方法结果到缓存。\n * 4）最后，返回方法结果。\n\n# 2.2.2 @cacheput 注解\n\n@cacheput 注解，添加在方法上，缓存方法的执行结果。不同于 @cacheable 注解，它的执行过程如下：\n\n * 1）首先，执行方法，获得方法结果。也就是说，无论是否有缓存，都会执行方法。\n * 2）然后，根据是否满足缓存的条件。如果满足，则缓存方法结果到缓存。\n * 3）最后，返回方法结果。\n\n# 2.2.3 @cacheevict 注解\n\n@cacheevict 注解，添加在方法上，删除缓存。\n\n\n# 2.3 实战案例\n\n在 roleserviceimpl 中，使用 spring cache 实现了 role 角色缓存，采用【被动读】的方案。原因是：\n\n\n\n * 【被动读】相对能够保证 redis 与 mysql 的一致性\n * 绝大数数据不需要放到 redis 缓存中，采用【主动写】会将非必要的数据进行缓存\n\n友情提示：\n\n如果你未学习过 mysql 与 redis 一致性的问题，可以后续阅读 《redis 与 mysql 双写一致性如何保证？ 》 文章。\n\n① 执行 #getrolefromcache(...) 方法，从 mysql 读取数据后，向 redis 写入缓存。如下图所示：\n\n\n\n② 执行 #updaterole(...) 或 #deleterole(...) 方法，在更新或者删除 mysql 数据后，从 redis 删除缓存。如下图所示：\n\n\n\n补充说明：\n\n如果你在多个项目里，使用了 redis 想通 db 的话，可以通过 spring.cache.redis.key-prefix 解决，可见 https://gitee.com/zhijiantianya/ruoyi-vue-pro/pulls/998/\n\n\n# 2.4 过期时间\n\nspring cache 默认使用 spring.cache.redis.time-to-live 配置项，设置缓存的过期时间，项目默认为 1 小时。\n\n如果你想自定义过期时间，可以在 @cacheable 注解中的 cachenames 属性中，添加 #{过期时间} 后缀，单位是秒。如下图所示：\n\n\n\n实现的原来，参考 《spring @cacheable 扩展支持自定义过期时间 》 文章。\n\n\n# 3. redis 监控\n\nyudao-module-infra 的 redis 模块，提供了 redis 监控的功能。\n\n点击 [基础设施 -> 监控中心 -> redis 监控] 菜单，可以查看到 redis 的基础信息、命令统计、内存信息。如下图所示：\n\n',
            charsets: {
                cjk: !0
            }
        }, {
            title: "多数据源（读写分离）、事务",
            frontmatter: {
                title: "多数据源（读写分离）、事务",
                date: "2022-04-02T12:35:22.000Z",
                permalink: "/dynamic-datasource"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/02.%E5%90%8E%E7%AB%AF%E6%89%8B%E5%86%8C/27.%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90.html",
            relativePath: "01.开发指南/02.后端手册/27.多数据源.md",
            key: "v-efcaad44",
            path: "/dynamic-datasource/",
            headers: [{
                level: 2,
                title: "1. 数据连接池",
                slug: "_1-数据连接池",
                normalizedTitle: "1. 数据连接池",
                charIndex: 188
            }, {
                level: 3,
                title: "1.1 Druid 监控配置",
                slug: "_1-1-druid-监控配置",
                normalizedTitle: "1.1 druid 监控配置",
                charIndex: 386
            }, {
                level: 3,
                title: "1.2 Druid 监控界面",
                slug: "_1-2-druid-监控界面",
                normalizedTitle: "1.2 druid 监控界面",
                charIndex: 536
            }, {
                level: 3,
                title: "1.3 如何开启登录？",
                slug: "_1-3-如何开启登录",
                normalizedTitle: "1.3 如何开启登录？",
                charIndex: 848
            }, {
                level: 2,
                title: "2. 多数据源",
                slug: "_2-多数据源",
                normalizedTitle: "2. 多数据源",
                charIndex: 1014
            }, {
                level: 3,
                title: "2.1 多数据源配置",
                slug: "_2-1-多数据源配置",
                normalizedTitle: "2.1 多数据源配置",
                charIndex: 1220
            }, {
                level: 3,
                title: "2.2 数据源切换",
                slug: "_2-2-数据源切换",
                normalizedTitle: "2.2 数据源切换",
                charIndex: 1334
            }, {
                level: 2,
                title: "3. 事务相关",
                slug: "_3-事务相关",
                normalizedTitle: "3. 事务相关",
                charIndex: 1654
            }, {
                level: 3,
                title: "3.1 @Transactional 注解",
                slug: "_3-1-transactional-注解",
                normalizedTitle: "3.1 @transactional 注解",
                charIndex: 1778
            }, {
                level: 3,
                title: "3.2 @DSTransactional 注解",
                slug: "_3-2-dstransactional-注解",
                normalizedTitle: "3.2 @dstransactional 注解",
                charIndex: 1918
            }, {
                level: 3,
                title: "3.3 分布式事务",
                slug: "_3-3-分布式事务",
                normalizedTitle: "3.3 分布式事务",
                charIndex: 3009
            }, {
                level: 2,
                title: "4. 分库分表",
                slug: "_4-分库分表",
                normalizedTitle: "4. 分库分表",
                charIndex: 3138
            }],
            headersStr: "1. 数据连接池 1.1 Druid 监控配置 1.2 Druid 监控界面 1.3 如何开启登录？ 2. 多数据源 2.1 多数据源配置 2.2 数据源切换 3. 事务相关 3.1 @Transactional 注解 3.2 @DSTransactional 注解 3.3 分布式事务 4. 分库分表",
            content: 'yudao-spring-boot-starter-mybatis 技术组件，除了提供 MyBatis 数据库操作，还提供了如下 2 种功能：\n\n * 数据连接池：基于 Alibaba Druid 实现，额外提供监控的能力。\n * 多数据源（读写分离）：基于 Dynamic Datasource 实现，支持 Druid 连接池，可集成 Seata 实现分布式事务。\n\n\n# 1. 数据连接池\n\n友情提示：\n\n如果你未学习过 Druid 数据库连接池，可以后续阅读 《芋道 Spring Boot 数据库连接池入门》 文章。\n\n<dependency>\n    <groupId>com.alibaba</groupId>\n    <artifactId>druid-spring-boot-starter</artifactId>\n</dependency>\n\n\n\n# 1.1 Druid 监控配置\n\n在 application-local.yaml 配置文件中，通过 spring.datasource.druid 配置项，仅仅设置了 Druid 监控相关的配置项目，具体数据库的设置需要使用 Dynamic Datasource 的配置项。如下图所示：\n\n\n\n\n# 1.2 Druid 监控界面\n\n① 访问后端的 /druid/index.html 路径，例如说本地的 http://127.0.0.1:48080/druid/index.html 地址，可以查看到 Druid 监控界面。如下图所示：\n\n\n\n② 访问前端的 [基础设施 -> MySQL 监控] 菜单，也可以查看到 Druid 监控界面。如下图所示：\n\n\n\n补充说明：\n\n前端 [基础设施 -> MySQL 监控] 菜单，通过 iframe 内嵌后端的 /druid/index.html 路径。\n\n如果你想自定义地址，可以前往 [基础设置 -> 配置管理] 菜单，设置 key 为 url.druid 配置项。\n\n\n# 1.3 如何开启登录？\n\n生产环境下，建议 Druid 监控界面开启“安全认证”的功能，避免出现安全事故。\n\n只需要在 spring.datasource.druid.stat-view-servlet 配置项中，设置 login-username 和 login-password 即可。开启后，登录界面如下图所示：\n\n\n\n\n# 2. 多数据源\n\n友情提示：\n\n如果你未学习过多数据源，可以后续阅读 《芋道 Spring Boot 多数据源（读写分离）入门》 文章。\n\n<dependency>\n    <groupId>com.baomidou</groupId>\n    <artifactId>dynamic-datasource-spring-boot-starter</artifactId>\n</dependency>\n\n\n\n# 2.1 多数据源配置\n\n在 application-local.yaml 配置文件中，通过 spring.datasource.dynamic 配置项，配置了 Master-Slave 主从两个数据源。如下图所示：\n\n\n\n\n# 2.2 数据源切换\n\n# 2.2.1 @Master 注解\n\n在方法上添加 @Master 注解，使用名字为 master 的数据源，即使用【主】库，一般适合【写】场景。示例如下图：\n\n\n\n由于项目的 spring.datasource.dynamic.primary 为 master，默认使用【主】库，所以无需手动添加 @Master 注解。\n\n# 2.2.2 @Slave 注解\n\n在方法上添加 @Slave 注解，使用名字为 slave 的数据源，即使用【从】库，一般适合【读】场景。示例如下图：\n\n\n\n# 2.2.3 @DS 注解\n\n在方法上添加 @DS 注解，使用指定名字的数据源，适合多数据源的情况。示例如下图：\n\n\n\n\n# 3. 事务相关\n\n事务一共有 3 种解决方案，分别是：\n\n * 单机 + 单数据源：@Transactional 注解\n * 单机 + 多数据源：@DSTransactional 注解\n * 多机 + 单/多数据源：Seata 分布式事务\n\n\n# 3.1 @Transactional 注解\n\n大多数情况下，是单机 + 单个数据源的操作，只需要在方法上添加 Spring @Transactional 注解，声明事务即可。\n\n具体的使用，可以项目里搜 @Transactional 关键字，就可以看到非常多的使用示例。\n\n\n# 3.2 @DSTransactional 注解\n\n如果单机 + 多个数据源的操作，使用 @Transactional 声明的事务中，无法进行数据源的切换。此时，可以使用 Dynamic Datasource 提供的 @DSTransactional 注解，支持多数据源的切换。\n\n友情提示：\n\n@DSTransactional 注解，提供相对可靠的多数据源的事务一致性，但是不绝对，可学习 《DSTransactional 实现源码分析 》 文章。\n\n使用的示例，AService 调用 BService、CService，并且分别对应 a、b、c 各自的数据源，代码如下所示：\n\npublic class AService {\n    \n    @Resource\n    private BService bService;\n    @Resource\n    private CService cService;\n    \n    @DS("a") // 注意：如果 a 是默认数据源时，则不需要 @DS 注解\n    @DSTransactional\n    public void create() {\n        bService.createB();\n        CService.createC();\n    }\n    \n}\n\n    public class BService {\n        \n        @DS("b")\n        public void createB() {\n            // 调用 bMapper 逻辑\n        }\n        \n    }\n    \n    public class CService {\n        \n        @DS("c")\n        public void createC() {\n            // 调用 cMapper 逻辑\n        }\n        \n    }\n\n\n场景问题：\n\n问题 ①：c 数据源的操作发生异常，a、b 数据源会回滚么？\n\n * 答案：会的，因为最终是最外层的 @DSTransactional 注解对应的方法结束后，才进行事务的提交，所以它实际不需要回滚。\n * 注意：但是有一点要注意，如果提交时某个数据源的事务提交失败，则可能导致事务的不一致。\n\n问题 ②：b、c 数据源的方法，也添加 @DSTransactional 注解，会不会影响事务？\n\n * 答案：不会，可以放心大胆的加。\n\n\n# 3.3 分布式事务\n\n在多机分布式场景下，无论是单数据源、多数据源，本质上都是分布式事务，建议引入 Seata 框架，提供完整的分布式事务的解决方案，可学习 《芋道 Seata 极简入门 》 文章。\n\n不过如果你是单机项目，则可以不用关注着一点哈！\n\n\n# 4. 分库分表\n\n建议采用 ShardingSphere 的子项目 Sharding-JDBC 完成分库分表的功能，可阅读 《芋道 Spring Boot 分库分表入门 》 文章，学习如何整合进项目。',
            normalizedContent: 'yudao-spring-boot-starter-mybatis 技术组件，除了提供 mybatis 数据库操作，还提供了如下 2 种功能：\n\n * 数据连接池：基于 alibaba druid 实现，额外提供监控的能力。\n * 多数据源（读写分离）：基于 dynamic datasource 实现，支持 druid 连接池，可集成 seata 实现分布式事务。\n\n\n# 1. 数据连接池\n\n友情提示：\n\n如果你未学习过 druid 数据库连接池，可以后续阅读 《芋道 spring boot 数据库连接池入门》 文章。\n\n<dependency>\n    <groupid>com.alibaba</groupid>\n    <artifactid>druid-spring-boot-starter</artifactid>\n</dependency>\n\n\n\n# 1.1 druid 监控配置\n\n在 application-local.yaml 配置文件中，通过 spring.datasource.druid 配置项，仅仅设置了 druid 监控相关的配置项目，具体数据库的设置需要使用 dynamic datasource 的配置项。如下图所示：\n\n\n\n\n# 1.2 druid 监控界面\n\n① 访问后端的 /druid/index.html 路径，例如说本地的 http://127.0.0.1:48080/druid/index.html 地址，可以查看到 druid 监控界面。如下图所示：\n\n\n\n② 访问前端的 [基础设施 -> mysql 监控] 菜单，也可以查看到 druid 监控界面。如下图所示：\n\n\n\n补充说明：\n\n前端 [基础设施 -> mysql 监控] 菜单，通过 iframe 内嵌后端的 /druid/index.html 路径。\n\n如果你想自定义地址，可以前往 [基础设置 -> 配置管理] 菜单，设置 key 为 url.druid 配置项。\n\n\n# 1.3 如何开启登录？\n\n生产环境下，建议 druid 监控界面开启“安全认证”的功能，避免出现安全事故。\n\n只需要在 spring.datasource.druid.stat-view-servlet 配置项中，设置 login-username 和 login-password 即可。开启后，登录界面如下图所示：\n\n\n\n\n# 2. 多数据源\n\n友情提示：\n\n如果你未学习过多数据源，可以后续阅读 《芋道 spring boot 多数据源（读写分离）入门》 文章。\n\n<dependency>\n    <groupid>com.baomidou</groupid>\n    <artifactid>dynamic-datasource-spring-boot-starter</artifactid>\n</dependency>\n\n\n\n# 2.1 多数据源配置\n\n在 application-local.yaml 配置文件中，通过 spring.datasource.dynamic 配置项，配置了 master-slave 主从两个数据源。如下图所示：\n\n\n\n\n# 2.2 数据源切换\n\n# 2.2.1 @master 注解\n\n在方法上添加 @master 注解，使用名字为 master 的数据源，即使用【主】库，一般适合【写】场景。示例如下图：\n\n\n\n由于项目的 spring.datasource.dynamic.primary 为 master，默认使用【主】库，所以无需手动添加 @master 注解。\n\n# 2.2.2 @slave 注解\n\n在方法上添加 @slave 注解，使用名字为 slave 的数据源，即使用【从】库，一般适合【读】场景。示例如下图：\n\n\n\n# 2.2.3 @ds 注解\n\n在方法上添加 @ds 注解，使用指定名字的数据源，适合多数据源的情况。示例如下图：\n\n\n\n\n# 3. 事务相关\n\n事务一共有 3 种解决方案，分别是：\n\n * 单机 + 单数据源：@transactional 注解\n * 单机 + 多数据源：@dstransactional 注解\n * 多机 + 单/多数据源：seata 分布式事务\n\n\n# 3.1 @transactional 注解\n\n大多数情况下，是单机 + 单个数据源的操作，只需要在方法上添加 spring @transactional 注解，声明事务即可。\n\n具体的使用，可以项目里搜 @transactional 关键字，就可以看到非常多的使用示例。\n\n\n# 3.2 @dstransactional 注解\n\n如果单机 + 多个数据源的操作，使用 @transactional 声明的事务中，无法进行数据源的切换。此时，可以使用 dynamic datasource 提供的 @dstransactional 注解，支持多数据源的切换。\n\n友情提示：\n\n@dstransactional 注解，提供相对可靠的多数据源的事务一致性，但是不绝对，可学习 《dstransactional 实现源码分析 》 文章。\n\n使用的示例，aservice 调用 bservice、cservice，并且分别对应 a、b、c 各自的数据源，代码如下所示：\n\npublic class aservice {\n    \n    @resource\n    private bservice bservice;\n    @resource\n    private cservice cservice;\n    \n    @ds("a") // 注意：如果 a 是默认数据源时，则不需要 @ds 注解\n    @dstransactional\n    public void create() {\n        bservice.createb();\n        cservice.createc();\n    }\n    \n}\n\n    public class bservice {\n        \n        @ds("b")\n        public void createb() {\n            // 调用 bmapper 逻辑\n        }\n        \n    }\n    \n    public class cservice {\n        \n        @ds("c")\n        public void createc() {\n            // 调用 cmapper 逻辑\n        }\n        \n    }\n\n\n场景问题：\n\n问题 ①：c 数据源的操作发生异常，a、b 数据源会回滚么？\n\n * 答案：会的，因为最终是最外层的 @dstransactional 注解对应的方法结束后，才进行事务的提交，所以它实际不需要回滚。\n * 注意：但是有一点要注意，如果提交时某个数据源的事务提交失败，则可能导致事务的不一致。\n\n问题 ②：b、c 数据源的方法，也添加 @dstransactional 注解，会不会影响事务？\n\n * 答案：不会，可以放心大胆的加。\n\n\n# 3.3 分布式事务\n\n在多机分布式场景下，无论是单数据源、多数据源，本质上都是分布式事务，建议引入 seata 框架，提供完整的分布式事务的解决方案，可学习 《芋道 seata 极简入门 》 文章。\n\n不过如果你是单机项目，则可以不用关注着一点哈！\n\n\n# 4. 分库分表\n\n建议采用 shardingsphere 的子项目 sharding-jdbc 完成分库分表的功能，可阅读 《芋道 spring boot 分库分表入门 》 文章，学习如何整合进项目。',
            charsets: {
                cjk: !0
            }
        }, {
            title: "本地缓存",
            frontmatter: {
                title: "本地缓存",
                date: "2022-04-03T13:57:13.000Z",
                permalink: "/local-cache"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/02.%E5%90%8E%E7%AB%AF%E6%89%8B%E5%86%8C/29.%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98.html",
            relativePath: "01.开发指南/02.后端手册/29.本地缓存.md",
            key: "v-0ef32c3e",
            path: "/local-cache/",
            headers: [{
                level: 2,
                title: "1. 实现原理",
                slug: "_1-实现原理",
                normalizedTitle: "1. 实现原理",
                charIndex: 363
            }, {
                level: 2,
                title: "2. 实战案例",
                slug: "_2-实战案例",
                normalizedTitle: "2. 实战案例",
                charIndex: 500
            }, {
                level: 3,
                title: "2.1 初始化缓存",
                slug: "_2-1-初始化缓存",
                normalizedTitle: "2.1 初始化缓存",
                charIndex: 540
            }, {
                level: 3,
                title: "2.2 实时刷新缓存",
                slug: "_2-2-实时刷新缓存",
                normalizedTitle: "2.2 实时刷新缓存",
                charIndex: 1565
            }],
            headersStr: "1. 实现原理 2. 实战案例 2.1 初始化缓存 2.2 实时刷新缓存",
            content: '重要说明：\n\n① 由于大家普遍反馈，“本地缓存”学习成本太高，一般 Redis 缓存足够满足大多数场景的性能要求，所以基本使用 Spring Cache + Redis 所替代。\n\n也因此，本章节更多的，是讲解如何在项目中使用本地缓存。如果你不需要本地缓存，可以忽略本章节。\n\n② 项目中还保留了部分地方使用本地缓存，例如说：短信客户端、文件客户端、敏感词等。主要原因是，它们是“有状态”的 Java 对象，无法缓存到 Redis 中。\n\n系统使用本地缓存，提升公用逻辑的执行性能。 例如说：\n\n * 租户模块 缓存租户信息，每次 RESTful API 校验租户是否禁用、过期时，无需读库。\n * 部门模块 缓存部门信息，每次数据权限校验时，无需读库。\n * 权限模块 缓存权限信息，每次功能权限校验时，无需读库。\n\n\n# 1. 实现原理\n\n本地缓存的实现，一共有两步，如下图所示：\n\n\n\n * 项目启动时，初始化缓存：从数据库中读取数据，写入到本地缓存（例如说一个 Map 对象）\n * 数据变化时，实时刷新缓存：（例如说通过管理后台修改数据）重新从数据库中读取数据，重新写入到本地缓存\n\n\n# 2. 实战案例\n\n以 角色模块 为例，讲解如何实现角色信息的本地缓存。\n\n\n# 2.1 初始化缓存\n\n① 在 RoleService 接口中，定义 #initLocalCache() 方法。代码如下：\n\n// RoleService.java\n\n/**\n * 初始化角色的本地缓存\n */\nvoid initLocalCache();\n\n\n为什么要定义接口方法？\n\n稍后实时刷新缓存时，会调用 RoleService 接口的该方法。\n\n② 在 RoleServiceImpl 类中，实现 #initLocalCache() 方法，通过 @PostConstruct 注解，在项目启动时进行本地缓存的初始化。代码如下：\n\n// RoleServiceImpl.java\n\n/**\n * 角色缓存\n * key：角色编号 {@link RoleDO#getId()}\n *\n * 这里声明 volatile 修饰的原因是，每次刷新时，直接修改指向\n */\n@Getter\nprivate volatile Map<Long, RoleDO> roleCache;\n\n/**\n * 初始化 {@link #roleCache} 缓存\n */\n@Override\n@PostConstruct\npublic void initLocalCache() {\n    // 注意：忽略自动多租户，因为要全局初始化缓存\n    TenantUtils.executeIgnore(() -> {\n        // 第一步：查询数据\n        List<RoleDO> roleList = roleMapper.selectList();\n        log.info("[initLocalCache][缓存角色，数量为:{}]", roleList.size());\n    \n        // 第二步：构建缓存\n        roleCache = CollectionUtils.convertMap(roleList, RoleDO::getId);\n    });\n}\n\n\n疑问：为什么使用 TenantUtils 的 executeIgnore 方法来执行逻辑？\n\n由于 RoleDO 是多租户隔离，如果使用 TenantUtils 方法，会导致缓存刷新时，只加载某个租户的角色数据，导致本地缓存的错误。\n\n所以，如果缓存的数据不存在多租户隔离的情况，可以不使用 TenantUtils 方法！！！！\n\n\n# 2.2 实时刷新缓存\n\n为什么需要使用 Redis Pub/Sub 来实时刷新缓存？考虑到高可用，线上会部署多个 JVM 实例，需要通过 Redis 广播到所有实例，实现本地缓存的刷新。\n\n\n\n友情提示：\n\nRedis Pub/Sub 的使用与讲解，可见 《开发指南 —— 消息队列》 文档。\n\n# 2.2.1 RoleRefreshMessage\n\n新建 RoleRefreshMessage 类，角色数据刷新 Message。代码如下：\n\n@Data\n@EqualsAndHashCode(callSuper = true)\npublic class RoleRefreshMessage extends AbstractRedisChannelMessage {\n}\n\n\n# 2.2.2 RoleProducer\n\n① 新建 RoleProducer 类，RoleRefreshMessage 的 Producer 生产者。代码如下：\n\n@Component\npublic class RoleProducer {\n\n    @Resource\n    private RedisMQTemplate redisMQTemplate;\n\n    /**\n     * 发送 {@link RoleRefreshMessage} 消息\n     */\n    public void sendRoleRefreshMessage() {\n        RoleRefreshMessage message = new RoleRefreshMessage();\n        redisMQTemplate.send(message);\n    }\n\n}\n\n\n② 在数据的新增 / 修改 / 删除等写入操作时，需要使用 RoleProducer 发送消息。如下图所示：\n\n\n\n# 2.2.3 RoleRefreshConsumer\n\n新建 RoleRefreshConsumer 类，RoleRefreshMessage 的 Consumer 消费者，刷新本地缓存。代码如下：\n\n@Component\n@Slf4j\npublic class RoleRefreshConsumer extends AbstractRedisChannelMessageListener<RoleRefreshMessage> {\n\n    @Resource\n    private RoleService roleService;\n\n    @Override\n    public void onMessage(RoleRefreshMessage message) {\n        log.info("[onMessage][收到 Role 刷新消息]");\n        roleService.initLocalCache();\n    }\n\n}\n',
            normalizedContent: '重要说明：\n\n① 由于大家普遍反馈，“本地缓存”学习成本太高，一般 redis 缓存足够满足大多数场景的性能要求，所以基本使用 spring cache + redis 所替代。\n\n也因此，本章节更多的，是讲解如何在项目中使用本地缓存。如果你不需要本地缓存，可以忽略本章节。\n\n② 项目中还保留了部分地方使用本地缓存，例如说：短信客户端、文件客户端、敏感词等。主要原因是，它们是“有状态”的 java 对象，无法缓存到 redis 中。\n\n系统使用本地缓存，提升公用逻辑的执行性能。 例如说：\n\n * 租户模块 缓存租户信息，每次 restful api 校验租户是否禁用、过期时，无需读库。\n * 部门模块 缓存部门信息，每次数据权限校验时，无需读库。\n * 权限模块 缓存权限信息，每次功能权限校验时，无需读库。\n\n\n# 1. 实现原理\n\n本地缓存的实现，一共有两步，如下图所示：\n\n\n\n * 项目启动时，初始化缓存：从数据库中读取数据，写入到本地缓存（例如说一个 map 对象）\n * 数据变化时，实时刷新缓存：（例如说通过管理后台修改数据）重新从数据库中读取数据，重新写入到本地缓存\n\n\n# 2. 实战案例\n\n以 角色模块 为例，讲解如何实现角色信息的本地缓存。\n\n\n# 2.1 初始化缓存\n\n① 在 roleservice 接口中，定义 #initlocalcache() 方法。代码如下：\n\n// roleservice.java\n\n/**\n * 初始化角色的本地缓存\n */\nvoid initlocalcache();\n\n\n为什么要定义接口方法？\n\n稍后实时刷新缓存时，会调用 roleservice 接口的该方法。\n\n② 在 roleserviceimpl 类中，实现 #initlocalcache() 方法，通过 @postconstruct 注解，在项目启动时进行本地缓存的初始化。代码如下：\n\n// roleserviceimpl.java\n\n/**\n * 角色缓存\n * key：角色编号 {@link roledo#getid()}\n *\n * 这里声明 volatile 修饰的原因是，每次刷新时，直接修改指向\n */\n@getter\nprivate volatile map<long, roledo> rolecache;\n\n/**\n * 初始化 {@link #rolecache} 缓存\n */\n@override\n@postconstruct\npublic void initlocalcache() {\n    // 注意：忽略自动多租户，因为要全局初始化缓存\n    tenantutils.executeignore(() -> {\n        // 第一步：查询数据\n        list<roledo> rolelist = rolemapper.selectlist();\n        log.info("[initlocalcache][缓存角色，数量为:{}]", rolelist.size());\n    \n        // 第二步：构建缓存\n        rolecache = collectionutils.convertmap(rolelist, roledo::getid);\n    });\n}\n\n\n疑问：为什么使用 tenantutils 的 executeignore 方法来执行逻辑？\n\n由于 roledo 是多租户隔离，如果使用 tenantutils 方法，会导致缓存刷新时，只加载某个租户的角色数据，导致本地缓存的错误。\n\n所以，如果缓存的数据不存在多租户隔离的情况，可以不使用 tenantutils 方法！！！！\n\n\n# 2.2 实时刷新缓存\n\n为什么需要使用 redis pub/sub 来实时刷新缓存？考虑到高可用，线上会部署多个 jvm 实例，需要通过 redis 广播到所有实例，实现本地缓存的刷新。\n\n\n\n友情提示：\n\nredis pub/sub 的使用与讲解，可见 《开发指南 —— 消息队列》 文档。\n\n# 2.2.1 rolerefreshmessage\n\n新建 rolerefreshmessage 类，角色数据刷新 message。代码如下：\n\n@data\n@equalsandhashcode(callsuper = true)\npublic class rolerefreshmessage extends abstractredischannelmessage {\n}\n\n\n# 2.2.2 roleproducer\n\n① 新建 roleproducer 类，rolerefreshmessage 的 producer 生产者。代码如下：\n\n@component\npublic class roleproducer {\n\n    @resource\n    private redismqtemplate redismqtemplate;\n\n    /**\n     * 发送 {@link rolerefreshmessage} 消息\n     */\n    public void sendrolerefreshmessage() {\n        rolerefreshmessage message = new rolerefreshmessage();\n        redismqtemplate.send(message);\n    }\n\n}\n\n\n② 在数据的新增 / 修改 / 删除等写入操作时，需要使用 roleproducer 发送消息。如下图所示：\n\n\n\n# 2.2.3 rolerefreshconsumer\n\n新建 rolerefreshconsumer 类，rolerefreshmessage 的 consumer 消费者，刷新本地缓存。代码如下：\n\n@component\n@slf4j\npublic class rolerefreshconsumer extends abstractredischannelmessagelistener<rolerefreshmessage> {\n\n    @resource\n    private roleservice roleservice;\n\n    @override\n    public void onmessage(rolerefreshmessage message) {\n        log.info("[onmessage][收到 role 刷新消息]");\n        roleservice.initlocalcache();\n    }\n\n}\n',
            charsets: {
                cjk: !0
            }
        }, {
            title: "异步任务",
            frontmatter: {
                title: "异步任务",
                date: "2022-04-03T23:28:11.000Z",
                permalink: "/async-task"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/02.%E5%90%8E%E7%AB%AF%E6%89%8B%E5%86%8C/30.%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1.html",
            relativePath: "01.开发指南/02.后端手册/30.异步任务.md",
            key: "v-78635b68",
            path: "/async-task/",
            headers: [{
                level: 2,
                title: "1. Async 配置",
                slug: "_1-async-配置",
                normalizedTitle: "1. async 配置",
                charIndex: 198
            }, {
                level: 2,
                title: "2. 引入依赖",
                slug: "_2-引入依赖",
                normalizedTitle: "2. 引入依赖",
                charIndex: 371
            }, {
                level: 3,
                title: "2.1 引入依赖",
                slug: "_2-1-引入依赖",
                normalizedTitle: "2.1 引入依赖",
                charIndex: 423
            }, {
                level: 3,
                title: "2.2 添加 @Async 注解",
                slug: "_2-2-添加-async-注解",
                normalizedTitle: "2.2 添加 @async 注解",
                charIndex: 640
            }, {
                level: 3,
                title: "2.3 测试调用",
                slug: "_2-3-测试调用",
                normalizedTitle: "2.3 测试调用",
                charIndex: 755
            }],
            headersStr: "1. Async 配置 2. 引入依赖 2.1 引入依赖 2.2 添加 @Async 注解 2.3 测试调用",
            content: "yudao-spring-boot-starter-job 技术组件，除了提供定时任务的功能，还提供了 Async 异步任务的能力。系统使用异步任务，提升执行效率。例如说：\n\n * 操作日志模块，异步记录【操作日志】\n * 访问日志模块，异步记录【访问日志】\n\n友情提示：\n\n如果你未学习过 Spring 异步任务，可以后续阅读 《芋道 Spring Boot 异步任务入门 》 文章。\n\n\n# 1. Async 配置\n\n在 YudaoAsyncAutoConfiguration 配置类，设置使用 TransmittableThreadLocal，解决异步执行时上下文传递的问题。如下图所示：\n\n\n\n友情提示：\n\n项目使用到 ThreadLocal 的地方，建议都使用 TransmittableThreadLocal 进行替换。\n\n\n# 2. 引入依赖\n\n以访问日志模块为例，讲解它如何使用异步任务，实现异步记录【访问日志】的功能。\n\n\n# 2.1 引入依赖\n\n在 yudao-module-system-infra 模块中，引入 yudao-spring-boot-starter-job 技术组件。如下所示：\n\n<dependency>\n    <groupId>cn.iocoder.boot</groupId>\n    <artifactId>yudao-spring-boot-starter-job</artifactId>\n</dependency>\n\n\n\n# 2.2 添加 @Async 注解\n\n在 ApiAccessLogServiceImpl 的 #createApiAccessLogAsync(...) 方法上，添加 @Async 注解，声明它要异步执行。如下图所示：\n\n\n\n\n# 2.3 测试调用\n\n随便请求一个 RESTful API 接口，可以看到在异步任务的线程池中，进行了访问日志的记录。如下图所示：\n\n",
            normalizedContent: "yudao-spring-boot-starter-job 技术组件，除了提供定时任务的功能，还提供了 async 异步任务的能力。系统使用异步任务，提升执行效率。例如说：\n\n * 操作日志模块，异步记录【操作日志】\n * 访问日志模块，异步记录【访问日志】\n\n友情提示：\n\n如果你未学习过 spring 异步任务，可以后续阅读 《芋道 spring boot 异步任务入门 》 文章。\n\n\n# 1. async 配置\n\n在 yudaoasyncautoconfiguration 配置类，设置使用 transmittablethreadlocal，解决异步执行时上下文传递的问题。如下图所示：\n\n\n\n友情提示：\n\n项目使用到 threadlocal 的地方，建议都使用 transmittablethreadlocal 进行替换。\n\n\n# 2. 引入依赖\n\n以访问日志模块为例，讲解它如何使用异步任务，实现异步记录【访问日志】的功能。\n\n\n# 2.1 引入依赖\n\n在 yudao-module-system-infra 模块中，引入 yudao-spring-boot-starter-job 技术组件。如下所示：\n\n<dependency>\n    <groupid>cn.iocoder.boot</groupid>\n    <artifactid>yudao-spring-boot-starter-job</artifactid>\n</dependency>\n\n\n\n# 2.2 添加 @async 注解\n\n在 apiaccesslogserviceimpl 的 #createapiaccesslogasync(...) 方法上，添加 @async 注解，声明它要异步执行。如下图所示：\n\n\n\n\n# 2.3 测试调用\n\n随便请求一个 restful api 接口，可以看到在异步任务的线程池中，进行了访问日志的记录。如下图所示：\n\n",
            charsets: {
                cjk: !0
            }
        }, {
            title: "分布式锁",
            frontmatter: {
                title: "分布式锁",
                date: "2022-04-05T00:21:34.000Z",
                permalink: "/distributed-lock"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/02.%E5%90%8E%E7%AB%AF%E6%89%8B%E5%86%8C/31.%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.html",
            relativePath: "01.开发指南/02.后端手册/31.分布式锁.md",
            key: "v-cad135d2",
            path: "/distributed-lock/",
            headers: [{
                level: 2,
                title: "1. 编程式锁",
                slug: "_1-编程式锁",
                normalizedTitle: "1. 编程式锁",
                charIndex: 189
            }, {
                level: 3,
                title: "1.1 Redisson 配置",
                slug: "_1-1-redisson-配置",
                normalizedTitle: "1.1 redisson 配置",
                charIndex: 324
            }, {
                level: 3,
                title: "1.2 实战案例",
                slug: "_1-2-实战案例",
                normalizedTitle: "1.2 实战案例",
                charIndex: 403
            }, {
                level: 2,
                title: "2. 声明式锁",
                slug: "_2-声明式锁",
                normalizedTitle: "2. 声明式锁",
                charIndex: 923
            }, {
                level: 3,
                title: "2.1 Lock4j 配置",
                slug: "_2-1-lock4j-配置",
                normalizedTitle: "2.1 lock4j 配置",
                charIndex: 1026
            }, {
                level: 3,
                title: "2.2 使用案例",
                slug: "_2-2-使用案例",
                normalizedTitle: "2.2 使用案例",
                charIndex: 1121
            }],
            headersStr: "1. 编程式锁 1.1 Redisson 配置 1.2 实战案例 2. 声明式锁 2.1 Lock4j 配置 2.2 使用案例",
            content: 'yudao-spring-boot-starter-protection 技术组件，使用 Redis 实现分布式锁的功能，它有 2 种使用方式：\n\n * 编程式锁：基于 Redisson 框架提供的各种分布式锁\n * 声明式锁：基于 Lock4j 框架的 @Lock4j 注解\n\nRedis 分布式锁的实现原理？\n\n参见 《Redis 实现原理与源码解析系列》 文章。\n\n\n# 1. 编程式锁\n\n<dependency>\n    <groupId>org.redisson</groupId>\n    <artifactId>redisson-spring-boot-starter</artifactId>\n</dependency>\n\n\n\n# 1.1 Redisson 配置\n\n无需配置。因为在 Redis 缓存 中，进行了 Spring Data Redis + Redisson 的配置。\n\n\n# 1.2 实战案例\n\nyudao-module-pay 模块的 notify 功能，使用到分布式锁，确保每个支付通知任务有且仅有一个在执行。下面，来看看这个案例是如何实现的。\n\n友情提示：\n\n建议你已经阅读过 《开发指南 —— Redis 缓存》 文档。\n\n① 在 RedisKeyConstants 类中，定义通知任务使用的分布式锁的 Redis Key。如下图所示：\n\n\n\n② 创建 PayNotifyLockRedisDAO 类，使用 RedisClient 实现分布式锁的加锁与解锁。如下图所示：\n\n\n\n③ 在 PayNotifyServiceImpl 执行指定的支付通知任务时，通过 PayNotifyLockRedisDAO 获得分布式锁。如下图所示：\n\n\n\n技术选型：为什么不使用 Lock4j 提供的 LockTemplate 实现编程式锁？\n\n两者各有优势，选择 Redisson 主要考虑它支持的 Redis 分布式锁的类型较多：可靠性较高的红锁、性能较好的读写锁等等。\n\nLock4j 的 LockTemplate 也是不错的选择，一方面不强依赖 Redisson 框架，一方面支持 ZooKeeper 等等。\n\n\n# 2. 声明式锁\n\n考虑到不是所有人都会使用 Lock4j 组件，所以默认项目未引入 lock4j-redisson-spring-boot-starter。如果你想要实用，可按照下图进行引入：\n\n\n\n\n# 2.1 Lock4j 配置\n\n在 application-local.yaml 配置文件中，通过 lock4j 配置项，添加 Lock4j 全局默认的分布式锁配置。如下图所示：\n\n\n\n\n# 2.2 使用案例\n\n在需要使用到分布式锁的方法上，添加 @Lock4j 注解，非常方便。示例代码如下：\n\n@Service\npublic class DemoService {\n\n    // 默认使用 lock4j 配置项\n    @Lock4j\n    public void simple() {\n        //do something\n    }\n\n    // 完全配置，支持 Spring EL 表达式\n    @Lock4j(keys = {"#user.id", "#user.name"}, expire = 60000, acquireTimeout = 1000)\n    public User customMethod(User user) {\n        return user;\n    }\n\n}\n',
            normalizedContent: 'yudao-spring-boot-starter-protection 技术组件，使用 redis 实现分布式锁的功能，它有 2 种使用方式：\n\n * 编程式锁：基于 redisson 框架提供的各种分布式锁\n * 声明式锁：基于 lock4j 框架的 @lock4j 注解\n\nredis 分布式锁的实现原理？\n\n参见 《redis 实现原理与源码解析系列》 文章。\n\n\n# 1. 编程式锁\n\n<dependency>\n    <groupid>org.redisson</groupid>\n    <artifactid>redisson-spring-boot-starter</artifactid>\n</dependency>\n\n\n\n# 1.1 redisson 配置\n\n无需配置。因为在 redis 缓存 中，进行了 spring data redis + redisson 的配置。\n\n\n# 1.2 实战案例\n\nyudao-module-pay 模块的 notify 功能，使用到分布式锁，确保每个支付通知任务有且仅有一个在执行。下面，来看看这个案例是如何实现的。\n\n友情提示：\n\n建议你已经阅读过 《开发指南 —— redis 缓存》 文档。\n\n① 在 rediskeyconstants 类中，定义通知任务使用的分布式锁的 redis key。如下图所示：\n\n\n\n② 创建 paynotifylockredisdao 类，使用 redisclient 实现分布式锁的加锁与解锁。如下图所示：\n\n\n\n③ 在 paynotifyserviceimpl 执行指定的支付通知任务时，通过 paynotifylockredisdao 获得分布式锁。如下图所示：\n\n\n\n技术选型：为什么不使用 lock4j 提供的 locktemplate 实现编程式锁？\n\n两者各有优势，选择 redisson 主要考虑它支持的 redis 分布式锁的类型较多：可靠性较高的红锁、性能较好的读写锁等等。\n\nlock4j 的 locktemplate 也是不错的选择，一方面不强依赖 redisson 框架，一方面支持 zookeeper 等等。\n\n\n# 2. 声明式锁\n\n考虑到不是所有人都会使用 lock4j 组件，所以默认项目未引入 lock4j-redisson-spring-boot-starter。如果你想要实用，可按照下图进行引入：\n\n\n\n\n# 2.1 lock4j 配置\n\n在 application-local.yaml 配置文件中，通过 lock4j 配置项，添加 lock4j 全局默认的分布式锁配置。如下图所示：\n\n\n\n\n# 2.2 使用案例\n\n在需要使用到分布式锁的方法上，添加 @lock4j 注解，非常方便。示例代码如下：\n\n@service\npublic class demoservice {\n\n    // 默认使用 lock4j 配置项\n    @lock4j\n    public void simple() {\n        //do something\n    }\n\n    // 完全配置，支持 spring el 表达式\n    @lock4j(keys = {"#user.id", "#user.name"}, expire = 60000, acquiretimeout = 1000)\n    public user custommethod(user user) {\n        return user;\n    }\n\n}\n',
            charsets: {
                cjk: !0
            }
        }, {
            title: "幂等性（防重复提交）",
            frontmatter: {
                title: "幂等性（防重复提交）",
                date: "2022-04-09T23:20:58.000Z",
                permalink: "/idempotent"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/02.%E5%90%8E%E7%AB%AF%E6%89%8B%E5%86%8C/32.%E5%B9%82%E7%AD%89%E6%80%A7.html",
            relativePath: "01.开发指南/02.后端手册/32.幂等性.md",
            key: "v-4542a8f3",
            path: "/idempotent/",
            headers: [{
                level: 2,
                title: "1. 实现原理",
                slug: "_1-实现原理",
                normalizedTitle: "1. 实现原理",
                charIndex: 579
            }, {
                level: 2,
                title: "2. @Idempotent 注解",
                slug: "_2-idempotent-注解",
                normalizedTitle: "2. @idempotent 注解",
                charIndex: 1153
            }, {
                level: 2,
                title: "3. 使用示例",
                slug: "_3-使用示例",
                normalizedTitle: "3. 使用示例",
                charIndex: 1345
            }],
            headersStr: "1. 实现原理 2. @Idempotent 注解 3. 使用示例",
            content: 'yudao-spring-boot-starter-protection 技术组件，由它的 idempotent 包，提供声明式的幂等特性，可防止重复请求。例如说，用户快速的双击了某个按钮，前端没有禁用该按钮，导致发送了两次重复的请求。\n\n// UserController.java\n\n@Idempotent(timeout = 10, timeUnit = TimeUnit.SECONDS, message = "正在添加用户中，请勿重复提交")\n@PostMapping("/user/create")\npublic String createUser(User user){\n    userService.createUser(user);\n    return "添加成功";\n}\n\n\n * 每 10 秒钟，所有用户，只能操作一次\n\n疑问：如果想按照每个用户，或者每个 IP，限制请求呢？\n\n可设置该注解的 keyResolver 属性，可选择的有：\n\n * DefaultIdempotentKeyResolver：全局级别\n * UserIdempotentKeyResolver：用户级别\n * ExpressionIdempotentKeyResolver：自定义级别，通过 keyArg 属性指定 Spring EL 表达式\n\n\n# 1. 实现原理\n\n友情提示：\n\n它的实现原理，和 《请求限流（RateLimiter）》 比较接近哈。\n\n它的实现原理非常简单，针对相同参数的方法，一段时间内，有且仅能执行一次。执行流程如下：\n\n① 在方法执行前，根据参数对应的 Key 查询是否存在：\n\n * 如果存在，说明正在执行中，则进行报错。\n * 如果不在，则计算参数对应的 Key，存储到 Redis 中，并设置过期时间，即标记正在执行中。\n\n默认参数的 Redis Key 的计算规则由 DefaultIdempotentKeyResolver 实现，使用 MD5(方法名 + 方法参数)，避免 Redis Key 过长。\n\n② 方法执行完成，不会主动删除参数对应的 Key。\n\n如果希望会主动删除 Key，可以使用 《开发指南 —— 分布式锁》 提供的 @Lock 来实现幂等性。\n\n🙂 从本质上来说，idempotent 包提供的幂等特性，本质上也是基于 Redis 实现的分布式锁。\n\n③ 如果方法执行时间较长，超过 Key 的过期时间，则 Redis 会自动删除对应的 Key。因此，需要大概评估下，避免方法的执行时间超过过期时间。\n\n④ 如果方法执行发生 Exception 异常时，默认会删除 Key，避免下次请求无法正常执行，此处参考 《美团 GTIS》 。\n\n\n# 2. @Idempotent 注解\n\n@Idempotent 注解，声明在方法上，表示该方法需要开启幂等性。代码如下：\n\n\n\n① 对应的 AOP 切面是 IdempotentAspect 类，核心就 10 行左右的代码，如下图所示：\n\n\n\n② 对应的 Redis Key 的前缀是 idempotent:%s，可见 IdempotentRedisDAO 类，如下图所示：\n\n\n\n\n# 3. 使用示例\n\n本小节，我们实现 /admin-api/infra/test-demo/get RESTful API 接口的幂等性。\n\n① 在 pom.xml 文件中，引入 yudao-spring-boot-starter-protection 依赖。\n\n<dependency>\n    <groupId>cn.iocoder.boot</groupId>\n    <artifactId>yudao-spring-boot-starter-protection</artifactId>\n</dependency>\n\n\n② 在该 API 接口的对应方法上，添加 @Idempotent 注解。代码如下：\n\n// TestDemoController.java\n\n@GetMapping("/get")\n@Idempotent(timeout = 10, message = "重复请求，请稍后重试")\npublic CommonResult<TestDemoRespVO> getTestDemo(@RequestParam("id") Long id) {\n    // ... 省略代码\n}\n\n\n③ 调用该 API 接口，执行成功。\n\n\n\n④ 再次调用该 API 接口，被幂等性拦截，执行失败。\n\n{\n  "code": 900,\n  "data": null,\n  "msg": "重复请求，请稍后重试"\n}\n',
            normalizedContent: 'yudao-spring-boot-starter-protection 技术组件，由它的 idempotent 包，提供声明式的幂等特性，可防止重复请求。例如说，用户快速的双击了某个按钮，前端没有禁用该按钮，导致发送了两次重复的请求。\n\n// usercontroller.java\n\n@idempotent(timeout = 10, timeunit = timeunit.seconds, message = "正在添加用户中，请勿重复提交")\n@postmapping("/user/create")\npublic string createuser(user user){\n    userservice.createuser(user);\n    return "添加成功";\n}\n\n\n * 每 10 秒钟，所有用户，只能操作一次\n\n疑问：如果想按照每个用户，或者每个 ip，限制请求呢？\n\n可设置该注解的 keyresolver 属性，可选择的有：\n\n * defaultidempotentkeyresolver：全局级别\n * useridempotentkeyresolver：用户级别\n * expressionidempotentkeyresolver：自定义级别，通过 keyarg 属性指定 spring el 表达式\n\n\n# 1. 实现原理\n\n友情提示：\n\n它的实现原理，和 《请求限流（ratelimiter）》 比较接近哈。\n\n它的实现原理非常简单，针对相同参数的方法，一段时间内，有且仅能执行一次。执行流程如下：\n\n① 在方法执行前，根据参数对应的 key 查询是否存在：\n\n * 如果存在，说明正在执行中，则进行报错。\n * 如果不在，则计算参数对应的 key，存储到 redis 中，并设置过期时间，即标记正在执行中。\n\n默认参数的 redis key 的计算规则由 defaultidempotentkeyresolver 实现，使用 md5(方法名 + 方法参数)，避免 redis key 过长。\n\n② 方法执行完成，不会主动删除参数对应的 key。\n\n如果希望会主动删除 key，可以使用 《开发指南 —— 分布式锁》 提供的 @lock 来实现幂等性。\n\n🙂 从本质上来说，idempotent 包提供的幂等特性，本质上也是基于 redis 实现的分布式锁。\n\n③ 如果方法执行时间较长，超过 key 的过期时间，则 redis 会自动删除对应的 key。因此，需要大概评估下，避免方法的执行时间超过过期时间。\n\n④ 如果方法执行发生 exception 异常时，默认会删除 key，避免下次请求无法正常执行，此处参考 《美团 gtis》 。\n\n\n# 2. @idempotent 注解\n\n@idempotent 注解，声明在方法上，表示该方法需要开启幂等性。代码如下：\n\n\n\n① 对应的 aop 切面是 idempotentaspect 类，核心就 10 行左右的代码，如下图所示：\n\n\n\n② 对应的 redis key 的前缀是 idempotent:%s，可见 idempotentredisdao 类，如下图所示：\n\n\n\n\n# 3. 使用示例\n\n本小节，我们实现 /admin-api/infra/test-demo/get restful api 接口的幂等性。\n\n① 在 pom.xml 文件中，引入 yudao-spring-boot-starter-protection 依赖。\n\n<dependency>\n    <groupid>cn.iocoder.boot</groupid>\n    <artifactid>yudao-spring-boot-starter-protection</artifactid>\n</dependency>\n\n\n② 在该 api 接口的对应方法上，添加 @idempotent 注解。代码如下：\n\n// testdemocontroller.java\n\n@getmapping("/get")\n@idempotent(timeout = 10, message = "重复请求，请稍后重试")\npublic commonresult<testdemorespvo> gettestdemo(@requestparam("id") long id) {\n    // ... 省略代码\n}\n\n\n③ 调用该 api 接口，执行成功。\n\n\n\n④ 再次调用该 api 接口，被幂等性拦截，执行失败。\n\n{\n  "code": 900,\n  "data": null,\n  "msg": "重复请求，请稍后重试"\n}\n',
            charsets: {
                cjk: !0
            }
        }, {
            title: "请求限流（RateLimiter）",
            frontmatter: {
                title: "请求限流（RateLimiter）",
                date: "2024-04-11T12:53:13.000Z",
                permalink: "/rate-limiter/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/02.%E5%90%8E%E7%AB%AF%E6%89%8B%E5%86%8C/33.%E8%AF%B7%E6%B1%82%E9%99%90%E6%B5%81.html",
            relativePath: "01.开发指南/02.后端手册/33.请求限流.md",
            key: "v-0e8d395b",
            path: "/rate-limiter/",
            headers: [{
                level: 2,
                title: "1. 实现原理",
                slug: "_1-实现原理",
                normalizedTitle: "1. 实现原理",
                charIndex: 612
            }, {
                level: 2,
                title: "2. @RateLimiter 注解",
                slug: "_2-ratelimiter-注解",
                normalizedTitle: "2. @ratelimiter 注解",
                charIndex: 868
            }, {
                level: 2,
                title: "3. 使用示例",
                slug: "_3-使用示例",
                normalizedTitle: "3. 使用示例",
                charIndex: 1064
            }],
            headersStr: "1. 实现原理 2. @RateLimiter 注解 3. 使用示例",
            content: 'yudao-spring-boot-starter-protection 技术组件，由它的 ratelimiter 包，提供声明式的限流特性，可防止请求过多。例如说，用户疯狂的点击了某个按钮，导致发送了大量的请求。\n\n\n@RateLimiter(count = 10, timeUnit = TimeUnit.MINUTES)\n@PostMapping("/user/create")\npublic String createUser(User user){\n    userService.createUser(user);\n    return "添加成功";\n}\n\n\n * 每分钟，所有用户，只能操作 10 次\n\n疑问：如果想按照每个用户，或者每个 IP，限制请求呢？\n\n可设置该注解的 keyResolver 属性，可选择的有：\n\n * DefaultRateLimiterKeyResolver：全局级别\n * UserRateLimiterKeyResolver：用户 ID 级别\n * ClientIpRateLimiterKeyResolver：用户 IP 级别\n * ServerNodeRateLimiterKeyResolver：服务器 Node 级别\n * ExpressionIdempotentKeyResolver：自定义级别，通过 keyArg 属性指定 Spring EL 表达式\n\n\n# 1. 实现原理\n\n友情提示：\n\n它的实现原理，和 《幂等性（防重复提交）》 比较接近哈。\n\n它的实现原理非常简单，针对相同参数的方法，一段时间内，只能执行一定次数。执行流程如下：\n\n在方法执行前，判断参数对应的 Key 是否超过限制：\n\n * 如果超过，则进行报错。\n * 如果未超过，则使用 Redis 计数 +1\n\n默认参数的 Redis Key 的计算规则由 DefaultRateLimiterKeyResolver 实现，使用 MD5(方法名 + 方法参数)，避免 Redis Key 过长。\n\n\n# 2. @RateLimiter 注解\n\n@RateLimiter 注解，声明在方法上，表示该方法需要开启限流。代码如下：\n\n\n\n① 对应的 AOP 切面是 RateLimiterAspect 类，核心就 10 行左右的代码，如下图所示：\n\n\n\n② 对应的 Redis Key 的前缀是 rate_limiter:% ，可见 IdempotentRedisDAO 类，如下图所示：\n\n\n\n\n# 3. 使用示例\n\n本小节，我们实现 /admin-api/system/user/page RESTful API 接口的限流。\n\n① 在 pom.xml 文件中，引入 yudao-spring-boot-starter-protection 依赖。\n\n<dependency>\n    <groupId>cn.iocoder.boot</groupId>\n    <artifactId>yudao-spring-boot-starter-protection</artifactId>\n</dependency>\n\n\n② 在 /admin-api/system/user/page RESTful API 接口的对应方法上，添加 @RateLimiter 注解。代码如下：\n\n// UserController.java\n\n@GetMapping("/page")\n@RateLimiter(count = 1, time = 60)\npublic CommonResult<PageResult<UserRespVO>> getUserPage(@Valid UserPageReqVO pageReqVO) {\n    // ... 省略代码\n}\n\n\n③ 调用该 API 接口，执行成功。\n\n\n\n④ 再次调用该 API 接口，被限流拦截，执行失败。\n\n{\n  "code": 429,\n  "data": null,\n  "msg": "请求过于频繁，请稍后重试"\n}\n',
            normalizedContent: 'yudao-spring-boot-starter-protection 技术组件，由它的 ratelimiter 包，提供声明式的限流特性，可防止请求过多。例如说，用户疯狂的点击了某个按钮，导致发送了大量的请求。\n\n\n@ratelimiter(count = 10, timeunit = timeunit.minutes)\n@postmapping("/user/create")\npublic string createuser(user user){\n    userservice.createuser(user);\n    return "添加成功";\n}\n\n\n * 每分钟，所有用户，只能操作 10 次\n\n疑问：如果想按照每个用户，或者每个 ip，限制请求呢？\n\n可设置该注解的 keyresolver 属性，可选择的有：\n\n * defaultratelimiterkeyresolver：全局级别\n * userratelimiterkeyresolver：用户 id 级别\n * clientipratelimiterkeyresolver：用户 ip 级别\n * servernoderatelimiterkeyresolver：服务器 node 级别\n * expressionidempotentkeyresolver：自定义级别，通过 keyarg 属性指定 spring el 表达式\n\n\n# 1. 实现原理\n\n友情提示：\n\n它的实现原理，和 《幂等性（防重复提交）》 比较接近哈。\n\n它的实现原理非常简单，针对相同参数的方法，一段时间内，只能执行一定次数。执行流程如下：\n\n在方法执行前，判断参数对应的 key 是否超过限制：\n\n * 如果超过，则进行报错。\n * 如果未超过，则使用 redis 计数 +1\n\n默认参数的 redis key 的计算规则由 defaultratelimiterkeyresolver 实现，使用 md5(方法名 + 方法参数)，避免 redis key 过长。\n\n\n# 2. @ratelimiter 注解\n\n@ratelimiter 注解，声明在方法上，表示该方法需要开启限流。代码如下：\n\n\n\n① 对应的 aop 切面是 ratelimiteraspect 类，核心就 10 行左右的代码，如下图所示：\n\n\n\n② 对应的 redis key 的前缀是 rate_limiter:% ，可见 idempotentredisdao 类，如下图所示：\n\n\n\n\n# 3. 使用示例\n\n本小节，我们实现 /admin-api/system/user/page restful api 接口的限流。\n\n① 在 pom.xml 文件中，引入 yudao-spring-boot-starter-protection 依赖。\n\n<dependency>\n    <groupid>cn.iocoder.boot</groupid>\n    <artifactid>yudao-spring-boot-starter-protection</artifactid>\n</dependency>\n\n\n② 在 /admin-api/system/user/page restful api 接口的对应方法上，添加 @ratelimiter 注解。代码如下：\n\n// usercontroller.java\n\n@getmapping("/page")\n@ratelimiter(count = 1, time = 60)\npublic commonresult<pageresult<userrespvo>> getuserpage(@valid userpagereqvo pagereqvo) {\n    // ... 省略代码\n}\n\n\n③ 调用该 api 接口，执行成功。\n\n\n\n④ 再次调用该 api 接口，被限流拦截，执行失败。\n\n{\n  "code": 429,\n  "data": null,\n  "msg": "请求过于频繁，请稍后重试"\n}\n',
            charsets: {
                cjk: !0
            }
        }, {
            title: "HTTP 接口签名（防篡改）",
            frontmatter: {
                title: "HTTP 接口签名（防篡改）",
                date: "2024-06-04T17:19:28.000Z",
                permalink: "/http-sign/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/02.%E5%90%8E%E7%AB%AF%E6%89%8B%E5%86%8C/34.HTTP%20%E7%AD%BE%E5%90%8D.html",
            relativePath: "01.开发指南/02.后端手册/34.HTTP 签名.md",
            key: "v-53547eb1",
            path: "/http-sign/",
            headers: [{
                level: 2,
                title: "1. 实现原理",
                slug: "_1-实现原理",
                normalizedTitle: "1. 实现原理",
                charIndex: 215
            }, {
                level: 2,
                title: "2. 使用示例",
                slug: "_2-使用示例",
                normalizedTitle: "2. 使用示例",
                charIndex: 1504
            }],
            headersStr: "1. 实现原理 2. 使用示例",
            content: 'yudao-spring-boot-starter-protection 技术组件，由它的 signature 包，提供 HTTP 接口签名特性，提高安全性。\n\n例如说：项目给第三方提供 HTTP 接口时，为了提高对接中数据传输的安全性（防止请求参数被篡改），同时校验调用方的有效性，通常都需要增加签名 sign。\n\n市面上也有非常多的案例，例如说：\n\n * 《微信支付 —— 安全规范》\n * 《支付宝 —— 签名 》\n\n\n# 1. 实现原理\n\n在 Controller 的方法上，添加 @ApiSignature 注解，声明它需要签名。\n\n然后，通过 AOP 切面，ApiSignatureAspect 对这些方法进行拦截，校验签名是否正确。它的签名算法如下：\n\n// ApiSignatureAspect.java\n\nString serverSignatureString = buildSignatureString(signature, request, appSecret)\nDigestUtil.sha256Hex(serverSignatureString);\n\n    private String buildSignatureString(ApiSignature signature, HttpServletRequest request, String appSecret) {\n        SortedMap<String, String> parameterMap = getRequestParameterMap(request); // 请求头\n        SortedMap<String, String> headerMap = getRequestHeaderMap(signature, request); // 请求参数\n        String requestBody = StrUtil.nullToDefault(ServletUtils.getBody(request), ""); // 请求体\n        return MapUtil.join(parameterMap, "&", "=")\n                + requestBody\n                + MapUtil.join(headerMap, "&", "=")\n                + appSecret;\n    }\n\n\n① 将请求头、请求体、请求参数，按照一定顺序排列，然后添加密钥，获得需要进行签名的字符串。\n\n其中，每个调用方 appId 对应一个唯一 appSecret，通过在 Redis 配置，它对应 key 为 api_signature_app 的 HASH 结构，hashKey 为 appId。\n\n② 之后，通过 SHA256 进行加密，得到签名 sign。\n\n----------------------------------------\n\n注意：第三方调用时，每次请求 Header 需要带上 appId、timestamp、nonce、sign 四个参数：\n\n * appId：调用方的唯一标识。\n * timestamp：请求时的时间戳。\n * nonce：用于请求的防重放攻击，每次请求唯一，例如说 UUID。\n * sign：HTTP 签名。\n\n疑问：为什么使用请求 Header 传参？\n\n避免这四个参数，在请求 QueryString、Request Body 可能重复的问题！\n\n\n# 2. 使用示例\n\n① 在需要使用的 xxx-biz 模块的 ，引入 yudao-spring-boot-starter-protection 依赖：\n\n<dependency>\n    <groupId>cn.iocoder.boot</groupId>\n    <artifactId>yudao-spring-boot-starter-protection</artifactId>\n</dependency>\n\n\n② 在 Redis 添加一个 appId 为 test，密钥为 123456 的配置：\n\nhset api_signature_app test 123456\n\n\n③ 在 Controller 的方法上，添加 @ApiSignature 注解：\n\n// UserController.java\n\n@GetMapping("/page")\n@Operation(summary = "获得用户分页列表")\n@PreAuthorize("@ss.hasPermission(\'system:user:list\')")\n@ApiSignature(timeout = 30, timeUnit = TimeUnit.MINUTES) // 关键是此处。ps：设置为 30 分钟，只是为了测试方便，不是必须！\npublic CommonResult<PageResult<UserRespVO>> getUserPage(@Valid UserPageReqVO pageReqVO) {\n    // ... 省略代码\n}\n\n\n④ 调用该 API 接口，执行成功。如下是一个 IDEA HTTP 的示例：\n\n// UserController.http\n\nGET {{baseUrl}}/system/user/page?pageNo=1&pageSize=10\nAuthorization: Bearer {{token}}\nappId: test\ntimestamp: 1717494535932\nnonce: e7eb4265-885d-40eb-ace3-2ecfc34bd639\nsign: 01e1c3df4d93eafc862753641ebfc1637e70f853733684a139f8b630af5c84cd\ntenant-id: {{adminTenentId}}\n\n\n * appId、timestamp、nonce、sign 通过请求 Header 传递，避免和请求参数冲突。【必须传递】\n * timestamp：请求时的时间戳。\n * nonce：用于请求的防重放攻击，每次请求唯一，例如说 UUID。\n * sign：HTTP 签名。如果你不知道多少，可以直接 debug ApiSignatureAspect 的 serverSignature 处的代码，进行获得。\n\n友情提示：强烈建议 ApiSignatureAspect 的实现代码，一共就 100 多行代码。可以通过 ApiSignatureTest 单元测试，直接执行噢！',
            normalizedContent: 'yudao-spring-boot-starter-protection 技术组件，由它的 signature 包，提供 http 接口签名特性，提高安全性。\n\n例如说：项目给第三方提供 http 接口时，为了提高对接中数据传输的安全性（防止请求参数被篡改），同时校验调用方的有效性，通常都需要增加签名 sign。\n\n市面上也有非常多的案例，例如说：\n\n * 《微信支付 —— 安全规范》\n * 《支付宝 —— 签名 》\n\n\n# 1. 实现原理\n\n在 controller 的方法上，添加 @apisignature 注解，声明它需要签名。\n\n然后，通过 aop 切面，apisignatureaspect 对这些方法进行拦截，校验签名是否正确。它的签名算法如下：\n\n// apisignatureaspect.java\n\nstring serversignaturestring = buildsignaturestring(signature, request, appsecret)\ndigestutil.sha256hex(serversignaturestring);\n\n    private string buildsignaturestring(apisignature signature, httpservletrequest request, string appsecret) {\n        sortedmap<string, string> parametermap = getrequestparametermap(request); // 请求头\n        sortedmap<string, string> headermap = getrequestheadermap(signature, request); // 请求参数\n        string requestbody = strutil.nulltodefault(servletutils.getbody(request), ""); // 请求体\n        return maputil.join(parametermap, "&", "=")\n                + requestbody\n                + maputil.join(headermap, "&", "=")\n                + appsecret;\n    }\n\n\n① 将请求头、请求体、请求参数，按照一定顺序排列，然后添加密钥，获得需要进行签名的字符串。\n\n其中，每个调用方 appid 对应一个唯一 appsecret，通过在 redis 配置，它对应 key 为 api_signature_app 的 hash 结构，hashkey 为 appid。\n\n② 之后，通过 sha256 进行加密，得到签名 sign。\n\n----------------------------------------\n\n注意：第三方调用时，每次请求 header 需要带上 appid、timestamp、nonce、sign 四个参数：\n\n * appid：调用方的唯一标识。\n * timestamp：请求时的时间戳。\n * nonce：用于请求的防重放攻击，每次请求唯一，例如说 uuid。\n * sign：http 签名。\n\n疑问：为什么使用请求 header 传参？\n\n避免这四个参数，在请求 querystring、request body 可能重复的问题！\n\n\n# 2. 使用示例\n\n① 在需要使用的 xxx-biz 模块的 ，引入 yudao-spring-boot-starter-protection 依赖：\n\n<dependency>\n    <groupid>cn.iocoder.boot</groupid>\n    <artifactid>yudao-spring-boot-starter-protection</artifactid>\n</dependency>\n\n\n② 在 redis 添加一个 appid 为 test，密钥为 123456 的配置：\n\nhset api_signature_app test 123456\n\n\n③ 在 controller 的方法上，添加 @apisignature 注解：\n\n// usercontroller.java\n\n@getmapping("/page")\n@operation(summary = "获得用户分页列表")\n@preauthorize("@ss.haspermission(\'system:user:list\')")\n@apisignature(timeout = 30, timeunit = timeunit.minutes) // 关键是此处。ps：设置为 30 分钟，只是为了测试方便，不是必须！\npublic commonresult<pageresult<userrespvo>> getuserpage(@valid userpagereqvo pagereqvo) {\n    // ... 省略代码\n}\n\n\n④ 调用该 api 接口，执行成功。如下是一个 idea http 的示例：\n\n// usercontroller.http\n\nget {{baseurl}}/system/user/page?pageno=1&pagesize=10\nauthorization: bearer {{token}}\nappid: test\ntimestamp: 1717494535932\nnonce: e7eb4265-885d-40eb-ace3-2ecfc34bd639\nsign: 01e1c3df4d93eafc862753641ebfc1637e70f853733684a139f8b630af5c84cd\ntenant-id: {{admintenentid}}\n\n\n * appid、timestamp、nonce、sign 通过请求 header 传递，避免和请求参数冲突。【必须传递】\n * timestamp：请求时的时间戳。\n * nonce：用于请求的防重放攻击，每次请求唯一，例如说 uuid。\n * sign：http 签名。如果你不知道多少，可以直接 debug apisignatureaspect 的 serversignature 处的代码，进行获得。\n\n友情提示：强烈建议 apisignatureaspect 的实现代码，一共就 100 多行代码。可以通过 apisignaturetest 单元测试，直接执行噢！',
            charsets: {
                cjk: !0
            }
        }, {
            title: "单元测试",
            frontmatter: {
                title: "单元测试",
                date: "2022-04-04T20:45:01.000Z",
                permalink: "/unit-test"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/02.%E5%90%8E%E7%AB%AF%E6%89%8B%E5%86%8C/40.%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.html",
            relativePath: "01.开发指南/02.后端手册/40.单元测试.md",
            key: "v-1538c668",
            path: "/unit-test/",
            headers: [{
                level: 2,
                title: "1.测试组件",
                slug: "_1-测试组件",
                normalizedTitle: "1.测试组件",
                charIndex: 199
            }, {
                level: 3,
                title: "1.1 快速测试的基类",
                slug: "_1-1-快速测试的基类",
                normalizedTitle: "1.1 快速测试的基类",
                charIndex: 268
            }, {
                level: 3,
                title: "1.2 测试工具类",
                slug: "_1-2-测试工具类",
                normalizedTitle: "1.2 测试工具类",
                charIndex: 644
            }, {
                level: 2,
                title: "2. BaseDbUnitTest 实战案例",
                slug: "_2-basedbunittest-实战案例",
                normalizedTitle: "2. basedbunittest 实战案例",
                charIndex: 764
            }, {
                level: 3,
                title: "2.1 引入依赖",
                slug: "_2-1-引入依赖",
                normalizedTitle: "2.1 引入依赖",
                charIndex: 861
            }, {
                level: 3,
                title: "2.2 新建 ut 配置文件",
                slug: "_2-2-新建-ut-配置文件",
                normalizedTitle: "2.2 新建 ut 配置文件",
                charIndex: 1102
            }, {
                level: 3,
                title: "2.3 添加 H2 SQL 脚本",
                slug: "_2-3-添加-h2-sql-脚本",
                normalizedTitle: "2.3 添加 h2 sql 脚本",
                charIndex: 1190
            }, {
                level: 3,
                title: "2.3 新建 DictTypeServiceTest 类",
                slug: "_2-3-新建-dicttypeservicetest-类",
                normalizedTitle: "2.3 新建 dicttypeservicetest 类",
                charIndex: 2118
            }, {
                level: 3,
                title: "2.4 新增方法的单测",
                slug: "_2-4-新增方法的单测",
                normalizedTitle: "2.4 新增方法的单测",
                charIndex: 2658
            }, {
                level: 3,
                title: "2.5 修改方法的单测",
                slug: "_2-5-修改方法的单测",
                normalizedTitle: "2.5 修改方法的单测",
                charIndex: 2676
            }, {
                level: 3,
                title: "2.6 删除方法的单测",
                slug: "_2-6-删除方法的单测",
                normalizedTitle: "2.6 删除方法的单测",
                charIndex: 2694
            }, {
                level: 3,
                title: "2.7 单条查询方法的单测",
                slug: "_2-7-单条查询方法的单测",
                normalizedTitle: "2.7 单条查询方法的单测",
                charIndex: 2712
            }, {
                level: 3,
                title: "2.8 分页查询方法的单测",
                slug: "_2-8-分页查询方法的单测",
                normalizedTitle: "2.8 分页查询方法的单测",
                charIndex: 2732
            }, {
                level: 2,
                title: "3. BaseMockitoUnitTest 实战案例",
                slug: "_3-basemockitounittest-实战案例",
                normalizedTitle: "3. basemockitounittest 实战案例",
                charIndex: 2752
            }],
            headersStr: "1.测试组件 1.1 快速测试的基类 1.2 测试工具类 2. BaseDbUnitTest 实战案例 2.1 引入依赖 2.2 新建 ut 配置文件 2.3 添加 H2 SQL 脚本 2.3 新建 DictTypeServiceTest 类 2.4 新增方法的单测 2.5 修改方法的单测 2.6 删除方法的单测 2.7 单条查询方法的单测 2.8 分页查询方法的单测 3. BaseMockitoUnitTest 实战案例",
            content: '项目使用 Junit5 + Mockito 实现单元测试，提升代码质量、重复测试效率、部署可靠性等。\n\n截止目前，项目已经有 500+ 测试用例。\n\n内容推荐\n\n如果你想系统学习单元测试，可以阅读《有效的单元测试》这本书，非常适合 Java 工程师。\n\n如果只是想学习 Spring Boot Test 的话，可以阅读 《芋道 Spring Boot 单元测试 Test 入门 》 文章。\n\n\n# 1.测试组件\n\nyudao-spring-boot-starter-test 是项目提供的测试组件，用于单元测试、集成测试等等。\n\n\n# 1.1 快速测试的基类\n\n测试组件提供了 4 种单元测试的基类，通过继承它们，可以快速的构建单元测试的环境。\n\n基类                       作用\nBaseMockitoUnitTest      纯 Mockito 的单元测试\nBaseDbUnitTest           使用内嵌的 H2 数据库的单元测试\nBaseRedisUnitTest        使用内嵌的 Redis 缓存的单元测试\nBaseDbAndRedisUnitTest   使用内嵌的 H2 数据库 + Redis 缓存的单元测试\n\n疑问：什么是内嵌的 Redis 缓存？\n\n基于 jedis-mock 开源项目，通过 RedisTestConfiguration 配置类，启动一个 Redis 进程。一般情况下，会使用 16379 端口。\n\n\n# 1.2 测试工具类\n\n① RandomUtils 基于 podam 开源项目，实现 Bean 对象的随机生成。\n\n② AssertUtils 封装 Junit 的 Assert 断言，实现 Bean 对象的断言，支持忽略部分属性。\n\n\n# 2. BaseDbUnitTest 实战案例\n\n以字典类型模块的 DictTypeServiceImpl 为例子，讲解它的 DictTypeServiceTest 单元测试的编写实现。\n\n\n# 2.1 引入依赖\n\n在 yudao-module-system-biz 模块中，引入 yudao-spring-boot-starter-test 技术组件。如下所示：\n\n<dependency>\n    <groupId>cn.iocoder.boot</groupId>\n    <artifactId>yudao-spring-boot-starter-test</artifactId>\n    <scope>test</scope>\n</dependency>\n\n\n\n# 2.2 新建 ut 配置文件\n\n在 test/resources 目录，新建单元测试的 application-unit-test.yaml 配置文件，内容如下：\n\n\n\n\n# 2.3 添加 H2 SQL 脚本\n\n修改 test/resources/sql 目录的两个 H2 SQL 脚本：\n\n① 在 create_tables.sql 文件中，添加 system_dict_type 的 H2 建表语句。SQL 如下：\n\nCREATE TABLE IF NOT EXISTS "system_dict_type" (\n    "id" bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY,\n    "name" varchar(100) NOT NULL DEFAULT \'\',\n    "type" varchar(100) NOT NULL DEFAULT \'\',\n    "status" tinyint NOT NULL DEFAULT \'0\',\n    "remark" varchar(500) DEFAULT NULL,\n    "creator" varchar(64) DEFAULT \'\',\n    "create_time" timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    "updater" varchar(64) DEFAULT \'\',\n    "update_time" timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    "deleted" bit NOT NULL DEFAULT FALSE,\n    PRIMARY KEY ("id")\n) COMMENT \'字典类型表\';\n\n\n注意，H2 和 MySQL 的建表语句有区别，需要手动进行转换。如果你不想进行转换，可以使用 [基础设置 -> 代码生成] 菜单的代码生成器功能，如下图所示：\n\n\n\n② 在 clean.sql 文件中，添加 system_dict_type 的清空数据的语句。SQL 如下：\n\nDELETE FROM "system_dict_type";\n\n\n每次单元测试的方法执行完后，会执行 clean.sql 脚本，进行数据的清理，保证每个单元测试的方法的数据隔离性。\n\n\n# 2.3 新建 DictTypeServiceTest 类\n\n新建 DictTypeServiceTest 测试类，继承 BaseMockitoUnitTest 基类，并完成它的配置。代码如下图所示：\n\n\n\n * 属于自己模块的，使用 Spring 初始化成真实的 Bean，然后通过 @Resource 注入。例如说：dictTypeService、dictTypeMapper\n * 属于别人模块的，使用 Spring @MockBean 注解，模拟 Mock 成一个 Bean 后注入。例如说：dictDataService\n\n疑问：为什么有的进行 Mock，有的不进行 Mock 呢？\n\n * 单元测试需要避免对外部的依赖，而 dictDataService 是外部依赖，所以需要 Mock 掉。\n * dictTypeMapper 某种程度来说，也是一种外部依赖，但是通过内嵌的 H2 内存数据库，进行“真实”的数据库操作，反而单元测试的编写效率更高，效果更好，所以不需要 Mock 掉。\n\n另外，[基础设置 -> 代码生成] 菜单的代码生成器功能，已经生成了绝大多数的单元测试的逻辑，这里主要是希望让你了解单元测试的具体使用，所以并没有使用它。如下图所示：\n\n\n\n\n# 2.4 新增方法的单测\n\n\n\n\n# 2.5 修改方法的单测\n\n\n\n\n# 2.6 删除方法的单测\n\n\n\n\n# 2.7 单条查询方法的单测\n\n\n\n\n# 2.8 分页查询方法的单测\n\n\n\n\n# 3. BaseMockitoUnitTest 实战案例\n\n一些类由于不依赖 MySQL 和 Redis，可以通过继承 BaseMockitoUnitTest 基类，实现纯 Mockito 的单元测试。例如说 SmsSendServiceTest 单元测试类，代码如下：\n\n\n\n具体 SmsSendServiceTest 的每个测试方法，和 DictTypeServiceTest 并没有什么差别，还是 Mock 模拟 + Assert 断言 + Verify 调用，你可以自己花点时间瞅瞅。',
            normalizedContent: '项目使用 junit5 + mockito 实现单元测试，提升代码质量、重复测试效率、部署可靠性等。\n\n截止目前，项目已经有 500+ 测试用例。\n\n内容推荐\n\n如果你想系统学习单元测试，可以阅读《有效的单元测试》这本书，非常适合 java 工程师。\n\n如果只是想学习 spring boot test 的话，可以阅读 《芋道 spring boot 单元测试 test 入门 》 文章。\n\n\n# 1.测试组件\n\nyudao-spring-boot-starter-test 是项目提供的测试组件，用于单元测试、集成测试等等。\n\n\n# 1.1 快速测试的基类\n\n测试组件提供了 4 种单元测试的基类，通过继承它们，可以快速的构建单元测试的环境。\n\n基类                       作用\nbasemockitounittest      纯 mockito 的单元测试\nbasedbunittest           使用内嵌的 h2 数据库的单元测试\nbaseredisunittest        使用内嵌的 redis 缓存的单元测试\nbasedbandredisunittest   使用内嵌的 h2 数据库 + redis 缓存的单元测试\n\n疑问：什么是内嵌的 redis 缓存？\n\n基于 jedis-mock 开源项目，通过 redistestconfiguration 配置类，启动一个 redis 进程。一般情况下，会使用 16379 端口。\n\n\n# 1.2 测试工具类\n\n① randomutils 基于 podam 开源项目，实现 bean 对象的随机生成。\n\n② assertutils 封装 junit 的 assert 断言，实现 bean 对象的断言，支持忽略部分属性。\n\n\n# 2. basedbunittest 实战案例\n\n以字典类型模块的 dicttypeserviceimpl 为例子，讲解它的 dicttypeservicetest 单元测试的编写实现。\n\n\n# 2.1 引入依赖\n\n在 yudao-module-system-biz 模块中，引入 yudao-spring-boot-starter-test 技术组件。如下所示：\n\n<dependency>\n    <groupid>cn.iocoder.boot</groupid>\n    <artifactid>yudao-spring-boot-starter-test</artifactid>\n    <scope>test</scope>\n</dependency>\n\n\n\n# 2.2 新建 ut 配置文件\n\n在 test/resources 目录，新建单元测试的 application-unit-test.yaml 配置文件，内容如下：\n\n\n\n\n# 2.3 添加 h2 sql 脚本\n\n修改 test/resources/sql 目录的两个 h2 sql 脚本：\n\n① 在 create_tables.sql 文件中，添加 system_dict_type 的 h2 建表语句。sql 如下：\n\ncreate table if not exists "system_dict_type" (\n    "id" bigint not null generated by default as identity,\n    "name" varchar(100) not null default \'\',\n    "type" varchar(100) not null default \'\',\n    "status" tinyint not null default \'0\',\n    "remark" varchar(500) default null,\n    "creator" varchar(64) default \'\',\n    "create_time" timestamp not null default current_timestamp,\n    "updater" varchar(64) default \'\',\n    "update_time" timestamp not null default current_timestamp,\n    "deleted" bit not null default false,\n    primary key ("id")\n) comment \'字典类型表\';\n\n\n注意，h2 和 mysql 的建表语句有区别，需要手动进行转换。如果你不想进行转换，可以使用 [基础设置 -> 代码生成] 菜单的代码生成器功能，如下图所示：\n\n\n\n② 在 clean.sql 文件中，添加 system_dict_type 的清空数据的语句。sql 如下：\n\ndelete from "system_dict_type";\n\n\n每次单元测试的方法执行完后，会执行 clean.sql 脚本，进行数据的清理，保证每个单元测试的方法的数据隔离性。\n\n\n# 2.3 新建 dicttypeservicetest 类\n\n新建 dicttypeservicetest 测试类，继承 basemockitounittest 基类，并完成它的配置。代码如下图所示：\n\n\n\n * 属于自己模块的，使用 spring 初始化成真实的 bean，然后通过 @resource 注入。例如说：dicttypeservice、dicttypemapper\n * 属于别人模块的，使用 spring @mockbean 注解，模拟 mock 成一个 bean 后注入。例如说：dictdataservice\n\n疑问：为什么有的进行 mock，有的不进行 mock 呢？\n\n * 单元测试需要避免对外部的依赖，而 dictdataservice 是外部依赖，所以需要 mock 掉。\n * dicttypemapper 某种程度来说，也是一种外部依赖，但是通过内嵌的 h2 内存数据库，进行“真实”的数据库操作，反而单元测试的编写效率更高，效果更好，所以不需要 mock 掉。\n\n另外，[基础设置 -> 代码生成] 菜单的代码生成器功能，已经生成了绝大多数的单元测试的逻辑，这里主要是希望让你了解单元测试的具体使用，所以并没有使用它。如下图所示：\n\n\n\n\n# 2.4 新增方法的单测\n\n\n\n\n# 2.5 修改方法的单测\n\n\n\n\n# 2.6 删除方法的单测\n\n\n\n\n# 2.7 单条查询方法的单测\n\n\n\n\n# 2.8 分页查询方法的单测\n\n\n\n\n# 3. basemockitounittest 实战案例\n\n一些类由于不依赖 mysql 和 redis，可以通过继承 basemockitounittest 基类，实现纯 mockito 的单元测试。例如说 smssendservicetest 单元测试类，代码如下：\n\n\n\n具体 smssendservicetest 的每个测试方法，和 dicttypeservicetest 并没有什么差别，还是 mock 模拟 + assert 断言 + verify 调用，你可以自己花点时间瞅瞅。',
            charsets: {
                cjk: !0
            }
        }, {
            title: "配置管理",
            frontmatter: {
                title: "配置管理",
                date: "2022-04-04T11:14:56.000Z",
                permalink: "/config-center"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/02.%E5%90%8E%E7%AB%AF%E6%89%8B%E5%86%8C/43.%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86.html",
            relativePath: "01.开发指南/02.后端手册/43.配置管理.md",
            key: "v-29cec904",
            path: "/config-center/",
            headers: [{
                level: 2,
                title: "1. 配置的表结构",
                slug: "_1-配置的表结构",
                normalizedTitle: "1. 配置的表结构",
                charIndex: 165
            }, {
                level: 2,
                title: "3. 后端案例",
                slug: "_3-后端案例",
                normalizedTitle: "3. 后端案例",
                charIndex: 1546
            }, {
                level: 2,
                title: "4. 前端案例",
                slug: "_4-前端案例",
                normalizedTitle: "4. 前端案例",
                charIndex: 1739
            }],
            headersStr: "1. 配置的表结构 3. 后端案例 4. 前端案例",
            content: "在 [基础设施 -> 配置管理] 菜单，可以查看和管理配置，适合业务上需要动态的管理某个配置。\n\n例如说：创建用户时，需要配置用户的默认密码，这个密码是不会变的，但是有时候需要修改这个默认密码，这个时候就可以通过配置管理来修改。\n\n\n\n对应的后端代码是 yudao-module-infra 的 config 业务模块。\n\n\n# 1. 配置的表结构\n\ninfra_config 的表结构如下：\n\nCREATE TABLE `infra_config` (\n  `id` int NOT NULL AUTO_INCREMENT COMMENT '参数主键',\n  `group` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '参数分组',\n  `type` tinyint NOT NULL COMMENT '参数类型',\n  `name` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '参数名称',\n  `key` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '参数键名',\n  `value` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '参数键值',\n  `sensitive` bit(1) NOT NULL COMMENT '是否敏感',\n  `remark` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '备注',\n  `creator` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT '' COMMENT '创建者',\n  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\n  `updater` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT '' COMMENT '更新者',\n  `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',\n  `deleted` bit(1) NOT NULL DEFAULT b'0' COMMENT '是否删除',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='参数配置表';\n\n\n * key 字段，对应到 Spring Boot 配置文件的配置项，例如说 yudao.captcha.enable、sys.user.init-password 等等。\n\n\n# 3. 后端案例\n\n调用 ConfigApi 的 #getConfigValueByKey(String key) 方法，可以读取指定 key 的参数值。\n\n具体案例，可见 AdminUserServiceImpl 的 #importUserList(...) 方法，在导入 Excel 用户时，它会读取 system.user.init-password 作为用户初始化密码。\n\n\n# 4. 前端案例\n\n后端提供了 /admin-api/infra/config/get-value-by-key RESTful API 接口，返回指定配置项的值。前端的使用示例如下图：\n\n",
            normalizedContent: "在 [基础设施 -> 配置管理] 菜单，可以查看和管理配置，适合业务上需要动态的管理某个配置。\n\n例如说：创建用户时，需要配置用户的默认密码，这个密码是不会变的，但是有时候需要修改这个默认密码，这个时候就可以通过配置管理来修改。\n\n\n\n对应的后端代码是 yudao-module-infra 的 config 业务模块。\n\n\n# 1. 配置的表结构\n\ninfra_config 的表结构如下：\n\ncreate table `infra_config` (\n  `id` int not null auto_increment comment '参数主键',\n  `group` varchar(50) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '参数分组',\n  `type` tinyint not null comment '参数类型',\n  `name` varchar(100) character set utf8mb4 collate utf8mb4_unicode_ci not null default '' comment '参数名称',\n  `key` varchar(100) character set utf8mb4 collate utf8mb4_unicode_ci not null default '' comment '参数键名',\n  `value` varchar(500) character set utf8mb4 collate utf8mb4_unicode_ci not null default '' comment '参数键值',\n  `sensitive` bit(1) not null comment '是否敏感',\n  `remark` varchar(500) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '备注',\n  `creator` varchar(64) character set utf8mb4 collate utf8mb4_unicode_ci default '' comment '创建者',\n  `create_time` datetime not null default current_timestamp comment '创建时间',\n  `updater` varchar(64) character set utf8mb4 collate utf8mb4_unicode_ci default '' comment '更新者',\n  `update_time` datetime not null default current_timestamp on update current_timestamp comment '更新时间',\n  `deleted` bit(1) not null default b'0' comment '是否删除',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=8 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='参数配置表';\n\n\n * key 字段，对应到 spring boot 配置文件的配置项，例如说 yudao.captcha.enable、sys.user.init-password 等等。\n\n\n# 3. 后端案例\n\n调用 configapi 的 #getconfigvaluebykey(string key) 方法，可以读取指定 key 的参数值。\n\n具体案例，可见 adminuserserviceimpl 的 #importuserlist(...) 方法，在导入 excel 用户时，它会读取 system.user.init-password 作为用户初始化密码。\n\n\n# 4. 前端案例\n\n后端提供了 /admin-api/infra/config/get-value-by-key restful api 接口，返回指定配置项的值。前端的使用示例如下图：\n\n",
            charsets: {
                cjk: !0
            }
        }, {
            title: "工具类 Util",
            frontmatter: {
                title: "工具类 Util",
                date: "2022-04-04T16:54:42.000Z",
                permalink: "/util"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/02.%E5%90%8E%E7%AB%AF%E6%89%8B%E5%86%8C/42.%E5%B7%A5%E5%85%B7%E7%B1%BB%20Util.html",
            relativePath: "01.开发指南/02.后端手册/42.工具类 Util.md",
            key: "v-083d3c72",
            path: "/util/",
            headers: [{
                level: 2,
                title: "1. Hutool",
                slug: "_1-hutool",
                normalizedTitle: "1. hutool",
                charIndex: 32
            }, {
                level: 2,
                title: "2. Lombok",
                slug: "_2-lombok",
                normalizedTitle: "2. lombok",
                charIndex: 1374
            }, {
                level: 2,
                title: "3. HTTP 调用",
                slug: "_3-http-调用",
                normalizedTitle: "3. http 调用",
                charIndex: 1586
            }],
            headersStr: "1. Hutool 2. Lombok 3. HTTP 调用",
            content: "本小节，介绍项目中使用到的工具类，避免大家重复造轮子。\n\n\n# 1. Hutool\n\n项目使用 Hutool 作为主工具库。Hutool 是国产的一个 Java 工具包，它可以帮助我们简化每一行代码，减少每一个方法，让 Java 语言也可以“甜甜的”。\n\nyudao-common 模块的 util 包作为辅工具库，以 Utils 结尾，补充 Hutool 缺少的工具能力。\n\n友情提示：常用的工具类，使用 ⭐ 标记，需要的时候可以找找有没对应的工具方法。\n\n作用            HUTOOL           芋道 UTILS\n数组工具          ArrayUtil        ArrayUtils\n⭐ 集合工具        CollUtil         CollectionUtils\n⭐ Map 工具      MapUtil          MapUtils\nSet 工具                         SetUtils\nList 工具       ListUtil         \n文件工具          FileUtil         FileUtils\n              FileTypeUtil\n压缩工具          ZipUtil          IoUtils\nIO 工具         ZipUtil          \nResource 工具   ResourceUtil     \nJSON 工具                        JsonUtils\n数字工具          NumberUtil       NumberUtils\n对象工具          ObjectUtil       ObjectUtils\n唯一 ID 工具      IdUtil           \n⭐ 字符串工具       StrUtil          StrUtils\n时间工具          DateUtil         DateUtils\n反射工具          ReflectUtil      \n异常工具          ExceptionUtil    \n随机工具          RandomUtil       RandomUtils\nURL 工具        URLUtil          HttpUtils\nServlet 工具                     ServletUtils\nSpring 工具     SpringUtil       SpringAopUtils\n                               SpringExpressionUtils\n分页工具                           PageUtils\n校验工具          ValidationUtil   ValidationUtils\n断言工具          Assert           AssertUtils\n\n强烈推荐：\n\nGuava 是 Google 开源的 Java 常用类库，如果你感兴趣，可以阅读 《Guava 学习笔记》 文章。\n\n\n# 2. Lombok\n\nLombok 是一个 Java 工具，通过使用其定义的注解，自动生成常见的冗余代码，提升开发效率。\n\n如果你没有学习过 Lombok，需要阅读下 《芋道 Spring Boot 消除冗余代码 Lombok 入门》 文章。\n\n在项目的根目录有 lombok.config 全局配置文件，开启链式调用、生成的 toString/hashcode/equals 方法需要调用父方法。如下图所示：\n\n\n\n\n# 3. HTTP 调用\n\n① 使用 Feign 实现声明式的调用，可参考《芋道 Spring Boot 声明式调用 Feign 入门 》文章。\n\n② 使用 Hutool 自带的 HttpUtil 工具类。",
            normalizedContent: "本小节，介绍项目中使用到的工具类，避免大家重复造轮子。\n\n\n# 1. hutool\n\n项目使用 hutool 作为主工具库。hutool 是国产的一个 java 工具包，它可以帮助我们简化每一行代码，减少每一个方法，让 java 语言也可以“甜甜的”。\n\nyudao-common 模块的 util 包作为辅工具库，以 utils 结尾，补充 hutool 缺少的工具能力。\n\n友情提示：常用的工具类，使用 ⭐ 标记，需要的时候可以找找有没对应的工具方法。\n\n作用            hutool           芋道 utils\n数组工具          arrayutil        arrayutils\n⭐ 集合工具        collutil         collectionutils\n⭐ map 工具      maputil          maputils\nset 工具                         setutils\nlist 工具       listutil         \n文件工具          fileutil         fileutils\n              filetypeutil\n压缩工具          ziputil          ioutils\nio 工具         ziputil          \nresource 工具   resourceutil     \njson 工具                        jsonutils\n数字工具          numberutil       numberutils\n对象工具          objectutil       objectutils\n唯一 id 工具      idutil           \n⭐ 字符串工具       strutil          strutils\n时间工具          dateutil         dateutils\n反射工具          reflectutil      \n异常工具          exceptionutil    \n随机工具          randomutil       randomutils\nurl 工具        urlutil          httputils\nservlet 工具                     servletutils\nspring 工具     springutil       springaoputils\n                               springexpressionutils\n分页工具                           pageutils\n校验工具          validationutil   validationutils\n断言工具          assert           assertutils\n\n强烈推荐：\n\nguava 是 google 开源的 java 常用类库，如果你感兴趣，可以阅读 《guava 学习笔记》 文章。\n\n\n# 2. lombok\n\nlombok 是一个 java 工具，通过使用其定义的注解，自动生成常见的冗余代码，提升开发效率。\n\n如果你没有学习过 lombok，需要阅读下 《芋道 spring boot 消除冗余代码 lombok 入门》 文章。\n\n在项目的根目录有 lombok.config 全局配置文件，开启链式调用、生成的 tostring/hashcode/equals 方法需要调用父方法。如下图所示：\n\n\n\n\n# 3. http 调用\n\n① 使用 feign 实现声明式的调用，可参考《芋道 spring boot 声明式调用 feign 入门 》文章。\n\n② 使用 hutool 自带的 httputil 工具类。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "定时任务",
            frontmatter: {
                title: "定时任务",
                date: "2022-04-03T20:38:58.000Z",
                permalink: "/job"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/03.%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%89%8B%E5%86%8C/06.%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1.html",
            relativePath: "01.开发指南/03.中间件手册/06.定时任务.md",
            key: "v-68f656d5",
            path: "/job/",
            headers: [{
                level: 2,
                title: "1. 如何开启？",
                slug: "_1-如何开启",
                normalizedTitle: "1. 如何开启？",
                charIndex: 419
            }, {
                level: 2,
                title: "2. 实战案例",
                slug: "_2-实战案例",
                normalizedTitle: "2. 实战案例",
                charIndex: 861
            }, {
                level: 3,
                title: "2.1 引入依赖",
                slug: "_2-1-引入依赖",
                normalizedTitle: "2.1 引入依赖",
                charIndex: 911
            }, {
                level: 3,
                title: "2.2 编写 Job 类",
                slug: "_2-2-编写-job-类",
                normalizedTitle: "2.2 编写 job 类",
                charIndex: 1126
            }, {
                level: 3,
                title: "2.3 配置任务",
                slug: "_2-3-配置任务",
                normalizedTitle: "2.3 配置任务",
                charIndex: 1418
            }, {
                level: 3,
                title: "2.4 测试任务",
                slug: "_2-4-测试任务",
                normalizedTitle: "2.4 测试任务",
                charIndex: 2506
            }],
            headersStr: "1. 如何开启？ 2. 实战案例 2.1 引入依赖 2.2 编写 Job 类 2.3 配置任务 2.4 测试任务",
            content: "定时任务的使用场景主要如下：\n\n * 时间驱动处理场景：每分钟扫描超时支付的订单，活动状态刷新，整点发送优惠券。\n * 批量处理数据：按月批量统计报表数据，批量更新短信状态，实时性要求不高。\n\n年度最佳定时任务：每个月初的工资单的推送！！！\n\n如果你对定时任务了解不多，可以后续阅读 《芋道 Spring Boot 定时任务入门》 文章。\n\n项目基于 Quartz + MySQL 实现分布式定时任务，并提供 [基础设施 -> 定时任务] 菜单，进行定时任务的统一管理，支持动态控制任务的添加、修改、开启、暂停、删除、执行一次等操作。\n\n\n\n * yudao-spring-boot-starter-job 技术组件：基于 Quartz 框架的封装，提供简便的 JobHandler 接入，任务的执行、重试，执行日志的记录。\n * yudao-module-infra 的 job 业务模块，提供任务的动态管理，执行日志的存储。\n\n\n# 1. 如何开启？\n\n① 导入 sql 目录下，对应数据库的 quartz.sql 文件，初始化 Quartz 表结构。如下图所示：\n\n\n\n② 在 application-local.yaml 配置文件中，通过 spring.quartz 配置项，设置 Quartz 使用 MySQL 实现集群。如下图所示：\n\n\n\n考虑到 local 本地和 dev 测试环境使用相同的数据库，如果 local 也跑定时任务，可能会影响 dev 测试环境的执行。所以默认配置下，local 禁用了定时任务。\n\n重要！！！如果你要开启 local 的定时任务，可以删除 - org.springframework.boot.autoconfigure.quartz.QuartzAutoConfiguration 那一行即可开启。\n\n③ 启动项目后，调用 JobController 提供的 #syncJob() 接口，将 infra_job 表的任务同步到 Quartz 中。如下图所示：\n\n\n\n\n# 2. 实战案例\n\n以用户 Session 超时的定时任务举例子，讲解在项目中使用定时任务。\n\n\n# 2.1 引入依赖\n\n在 yudao-module-system-biz 模块中，引入 yudao-spring-boot-starter-job 技术组件。如下所示：\n\n<dependency>\n    <groupId>cn.iocoder.boot</groupId>\n    <artifactId>yudao-spring-boot-starter-job</artifactId>\n</dependency>\n\n\n\n# 2.2 编写 Job 类\n\n每个 yudao-module-xxx-biz 模块的 job 包，用于定义定时任务的 Job 类。\n\n因此，在 yudao-module-system-biz 模块的 job 包下，创建 UserSessionTimeoutJob 类，实现 JobHandler 接口，执行用户 Session 超时 Job。如下图所示：\n\n\n\n疑问：为什么添加 @TenantJob 注解？\n\n声明 @TenantJob 注解在 Job 类上，实现并行遍历每个租户，执行定时任务的逻辑。\n\n更多多租户的内容，可见 《开发指南 —— SaaS 多租户》 文档。\n\n\n# 2.3 配置任务\n\n① 点击 [新增] 按钮，填写定时任务 UserSessionTimeoutJob 的信息。如下图所示：\n\n\n\n * 处理器的名字：对应的 Spring Bean 名字。例如说 UserSessionTimeoutJob 对应 userSessionTimeoutJob\n\n * Cron 表达式：执行周期，可通过 [生成表达式] 功能，进行生成\n\n * 重试次数、重试间隔：执行失败后，立即重试的次数以及重试的间隔时间\n\n * 超时时间监控：执行超过该时间后，发送告警邮件给开发【暂不支持，未来实现】\n\n常用的 Cron 表达式如下：\n\n0 0 10,14,16 * * ? 每天上午 10 点，下午 2 点、4 点 \n0 0/30 9-17 * * ? 朝九晚五工作时间内，每半小时 \n0 0 12 ? * WED 表示每个星期三中午 12 点 \n0 0 12 * * ? 每天中午 12 点触发 \n0 15 10 ? * * 每天上午 10:15 触发 \n0 15 10 * * ? 每天上午 10:15 触发 \n0 15 10 * * ? * 每天上午 10:15 触发 \n0 15 10 * * ? 2005 2005 年的每天上午 10:15 触发 \n0 * 14 * * ? 在每天下午 2 点到下午 2:59 期间，每 1 分钟触发 \n0 0/5 14 * * ? 在每天下午 2 点到下午 2:55 期间，每 5 分钟触发 \n0 0/5 14,18 * * ? 在每天下午 2 点到 2:55 期间和下午 6 点到 6:55 期间，每 5 分钟触发 \n0 0-5 14 * * ? 在每天下午 2 点到下午 2:05 期间，每 1 分钟触发 \n0 10,44 14 ? 3 WED 每年三月的星期三的下午 2:10 和 2:44 触发 \n0 15 10 ? * MON-FRI 周一至周五的上午 10:15 触发 \n0 15 10 15 * ? 每月15日上午 10:15 触发 \n0 15 10 L * ? 每月最后一日的上午 10:15 触发 \n0 15 10 ? * 6L 每月的最后一个星期五上午 10:15 触发 \n0 15 10 ? * 6L 2002-2005 2002 年至 2005 年，每月的最后一个星期五上午 10:15 触发 \n0 15 10 ? * 6#3 每月的第三个星期五上午 10:15 触发\n\n\n② 点击 [更多 -> 任务详情] 按钮，可以查看任务的基础信息、后续的执行时间。如下图所示：\n\n\n\n\n# 2.4 测试任务\n\n① 点击 [更多 -> 执行一次] 按钮，立即执行一次 UserSessionTimeoutJob 定时任务。可以在 IDEA 控制台看到输出，如下图所示：\n\n\n\n② 点击 [更多 -> 调度日志] 按钮，可以查看到 UserSessionTimeoutJob 的执行日志。如下图所示：\n\n",
            normalizedContent: "定时任务的使用场景主要如下：\n\n * 时间驱动处理场景：每分钟扫描超时支付的订单，活动状态刷新，整点发送优惠券。\n * 批量处理数据：按月批量统计报表数据，批量更新短信状态，实时性要求不高。\n\n年度最佳定时任务：每个月初的工资单的推送！！！\n\n如果你对定时任务了解不多，可以后续阅读 《芋道 spring boot 定时任务入门》 文章。\n\n项目基于 quartz + mysql 实现分布式定时任务，并提供 [基础设施 -> 定时任务] 菜单，进行定时任务的统一管理，支持动态控制任务的添加、修改、开启、暂停、删除、执行一次等操作。\n\n\n\n * yudao-spring-boot-starter-job 技术组件：基于 quartz 框架的封装，提供简便的 jobhandler 接入，任务的执行、重试，执行日志的记录。\n * yudao-module-infra 的 job 业务模块，提供任务的动态管理，执行日志的存储。\n\n\n# 1. 如何开启？\n\n① 导入 sql 目录下，对应数据库的 quartz.sql 文件，初始化 quartz 表结构。如下图所示：\n\n\n\n② 在 application-local.yaml 配置文件中，通过 spring.quartz 配置项，设置 quartz 使用 mysql 实现集群。如下图所示：\n\n\n\n考虑到 local 本地和 dev 测试环境使用相同的数据库，如果 local 也跑定时任务，可能会影响 dev 测试环境的执行。所以默认配置下，local 禁用了定时任务。\n\n重要！！！如果你要开启 local 的定时任务，可以删除 - org.springframework.boot.autoconfigure.quartz.quartzautoconfiguration 那一行即可开启。\n\n③ 启动项目后，调用 jobcontroller 提供的 #syncjob() 接口，将 infra_job 表的任务同步到 quartz 中。如下图所示：\n\n\n\n\n# 2. 实战案例\n\n以用户 session 超时的定时任务举例子，讲解在项目中使用定时任务。\n\n\n# 2.1 引入依赖\n\n在 yudao-module-system-biz 模块中，引入 yudao-spring-boot-starter-job 技术组件。如下所示：\n\n<dependency>\n    <groupid>cn.iocoder.boot</groupid>\n    <artifactid>yudao-spring-boot-starter-job</artifactid>\n</dependency>\n\n\n\n# 2.2 编写 job 类\n\n每个 yudao-module-xxx-biz 模块的 job 包，用于定义定时任务的 job 类。\n\n因此，在 yudao-module-system-biz 模块的 job 包下，创建 usersessiontimeoutjob 类，实现 jobhandler 接口，执行用户 session 超时 job。如下图所示：\n\n\n\n疑问：为什么添加 @tenantjob 注解？\n\n声明 @tenantjob 注解在 job 类上，实现并行遍历每个租户，执行定时任务的逻辑。\n\n更多多租户的内容，可见 《开发指南 —— saas 多租户》 文档。\n\n\n# 2.3 配置任务\n\n① 点击 [新增] 按钮，填写定时任务 usersessiontimeoutjob 的信息。如下图所示：\n\n\n\n * 处理器的名字：对应的 spring bean 名字。例如说 usersessiontimeoutjob 对应 usersessiontimeoutjob\n\n * cron 表达式：执行周期，可通过 [生成表达式] 功能，进行生成\n\n * 重试次数、重试间隔：执行失败后，立即重试的次数以及重试的间隔时间\n\n * 超时时间监控：执行超过该时间后，发送告警邮件给开发【暂不支持，未来实现】\n\n常用的 cron 表达式如下：\n\n0 0 10,14,16 * * ? 每天上午 10 点，下午 2 点、4 点 \n0 0/30 9-17 * * ? 朝九晚五工作时间内，每半小时 \n0 0 12 ? * wed 表示每个星期三中午 12 点 \n0 0 12 * * ? 每天中午 12 点触发 \n0 15 10 ? * * 每天上午 10:15 触发 \n0 15 10 * * ? 每天上午 10:15 触发 \n0 15 10 * * ? * 每天上午 10:15 触发 \n0 15 10 * * ? 2005 2005 年的每天上午 10:15 触发 \n0 * 14 * * ? 在每天下午 2 点到下午 2:59 期间，每 1 分钟触发 \n0 0/5 14 * * ? 在每天下午 2 点到下午 2:55 期间，每 5 分钟触发 \n0 0/5 14,18 * * ? 在每天下午 2 点到 2:55 期间和下午 6 点到 6:55 期间，每 5 分钟触发 \n0 0-5 14 * * ? 在每天下午 2 点到下午 2:05 期间，每 1 分钟触发 \n0 10,44 14 ? 3 wed 每年三月的星期三的下午 2:10 和 2:44 触发 \n0 15 10 ? * mon-fri 周一至周五的上午 10:15 触发 \n0 15 10 15 * ? 每月15日上午 10:15 触发 \n0 15 10 l * ? 每月最后一日的上午 10:15 触发 \n0 15 10 ? * 6l 每月的最后一个星期五上午 10:15 触发 \n0 15 10 ? * 6l 2002-2005 2002 年至 2005 年，每月的最后一个星期五上午 10:15 触发 \n0 15 10 ? * 6#3 每月的第三个星期五上午 10:15 触发\n\n\n② 点击 [更多 -> 任务详情] 按钮，可以查看任务的基础信息、后续的执行时间。如下图所示：\n\n\n\n\n# 2.4 测试任务\n\n① 点击 [更多 -> 执行一次] 按钮，立即执行一次 usersessiontimeoutjob 定时任务。可以在 idea 控制台看到输出，如下图所示：\n\n\n\n② 点击 [更多 -> 调度日志] 按钮，可以查看到 usersessiontimeoutjob 的执行日志。如下图所示：\n\n",
            charsets: {
                cjk: !0
            }
        }, {
            title: "数据库文档",
            frontmatter: {
                title: "数据库文档",
                date: "2022-04-10T00:55:24.000Z",
                permalink: "/db-doc"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/02.%E5%90%8E%E7%AB%AF%E6%89%8B%E5%86%8C/44.%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E6%A1%A3.html",
            relativePath: "01.开发指南/02.后端手册/44.数据库文档.md",
            key: "v-10102f0d",
            path: "/db-doc/",
            headersStr: null,
            content: "友情提示：\n\n最新版本的代码，已经移除“数据库文档”功能。原因是，该功能比较小众，可能只有极少数的用户需要~\n\n如果你系统里需要，可以参考 ff0c12c（后端）、ff52769（前端） 把代码复制、粘贴回来。\n\nyudao-module-infra 的 DatabaseDocController 类，基于 Screw 工具，生成数据库表结构的文档。\n\n访问 [基础设施 -> 数据库文档] 菜单，可以查看项目的数据库文档。如下图所示：\n\n\n\n关于 Screw 的使用讲解，可见 《芋道 Spring Boot 数据表结构文档 》 文章。",
            normalizedContent: "友情提示：\n\n最新版本的代码，已经移除“数据库文档”功能。原因是，该功能比较小众，可能只有极少数的用户需要~\n\n如果你系统里需要，可以参考 ff0c12c（后端）、ff52769（前端） 把代码复制、粘贴回来。\n\nyudao-module-infra 的 databasedoccontroller 类，基于 screw 工具，生成数据库表结构的文档。\n\n访问 [基础设施 -> 数据库文档] 菜单，可以查看项目的数据库文档。如下图所示：\n\n\n\n关于 screw 的使用讲解，可见 《芋道 spring boot 数据表结构文档 》 文章。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "消息队列（内存）",
            frontmatter: {
                title: "消息队列（内存）",
                date: "2023-11-01T19:48:34.000Z",
                permalink: "/message-queue/event"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/03.%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%89%8B%E5%86%8C/11.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88%E5%86%85%E5%AD%98%EF%BC%89.html",
            relativePath: "01.开发指南/03.中间件手册/11.消息队列（内存）.md",
            key: "v-c5941d2e",
            path: "/message-queue/event/",
            headers: [{
                level: 2,
                title: "1. Spring Event",
                slug: "_1-spring-event",
                normalizedTitle: "1. spring event",
                charIndex: 2
            }, {
                level: 2,
                title: "2. 使用示例",
                slug: "_2-使用示例",
                normalizedTitle: "2. 使用示例",
                charIndex: 390
            }, {
                level: 3,
                title: "2.1 Message 消息",
                slug: "_2-1-message-消息",
                normalizedTitle: "2.1 message 消息",
                charIndex: 446
            }, {
                level: 3,
                title: "2.2 SmsProducer 生产者",
                slug: "_2-2-smsproducer-生产者",
                normalizedTitle: "2.2 smsproducer 生产者",
                charIndex: 1030
            }, {
                level: 3,
                title: "2.3 SmsSendConsumer 消费者",
                slug: "_2-3-smssendconsumer-消费者",
                normalizedTitle: "2.3 smssendconsumer 消费者",
                charIndex: 1871
            }, {
                level: 3,
                title: "2.4 简单测试",
                slug: "_2-4-简单测试",
                normalizedTitle: "2.4 简单测试",
                charIndex: 2307
            }],
            headersStr: "1. Spring Event 2. 使用示例 2.1 Message 消息 2.2 SmsProducer 生产者 2.3 SmsSendConsumer 消费者 2.4 简单测试",
            content: '# 1. Spring Event\n\nyudao-spring-boot-starter-mq 技术组件，提供了 Redis、RocketMQ、RabbitMQ、Kafka 分布式消息队列的封装。\n\n考虑到部分同学的项目对消息队列的要求不高，又不想引入额外部署的消息队列，所以默认使用 Spring Event 实现【内存】级别的消息队列。\n\n疑问：为什么默认不使用 Redis 作为消息队列？\n\n这确实是一种选择，但是想要使用 Redis 实现可靠的消息队列，必须使用 Redis 5.0 版本的 Stream 特性。\n\n这样一方面对 Redis 要求的版本比较高，另一方面大多数同学对 Redis Stream 基本不了解，生产经验不足。\n\n如果你对 Spring Event 不太了解，可以看看 《芋道 Spring Boot 事件机制 Event 入门》 文档。\n\n\n# 2. 使用示例\n\n以【短信发送】举例子，我们来看看 Spring Event 的使用。如下图所示：\n\n\n\n\n# 2.1 Message 消息\n\n在 message 包下，新建 SmsSendMessage 类，短信发送消息。代码如下：\n\n@Data\npublic class SmsSendMessage {\n\n    /**\n     * 短信日志编号\n     */\n    @NotNull(message = "短信日志编号不能为空")\n    private Long logId;\n    /**\n     * 手机号\n     */\n    @NotNull(message = "手机号不能为空")\n    private String mobile;\n    /**\n     * 短信渠道编号\n     */\n    @NotNull(message = "短信渠道编号不能为空")\n    private Long channelId;\n    /**\n     * 短信 API 的模板编号\n     */\n    @NotNull(message = "短信 API 的模板编号不能为空")\n    private String apiTemplateId;\n    /**\n     * 短信模板参数\n     */\n    private List<KeyValue<String, Object>> templateParams;\n\n}\n\n\n\n# 2.2 SmsProducer 生产者\n\n在 producer 包下，新建 SmsProducer 类，Sms 短信相关消息的生产者。代码如下：\n\n@Slf4j\n@Component\npublic class SmsProducer {\n\n    @Resource\n    private ApplicationContext applicationContext;\n\n    /**\n     * 发送 {@link SmsSendMessage} 消息\n     *\n     * @param logId 短信日志编号\n     * @param mobile 手机号\n     * @param channelId 渠道编号\n     * @param apiTemplateId 短信模板编号\n     * @param templateParams 短信模板参数\n     */\n    public void sendSmsSendMessage(Long logId, String mobile,\n                                   Long channelId, String apiTemplateId, List<KeyValue<String, Object>> templateParams) {\n        SmsSendMessage message = new SmsSendMessage().setLogId(logId).setMobile(mobile);\n        message.setChannelId(channelId).setApiTemplateId(apiTemplateId).setTemplateParams(templateParams);\n        applicationContext.publishEvent(message);\n    }\n\n}\n\n\n\n# 2.3 SmsSendConsumer 消费者\n\n在 consumer 包下，新建 SmsSendConsumer 类，SmsSendMessage 的消费者。代码如下：\n\n@Component\n@Slf4j\npublic class SmsSendConsumer {\n\n    @Resource\n    private SmsSendService smsSendService;\n\n    @EventListener\n    @Async // Spring Event 默认在 Producer 发送的线程，通过 @Async 实现异步\n    public void onMessage(SmsSendMessage message) {\n        log.info("[onMessage][消息内容({})]", message);\n        smsSendService.doSendSms(message);\n    }\n\n}\n\n\n\n# 2.4 简单测试\n\n① Debug 启动后端项目，可以在 SmsProducer 和 SmsSendConsumer 上面打上断点，稍微调试下。\n\n② 打开 SmsTemplateController.http 文件，使用 IDEA httpclient 发起请求，发送短信。如下图所示：\n\n\n\n如果 IDEA 控制台看到 [onMessage][消息内容 日志内容，说明消息的发送和消费成功。',
            normalizedContent: '# 1. spring event\n\nyudao-spring-boot-starter-mq 技术组件，提供了 redis、rocketmq、rabbitmq、kafka 分布式消息队列的封装。\n\n考虑到部分同学的项目对消息队列的要求不高，又不想引入额外部署的消息队列，所以默认使用 spring event 实现【内存】级别的消息队列。\n\n疑问：为什么默认不使用 redis 作为消息队列？\n\n这确实是一种选择，但是想要使用 redis 实现可靠的消息队列，必须使用 redis 5.0 版本的 stream 特性。\n\n这样一方面对 redis 要求的版本比较高，另一方面大多数同学对 redis stream 基本不了解，生产经验不足。\n\n如果你对 spring event 不太了解，可以看看 《芋道 spring boot 事件机制 event 入门》 文档。\n\n\n# 2. 使用示例\n\n以【短信发送】举例子，我们来看看 spring event 的使用。如下图所示：\n\n\n\n\n# 2.1 message 消息\n\n在 message 包下，新建 smssendmessage 类，短信发送消息。代码如下：\n\n@data\npublic class smssendmessage {\n\n    /**\n     * 短信日志编号\n     */\n    @notnull(message = "短信日志编号不能为空")\n    private long logid;\n    /**\n     * 手机号\n     */\n    @notnull(message = "手机号不能为空")\n    private string mobile;\n    /**\n     * 短信渠道编号\n     */\n    @notnull(message = "短信渠道编号不能为空")\n    private long channelid;\n    /**\n     * 短信 api 的模板编号\n     */\n    @notnull(message = "短信 api 的模板编号不能为空")\n    private string apitemplateid;\n    /**\n     * 短信模板参数\n     */\n    private list<keyvalue<string, object>> templateparams;\n\n}\n\n\n\n# 2.2 smsproducer 生产者\n\n在 producer 包下，新建 smsproducer 类，sms 短信相关消息的生产者。代码如下：\n\n@slf4j\n@component\npublic class smsproducer {\n\n    @resource\n    private applicationcontext applicationcontext;\n\n    /**\n     * 发送 {@link smssendmessage} 消息\n     *\n     * @param logid 短信日志编号\n     * @param mobile 手机号\n     * @param channelid 渠道编号\n     * @param apitemplateid 短信模板编号\n     * @param templateparams 短信模板参数\n     */\n    public void sendsmssendmessage(long logid, string mobile,\n                                   long channelid, string apitemplateid, list<keyvalue<string, object>> templateparams) {\n        smssendmessage message = new smssendmessage().setlogid(logid).setmobile(mobile);\n        message.setchannelid(channelid).setapitemplateid(apitemplateid).settemplateparams(templateparams);\n        applicationcontext.publishevent(message);\n    }\n\n}\n\n\n\n# 2.3 smssendconsumer 消费者\n\n在 consumer 包下，新建 smssendconsumer 类，smssendmessage 的消费者。代码如下：\n\n@component\n@slf4j\npublic class smssendconsumer {\n\n    @resource\n    private smssendservice smssendservice;\n\n    @eventlistener\n    @async // spring event 默认在 producer 发送的线程，通过 @async 实现异步\n    public void onmessage(smssendmessage message) {\n        log.info("[onmessage][消息内容({})]", message);\n        smssendservice.dosendsms(message);\n    }\n\n}\n\n\n\n# 2.4 简单测试\n\n① debug 启动后端项目，可以在 smsproducer 和 smssendconsumer 上面打上断点，稍微调试下。\n\n② 打开 smstemplatecontroller.http 文件，使用 idea httpclient 发起请求，发送短信。如下图所示：\n\n\n\n如果 idea 控制台看到 [onmessage][消息内容 日志内容，说明消息的发送和消费成功。',
            charsets: {
                cjk: !0
            }
        }, {
            title: "消息队列（Redis）",
            frontmatter: {
                title: "消息队列（Redis）",
                date: "2022-04-03T19:48:34.000Z",
                permalink: "/message-queue/redis"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/03.%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%89%8B%E5%86%8C/12.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88Redis%EF%BC%89.html",
            relativePath: "01.开发指南/03.中间件手册/12.消息队列（Redis）.md",
            key: "v-1d2b9a12",
            path: "/message-queue/redis/",
            headers: [{
                level: 2,
                title: "1. 集群消费",
                slug: "_1-集群消费",
                normalizedTitle: "1. 集群消费",
                charIndex: 168
            }, {
                level: 3,
                title: "1.1 使用场景",
                slug: "_1-1-使用场景",
                normalizedTitle: "1.1 使用场景",
                charIndex: 312
            }, {
                level: 3,
                title: "1.2 实现源码",
                slug: "_1-2-实现源码",
                normalizedTitle: "1.2 实现源码",
                charIndex: 499
            }, {
                level: 3,
                title: "1.3 实战案例",
                slug: "_1-3-实战案例",
                normalizedTitle: "1.3 实战案例",
                charIndex: 787
            }, {
                level: 2,
                title: "2. 广播消费",
                slug: "_2-广播消费",
                normalizedTitle: "2. 广播消费",
                charIndex: 3328
            }, {
                level: 3,
                title: "2.1 使用场景",
                slug: "_2-1-使用场景",
                normalizedTitle: "2.1 使用场景",
                charIndex: 3397
            }, {
                level: 3,
                title: "2.2 实现源码",
                slug: "_2-2-实现源码",
                normalizedTitle: "2.2 实现源码",
                charIndex: 3621
            }, {
                level: 3,
                title: "2.3 实战案例",
                slug: "_2-3-实战案例",
                normalizedTitle: "2.3 实战案例",
                charIndex: 3908
            }],
            headersStr: "1. 集群消费 1.1 使用场景 1.2 实现源码 1.3 实战案例 2. 广播消费 2.1 使用场景 2.2 实现源码 2.3 实战案例",
            content: 'yudao-spring-boot-starter-mq 技术组件，基于 Redis 实现分布式消息队列：\n\n * 使用 Stream 特性，提供【集群】消费的能力。\n * 使用 Pub/Sub 特性，提供【广播】消费的能力。\n\n疑问：什么是【广播】消费？什么是【集群】消费？\n\n参见《阿里云 —— 集群消费和广播消费 》文档\n\n\n# 1. 集群消费\n\n集群消费，是指消息发送到 Redis 时，有且只会被一个消费者（应用 JVM 实例）收到，然后消费成功。如下图所示：\n\n\n\n友情提示：\n\n如果你需要使用到【集群】消费，必须使用 Redis 5.0.0 以上版本，因为 Stream 特性是在该版本之后才引入噢！\n\n\n# 1.1 使用场景\n\n集群消费在项目中的使用场景，主要是提供可靠的、可堆积的异步任务的能力。例如说：\n\n * 短信模块，使用它异步发送短信。\n * 邮件模块，使用它异步发送邮件。\n\n相比 《开发指南 —— 异步任务》 来说，Spring Async 在 JVM 实例重启时，会导致未执行完的任务丢失。而集群消费，因为消息是存储在 Redis 中，所以不会存在该问题。\n\n\n# 1.2 实现源码\n\n集群消费基于 Redis Stream 实现：\n\n * 实现 AbstractRedisStreamMessage 抽象类，定义【集群】消息。\n * 使用 RedisMQTemplate 的 #send(message) 方法，发送消息。\n * 实现 AbstractRedisStreamMessageListener 接口，消费消息。\n\n最终使用 YudaoRedisMQAutoConfiguration 配置类，扫描所有的 AbstractRedisStreamMessageListener 监听器，初始化对应的消费者。如下图所示：\n\n\n\n\n# 1.3 实战案例\n\n以【短信发送】举例子，改造使用 Redis 作为消息队列，同时也是讲解集群消费的使用。如下图所示：\n\n\n\n# 1.3.0 引入依赖\n\n在 yudao-module-system-biz 模块中，引入 yudao-spring-boot-starter-mq 技术组件。如下所示：\n\n<dependency>\n    <groupId>cn.iocoder.boot</groupId>\n    <artifactId>yudao-spring-boot-starter-mq</artifactId>\n</dependency>\n\n\n# 1.3.1 Message 消息\n\n在 message 包下，修改 SmsSendMessage 类，短信发送消息。代码如下：\n\n@Data\npublic class SmsSendMessage extends AbstractRedisStreamMessage { // 重点：需要继承 AbstractRedisStreamMessage 类\n\n    /**\n     * 短信日志编号\n     */\n    @NotNull(message = "短信日志编号不能为空")\n    private Long logId;\n    /**\n     * 手机号\n     */\n    @NotNull(message = "手机号不能为空")\n    private String mobile;\n    /**\n     * 短信渠道编号\n     */\n    @NotNull(message = "短信渠道编号不能为空")\n    private Long channelId;\n    /**\n     * 短信 API 的模板编号\n     */\n    @NotNull(message = "短信 API 的模板编号不能为空")\n    private String apiTemplateId;\n    /**\n     * 短信模板参数\n     */\n    private List<KeyValue<String, Object>> templateParams;\n\n}\n\n\n# 1.3.2 SmsProducer 生产者\n\n在 producer 包下，修改 SmsProducer 类，Sms 短信相关消息的生产者。代码如下：\n\n@Slf4j\n@Component\npublic class SmsProducer {\n\n    @Resource\n    private RedisMQTemplate redisMQTemplate; // 重点：注入 RedisMQTemplate 对象\n\n    /**\n     * 发送 {@link SmsSendMessage} 消息\n     *\n     * @param logId 短信日志编号\n     * @param mobile 手机号\n     * @param channelId 渠道编号\n     * @param apiTemplateId 短信模板编号\n     * @param templateParams 短信模板参数\n     */\n    public void sendSmsSendMessage(Long logId, String mobile,\n                                   Long channelId, String apiTemplateId, List<KeyValue<String, Object>> templateParams) {\n        SmsSendMessage message = new SmsSendMessage().setLogId(logId).setMobile(mobile);\n        message.setChannelId(channelId).setApiTemplateId(apiTemplateId).setTemplateParams(templateParams);\n        redisMQTemplate.send(message); // 重点：使用 RedisMQTemplate 发送消息\n    }\n\n}\n\n\n# 1.3.3 SmsSendConsumer 消费者\n\n在 consumer 包下，修改 SmsSendConsumer 类，SmsSendMessage 的消费者。代码如下：\n\n@Component\n@Slf4j\npublic class SmsSendConsumer extends AbstractRedisStreamMessageListener<SmsSendMessage> { // 重点：继承 AbstractRedisStreamMessageListener 类，并填写对应的 Message 类\n\n    @Resource\n    private SmsSendService smsSendService;\n\n    @Override // 重点：实现 onMessage 方法\n    public void onMessage(SmsSendMessage message) {\n        log.info("[onMessage][消息内容({})]", message);\n        smsSendService.doSendSms(message);\n    }\n\n}\n\n\n# 1.3.4 简单测试\n\n① Debug 启动后端项目，可以在 SmsProducer 和 SmsSendConsumer 上面打上断点，稍微调试下。\n\n② 打开 SmsTemplateController.http 文件，使用 IDEA httpclient 发起请求，发送短信。如下图所示：\n\n\n\n如果 IDEA 控制台看到 [onMessage][消息内容 日志内容，说明消息的发送和消费成功。\n\n\n# 2. 广播消费\n\n广播消费，是指消息发送到 Redis 时，所有消费者（应用 JVM 实例）收到，然后消费成功。如下图所示：\n\n\n\n\n# 2.1 使用场景\n\n例如说，在应用中，缓存了数据字典等配置表在内存中，可以通过 Redis 广播消费，实现每个应用节点都消费消息，刷新本地内存的缓存。\n\n又例如说，我们基于 WebSocket 实现了 IM 聊天，在我们给用户主动发送消息时，因为我们不知道用户连接的是哪个提供 WebSocket 的应用，所以可以通过 Redis 广播消费。每个应用判断当前用户是否是和自己提供的 WebSocket 服务连接，如果是，则推送消息给用户。\n\n\n# 2.2 实现源码\n\n广播消费基于 Redis Pub/Sub 实现：\n\n * 实现 AbstractChannelMessage 抽象类，定义【广播】消息。\n * 使用 RedisMQTemplate 的 #send(message) 方法，发送消息。\n * 实现 AbstractRedisChannelMessageListener 接口，消费消息。\n\n最终使用 YudaoRedisMQAutoConfiguration 配置类，扫描所有的 AbstractRedisChannelMessageListener 监听器，初始化对应的消费者。如下图所示：\n\n\n\n\n# 2.3 实战案例\n\n参见 《开发指南 —— 本地缓存》',
            normalizedContent: 'yudao-spring-boot-starter-mq 技术组件，基于 redis 实现分布式消息队列：\n\n * 使用 stream 特性，提供【集群】消费的能力。\n * 使用 pub/sub 特性，提供【广播】消费的能力。\n\n疑问：什么是【广播】消费？什么是【集群】消费？\n\n参见《阿里云 —— 集群消费和广播消费 》文档\n\n\n# 1. 集群消费\n\n集群消费，是指消息发送到 redis 时，有且只会被一个消费者（应用 jvm 实例）收到，然后消费成功。如下图所示：\n\n\n\n友情提示：\n\n如果你需要使用到【集群】消费，必须使用 redis 5.0.0 以上版本，因为 stream 特性是在该版本之后才引入噢！\n\n\n# 1.1 使用场景\n\n集群消费在项目中的使用场景，主要是提供可靠的、可堆积的异步任务的能力。例如说：\n\n * 短信模块，使用它异步发送短信。\n * 邮件模块，使用它异步发送邮件。\n\n相比 《开发指南 —— 异步任务》 来说，spring async 在 jvm 实例重启时，会导致未执行完的任务丢失。而集群消费，因为消息是存储在 redis 中，所以不会存在该问题。\n\n\n# 1.2 实现源码\n\n集群消费基于 redis stream 实现：\n\n * 实现 abstractredisstreammessage 抽象类，定义【集群】消息。\n * 使用 redismqtemplate 的 #send(message) 方法，发送消息。\n * 实现 abstractredisstreammessagelistener 接口，消费消息。\n\n最终使用 yudaoredismqautoconfiguration 配置类，扫描所有的 abstractredisstreammessagelistener 监听器，初始化对应的消费者。如下图所示：\n\n\n\n\n# 1.3 实战案例\n\n以【短信发送】举例子，改造使用 redis 作为消息队列，同时也是讲解集群消费的使用。如下图所示：\n\n\n\n# 1.3.0 引入依赖\n\n在 yudao-module-system-biz 模块中，引入 yudao-spring-boot-starter-mq 技术组件。如下所示：\n\n<dependency>\n    <groupid>cn.iocoder.boot</groupid>\n    <artifactid>yudao-spring-boot-starter-mq</artifactid>\n</dependency>\n\n\n# 1.3.1 message 消息\n\n在 message 包下，修改 smssendmessage 类，短信发送消息。代码如下：\n\n@data\npublic class smssendmessage extends abstractredisstreammessage { // 重点：需要继承 abstractredisstreammessage 类\n\n    /**\n     * 短信日志编号\n     */\n    @notnull(message = "短信日志编号不能为空")\n    private long logid;\n    /**\n     * 手机号\n     */\n    @notnull(message = "手机号不能为空")\n    private string mobile;\n    /**\n     * 短信渠道编号\n     */\n    @notnull(message = "短信渠道编号不能为空")\n    private long channelid;\n    /**\n     * 短信 api 的模板编号\n     */\n    @notnull(message = "短信 api 的模板编号不能为空")\n    private string apitemplateid;\n    /**\n     * 短信模板参数\n     */\n    private list<keyvalue<string, object>> templateparams;\n\n}\n\n\n# 1.3.2 smsproducer 生产者\n\n在 producer 包下，修改 smsproducer 类，sms 短信相关消息的生产者。代码如下：\n\n@slf4j\n@component\npublic class smsproducer {\n\n    @resource\n    private redismqtemplate redismqtemplate; // 重点：注入 redismqtemplate 对象\n\n    /**\n     * 发送 {@link smssendmessage} 消息\n     *\n     * @param logid 短信日志编号\n     * @param mobile 手机号\n     * @param channelid 渠道编号\n     * @param apitemplateid 短信模板编号\n     * @param templateparams 短信模板参数\n     */\n    public void sendsmssendmessage(long logid, string mobile,\n                                   long channelid, string apitemplateid, list<keyvalue<string, object>> templateparams) {\n        smssendmessage message = new smssendmessage().setlogid(logid).setmobile(mobile);\n        message.setchannelid(channelid).setapitemplateid(apitemplateid).settemplateparams(templateparams);\n        redismqtemplate.send(message); // 重点：使用 redismqtemplate 发送消息\n    }\n\n}\n\n\n# 1.3.3 smssendconsumer 消费者\n\n在 consumer 包下，修改 smssendconsumer 类，smssendmessage 的消费者。代码如下：\n\n@component\n@slf4j\npublic class smssendconsumer extends abstractredisstreammessagelistener<smssendmessage> { // 重点：继承 abstractredisstreammessagelistener 类，并填写对应的 message 类\n\n    @resource\n    private smssendservice smssendservice;\n\n    @override // 重点：实现 onmessage 方法\n    public void onmessage(smssendmessage message) {\n        log.info("[onmessage][消息内容({})]", message);\n        smssendservice.dosendsms(message);\n    }\n\n}\n\n\n# 1.3.4 简单测试\n\n① debug 启动后端项目，可以在 smsproducer 和 smssendconsumer 上面打上断点，稍微调试下。\n\n② 打开 smstemplatecontroller.http 文件，使用 idea httpclient 发起请求，发送短信。如下图所示：\n\n\n\n如果 idea 控制台看到 [onmessage][消息内容 日志内容，说明消息的发送和消费成功。\n\n\n# 2. 广播消费\n\n广播消费，是指消息发送到 redis 时，所有消费者（应用 jvm 实例）收到，然后消费成功。如下图所示：\n\n\n\n\n# 2.1 使用场景\n\n例如说，在应用中，缓存了数据字典等配置表在内存中，可以通过 redis 广播消费，实现每个应用节点都消费消息，刷新本地内存的缓存。\n\n又例如说，我们基于 websocket 实现了 im 聊天，在我们给用户主动发送消息时，因为我们不知道用户连接的是哪个提供 websocket 的应用，所以可以通过 redis 广播消费。每个应用判断当前用户是否是和自己提供的 websocket 服务连接，如果是，则推送消息给用户。\n\n\n# 2.2 实现源码\n\n广播消费基于 redis pub/sub 实现：\n\n * 实现 abstractchannelmessage 抽象类，定义【广播】消息。\n * 使用 redismqtemplate 的 #send(message) 方法，发送消息。\n * 实现 abstractredischannelmessagelistener 接口，消费消息。\n\n最终使用 yudaoredismqautoconfiguration 配置类，扫描所有的 abstractredischannelmessagelistener 监听器，初始化对应的消费者。如下图所示：\n\n\n\n\n# 2.3 实战案例\n\n参见 《开发指南 —— 本地缓存》',
            charsets: {
                cjk: !0
            }
        }, {
            title: "消息队列（RocketMQ）",
            frontmatter: {
                title: "消息队列（RocketMQ）",
                date: "2023-11-02T00:00:34.000Z",
                permalink: "/message-queue/rocketmq"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/03.%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%89%8B%E5%86%8C/13.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88RocketMQ%EF%BC%89.html",
            relativePath: "01.开发指南/03.中间件手册/13.消息队列（RocketMQ）.md",
            key: "v-7e706b0d",
            path: "/message-queue/rocketmq/",
            headers: [{
                level: 2,
                title: "RocketMQ-Spring",
                slug: "rocketmq-spring",
                normalizedTitle: "rocketmq-spring",
                charIndex: 2
            }, {
                level: 2,
                title: "2. 使用示例",
                slug: "_2-使用示例",
                normalizedTitle: "2. 使用示例",
                charIndex: 192
            }, {
                level: 2,
                title: "2.0 引入依赖与配置",
                slug: "_2-0-引入依赖与配置",
                normalizedTitle: "2.0 引入依赖与配置",
                charIndex: 238
            }, {
                level: 3,
                title: "2.1 Message 消息",
                slug: "_2-1-message-消息",
                normalizedTitle: "2.1 message 消息",
                charIndex: 1140
            }, {
                level: 3,
                title: "2.2 SmsProducer 生产者",
                slug: "_2-2-smsproducer-生产者",
                normalizedTitle: "2.2 smsproducer 生产者",
                charIndex: 1804
            }, {
                level: 3,
                title: "2.3 SmsSendConsumer 消费者",
                slug: "_2-3-smssendconsumer-消费者",
                normalizedTitle: "2.3 smssendconsumer 消费者",
                charIndex: 2719
            }, {
                level: 3,
                title: "2.4 简单测试",
                slug: "_2-4-简单测试",
                normalizedTitle: "2.4 简单测试",
                charIndex: 3374
            }],
            headersStr: "RocketMQ-Spring 2. 使用示例 2.0 引入依赖与配置 2.1 Message 消息 2.2 SmsProducer 生产者 2.3 SmsSendConsumer 消费者 2.4 简单测试",
            content: '# RocketMQ-Spring\n\nyudao-spring-boot-starter-mq 技术组件，基于 RocketMQ 实现分布式消息队列。\n\n如果你对 RocketMQ 不太了解，可以看看 《芋道 Spring Boot 消息队列 RocketMQ 入门》 文档。\n\n如何安装一个 RocketMQ 服务？\n\n参考 《芋道 RocketMQ 极简入门 》 文档。\n\n\n# 2. 使用示例\n\n以【短信发送】举例子，改造使用 RocketMQ 作为消息队列。\n\n\n# 2.0 引入依赖与配置\n\n① 在 yudao-module-system-biz 模块中，引入 yudao-spring-boot-starter-mq 技术组件。如下所示：\n\n<dependency>\n    <groupId>cn.iocoder.boot</groupId>\n    <artifactId>yudao-spring-boot-starter-mq</artifactId>\n</dependency>\n\n\n② 修改 yudao-spring-boot-starter-mq 的 pom.xml 文件，引入 rocketmq-spring-boot-starter 依赖。如下所示：\n\n\x3c!-- 实际只要删除  <optional>true</optional> 部分即可 --\x3e\n<dependency>\n    <groupId>org.apache.rocketmq</groupId>\n    <artifactId>rocketmq-spring-boot-starter</artifactId>\n</dependency>\n\n\n记得需要手动在 IDEA 刷新下 Maven 依赖。\n\n③ 修改 application.xml 配置文件，添加 RocketMQ 全局配置。如下所示：\n\n# rocketmq 配置项，对应 RocketMQProperties 配置类\nrocketmq:\n  # Producer 配置项\n  producer:\n    group: ${spring.application.name}_PRODUCER # 生产者分组\n\n\nps：默认已经添加，无需操作。\n\n④ 修改 application-local.xml 配置文件，添加 RocketMQ name-server 配置。如下所示：\n\n# rocketmq 配置项，对应 RocketMQProperties 配置类\nrocketmq:\n  name-server: 127.0.0.1:9876 # RocketMQ Namesrv\n\n\nps：默认已经添加，无需操作。\n\n\n# 2.1 Message 消息\n\n在 message 包下，修改 SmsSendMessage 类，短信发送消息。代码如下：\n\n@Data\npublic class SmsSendMessage {\n\n    public static final String TOPIC = "SMS_SEND_TOPIC"; // 重点：需要增加消息对应的 Topic\n\n    /**\n     * 短信日志编号\n     */\n    @NotNull(message = "短信日志编号不能为空")\n    private Long logId;\n    /**\n     * 手机号\n     */\n    @NotNull(message = "手机号不能为空")\n    private String mobile;\n    /**\n     * 短信渠道编号\n     */\n    @NotNull(message = "短信渠道编号不能为空")\n    private Long channelId;\n    /**\n     * 短信 API 的模板编号\n     */\n    @NotNull(message = "短信 API 的模板编号不能为空")\n    private String apiTemplateId;\n    /**\n     * 短信模板参数\n     */\n    private List<KeyValue<String, Object>> templateParams;\n\n}\n\n\n\n# 2.2 SmsProducer 生产者\n\n在 producer 包下，修改 SmsProducer 类，Sms 短信相关消息的生产者。代码如下：\n\n@Slf4j\n@Component\npublic class SmsProducer {\n\n    @Resource\n    private RocketMQTemplate rocketMQTemplate; // 重点：注入 RocketMQTemplate 对象\n\n    /**\n     * 发送 {@link SmsSendMessage} 消息\n     *\n     * @param logId 短信日志编号\n     * @param mobile 手机号\n     * @param channelId 渠道编号\n     * @param apiTemplateId 短信模板编号\n     * @param templateParams 短信模板参数\n     */\n    public void sendSmsSendMessage(Long logId, String mobile,\n                                   Long channelId, String apiTemplateId, List<KeyValue<String, Object>> templateParams) {\n        SmsSendMessage message = new SmsSendMessage().setLogId(logId).setMobile(mobile);\n        message.setChannelId(channelId).setApiTemplateId(apiTemplateId).setTemplateParams(templateParams);\n        rocketMQTemplate.syncSend(SmsSendMessage.TOPIC, message); // 重点：使用 RocketMQTemplate 同步发送消息\n    }\n\n}\n\n\n\n# 2.3 SmsSendConsumer 消费者\n\n在 consumer 包下，修改 SmsSendConsumer 类，SmsSendMessage 的消费者。代码如下：\n\n@Component\n@RocketMQMessageListener( // 重点：添加 @RocketMQMessageListener 注解，声明消费的 topic\n        topic = SmsSendMessage.TOPIC,\n        consumerGroup = SmsSendMessage.TOPIC + "_CONSUMER"\n)\n@Slf4j\npublic class SmsSendConsumer implements RocketMQListener<SmsSendMessage> { // 重点：实现 RocketMQListener 类，并填写对应的 Message 类\n\n    @Resource\n    private SmsSendService smsSendService;\n\n    @Override // 重点：实现 onMessage 方法\n    public void onMessage(SmsSendMessage message) {\n        log.info("[onMessage][消息内容({})]", message);\n        smsSendService.doSendSms(message);\n    }\n\n}\n\n\n\n# 2.4 简单测试\n\n① Debug 启动后端项目，可以在 SmsProducer 和 SmsSendConsumer 上面打上断点，稍微调试下。\n\n② 打开 SmsTemplateController.http 文件，使用 IDEA httpclient 发起请求，发送短信。如下图所示：\n\n\n\n如果 IDEA 控制台看到 [onMessage][消息内容 日志内容，说明消息的发送和消费成功。',
            normalizedContent: '# rocketmq-spring\n\nyudao-spring-boot-starter-mq 技术组件，基于 rocketmq 实现分布式消息队列。\n\n如果你对 rocketmq 不太了解，可以看看 《芋道 spring boot 消息队列 rocketmq 入门》 文档。\n\n如何安装一个 rocketmq 服务？\n\n参考 《芋道 rocketmq 极简入门 》 文档。\n\n\n# 2. 使用示例\n\n以【短信发送】举例子，改造使用 rocketmq 作为消息队列。\n\n\n# 2.0 引入依赖与配置\n\n① 在 yudao-module-system-biz 模块中，引入 yudao-spring-boot-starter-mq 技术组件。如下所示：\n\n<dependency>\n    <groupid>cn.iocoder.boot</groupid>\n    <artifactid>yudao-spring-boot-starter-mq</artifactid>\n</dependency>\n\n\n② 修改 yudao-spring-boot-starter-mq 的 pom.xml 文件，引入 rocketmq-spring-boot-starter 依赖。如下所示：\n\n\x3c!-- 实际只要删除  <optional>true</optional> 部分即可 --\x3e\n<dependency>\n    <groupid>org.apache.rocketmq</groupid>\n    <artifactid>rocketmq-spring-boot-starter</artifactid>\n</dependency>\n\n\n记得需要手动在 idea 刷新下 maven 依赖。\n\n③ 修改 application.xml 配置文件，添加 rocketmq 全局配置。如下所示：\n\n# rocketmq 配置项，对应 rocketmqproperties 配置类\nrocketmq:\n  # producer 配置项\n  producer:\n    group: ${spring.application.name}_producer # 生产者分组\n\n\nps：默认已经添加，无需操作。\n\n④ 修改 application-local.xml 配置文件，添加 rocketmq name-server 配置。如下所示：\n\n# rocketmq 配置项，对应 rocketmqproperties 配置类\nrocketmq:\n  name-server: 127.0.0.1:9876 # rocketmq namesrv\n\n\nps：默认已经添加，无需操作。\n\n\n# 2.1 message 消息\n\n在 message 包下，修改 smssendmessage 类，短信发送消息。代码如下：\n\n@data\npublic class smssendmessage {\n\n    public static final string topic = "sms_send_topic"; // 重点：需要增加消息对应的 topic\n\n    /**\n     * 短信日志编号\n     */\n    @notnull(message = "短信日志编号不能为空")\n    private long logid;\n    /**\n     * 手机号\n     */\n    @notnull(message = "手机号不能为空")\n    private string mobile;\n    /**\n     * 短信渠道编号\n     */\n    @notnull(message = "短信渠道编号不能为空")\n    private long channelid;\n    /**\n     * 短信 api 的模板编号\n     */\n    @notnull(message = "短信 api 的模板编号不能为空")\n    private string apitemplateid;\n    /**\n     * 短信模板参数\n     */\n    private list<keyvalue<string, object>> templateparams;\n\n}\n\n\n\n# 2.2 smsproducer 生产者\n\n在 producer 包下，修改 smsproducer 类，sms 短信相关消息的生产者。代码如下：\n\n@slf4j\n@component\npublic class smsproducer {\n\n    @resource\n    private rocketmqtemplate rocketmqtemplate; // 重点：注入 rocketmqtemplate 对象\n\n    /**\n     * 发送 {@link smssendmessage} 消息\n     *\n     * @param logid 短信日志编号\n     * @param mobile 手机号\n     * @param channelid 渠道编号\n     * @param apitemplateid 短信模板编号\n     * @param templateparams 短信模板参数\n     */\n    public void sendsmssendmessage(long logid, string mobile,\n                                   long channelid, string apitemplateid, list<keyvalue<string, object>> templateparams) {\n        smssendmessage message = new smssendmessage().setlogid(logid).setmobile(mobile);\n        message.setchannelid(channelid).setapitemplateid(apitemplateid).settemplateparams(templateparams);\n        rocketmqtemplate.syncsend(smssendmessage.topic, message); // 重点：使用 rocketmqtemplate 同步发送消息\n    }\n\n}\n\n\n\n# 2.3 smssendconsumer 消费者\n\n在 consumer 包下，修改 smssendconsumer 类，smssendmessage 的消费者。代码如下：\n\n@component\n@rocketmqmessagelistener( // 重点：添加 @rocketmqmessagelistener 注解，声明消费的 topic\n        topic = smssendmessage.topic,\n        consumergroup = smssendmessage.topic + "_consumer"\n)\n@slf4j\npublic class smssendconsumer implements rocketmqlistener<smssendmessage> { // 重点：实现 rocketmqlistener 类，并填写对应的 message 类\n\n    @resource\n    private smssendservice smssendservice;\n\n    @override // 重点：实现 onmessage 方法\n    public void onmessage(smssendmessage message) {\n        log.info("[onmessage][消息内容({})]", message);\n        smssendservice.dosendsms(message);\n    }\n\n}\n\n\n\n# 2.4 简单测试\n\n① debug 启动后端项目，可以在 smsproducer 和 smssendconsumer 上面打上断点，稍微调试下。\n\n② 打开 smstemplatecontroller.http 文件，使用 idea httpclient 发起请求，发送短信。如下图所示：\n\n\n\n如果 idea 控制台看到 [onmessage][消息内容 日志内容，说明消息的发送和消费成功。',
            charsets: {
                cjk: !0
            }
        }, {
            title: "验证码",
            frontmatter: {
                title: "验证码",
                date: "2023-01-20T01:13:58.000Z",
                permalink: "/captcha"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/02.%E5%90%8E%E7%AB%AF%E6%89%8B%E5%86%8C/41.%E9%AA%8C%E8%AF%81%E7%A0%81.html",
            relativePath: "01.开发指南/02.后端手册/41.验证码.md",
            key: "v-c869afae",
            path: "/captcha/",
            headers: [{
                level: 2,
                title: "1. 交互流程",
                slug: "_1-交互流程",
                normalizedTitle: "1. 交互流程",
                charIndex: 224
            }, {
                level: 2,
                title: "2. 如何关闭验证码",
                slug: "_2-如何关闭验证码",
                normalizedTitle: "2. 如何关闭验证码",
                charIndex: 410
            }, {
                level: 2,
                title: "3. 接入场景",
                slug: "_3-接入场景",
                normalizedTitle: "3. 接入场景",
                charIndex: 743
            }, {
                level: 3,
                title: "3.1 后端接入",
                slug: "_3-1-后端接入",
                normalizedTitle: "3.1 后端接入",
                charIndex: 755
            }, {
                level: 3,
                title: "3.2 Vue2.X 管理后台",
                slug: "_3-2-vue2-x-管理后台",
                normalizedTitle: "3.2 vue2.x 管理后台",
                charIndex: 2111
            }, {
                level: 3,
                title: "3.3 Vue3.X 管理后台",
                slug: "_3-3-vue3-x-管理后台",
                normalizedTitle: "3.3 vue3.x 管理后台",
                charIndex: 2317
            }, {
                level: 3,
                title: "3.4 uni-app 用户 App",
                slug: "_3-4-uni-app-用户-app",
                normalizedTitle: "3.4 uni-app 用户 app",
                charIndex: 2536
            }],
            headersStr: "1. 交互流程 2. 如何关闭验证码 3. 接入场景 3.1 后端接入 3.2 Vue2.X 管理后台 3.3 Vue3.X 管理后台 3.4 uni-app 用户 App",
            content: '项目基于 AJ-Captcha 实现行为验证码，包含滑动拼图、文字点选两种方式，UI 支持弹出和嵌入两种方式。如下图所示：\n\n滑动拼图   文字点选\n       \n\n疑问：为什么采用行为验证码？\n\n相比传统的「传统字符型验证码」的“展示验证码-填写字符-比对答案”的流程来说，「行为验证码」的“展示验证码-操作-比对答案”的流程，用户只需要使用鼠标产生指定的行为轨迹，不需要键盘手动输入，用户体验更好，更加难以被机器识别，更加安全可靠。\n\n\n# 1. 交互流程\n\n\n\n * ① 用户访问应用页面，请求显示行为验证码\n * ② 用户按照提示要求完成验证码拼图/点击\n * ③ 用户提交表单，前端将第二步的输出一同提交到后台\n * ④ 验证数据随表单提交到后台后，后台需要调用 captchaService.verification 做二次校验\n * ⑤ 第 4 步返回校验通过/失败到产品应用后端，再返回到前端\n\n\n# 2. 如何关闭验证码\n\n管理后台的登录界面，默认开启验证码。如果需要关闭验证码，操作如下：\n\n① 后端的 application-local.yaml 配置文件中，将 yudao.captcha.enable 设置为 false。\n\n② 如果前端使用 yudao-ui-admin-vue2 项目，将环境对应的 .env 配置文件中，将 VUE_APP_DOC_ENABLE 设置为 false。\n\n如果前端使用 yudao-ui-admin-vue3 项目，将环境对应的 .env 配置文件中，将 VITE_APP_CAPTCHA_ENABLE 设置为 false。\n\nps：如果你不知道环境对应的 .env 配置文件是哪个，就全部改成 false 吧！\n\n\n# 3. 接入场景\n\n\n# 3.1 后端接入\n\nyudao-module-system-biz 模块，默认在 pom.xml) 已经引入 spring-boot-starter-captcha-plus 依赖，代码如下：\n\n> 由于 AJ-Captcha 对 Spring Boot 3.X 版本的支持还不完善，所以使用 captcha-plus 替代，它是基于 AJ-Captcha 进行增强。\n\n<dependency>\n    <groupId>cn.iocoder.boot</groupId>\n    <artifactId>yudao-spring-boot-starter-captcha</artifactId>\n</dependency>\n\n\n② 验证码的配置，在 application.yaml 配置文件中，配置项如下：\n\naj:\n  captcha:\n    jigsaw: classpath:images/jigsaw # 滑动验证，底图路径，不配置将使用默认图片；以 classpath: 开头，取 resource 目录下路径\n    pic-click: classpath:images/pic-click # 滑动验证，底图路径，不配置将使用默认图片；以 classpath: 开头，取 resource 目录下路径\n    cache-type: redis # 缓存 local/redis...\n    cache-number: 1000 # local 缓存的阈值,达到这个值，清除缓存\n    timing-clear: 180 # local定时清除过期缓存(单位秒),设置为0代表不执行\n    type: blockPuzzle # 验证码类型 default两种都实例化。 blockPuzzle 滑块拼图 clickWord 文字点选\n    water-mark: 芋道源码 # 右下角水印文字(我的水印)，可使用 https://tool.chinaz.com/tools/unicode.aspx 中文转 Unicode，Linux 可能需要转 unicode\n    interference-options: 0 # 滑动干扰项(0/1/2)\n    req-frequency-limit-enable: false # 接口请求次数一分钟限制是否开启 true|false\n    req-get-lock-limit: 5 # 验证失败 5 次，get接口锁定\n    req-get-lock-seconds: 10 # 验证失败后，锁定时间间隔\n    req-get-minute-limit: 30 # get 接口一分钟内请求数限制\n    req-check-minute-limit: 60 # check 接口一分钟内请求数限制\n    req-verify-minute-limit: 60 # verify 接口一分钟内请求数限制\n\n\n如果你想修改验证码的 图片，修改 resources/images 目录即可。\n\n③ 验证码的使用，可以参考 CaptchaController 和 AuthController 两个类的实现代码。\n\n\n# 3.2 Vue2.X 管理后台\n\n① 验证码组件：Verifition\n\n② 登录界面的接入：login.vue\n\n\x3c!-- 图形验证码 --\x3e\n<Verify ref="verify" :captcha-type="\'blockPuzzle\'" :img-size="{width:\'400px\',height:\'200px\'}"\n        @success="handleLogin" />\n\n\n\n# 3.3 Vue3.X 管理后台\n\n① 验证码组件：Verifition\n\n② 登录界面的接入：LoginForm.vue\n\n<Verify\n    ref="verify"\n    mode="pop"\n    :captchaType="captchaType"\n    :imgSize="{ width: \'400px\', height: \'200px\' }"\n    @success="handleLogin"\n/>\n\n\n\n# 3.4 uni-app 用户 App\n\n① 验证码组件：verifition\n\n② 登录界面的接入：login.vue\n\n<Verify @success="pwdLogin" :mode="\'pop\'" :captchaType="\'blockPuzzle\'"\n        :imgSize="{ width: \'330px\', height: \'155px\' }" ref="verify"></Verify>\n',
            normalizedContent: '项目基于 aj-captcha 实现行为验证码，包含滑动拼图、文字点选两种方式，ui 支持弹出和嵌入两种方式。如下图所示：\n\n滑动拼图   文字点选\n       \n\n疑问：为什么采用行为验证码？\n\n相比传统的「传统字符型验证码」的“展示验证码-填写字符-比对答案”的流程来说，「行为验证码」的“展示验证码-操作-比对答案”的流程，用户只需要使用鼠标产生指定的行为轨迹，不需要键盘手动输入，用户体验更好，更加难以被机器识别，更加安全可靠。\n\n\n# 1. 交互流程\n\n\n\n * ① 用户访问应用页面，请求显示行为验证码\n * ② 用户按照提示要求完成验证码拼图/点击\n * ③ 用户提交表单，前端将第二步的输出一同提交到后台\n * ④ 验证数据随表单提交到后台后，后台需要调用 captchaservice.verification 做二次校验\n * ⑤ 第 4 步返回校验通过/失败到产品应用后端，再返回到前端\n\n\n# 2. 如何关闭验证码\n\n管理后台的登录界面，默认开启验证码。如果需要关闭验证码，操作如下：\n\n① 后端的 application-local.yaml 配置文件中，将 yudao.captcha.enable 设置为 false。\n\n② 如果前端使用 yudao-ui-admin-vue2 项目，将环境对应的 .env 配置文件中，将 vue_app_doc_enable 设置为 false。\n\n如果前端使用 yudao-ui-admin-vue3 项目，将环境对应的 .env 配置文件中，将 vite_app_captcha_enable 设置为 false。\n\nps：如果你不知道环境对应的 .env 配置文件是哪个，就全部改成 false 吧！\n\n\n# 3. 接入场景\n\n\n# 3.1 后端接入\n\nyudao-module-system-biz 模块，默认在 pom.xml) 已经引入 spring-boot-starter-captcha-plus 依赖，代码如下：\n\n> 由于 aj-captcha 对 spring boot 3.x 版本的支持还不完善，所以使用 captcha-plus 替代，它是基于 aj-captcha 进行增强。\n\n<dependency>\n    <groupid>cn.iocoder.boot</groupid>\n    <artifactid>yudao-spring-boot-starter-captcha</artifactid>\n</dependency>\n\n\n② 验证码的配置，在 application.yaml 配置文件中，配置项如下：\n\naj:\n  captcha:\n    jigsaw: classpath:images/jigsaw # 滑动验证，底图路径，不配置将使用默认图片；以 classpath: 开头，取 resource 目录下路径\n    pic-click: classpath:images/pic-click # 滑动验证，底图路径，不配置将使用默认图片；以 classpath: 开头，取 resource 目录下路径\n    cache-type: redis # 缓存 local/redis...\n    cache-number: 1000 # local 缓存的阈值,达到这个值，清除缓存\n    timing-clear: 180 # local定时清除过期缓存(单位秒),设置为0代表不执行\n    type: blockpuzzle # 验证码类型 default两种都实例化。 blockpuzzle 滑块拼图 clickword 文字点选\n    water-mark: 芋道源码 # 右下角水印文字(我的水印)，可使用 https://tool.chinaz.com/tools/unicode.aspx 中文转 unicode，linux 可能需要转 unicode\n    interference-options: 0 # 滑动干扰项(0/1/2)\n    req-frequency-limit-enable: false # 接口请求次数一分钟限制是否开启 true|false\n    req-get-lock-limit: 5 # 验证失败 5 次，get接口锁定\n    req-get-lock-seconds: 10 # 验证失败后，锁定时间间隔\n    req-get-minute-limit: 30 # get 接口一分钟内请求数限制\n    req-check-minute-limit: 60 # check 接口一分钟内请求数限制\n    req-verify-minute-limit: 60 # verify 接口一分钟内请求数限制\n\n\n如果你想修改验证码的 图片，修改 resources/images 目录即可。\n\n③ 验证码的使用，可以参考 captchacontroller 和 authcontroller 两个类的实现代码。\n\n\n# 3.2 vue2.x 管理后台\n\n① 验证码组件：verifition\n\n② 登录界面的接入：login.vue\n\n\x3c!-- 图形验证码 --\x3e\n<verify ref="verify" :captcha-type="\'blockpuzzle\'" :img-size="{width:\'400px\',height:\'200px\'}"\n        @success="handlelogin" />\n\n\n\n# 3.3 vue3.x 管理后台\n\n① 验证码组件：verifition\n\n② 登录界面的接入：loginform.vue\n\n<verify\n    ref="verify"\n    mode="pop"\n    :captchatype="captchatype"\n    :imgsize="{ width: \'400px\', height: \'200px\' }"\n    @success="handlelogin"\n/>\n\n\n\n# 3.4 uni-app 用户 app\n\n① 验证码组件：verifition\n\n② 登录界面的接入：login.vue\n\n<verify @success="pwdlogin" :mode="\'pop\'" :captchatype="\'blockpuzzle\'"\n        :imgsize="{ width: \'330px\', height: \'155px\' }" ref="verify"></verify>\n',
            charsets: {
                cjk: !0
            }
        }, {
            title: "消息队列（RabbitMQ）",
            frontmatter: {
                title: "消息队列（RabbitMQ）",
                date: "2023-11-02T00:00:34.000Z",
                permalink: "/message-queue/rabbitmq"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/03.%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%89%8B%E5%86%8C/14.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88RabbitMQ%EF%BC%89.html",
            relativePath: "01.开发指南/03.中间件手册/14.消息队列（RabbitMQ）.md",
            key: "v-6af50b4a",
            path: "/message-queue/rabbitmq/",
            headers: [{
                level: 2,
                title: "RabbitMQ-Spring",
                slug: "rabbitmq-spring",
                normalizedTitle: "rabbitmq-spring",
                charIndex: 2
            }, {
                level: 2,
                title: "2. 使用示例",
                slug: "_2-使用示例",
                normalizedTitle: "2. 使用示例",
                charIndex: 192
            }, {
                level: 2,
                title: "2.0 引入依赖与配置",
                slug: "_2-0-引入依赖与配置",
                normalizedTitle: "2.0 引入依赖与配置",
                charIndex: 238
            }, {
                level: 3,
                title: "2.1 Message 消息",
                slug: "_2-1-message-消息",
                normalizedTitle: "2.1 message 消息",
                charIndex: 1003
            }, {
                level: 3,
                title: "2.2 SmsProducer 生产者",
                slug: "_2-2-smsproducer-生产者",
                normalizedTitle: "2.2 smsproducer 生产者",
                charIndex: 1779
            }, {
                level: 3,
                title: "2.3 SmsSendConsumer 消费者",
                slug: "_2-3-smssendconsumer-消费者",
                normalizedTitle: "2.3 smssendconsumer 消费者",
                charIndex: 2688
            }, {
                level: 3,
                title: "2.4 简单测试",
                slug: "_2-4-简单测试",
                normalizedTitle: "2.4 简单测试",
                charIndex: 3185
            }],
            headersStr: "RabbitMQ-Spring 2. 使用示例 2.0 引入依赖与配置 2.1 Message 消息 2.2 SmsProducer 生产者 2.3 SmsSendConsumer 消费者 2.4 简单测试",
            content: '# RabbitMQ-Spring\n\nyudao-spring-boot-starter-mq 技术组件，基于 RabbitMQ 实现分布式消息队列。\n\n如果你对 RabbitMQ 不太了解，可以看看 《芋道 Spring Boot 消息队列 RabbitMQ 入门》 文档。\n\n如何安装一个 RabbitMQ 服务？\n\n参考 《芋道 RabbitMQ 极简入门 》 文档。\n\n\n# 2. 使用示例\n\n以【短信发送】举例子，改造使用 RabbitMQ 作为消息队列。\n\n\n# 2.0 引入依赖与配置\n\n① 在 yudao-module-system-biz 模块中，引入 yudao-spring-boot-starter-mq 技术组件。如下所示：\n\n<dependency>\n    <groupId>cn.iocoder.boot</groupId>\n    <artifactId>yudao-spring-boot-starter-mq</artifactId>\n</dependency>\n\n\n② 修改 yudao-spring-boot-starter-mq 的 pom.xml 文件，引入 spring-rabbit 依赖。如下所示：\n\n\x3c!-- 实际只要删除  <optional>true</optional> 部分即可 --\x3e\n<dependency>\n    <groupId>org.springframework.amqp</groupId>\n    <artifactId>spring-rabbit</artifactId>\n</dependency>\n\n\n记得需要手动在 IDEA 刷新下 Maven 依赖。\n\n③ 修改 application-local.xml 配置文件，添加 RabbitMQ 配置。如下所示：\n\nspring:\n  # RabbitMQ 配置项，对应 RabbitProperties 配置类\n  rabbitmq:\n    host: 127.0.0.1 # RabbitMQ 服务的地址\n    port: 5672 # RabbitMQ 服务的端口\n    username: guest # RabbitMQ 服务的账号\n    password: guest # RabbitMQ 服务的密码\n\n\nps：默认已经添加，无需操作。\n\n\n# 2.1 Message 消息\n\n① 在 message 包下，修改 SmsSendMessage 类，短信发送消息。代码如下：\n\n@Data\npublic class SmsSendMessage implements Serializable { // 重点：需要添加 Serializable 接口 \n\n    public static final String QUEUE = "SEND_MESSAGE_QUEUE"; // 重点：需要增加消息对应的 Queue\n\n    /**\n     * 短信日志编号\n     */\n    @NotNull(message = "短信日志编号不能为空")\n    private Long logId;\n    /**\n     * 手机号\n     */\n    @NotNull(message = "手机号不能为空")\n    private String mobile;\n    /**\n     * 短信渠道编号\n     */\n    @NotNull(message = "短信渠道编号不能为空")\n    private Long channelId;\n    /**\n     * 短信 API 的模板编号\n     */\n    @NotNull(message = "短信 API 的模板编号不能为空")\n    private String apiTemplateId;\n    /**\n     * 短信模板参数\n     */\n    private List<KeyValue<String, Object>> templateParams;\n\n}\n\n\n② 在 RabbitMQ 控制台，新增 "SEND_MESSAGE_QUEUE" 队列。如下图所示：\n\n\n\n\n# 2.2 SmsProducer 生产者\n\n在 producer 包下，修改 SmsProducer 类，Sms 短信相关消息的生产者。代码如下：\n\n@Slf4j\n@Component\npublic class SmsProducer {\n\n    @Resource\n    private RabbitTemplate rabbitTemplate; // 重点：注入 RabbitTemplate 对象\n\n    /**\n     * 发送 {@link SmsSendMessage} 消息\n     *\n     * @param logId 短信日志编号\n     * @param mobile 手机号\n     * @param channelId 渠道编号\n     * @param apiTemplateId 短信模板编号\n     * @param templateParams 短信模板参数\n     */\n    public void sendSmsSendMessage(Long logId, String mobile,\n                                   Long channelId, String apiTemplateId, List<KeyValue<String, Object>> templateParams) {\n        SmsSendMessage message = new SmsSendMessage().setLogId(logId).setMobile(mobile);\n        message.setChannelId(channelId).setApiTemplateId(apiTemplateId).setTemplateParams(templateParams);\n        rabbitTemplate.convertAndSend(SmsSendMessage.QUEUE, message); // 重点：使用 RabbitTemplate 发送消息\n    }\n\n}\n\n\n\n# 2.3 SmsSendConsumer 消费者\n\n在 consumer 包下，修改 SmsSendConsumer 类，SmsSendMessage 的消费者。代码如下：\n\n@Component\n@RabbitListener(queues = SmsSendMessage.QUEUE) // 重点：添加 @RabbitListener 注解，声明消费的 queue\n@Slf4j\npublic class SmsSendConsumer {\n\n    @Resource\n    private SmsSendService smsSendService;\n\n    @RabbitHandler // 重点：添加 @RabbitHandler 注解，实现消息的消费\n    public void onMessage(SmsSendMessage message) {\n        log.info("[onMessage][消息内容({})]", message);\n        smsSendService.doSendSms(message);\n    }\n\n}\n\n\n\n# 2.4 简单测试\n\n① Debug 启动后端项目，可以在 SmsProducer 和 SmsSendConsumer 上面打上断点，稍微调试下。\n\n② 打开 SmsTemplateController.http 文件，使用 IDEA httpclient 发起请求，发送短信。如下图所示：\n\n\n\n如果 IDEA 控制台看到 [onMessage][消息内容 日志内容，说明消息的发送和消费成功。',
            normalizedContent: '# rabbitmq-spring\n\nyudao-spring-boot-starter-mq 技术组件，基于 rabbitmq 实现分布式消息队列。\n\n如果你对 rabbitmq 不太了解，可以看看 《芋道 spring boot 消息队列 rabbitmq 入门》 文档。\n\n如何安装一个 rabbitmq 服务？\n\n参考 《芋道 rabbitmq 极简入门 》 文档。\n\n\n# 2. 使用示例\n\n以【短信发送】举例子，改造使用 rabbitmq 作为消息队列。\n\n\n# 2.0 引入依赖与配置\n\n① 在 yudao-module-system-biz 模块中，引入 yudao-spring-boot-starter-mq 技术组件。如下所示：\n\n<dependency>\n    <groupid>cn.iocoder.boot</groupid>\n    <artifactid>yudao-spring-boot-starter-mq</artifactid>\n</dependency>\n\n\n② 修改 yudao-spring-boot-starter-mq 的 pom.xml 文件，引入 spring-rabbit 依赖。如下所示：\n\n\x3c!-- 实际只要删除  <optional>true</optional> 部分即可 --\x3e\n<dependency>\n    <groupid>org.springframework.amqp</groupid>\n    <artifactid>spring-rabbit</artifactid>\n</dependency>\n\n\n记得需要手动在 idea 刷新下 maven 依赖。\n\n③ 修改 application-local.xml 配置文件，添加 rabbitmq 配置。如下所示：\n\nspring:\n  # rabbitmq 配置项，对应 rabbitproperties 配置类\n  rabbitmq:\n    host: 127.0.0.1 # rabbitmq 服务的地址\n    port: 5672 # rabbitmq 服务的端口\n    username: guest # rabbitmq 服务的账号\n    password: guest # rabbitmq 服务的密码\n\n\nps：默认已经添加，无需操作。\n\n\n# 2.1 message 消息\n\n① 在 message 包下，修改 smssendmessage 类，短信发送消息。代码如下：\n\n@data\npublic class smssendmessage implements serializable { // 重点：需要添加 serializable 接口 \n\n    public static final string queue = "send_message_queue"; // 重点：需要增加消息对应的 queue\n\n    /**\n     * 短信日志编号\n     */\n    @notnull(message = "短信日志编号不能为空")\n    private long logid;\n    /**\n     * 手机号\n     */\n    @notnull(message = "手机号不能为空")\n    private string mobile;\n    /**\n     * 短信渠道编号\n     */\n    @notnull(message = "短信渠道编号不能为空")\n    private long channelid;\n    /**\n     * 短信 api 的模板编号\n     */\n    @notnull(message = "短信 api 的模板编号不能为空")\n    private string apitemplateid;\n    /**\n     * 短信模板参数\n     */\n    private list<keyvalue<string, object>> templateparams;\n\n}\n\n\n② 在 rabbitmq 控制台，新增 "send_message_queue" 队列。如下图所示：\n\n\n\n\n# 2.2 smsproducer 生产者\n\n在 producer 包下，修改 smsproducer 类，sms 短信相关消息的生产者。代码如下：\n\n@slf4j\n@component\npublic class smsproducer {\n\n    @resource\n    private rabbittemplate rabbittemplate; // 重点：注入 rabbittemplate 对象\n\n    /**\n     * 发送 {@link smssendmessage} 消息\n     *\n     * @param logid 短信日志编号\n     * @param mobile 手机号\n     * @param channelid 渠道编号\n     * @param apitemplateid 短信模板编号\n     * @param templateparams 短信模板参数\n     */\n    public void sendsmssendmessage(long logid, string mobile,\n                                   long channelid, string apitemplateid, list<keyvalue<string, object>> templateparams) {\n        smssendmessage message = new smssendmessage().setlogid(logid).setmobile(mobile);\n        message.setchannelid(channelid).setapitemplateid(apitemplateid).settemplateparams(templateparams);\n        rabbittemplate.convertandsend(smssendmessage.queue, message); // 重点：使用 rabbittemplate 发送消息\n    }\n\n}\n\n\n\n# 2.3 smssendconsumer 消费者\n\n在 consumer 包下，修改 smssendconsumer 类，smssendmessage 的消费者。代码如下：\n\n@component\n@rabbitlistener(queues = smssendmessage.queue) // 重点：添加 @rabbitlistener 注解，声明消费的 queue\n@slf4j\npublic class smssendconsumer {\n\n    @resource\n    private smssendservice smssendservice;\n\n    @rabbithandler // 重点：添加 @rabbithandler 注解，实现消息的消费\n    public void onmessage(smssendmessage message) {\n        log.info("[onmessage][消息内容({})]", message);\n        smssendservice.dosendsms(message);\n    }\n\n}\n\n\n\n# 2.4 简单测试\n\n① debug 启动后端项目，可以在 smsproducer 和 smssendconsumer 上面打上断点，稍微调试下。\n\n② 打开 smstemplatecontroller.http 文件，使用 idea httpclient 发起请求，发送短信。如下图所示：\n\n\n\n如果 idea 控制台看到 [onmessage][消息内容 日志内容，说明消息的发送和消费成功。',
            charsets: {
                cjk: !0
            }
        }, {
            title: "限流熔断",
            frontmatter: {
                title: "限流熔断",
                date: "2022-04-10T00:45:49.000Z",
                permalink: "/server-protection"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/03.%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%89%8B%E5%86%8C/22.%E9%99%90%E6%B5%81%E7%86%94%E6%96%AD.html",
            relativePath: "01.开发指南/03.中间件手册/22.限流熔断.md",
            key: "v-bcabe830",
            path: "/server-protection/",
            headersStr: null,
            content: "yudao-spring-boot-starter-protection 技术组件，基于 Sentinel 组件，以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。\n\n使用的示例，参见 《芋道 Spring Boot 服务容错 Sentinel 入门》 文章。",
            normalizedContent: "yudao-spring-boot-starter-protection 技术组件，基于 sentinel 组件，以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。\n\n使用的示例，参见 《芋道 spring boot 服务容错 sentinel 入门》 文章。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "消息队列（Kafka）",
            frontmatter: {
                title: "消息队列（Kafka）",
                date: "2023-11-02T00:00:34.000Z",
                permalink: "/message-queue/kafka"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/03.%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%89%8B%E5%86%8C/15.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88Kafka%EF%BC%89.html",
            relativePath: "01.开发指南/03.中间件手册/15.消息队列（Kafka）.md",
            key: "v-7f482612",
            path: "/message-queue/kafka/",
            headers: [{
                level: 2,
                title: "Kafka-Spring",
                slug: "kafka-spring",
                normalizedTitle: "kafka-spring",
                charIndex: 2
            }, {
                level: 2,
                title: "2. 使用示例",
                slug: "_2-使用示例",
                normalizedTitle: "2. 使用示例",
                charIndex: 174
            }, {
                level: 2,
                title: "2.0 引入依赖与配置",
                slug: "_2-0-引入依赖与配置",
                normalizedTitle: "2.0 引入依赖与配置",
                charIndex: 217
            }, {
                level: 3,
                title: "2.1 Message 消息",
                slug: "_2-1-message-消息",
                normalizedTitle: "2.1 message 消息",
                charIndex: 1723
            }, {
                level: 3,
                title: "2.2 SmsProducer 生产者",
                slug: "_2-2-smsproducer-生产者",
                normalizedTitle: "2.2 smsproducer 生产者",
                charIndex: 2415
            }, {
                level: 3,
                title: "2.3 SmsSendConsumer 消费者",
                slug: "_2-3-smssendconsumer-消费者",
                normalizedTitle: "2.3 smssendconsumer 消费者",
                charIndex: 3325
            }, {
                level: 3,
                title: "2.4 简单测试",
                slug: "_2-4-简单测试",
                normalizedTitle: "2.4 简单测试",
                charIndex: 3821
            }],
            headersStr: "Kafka-Spring 2. 使用示例 2.0 引入依赖与配置 2.1 Message 消息 2.2 SmsProducer 生产者 2.3 SmsSendConsumer 消费者 2.4 简单测试",
            content: '# Kafka-Spring\n\nyudao-spring-boot-starter-mq 技术组件，基于 Kafka 实现分布式消息队列。\n\n如果你对 Kafka 不太了解，可以看看 《芋道 Spring Boot 消息队列 Kafka 入门》 文档。\n\n如何安装一个 Kafka 服务？\n\n参考 《芋道 Kafka 极简入门 》 文档。\n\n\n# 2. 使用示例\n\n以【短信发送】举例子，改造使用 Kafka 作为消息队列。\n\n\n# 2.0 引入依赖与配置\n\n① 在 yudao-module-system-biz 模块中，引入 yudao-spring-boot-starter-mq 技术组件。如下所示：\n\n<dependency>\n    <groupId>cn.iocoder.boot</groupId>\n    <artifactId>yudao-spring-boot-starter-mq</artifactId>\n</dependency>\n\n\n② 修改 yudao-spring-boot-starter-mq 的 pom.xml 文件，引入 spring-kafka 依赖。如下所示：\n\n\x3c!-- 实际只要删除  <optional>true</optional> 部分即可 --\x3e\n<dependency>\n    <groupId>org.springframework.kafka</groupId>\n    <artifactId>spring-kafka</artifactId>\n</dependency>\n\n\n记得需要手动在 IDEA 刷新下 Maven 依赖。\n\n③ 修改 application.xml 配置文件，添加 Kafka 全局配置。如下所示：\n\nspring:\n  # Kafka 配置项，对应 KafkaProperties 配置类\n  kafka:\n    # Kafka Producer 配置项\n    producer:\n      acks: 1 # 0-不应答。1-leader 应答。all-所有 leader 和 follower 应答。\n      retries: 3 # 发送失败时，重试发送的次数\n      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer # 消息的 value 的序列化\n    # Kafka Consumer 配置项\n    consumer:\n      auto-offset-reset: earliest # 设置消费者分组最初的消费进度为 earliest 。可参考博客 https://blog.csdn.net/lishuangzhe7047/article/details/74530417 理解\n      value-deserializer: org.springframework.kafka.support.serializer.JsonDeserializer\n      properties:\n        spring.json.trusted.packages: \'*\'\n    # Kafka Consumer Listener 监听器配置\n    listener:\n      missing-topics-fatal: false # 消费监听接口监听的主题不存在时，默认会报错。所以通过设置为 false ，解决报错\n\n\nps：默认已经添加，无需操作。\n\n④ 修改 application-local.xml 配置文件，添加 Kafka bootstrap-servers 配置。如下所示：\n\nspring:\n  # Kafka 配置项，对应 KafkaProperties 配置类\n  kafka:\n    bootstrap-servers: 127.0.0.1:9092 # 指定 Kafka Broker 地址，可以设置多个，以逗号分隔\n\n\nps：默认已经添加，无需操作。\n\n\n# 2.1 Message 消息\n\n在 message 包下，修改 SmsSendMessage 类，短信发送消息。代码如下：\n\n@Data\npublic class SmsSendMessage implements Serializable {\n\n    public static final String TOPIC = "SEND_MESSAGE_TOPIC"; // 重点：需要增加消息对应的 Topic\n\n    /**\n     * 短信日志编号\n     */\n    @NotNull(message = "短信日志编号不能为空")\n    private Long logId;\n    /**\n     * 手机号\n     */\n    @NotNull(message = "手机号不能为空")\n    private String mobile;\n    /**\n     * 短信渠道编号\n     */\n    @NotNull(message = "短信渠道编号不能为空")\n    private Long channelId;\n    /**\n     * 短信 API 的模板编号\n     */\n    @NotNull(message = "短信 API 的模板编号不能为空")\n    private String apiTemplateId;\n    /**\n     * 短信模板参数\n     */\n    private List<KeyValue<String, Object>> templateParams;\n\n}\n\n\n\n# 2.2 SmsProducer 生产者\n\n在 producer 包下，修改 SmsProducer 类，Sms 短信相关消息的生产者。代码如下：\n\n@Slf4j\n@Component\npublic class SmsProducer {\n\n    @Resource\n    private KafkaTemplate<Object, Object> kafkaTemplate; // 重点：注入 KafkaTemplate 对象\n\n    /**\n     * 发送 {@link SmsSendMessage} 消息\n     *\n     * @param logId 短信日志编号\n     * @param mobile 手机号\n     * @param channelId 渠道编号\n     * @param apiTemplateId 短信模板编号\n     * @param templateParams 短信模板参数\n     */\n    public void sendSmsSendMessage(Long logId, String mobile,\n                                   Long channelId, String apiTemplateId, List<KeyValue<String, Object>> templateParams) {\n        SmsSendMessage message = new SmsSendMessage().setLogId(logId).setMobile(mobile);\n        message.setChannelId(channelId).setApiTemplateId(apiTemplateId).setTemplateParams(templateParams);\n        kafkaTemplate.send(SmsSendMessage.TOPIC, message); // 重点：使用 KafkaTemplate 发送消息\n    }\n\n}\n\n\n\n# 2.3 SmsSendConsumer 消费者\n\n在 consumer 包下，修改 SmsSendConsumer 类，SmsSendMessage 的消费者。代码如下：\n\n@Component\n@Slf4j\npublic class SmsSendConsumer {\n\n    @Resource\n    private SmsSendService smsSendService;\n\n    @KafkaListener(topics = SmsSendMessage.TOPIC, // 重点：添加 @KafkaListener 注解，实现消息的消费\n        groupId = SmsSendMessage.TOPIC + "_CONSUMER") \n    public void onMessage(SmsSendMessage message) {\n        log.info("[onMessage][消息内容({})]", message);\n        smsSendService.doSendSms(message);\n    }\n\n}\n\n\n\n# 2.4 简单测试\n\n① Debug 启动后端项目，可以在 SmsProducer 和 SmsSendConsumer 上面打上断点，稍微调试下。\n\n② 打开 SmsTemplateController.http 文件，使用 IDEA httpclient 发起请求，发送短信。如下图所示：\n\n\n\n如果 IDEA 控制台看到 [onMessage][消息内容 日志内容，说明消息的发送和消费成功。',
            normalizedContent: '# kafka-spring\n\nyudao-spring-boot-starter-mq 技术组件，基于 kafka 实现分布式消息队列。\n\n如果你对 kafka 不太了解，可以看看 《芋道 spring boot 消息队列 kafka 入门》 文档。\n\n如何安装一个 kafka 服务？\n\n参考 《芋道 kafka 极简入门 》 文档。\n\n\n# 2. 使用示例\n\n以【短信发送】举例子，改造使用 kafka 作为消息队列。\n\n\n# 2.0 引入依赖与配置\n\n① 在 yudao-module-system-biz 模块中，引入 yudao-spring-boot-starter-mq 技术组件。如下所示：\n\n<dependency>\n    <groupid>cn.iocoder.boot</groupid>\n    <artifactid>yudao-spring-boot-starter-mq</artifactid>\n</dependency>\n\n\n② 修改 yudao-spring-boot-starter-mq 的 pom.xml 文件，引入 spring-kafka 依赖。如下所示：\n\n\x3c!-- 实际只要删除  <optional>true</optional> 部分即可 --\x3e\n<dependency>\n    <groupid>org.springframework.kafka</groupid>\n    <artifactid>spring-kafka</artifactid>\n</dependency>\n\n\n记得需要手动在 idea 刷新下 maven 依赖。\n\n③ 修改 application.xml 配置文件，添加 kafka 全局配置。如下所示：\n\nspring:\n  # kafka 配置项，对应 kafkaproperties 配置类\n  kafka:\n    # kafka producer 配置项\n    producer:\n      acks: 1 # 0-不应答。1-leader 应答。all-所有 leader 和 follower 应答。\n      retries: 3 # 发送失败时，重试发送的次数\n      value-serializer: org.springframework.kafka.support.serializer.jsonserializer # 消息的 value 的序列化\n    # kafka consumer 配置项\n    consumer:\n      auto-offset-reset: earliest # 设置消费者分组最初的消费进度为 earliest 。可参考博客 https://blog.csdn.net/lishuangzhe7047/article/details/74530417 理解\n      value-deserializer: org.springframework.kafka.support.serializer.jsondeserializer\n      properties:\n        spring.json.trusted.packages: \'*\'\n    # kafka consumer listener 监听器配置\n    listener:\n      missing-topics-fatal: false # 消费监听接口监听的主题不存在时，默认会报错。所以通过设置为 false ，解决报错\n\n\nps：默认已经添加，无需操作。\n\n④ 修改 application-local.xml 配置文件，添加 kafka bootstrap-servers 配置。如下所示：\n\nspring:\n  # kafka 配置项，对应 kafkaproperties 配置类\n  kafka:\n    bootstrap-servers: 127.0.0.1:9092 # 指定 kafka broker 地址，可以设置多个，以逗号分隔\n\n\nps：默认已经添加，无需操作。\n\n\n# 2.1 message 消息\n\n在 message 包下，修改 smssendmessage 类，短信发送消息。代码如下：\n\n@data\npublic class smssendmessage implements serializable {\n\n    public static final string topic = "send_message_topic"; // 重点：需要增加消息对应的 topic\n\n    /**\n     * 短信日志编号\n     */\n    @notnull(message = "短信日志编号不能为空")\n    private long logid;\n    /**\n     * 手机号\n     */\n    @notnull(message = "手机号不能为空")\n    private string mobile;\n    /**\n     * 短信渠道编号\n     */\n    @notnull(message = "短信渠道编号不能为空")\n    private long channelid;\n    /**\n     * 短信 api 的模板编号\n     */\n    @notnull(message = "短信 api 的模板编号不能为空")\n    private string apitemplateid;\n    /**\n     * 短信模板参数\n     */\n    private list<keyvalue<string, object>> templateparams;\n\n}\n\n\n\n# 2.2 smsproducer 生产者\n\n在 producer 包下，修改 smsproducer 类，sms 短信相关消息的生产者。代码如下：\n\n@slf4j\n@component\npublic class smsproducer {\n\n    @resource\n    private kafkatemplate<object, object> kafkatemplate; // 重点：注入 kafkatemplate 对象\n\n    /**\n     * 发送 {@link smssendmessage} 消息\n     *\n     * @param logid 短信日志编号\n     * @param mobile 手机号\n     * @param channelid 渠道编号\n     * @param apitemplateid 短信模板编号\n     * @param templateparams 短信模板参数\n     */\n    public void sendsmssendmessage(long logid, string mobile,\n                                   long channelid, string apitemplateid, list<keyvalue<string, object>> templateparams) {\n        smssendmessage message = new smssendmessage().setlogid(logid).setmobile(mobile);\n        message.setchannelid(channelid).setapitemplateid(apitemplateid).settemplateparams(templateparams);\n        kafkatemplate.send(smssendmessage.topic, message); // 重点：使用 kafkatemplate 发送消息\n    }\n\n}\n\n\n\n# 2.3 smssendconsumer 消费者\n\n在 consumer 包下，修改 smssendconsumer 类，smssendmessage 的消费者。代码如下：\n\n@component\n@slf4j\npublic class smssendconsumer {\n\n    @resource\n    private smssendservice smssendservice;\n\n    @kafkalistener(topics = smssendmessage.topic, // 重点：添加 @kafkalistener 注解，实现消息的消费\n        groupid = smssendmessage.topic + "_consumer") \n    public void onmessage(smssendmessage message) {\n        log.info("[onmessage][消息内容({})]", message);\n        smssendservice.dosendsms(message);\n    }\n\n}\n\n\n\n# 2.4 简单测试\n\n① debug 启动后端项目，可以在 smsproducer 和 smssendconsumer 上面打上断点，稍微调试下。\n\n② 打开 smstemplatecontroller.http 文件，使用 idea httpclient 发起请求，发送短信。如下图所示：\n\n\n\n如果 idea 控制台看到 [onmessage][消息内容 日志内容，说明消息的发送和消费成功。',
            charsets: {
                cjk: !0
            }
        }, {
            title: "功能开启",
            frontmatter: {
                title: "功能开启",
                date: "2024-03-24T18:27:17.000Z",
                permalink: "/bpm/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/10.%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%89%8B%E5%86%8C/02.%E5%8A%9F%E8%83%BD%E5%BC%80%E5%90%AF.html",
            relativePath: "01.开发指南/10.工作流手册/02.功能开启.md",
            key: "v-fc3ae356",
            path: "/bpm/",
            headers: [{
                level: 2,
                title: "1. 第一步，开启模块",
                slug: "_1-第一步-开启模块",
                normalizedTitle: "1. 第一步，开启模块",
                charIndex: 389
            }, {
                level: 2,
                title: "2. 第二步，导入 SQL",
                slug: "_2-第二步-导入-sql",
                normalizedTitle: "2. 第二步，导入 sql",
                charIndex: 608
            }, {
                level: 2,
                title: "3. 第三步，重启项目",
                slug: "_3-第三步-重启项目",
                normalizedTitle: "3. 第三步，重启项目",
                charIndex: 742
            }, {
                level: 2,
                title: "666. 后续学习",
                slug: "_666-后续学习",
                normalizedTitle: "666. 后续学习",
                charIndex: 1288
            }, {
                level: 2,
                title: "补充说明：如何集成 Activiti？",
                slug: "补充说明-如何集成-activiti",
                normalizedTitle: "补充说明：如何集成 activiti？",
                charIndex: 1364
            }],
            headersStr: "1. 第一步，开启模块 2. 第二步，导入 SQL 3. 第三步，重启项目 666. 后续学习 补充说明：如何集成 Activiti？",
            content: "进度说明：\n\n * 管理后台，请使用 https://gitee.com/yudaocode/yudao-ui-admin-vue3 仓库的 master 分支\n * 后端项目，请使用 https://gitee.com/zhijiantianya/ruoyi-vue-pro 仓库的 master（JDK8） 或 master-jdk17（JDK17/21） 分支\n\nBPM 系统，后端由 yudao-module-bpm 模块实现，前端由 yudao-ui-admin-vue3 的 bpm 目录实现。\n\n考虑到编译速度，默认 yudao-module-bpm 模块是关闭的，需要手动开启。步骤如下：\n\n * 第一步，开启 yudao-module-bpm 模块\n * 第二步，导入 bpm 系统的 SQL 数据库脚本\n * 第三步，重启后端项目，确认功能是否生效\n\n\n# 1. 第一步，开启模块\n\n① 修改根目录的 pom.xml 文件，取消 yudao-module-bpm 模块的注释。\n\n\n\n② 第二步，修改 yudao-server 的 pom.xml 文件，取消 yudao-module-bpm-biz 依赖的注释，并进行 IDEA 的 Maven 刷新。\n\n\n\n③ 点击 IDEA 右上角的【Reload All Maven Projects】，刷新 Maven 依赖。如下图所示：\n\n\n\n\n# 2. 第二步，导入 SQL\n\n点击 bpm-2024-03-24.sql.zip 下载附件，解压出 SQL 文件，然后导入到数据库中。\n\n友情提示：↑↑↑ bpm.sql 是可以点击下载的！ ↑↑↑\n\n\n\n以 bpm_ 作为前缀的表，就是 BPM 模块的表。\n\n\n# 3. 第三步，重启项目\n\n重启后端项目，重启项目，看到 Property Source flowable-liquibase-override refreshed 说明开启成功。\n\n然后访问前端的 BPM 菜单，确认功能是否生效。如下图所示：\n\n\n\n另外，启动过程中，Flowable 会自动创建 ACT_ 和 FLW_ 开头的表。\n\n常见问题：\n\n① 问题：如果启动中报 MySQL “Specified key was too long; max key length is 1000 bytes” 错误？\n\n解决方案：可以将 MySQL 的缺省存储引擎设置为 innodb，即 default-storage-engine=innodb 配置项。\n\n② 问题：如果 Flowable 启动报错 problem during schema upgrade&&couldn‘t upgrade db schema 错误？\n\n解决方案：参见 https://www.cnblogs.com/sowler/p/17195427.html 帖子，MySQL 不区分大小写导致的，需要调整为区分。\n\n③ 问题：我想使用达梦数据库，怎么办？\n\n解决方案：参见 《工作流（达梦适配）》 文档。\n\n\n# 666. 后续学习\n\n建议阅读如下两篇文档，对整个工作流建立一个整体的认识：\n\n * 《审批接入（流程表单）》\n * 《审批接入（业务表单）》\n\n\n# 补充说明：如何集成 Activiti？\n\nActiviti 和 Flowable 提供的 Java API 是基本一致的，例如说 Flowable 的 org.flowable.engine.RepositoryService 对应 Activiti 的 org.activiti.engine .RepositoryService。所以，我们可以修改 import 的包路径来替换。\n\n另外，在项目的老版本，我们也提供了 Activiti 实现，你可以具体参考下：\n\n * yudao-spring-boot-starter-activiti\n * yudao-module-bpm-biz-activiti\n\n",
            normalizedContent: "进度说明：\n\n * 管理后台，请使用 https://gitee.com/yudaocode/yudao-ui-admin-vue3 仓库的 master 分支\n * 后端项目，请使用 https://gitee.com/zhijiantianya/ruoyi-vue-pro 仓库的 master（jdk8） 或 master-jdk17（jdk17/21） 分支\n\nbpm 系统，后端由 yudao-module-bpm 模块实现，前端由 yudao-ui-admin-vue3 的 bpm 目录实现。\n\n考虑到编译速度，默认 yudao-module-bpm 模块是关闭的，需要手动开启。步骤如下：\n\n * 第一步，开启 yudao-module-bpm 模块\n * 第二步，导入 bpm 系统的 sql 数据库脚本\n * 第三步，重启后端项目，确认功能是否生效\n\n\n# 1. 第一步，开启模块\n\n① 修改根目录的 pom.xml 文件，取消 yudao-module-bpm 模块的注释。\n\n\n\n② 第二步，修改 yudao-server 的 pom.xml 文件，取消 yudao-module-bpm-biz 依赖的注释，并进行 idea 的 maven 刷新。\n\n\n\n③ 点击 idea 右上角的【reload all maven projects】，刷新 maven 依赖。如下图所示：\n\n\n\n\n# 2. 第二步，导入 sql\n\n点击 bpm-2024-03-24.sql.zip 下载附件，解压出 sql 文件，然后导入到数据库中。\n\n友情提示：↑↑↑ bpm.sql 是可以点击下载的！ ↑↑↑\n\n\n\n以 bpm_ 作为前缀的表，就是 bpm 模块的表。\n\n\n# 3. 第三步，重启项目\n\n重启后端项目，重启项目，看到 property source flowable-liquibase-override refreshed 说明开启成功。\n\n然后访问前端的 bpm 菜单，确认功能是否生效。如下图所示：\n\n\n\n另外，启动过程中，flowable 会自动创建 act_ 和 flw_ 开头的表。\n\n常见问题：\n\n① 问题：如果启动中报 mysql “specified key was too long; max key length is 1000 bytes” 错误？\n\n解决方案：可以将 mysql 的缺省存储引擎设置为 innodb，即 default-storage-engine=innodb 配置项。\n\n② 问题：如果 flowable 启动报错 problem during schema upgrade&&couldn‘t upgrade db schema 错误？\n\n解决方案：参见 https://www.cnblogs.com/sowler/p/17195427.html 帖子，mysql 不区分大小写导致的，需要调整为区分。\n\n③ 问题：我想使用达梦数据库，怎么办？\n\n解决方案：参见 《工作流（达梦适配）》 文档。\n\n\n# 666. 后续学习\n\n建议阅读如下两篇文档，对整个工作流建立一个整体的认识：\n\n * 《审批接入（流程表单）》\n * 《审批接入（业务表单）》\n\n\n# 补充说明：如何集成 activiti？\n\nactiviti 和 flowable 提供的 java api 是基本一致的，例如说 flowable 的 org.flowable.engine.repositoryservice 对应 activiti 的 org.activiti.engine .repositoryservice。所以，我们可以修改 import 的包路径来替换。\n\n另外，在项目的老版本，我们也提供了 activiti 实现，你可以具体参考下：\n\n * yudao-spring-boot-starter-activiti\n * yudao-module-bpm-biz-activiti\n\n",
            charsets: {
                cjk: !0
            }
        }, {
            title: "工作流演示",
            frontmatter: {
                title: "工作流演示",
                permalink: "/bpm-preview",
                date: "2024-03-24T13:34:26.000Z"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/10.%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%89%8B%E5%86%8C/01.%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%BC%94%E7%A4%BA.html",
            relativePath: "01.开发指南/10.工作流手册/01.工作流演示.md",
            key: "v-062f85ec",
            path: "/bpm-preview/",
            headers: [{
                level: 2,
                title: "1. 演示地址",
                slug: "_1-演示地址",
                normalizedTitle: "1. 演示地址",
                charIndex: 62
            }, {
                level: 3,
                title: "1.1 BPM 管理后台",
                slug: "_1-1-bpm-管理后台",
                normalizedTitle: "1.1 bpm 管理后台",
                charIndex: 74
            }, {
                level: 3,
                title: "1.2 BPM 后端",
                slug: "_1-2-bpm-后端",
                normalizedTitle: "1.2 bpm 后端",
                charIndex: 267
            }, {
                level: 2,
                title: "2. 工作流启动",
                slug: "_2-工作流启动",
                normalizedTitle: "2. 工作流启动",
                charIndex: 462
            }, {
                level: 2,
                title: "3. 工作流交流",
                slug: "_3-工作流交流",
                normalizedTitle: "3. 工作流交流",
                charIndex: 514
            }, {
                level: 2,
                title: "4. 功能描述",
                slug: "_4-功能描述",
                normalizedTitle: "4. 功能描述",
                charIndex: 1043
            }, {
                level: 3,
                title: "4.1 BPMN 流程设计器",
                slug: "_4-1-bpmn-流程设计器",
                normalizedTitle: "4.1 bpmn 流程设计器",
                charIndex: 1959
            }, {
                level: 3,
                title: "4.2 钉钉（飞书）流程设计器",
                slug: "_4-2-钉钉-飞书-流程设计器",
                normalizedTitle: "4.2 钉钉（飞书）流程设计器",
                charIndex: 2059
            }, {
                level: 3,
                title: "4.3 审批界面",
                slug: "_4-3-审批界面",
                normalizedTitle: "4.3 审批界面",
                charIndex: 2100
            }],
            headersStr: "1. 演示地址 1.1 BPM 管理后台 1.2 BPM 后端 2. 工作流启动 3. 工作流交流 4. 功能描述 4.1 BPMN 流程设计器 4.2 钉钉（飞书）流程设计器 4.3 审批界面",
            content: "友情提示：BPM 全称是，业务流程管理（Business Process Management），实现工作流的功能\n\n\n# 1. 演示地址\n\n\n# 1.1 BPM 管理后台\n\n * 演示地址：http://dashboard-vue3.yudao.iocoder.cn/\n * 菜单：“工作流程”下的「流程管理」「审批菜单」「OA 实例」等\n * 仓库：https://github.com/yudaocode/yudao-ui-admin-vue3 的 bpm 目录，基于 Vue3 + Element Plus 实现\n\n\n\n\n# 1.2 BPM 后端\n\n支持 Spring Boot 单体、Spring Cloud 微服务架构\n\n * 单体仓库： https://github.com/YunaiV/ruoyi-vue-pro 的 yudao-module-bpm 模块\n * 微服务仓库： https://github.com/YunaiV/yudao-cloud 的 yudao-module-bpm 服务\n\n\n# 2. 工作流启动\n\n参见 《工作流手册 —— 功能开启》 文档，一般 3 分钟就可以启动完成。\n\n\n# 3. 工作流交流\n\n专属交流社区，欢迎扫码加入。\n\n\n\n微信扫描上方二维码，加入后可观看视频！\n\n * 01、如何集成 Flowable 框架？\n * 02、如何实现动态的流程表单？\n * 03、如何实现流程表单的保存？\n * 04、如何实现流程表单的展示？\n * 05、如何实现流程模型的新建？\n * 06、如何实现流程模型的流程图的设计？\n * 07、如何实现流程模型的流程图的预览？\n * 08、如何实现流程模型的分配规则？\n * 09、如何实现流程模型的发布？\n * 10、如何实现流程定义的查询？\n * 11、如何实现流程的发起？\n * 12、如何实现我的流程列表？\n * 13、如何实现流程的取消？\n * 14、如何实现流程的任务分配？\n * 15、如何实现会签、或签任务？\n * 16、如何实现我的待办任务列表？\n * 17、如何实现我的已办任务列表？\n * 18、如何实现任务的审批通过？\n * 19、如何实现任务的审批不通过？\n * 20、如何实现流程的审批记录？\n * 21、如何实现流程的流程图的高亮？\n * 22、如何实现工作流的短信通知？\n * 23、如何实现 OA 请假的发起？\n * 24、如何实现 OA 请假的审批？\n\n\n# 4. 功能描述\n\n\n\n基于 Flowable 构建，满足中国特色流程操作：\n\n功能     描述                                                           进度\n会签     同一个审批节点设置多个人（如 A、B、C 三人，三人会同时收到待办任务），需全部同意之后，审批才可到下一审批节点     ✅\n或签     同一个审批节点设置多个人，任意一个人处理后，就能进入下一个节点                              ✅\n依次审批   （顺序会签）同一个审批节点设置多个人（如 A、B、C 三人），三人按顺序依次收到待办，即 A 先审批，A 提交后 B   ✅\n       才能审批，需全部同意之后，审批才可到下一审批节点\n抄送     将审批结果通知给抄送列表对应的人，同一个流程实例默认不重复抄送给同一人                          ✅\n驳回     （退回）将审批重置发送给某节点，重新审批                                         ✅\n转办     A 转给其 B 审批，B 审批后，进入下一节点                                      ✅\n委派     A 转给其 B 审批，B 审批后，转给 A，A 继续审批后进入下一节点                          ✅\n加签     允许当前办理人根据需要，自行增加当前办理节点的办理人员，支持向前、向后加签                        ✅\n减签     在当前办理人操作之前减少办理人                                              ✅\n撤销     流程发起者可以对流程进行撤销处理                                             ✅\n终止     在任意节点终止流程实例                                                  ✅\n\n\n# 4.1 BPMN 流程设计器\n\n\n\n * 《流程设计器（BPMN）》\n * 《选择审批人、发起人自选》\n * 《会签、或签、依次审批》\n * 《执行监听器、任务监听器》\n * 《流程表达式》\n\n\n# 4.2 钉钉（飞书）流程设计器\n\n\n\n * 《流程设计器（钉钉、飞书）》\n\n\n# 4.3 审批界面\n\n\n\n * 《审批接入（流程表单）》\n * 《审批接入（业务表单）》\n * 《流程发起、取消、重新发起》\n * 《审批通过、不通过、驳回》\n * 《审批加签、减签》\n * 《审批转办、委派、抄送》\n * 《流程审批通知》",
            normalizedContent: "友情提示：bpm 全称是，业务流程管理（business process management），实现工作流的功能\n\n\n# 1. 演示地址\n\n\n# 1.1 bpm 管理后台\n\n * 演示地址：http://dashboard-vue3.yudao.iocoder.cn/\n * 菜单：“工作流程”下的「流程管理」「审批菜单」「oa 实例」等\n * 仓库：https://github.com/yudaocode/yudao-ui-admin-vue3 的 bpm 目录，基于 vue3 + element plus 实现\n\n\n\n\n# 1.2 bpm 后端\n\n支持 spring boot 单体、spring cloud 微服务架构\n\n * 单体仓库： https://github.com/yunaiv/ruoyi-vue-pro 的 yudao-module-bpm 模块\n * 微服务仓库： https://github.com/yunaiv/yudao-cloud 的 yudao-module-bpm 服务\n\n\n# 2. 工作流启动\n\n参见 《工作流手册 —— 功能开启》 文档，一般 3 分钟就可以启动完成。\n\n\n# 3. 工作流交流\n\n专属交流社区，欢迎扫码加入。\n\n\n\n微信扫描上方二维码，加入后可观看视频！\n\n * 01、如何集成 flowable 框架？\n * 02、如何实现动态的流程表单？\n * 03、如何实现流程表单的保存？\n * 04、如何实现流程表单的展示？\n * 05、如何实现流程模型的新建？\n * 06、如何实现流程模型的流程图的设计？\n * 07、如何实现流程模型的流程图的预览？\n * 08、如何实现流程模型的分配规则？\n * 09、如何实现流程模型的发布？\n * 10、如何实现流程定义的查询？\n * 11、如何实现流程的发起？\n * 12、如何实现我的流程列表？\n * 13、如何实现流程的取消？\n * 14、如何实现流程的任务分配？\n * 15、如何实现会签、或签任务？\n * 16、如何实现我的待办任务列表？\n * 17、如何实现我的已办任务列表？\n * 18、如何实现任务的审批通过？\n * 19、如何实现任务的审批不通过？\n * 20、如何实现流程的审批记录？\n * 21、如何实现流程的流程图的高亮？\n * 22、如何实现工作流的短信通知？\n * 23、如何实现 oa 请假的发起？\n * 24、如何实现 oa 请假的审批？\n\n\n# 4. 功能描述\n\n\n\n基于 flowable 构建，满足中国特色流程操作：\n\n功能     描述                                                           进度\n会签     同一个审批节点设置多个人（如 a、b、c 三人，三人会同时收到待办任务），需全部同意之后，审批才可到下一审批节点     ✅\n或签     同一个审批节点设置多个人，任意一个人处理后，就能进入下一个节点                              ✅\n依次审批   （顺序会签）同一个审批节点设置多个人（如 a、b、c 三人），三人按顺序依次收到待办，即 a 先审批，a 提交后 b   ✅\n       才能审批，需全部同意之后，审批才可到下一审批节点\n抄送     将审批结果通知给抄送列表对应的人，同一个流程实例默认不重复抄送给同一人                          ✅\n驳回     （退回）将审批重置发送给某节点，重新审批                                         ✅\n转办     a 转给其 b 审批，b 审批后，进入下一节点                                      ✅\n委派     a 转给其 b 审批，b 审批后，转给 a，a 继续审批后进入下一节点                          ✅\n加签     允许当前办理人根据需要，自行增加当前办理节点的办理人员，支持向前、向后加签                        ✅\n减签     在当前办理人操作之前减少办理人                                              ✅\n撤销     流程发起者可以对流程进行撤销处理                                             ✅\n终止     在任意节点终止流程实例                                                  ✅\n\n\n# 4.1 bpmn 流程设计器\n\n\n\n * 《流程设计器（bpmn）》\n * 《选择审批人、发起人自选》\n * 《会签、或签、依次审批》\n * 《执行监听器、任务监听器》\n * 《流程表达式》\n\n\n# 4.2 钉钉（飞书）流程设计器\n\n\n\n * 《流程设计器（钉钉、飞书）》\n\n\n# 4.3 审批界面\n\n\n\n * 《审批接入（流程表单）》\n * 《审批接入（业务表单）》\n * 《流程发起、取消、重新发起》\n * 《审批通过、不通过、驳回》\n * 《审批加签、减签》\n * 《审批转办、委派、抄送》\n * 《流程审批通知》",
            charsets: {
                cjk: !0
            }
        }, {
            title: "工作流（达梦适配）",
            frontmatter: {
                title: "工作流（达梦适配）",
                date: "2023-11-26T11:26:00.000Z",
                permalink: "/bpm/dameng/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/10.%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%89%8B%E5%86%8C/03.%E5%B7%A5%E4%BD%9C%E6%B5%81%EF%BC%88%E8%BE%BE%E6%A2%A6%E9%80%82%E9%85%8D%EF%BC%89.html",
            relativePath: "01.开发指南/10.工作流手册/03.工作流（达梦适配）.md",
            key: "v-cc2f8ada",
            path: "/bpm/dameng/",
            headers: [{
                level: 2,
                title: "1. 覆盖 Flowable Liquibase 相关代码",
                slug: "_1-覆盖-flowable-liquibase-相关代码",
                normalizedTitle: "1. 覆盖 flowable liquibase 相关代码",
                charIndex: 107
            }, {
                level: 2,
                title: "2. 关于 flowable.database-schema-update 配置",
                slug: "_2-关于-flowable-database-schema-update-配置",
                normalizedTitle: "2. 关于 flowable.database-schema-update 配置",
                charIndex: 216
            }],
            headersStr: "1. 覆盖 Flowable Liquibase 相关代码 2. 关于 flowable.database-schema-update 配置",
            content: "友情提示：\n\n本文参考 《Flowable6.8(6.x 版本通用)整合集成达梦 8 数据库(DM8)详解，解决自动生成表时 dmn 相关表语法报错问题》 博客，由开发者（微信号 barry82）所贡献！\n\n\n# 1. 覆盖 Flowable Liquibase 相关代码\n\n把项目的 sql/dm/flowable-patch/src 下的文件，复制到 yudao-module-bpm-biz 项目的 src 目录中。\n\n\n# 2. 关于 flowable.database-schema-update 配置\n\n① 首次运行，全局搜 flowable.database-schema-update 配置项，修改为 true，以便生成 Flowable 数据库表。\n\n② 再次运行，全局搜 flowable.database-schema-update 配置项，修改为 false，避免如下报错：\n\nObject [FLW_EV_DATABASECHANGELOG] already exists\n\n\n----------------------------------------\n\nps：😭 MacBook 从 Intel 平台迁移到 M1 平台，达梦数据库的环境坏了，先暂时把相关的操作写到文档里，算是给大家做适配一个方向！",
            normalizedContent: "友情提示：\n\n本文参考 《flowable6.8(6.x 版本通用)整合集成达梦 8 数据库(dm8)详解，解决自动生成表时 dmn 相关表语法报错问题》 博客，由开发者（微信号 barry82）所贡献！\n\n\n# 1. 覆盖 flowable liquibase 相关代码\n\n把项目的 sql/dm/flowable-patch/src 下的文件，复制到 yudao-module-bpm-biz 项目的 src 目录中。\n\n\n# 2. 关于 flowable.database-schema-update 配置\n\n① 首次运行，全局搜 flowable.database-schema-update 配置项，修改为 true，以便生成 flowable 数据库表。\n\n② 再次运行，全局搜 flowable.database-schema-update 配置项，修改为 false，避免如下报错：\n\nobject [flw_ev_databasechangelog] already exists\n\n\n----------------------------------------\n\nps：😭 macbook 从 intel 平台迁移到 m1 平台，达梦数据库的环境坏了，先暂时把相关的操作写到文档里，算是给大家做适配一个方向！",
            charsets: {
                cjk: !0
            }
        }, {
            title: "审批接入（业务表单）",
            frontmatter: {
                title: "审批接入（业务表单）",
                date: "2022-03-07T12:40:00.000Z",
                permalink: "/bpm/use-business-form/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/10.%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%89%8B%E5%86%8C/05.%E5%AE%A1%E6%89%B9%E6%8E%A5%E5%85%A5%EF%BC%88%E4%B8%9A%E5%8A%A1%E8%A1%A8%E5%8D%95%EF%BC%89.html",
            relativePath: "01.开发指南/10.工作流手册/05.审批接入（业务表单）.md",
            key: "v-1c97a241",
            path: "/bpm/use-business-form/",
            headers: [{
                level: 2,
                title: "1. 业务接入（业务表单）",
                slug: "_1-业务接入-业务表单",
                normalizedTitle: "1. 业务接入（业务表单）",
                charIndex: 237
            }, {
                level: 3,
                title: "1.0 第零步：业务开发",
                slug: "_1-0-第零步-业务开发",
                normalizedTitle: "1.0 第零步：业务开发",
                charIndex: 621
            }, {
                level: 3,
                title: "2.1 第一步：定义流程",
                slug: "_2-1-第一步-定义流程",
                normalizedTitle: "2.1 第一步：定义流程",
                charIndex: 3996
            }, {
                level: 3,
                title: "2.2 第二步：发起流程",
                slug: "_2-2-第二步-发起流程",
                normalizedTitle: "2.2 第二步：发起流程",
                charIndex: 4839
            }, {
                level: 3,
                title: "2.3 第三步：审批流程",
                slug: "_2-3-第三步-审批流程",
                normalizedTitle: "2.3 第三步：审批流程",
                charIndex: 5175
            }, {
                level: 2,
                title: "2. 选择业务表单、流程表单？",
                slug: "_2-选择业务表单、流程表单",
                normalizedTitle: "2. 选择业务表单、流程表单？",
                charIndex: 5310
            }, {
                level: 2,
                title: "3. 业务表单是如何集成的？",
                slug: "_3-业务表单是如何集成的",
                normalizedTitle: "3. 业务表单是如何集成的？",
                charIndex: 5502
            }],
            headersStr: "1. 业务接入（业务表单） 1.0 第零步：业务开发 2.1 第一步：定义流程 2.2 第二步：发起流程 2.3 第三步：审批流程 2. 选择业务表单、流程表单？ 3. 业务表单是如何集成的？",
            content: "相关视频：\n\n * 23、如何实现 OA 请假的发起？\n * 24、如何实现 OA 请假的审批？\n\n本文接 《审批接入（流程表单）》，讲解的是「业务接入（业务表单）」的流程：业务需建立独立的数据库表，并开发对应的表单、详情界面。\n\n整个过程，还是：\n\n 1. 定义流程：【管理员】新建流程、设计流程模型、并设置用户任务的审批人，最终发布流程\n 2. 发起流程：【员工】选择流程，并发起流程实例\n 3. 审批流程：【审批人】接收到流程任务，审批结果为通过或不通过\n\n\n\n\n# 1. 业务接入（业务表单）\n\n根据业务需要，业务通过建立独立的数据库表（业务表）记录申请信息，而流程引擎只负责推动流程的前进或者结束。两者需要进行双向的关联：\n\n * 每一条业务表记录，通过它的流程实例的编号( process_instance_id )指向对应的流程实例\n * 每一个流程实例，通过它的业务键( BUSINESS_KEY_ ) 指向对应的业务表记录\n\n以项目中提供的 OALeave 请假举例子，它的业务表 bpm_oa_leave 和流程引擎的流程实例的关系如下图：\n\n\n\n也因为业务建立了独立的业务表，所以必须开发业务表对应的列表、表单、详情页面。不过，审核相关的功能是无需重新开发的，原因是业务表已经关联对应的流程实例，流程引擎审批流程实例即可。\n\n下面，我们以项目中的 OALeave 为例子，详细讲解下业务表单的开发与使用的过程。\n\n\n# 1.0 第零步：业务开发\n\n# 1.0.1 新建业务表\n\n新建业务表 bpm_oa_leave，建表语句如下：\n\nCREATE TABLE `bpm_oa_leave` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '请假表单主键',\n  `user_id` bigint NOT NULL COMMENT '申请人的用户编号',\n  `type` tinyint NOT NULL COMMENT '请假类型',\n  `reason` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '请假原因',\n  `start_time` datetime NOT NULL COMMENT '开始时间',\n  `end_time` datetime NOT NULL COMMENT '结束时间',\n  `day` tinyint NOT NULL COMMENT '请假天数',\n  `status` tinyint NOT NULL COMMENT '请假结果',\n  `process_instance_id` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '流程实例的编号',\n  `creator` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT '' COMMENT '创建者',\n  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\n  `updater` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT '' COMMENT '更新者',\n  `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',\n  `deleted` bit(1) NOT NULL DEFAULT b'0' COMMENT '是否删除',\n  `tenant_id` bigint NOT NULL DEFAULT '0' COMMENT '租户编号',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=26 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='OA 请假申请表';\n\n\n重点是两个字段：\n\n * process_instance_id 字段，关联流程引擎的流程实例对应的 ACT_HI_PROCINST 表的 PROC_INST_ID_ 字段\n * status 字段，请假结果，需要通过 Listener 监听回调结果，稍后来看看\n\n# 1.0.2 【后端】实现业务逻辑\n\n实现业务表的【后端】业务逻辑，具体代码可以看看如下两个类：\n\n * BpmOALeaveController\n * BpmOALeaveServiceImpl\n\n重点是看流程发起的逻辑，它定义了 /bpm/oa/leave/create 给业务的表单界面调用，UML 时序图如下：\n\n\n\n具体的实现代码比较简单，如下图所示：\n\n\n\n * PROCESS_KEY 静态变量：是业务对应的流程模型的编号，稍后会进行创建编号为 oa_leave 的流程模型。\n * BpmProcessInstanceApi 定义了 #createProcessInstance(...) 方法，用于创建流程实例，业务无需关心底层是 Flowable 引擎，还是 Activiti、Camunda 引擎。\n\n# 1.0.3 【前端】实现业务逻辑\n\n实现业务表的【前端】业务逻辑，具体代码可以看看如下三个页面：\n\n * 请假发起界面：leave/create.vue\n * 请假详情界面：leave/detail.vue\n * 请假列表界面：leave/index.vue\n\n另外，在 router/modules/remaining.ts 中定义 create.vue 和 detail.vue 的路由，配置如下：\n\n{\n    path: '/bpm',\n    component: Layout,\n    name: 'bpm',\n    meta: {\n      hidden: true\n    },\n    children: [\n      {\n        path: 'oa/leave/create',\n        component: () => import('@/views/bpm/oa/leave/create.vue'),\n        name: 'OALeaveCreate',\n        meta: {\n          noCache: true,\n          hidden: true,\n          canTo: true,\n          title: '发起 OA 请假',\n          activeMenu: '/bpm/oa/leave'\n        }\n      },\n      {\n        path: 'oa/leave/detail',\n        component: () => import('@/views/bpm/oa/leave/detail.vue'),\n        name: 'OALeaveDetail',\n        meta: {\n          noCache: true,\n          hidden: true,\n          canTo: true,\n          title: '查看 OA 请假',\n          activeMenu: '/bpm/oa/leave'\n        }\n      }\n    ]\n}\n\n\n为什么要做独立的 `create.vue` 和 `index.vue` 页面？\n\n * 创建流程时，需要跳转到 create.vue 页面，填写业务表的信息，才能提交流程。\n * 审批流程时，需要跳转到 detail.vue 页面，查看业务表的信息。\n\n# 1.0.4 【实现】实现审批结果的监听\n\n审批结束时（例如说流程实例最终被审批通过、不通过、取消），后端需要监听审批结果，然后更新业务表的状态。\n\n具体可见 BpmOALeaveStatusListener 监听器，它实现流程引擎定义的 BpmProcessInstanceStatusEventListener 抽象类，在流程实例结束时，回调通知它最终的结果是通过还是不通过。代码如下图：\n\n\n\n友情提示：BpmProcessInstanceStatusEventListener 是什么呢？\n\nBpmProcessInstanceStatusEventListener 是我们框架自己封装的一个监听器，用于监听流程实例的最终结果。在流程实例结束时，会回调通知它。\n\n如果你自己的业务接入工作流，并且需要监听审批结果，必须继承它，实现自己的监听器！！！\n\n----------------------------------------\n\n至此，我们了解了 OALeave 使用业务表单所涉及到的开发，下面我们来定义对应的流程、发起该流程、并审批该流程。\n\n友情提示：从这一步开始，和「1. 请假流程【流程表单】」的流程基本是一致的，所以重点还是上面。\n\n\n# 2.1 第一步：定义流程\n\n登录账号 admin、密码 admin123 的用户，扮演【管理员】的角色，进行流程的定义。\n\n# 1.1.1 新建流程\n\n访问 [工作流程 -> 流程管理 -> 流程模型] 菜单，点击「新建流程」按钮，填写流程标识、流程名称。如下图所示：\n\n\n\n注意，流程标识需要填 oa_leave。因为在 BpmOALeaveServiceImpl 类中，发起流程的标识是 oa_leave。\n\n# 1.1.2 修改流程\n\n点击「修改流程」按钮，配置表单类型为业务表单，填写表单提交路由为 /bpm/oa/leave/create（用于发起流程时，跳转的业务表单的路由）、表单查看路由为 /bpm/oa/leave/detail（用于在流程详情中，点击查看表单的路由）。如下图所示：\n\n\n\n友情提示：注意！！！`/bpm/oa/leave/create` 和 `/bpm/oa/leave/detail`，都是相对 `/views` 开始的 Vue 文件的路径！！！\n\n# 1.1.3 设计流程\n\n① 点击「设计流程」按钮，在线设计请假流程模型，包含两个用户任务：领导审批、HR 审批。如下图所示：\n\n\n\n可以点击 oa_leave_bpmn.XML 进行下载，然后点击「打开文件」按钮，进行导入。\n\n② 点击图中的“领导审批”，规则类型为“流程表达式”，流程表达式为 ${bpmTaskAssignLeaderExpression.calculateUsers(execution, 1)}。如下图所示：\n\n\n\n友情提示：该流程表达式的作用是，流程发起人的一级领导。\n\n为什么呢？这块我们在 《流程表达式》 详细讲解。\n\n点击图中的“HR 审批”，规则类型为“岗位”，指定岗位为“人力资源”。如下图所示：\n\n\n\n之后，点击右上角的「保存模型」按钮，完成流程模型的设计。\n\n③ 点击「发布流程」按钮，把定义的流程模型部署出去。部署成功后，就可以发起该流程了。\n\n\n# 2.2 第二步：发起流程\n\n登录账号 admin、密码 admin123 的用户，扮演【员工】的角色，进行流程的发起。\n\n① 发起业务表单请假流程，两种路径：\n\n 1. 访问 [工作流程 -> 审批中心 -> 发起流程] 菜单，选择“OA 请求”流程，会跳转到流程模型 oa_leave 配置的表单提交路由。\n\n 2. 访问 [工作流程 -> OA 示例 -> 请假查询] 菜单，点击「发起请假」按钮。\n\n② 填写一个小于等于 3 天的请假，只会走【领导审批】任务；填写一个大于 3 天的请假，在走完【领导审批】任务后，会额外走【HR 审批】任务。\n\n后续的流程，和 审批接入（流程表单） 是基本一致的，这里就不重复赘述，当然你还是要试着跑一跑，了解整个的过程。\n\n\n# 2.3 第三步：审批流程\n\n略~自己跑\n\n * 登录账号 test、密码 test123 的用户，扮演【审批人】的角色，进行请假流程的【领导审批】任务\n * 登录账号 hrmgr、密码 hr123 的用户，扮演【审批人】的角色，进行请假流程的【HR 审批】任务\n\n\n# 2. 选择业务表单、流程表单？\n\n流程表单，适合简单业务，无需开发的那种。大多数场景下，我们还是选择业务表单，例如说：\n\n * 《CRM 手册 —— 【合同】合同管理、合同提醒》 的合同审批\n * 《CRM 手册 —— 【回款】回款管理、回款计划》 的回款审批\n\n也就是说，审批只是业务的一个环节，而不是整个业务的所有。所以，我们选择业务表单，是为了更好的支持业务的复杂度。\n\n\n# 3. 业务表单是如何集成的？\n\n① 流程发起时，会跳转流程模型配置的“表单提交路由”，代码如下图所示：\n\n\n\n② 流程详情时，需要展示业务表单详情时，通过 Vue3 异步组件 特性，将展示流程模型配置的“表单查看路由”，代码如下图所示：\n\n",
            normalizedContent: "相关视频：\n\n * 23、如何实现 oa 请假的发起？\n * 24、如何实现 oa 请假的审批？\n\n本文接 《审批接入（流程表单）》，讲解的是「业务接入（业务表单）」的流程：业务需建立独立的数据库表，并开发对应的表单、详情界面。\n\n整个过程，还是：\n\n 1. 定义流程：【管理员】新建流程、设计流程模型、并设置用户任务的审批人，最终发布流程\n 2. 发起流程：【员工】选择流程，并发起流程实例\n 3. 审批流程：【审批人】接收到流程任务，审批结果为通过或不通过\n\n\n\n\n# 1. 业务接入（业务表单）\n\n根据业务需要，业务通过建立独立的数据库表（业务表）记录申请信息，而流程引擎只负责推动流程的前进或者结束。两者需要进行双向的关联：\n\n * 每一条业务表记录，通过它的流程实例的编号( process_instance_id )指向对应的流程实例\n * 每一个流程实例，通过它的业务键( business_key_ ) 指向对应的业务表记录\n\n以项目中提供的 oaleave 请假举例子，它的业务表 bpm_oa_leave 和流程引擎的流程实例的关系如下图：\n\n\n\n也因为业务建立了独立的业务表，所以必须开发业务表对应的列表、表单、详情页面。不过，审核相关的功能是无需重新开发的，原因是业务表已经关联对应的流程实例，流程引擎审批流程实例即可。\n\n下面，我们以项目中的 oaleave 为例子，详细讲解下业务表单的开发与使用的过程。\n\n\n# 1.0 第零步：业务开发\n\n# 1.0.1 新建业务表\n\n新建业务表 bpm_oa_leave，建表语句如下：\n\ncreate table `bpm_oa_leave` (\n  `id` bigint not null auto_increment comment '请假表单主键',\n  `user_id` bigint not null comment '申请人的用户编号',\n  `type` tinyint not null comment '请假类型',\n  `reason` varchar(200) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '请假原因',\n  `start_time` datetime not null comment '开始时间',\n  `end_time` datetime not null comment '结束时间',\n  `day` tinyint not null comment '请假天数',\n  `status` tinyint not null comment '请假结果',\n  `process_instance_id` varchar(64) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '流程实例的编号',\n  `creator` varchar(64) character set utf8mb4 collate utf8mb4_unicode_ci default '' comment '创建者',\n  `create_time` datetime not null default current_timestamp comment '创建时间',\n  `updater` varchar(64) character set utf8mb4 collate utf8mb4_unicode_ci default '' comment '更新者',\n  `update_time` datetime not null default current_timestamp on update current_timestamp comment '更新时间',\n  `deleted` bit(1) not null default b'0' comment '是否删除',\n  `tenant_id` bigint not null default '0' comment '租户编号',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=26 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='oa 请假申请表';\n\n\n重点是两个字段：\n\n * process_instance_id 字段，关联流程引擎的流程实例对应的 act_hi_procinst 表的 proc_inst_id_ 字段\n * status 字段，请假结果，需要通过 listener 监听回调结果，稍后来看看\n\n# 1.0.2 【后端】实现业务逻辑\n\n实现业务表的【后端】业务逻辑，具体代码可以看看如下两个类：\n\n * bpmoaleavecontroller\n * bpmoaleaveserviceimpl\n\n重点是看流程发起的逻辑，它定义了 /bpm/oa/leave/create 给业务的表单界面调用，uml 时序图如下：\n\n\n\n具体的实现代码比较简单，如下图所示：\n\n\n\n * process_key 静态变量：是业务对应的流程模型的编号，稍后会进行创建编号为 oa_leave 的流程模型。\n * bpmprocessinstanceapi 定义了 #createprocessinstance(...) 方法，用于创建流程实例，业务无需关心底层是 flowable 引擎，还是 activiti、camunda 引擎。\n\n# 1.0.3 【前端】实现业务逻辑\n\n实现业务表的【前端】业务逻辑，具体代码可以看看如下三个页面：\n\n * 请假发起界面：leave/create.vue\n * 请假详情界面：leave/detail.vue\n * 请假列表界面：leave/index.vue\n\n另外，在 router/modules/remaining.ts 中定义 create.vue 和 detail.vue 的路由，配置如下：\n\n{\n    path: '/bpm',\n    component: layout,\n    name: 'bpm',\n    meta: {\n      hidden: true\n    },\n    children: [\n      {\n        path: 'oa/leave/create',\n        component: () => import('@/views/bpm/oa/leave/create.vue'),\n        name: 'oaleavecreate',\n        meta: {\n          nocache: true,\n          hidden: true,\n          canto: true,\n          title: '发起 oa 请假',\n          activemenu: '/bpm/oa/leave'\n        }\n      },\n      {\n        path: 'oa/leave/detail',\n        component: () => import('@/views/bpm/oa/leave/detail.vue'),\n        name: 'oaleavedetail',\n        meta: {\n          nocache: true,\n          hidden: true,\n          canto: true,\n          title: '查看 oa 请假',\n          activemenu: '/bpm/oa/leave'\n        }\n      }\n    ]\n}\n\n\n为什么要做独立的 `create.vue` 和 `index.vue` 页面？\n\n * 创建流程时，需要跳转到 create.vue 页面，填写业务表的信息，才能提交流程。\n * 审批流程时，需要跳转到 detail.vue 页面，查看业务表的信息。\n\n# 1.0.4 【实现】实现审批结果的监听\n\n审批结束时（例如说流程实例最终被审批通过、不通过、取消），后端需要监听审批结果，然后更新业务表的状态。\n\n具体可见 bpmoaleavestatuslistener 监听器，它实现流程引擎定义的 bpmprocessinstancestatuseventlistener 抽象类，在流程实例结束时，回调通知它最终的结果是通过还是不通过。代码如下图：\n\n\n\n友情提示：bpmprocessinstancestatuseventlistener 是什么呢？\n\nbpmprocessinstancestatuseventlistener 是我们框架自己封装的一个监听器，用于监听流程实例的最终结果。在流程实例结束时，会回调通知它。\n\n如果你自己的业务接入工作流，并且需要监听审批结果，必须继承它，实现自己的监听器！！！\n\n----------------------------------------\n\n至此，我们了解了 oaleave 使用业务表单所涉及到的开发，下面我们来定义对应的流程、发起该流程、并审批该流程。\n\n友情提示：从这一步开始，和「1. 请假流程【流程表单】」的流程基本是一致的，所以重点还是上面。\n\n\n# 2.1 第一步：定义流程\n\n登录账号 admin、密码 admin123 的用户，扮演【管理员】的角色，进行流程的定义。\n\n# 1.1.1 新建流程\n\n访问 [工作流程 -> 流程管理 -> 流程模型] 菜单，点击「新建流程」按钮，填写流程标识、流程名称。如下图所示：\n\n\n\n注意，流程标识需要填 oa_leave。因为在 bpmoaleaveserviceimpl 类中，发起流程的标识是 oa_leave。\n\n# 1.1.2 修改流程\n\n点击「修改流程」按钮，配置表单类型为业务表单，填写表单提交路由为 /bpm/oa/leave/create（用于发起流程时，跳转的业务表单的路由）、表单查看路由为 /bpm/oa/leave/detail（用于在流程详情中，点击查看表单的路由）。如下图所示：\n\n\n\n友情提示：注意！！！`/bpm/oa/leave/create` 和 `/bpm/oa/leave/detail`，都是相对 `/views` 开始的 vue 文件的路径！！！\n\n# 1.1.3 设计流程\n\n① 点击「设计流程」按钮，在线设计请假流程模型，包含两个用户任务：领导审批、hr 审批。如下图所示：\n\n\n\n可以点击 oa_leave_bpmn.xml 进行下载，然后点击「打开文件」按钮，进行导入。\n\n② 点击图中的“领导审批”，规则类型为“流程表达式”，流程表达式为 ${bpmtaskassignleaderexpression.calculateusers(execution, 1)}。如下图所示：\n\n\n\n友情提示：该流程表达式的作用是，流程发起人的一级领导。\n\n为什么呢？这块我们在 《流程表达式》 详细讲解。\n\n点击图中的“hr 审批”，规则类型为“岗位”，指定岗位为“人力资源”。如下图所示：\n\n\n\n之后，点击右上角的「保存模型」按钮，完成流程模型的设计。\n\n③ 点击「发布流程」按钮，把定义的流程模型部署出去。部署成功后，就可以发起该流程了。\n\n\n# 2.2 第二步：发起流程\n\n登录账号 admin、密码 admin123 的用户，扮演【员工】的角色，进行流程的发起。\n\n① 发起业务表单请假流程，两种路径：\n\n 1. 访问 [工作流程 -> 审批中心 -> 发起流程] 菜单，选择“oa 请求”流程，会跳转到流程模型 oa_leave 配置的表单提交路由。\n\n 2. 访问 [工作流程 -> oa 示例 -> 请假查询] 菜单，点击「发起请假」按钮。\n\n② 填写一个小于等于 3 天的请假，只会走【领导审批】任务；填写一个大于 3 天的请假，在走完【领导审批】任务后，会额外走【hr 审批】任务。\n\n后续的流程，和 审批接入（流程表单） 是基本一致的，这里就不重复赘述，当然你还是要试着跑一跑，了解整个的过程。\n\n\n# 2.3 第三步：审批流程\n\n略~自己跑\n\n * 登录账号 test、密码 test123 的用户，扮演【审批人】的角色，进行请假流程的【领导审批】任务\n * 登录账号 hrmgr、密码 hr123 的用户，扮演【审批人】的角色，进行请假流程的【hr 审批】任务\n\n\n# 2. 选择业务表单、流程表单？\n\n流程表单，适合简单业务，无需开发的那种。大多数场景下，我们还是选择业务表单，例如说：\n\n * 《crm 手册 —— 【合同】合同管理、合同提醒》 的合同审批\n * 《crm 手册 —— 【回款】回款管理、回款计划》 的回款审批\n\n也就是说，审批只是业务的一个环节，而不是整个业务的所有。所以，我们选择业务表单，是为了更好的支持业务的复杂度。\n\n\n# 3. 业务表单是如何集成的？\n\n① 流程发起时，会跳转流程模型配置的“表单提交路由”，代码如下图所示：\n\n\n\n② 流程详情时，需要展示业务表单详情时，通过 vue3 异步组件 特性，将展示流程模型配置的“表单查看路由”，代码如下图所示：\n\n",
            charsets: {
                cjk: !0
            }
        }, {
            title: "审批接入（流程表单）",
            frontmatter: {
                title: "审批接入（流程表单）",
                date: "2024-03-24T19:21:47.000Z",
                permalink: "/bpm/use-bpm-form/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/10.%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%89%8B%E5%86%8C/04.%E5%AE%A1%E6%89%B9%E6%8E%A5%E5%85%A5%EF%BC%88%E6%B5%81%E7%A8%8B%E8%A1%A8%E5%8D%95%EF%BC%89.html",
            relativePath: "01.开发指南/10.工作流手册/04.审批接入（流程表单）.md",
            key: "v-66fc1dcc",
            path: "/bpm/use-bpm-form/",
            headers: [{
                level: 2,
                title: "1. 业务接入（流程表单）",
                slug: "_1-业务接入-流程表单",
                normalizedTitle: "1. 业务接入（流程表单）",
                charIndex: 364
            }, {
                level: 3,
                title: "1.1 第一步：定义流程",
                slug: "_1-1-第一步-定义流程",
                normalizedTitle: "1.1 第一步：定义流程",
                charIndex: 382
            }, {
                level: 3,
                title: "2. 第二步：发起流程",
                slug: "_2-第二步-发起流程",
                normalizedTitle: "2. 第二步：发起流程",
                charIndex: 1879
            }, {
                level: 3,
                title: "3. 第三步：审批流程",
                slug: "_3-第三步-审批流程",
                normalizedTitle: "3. 第三步：审批流程",
                charIndex: 2151
            }, {
                level: 2,
                title: "2. 菜单【流程表单】",
                slug: "_2-菜单【流程表单】",
                normalizedTitle: "2. 菜单【流程表单】",
                charIndex: 2715
            }, {
                level: 3,
                title: "2.1 表结构",
                slug: "_2-1-表结构",
                normalizedTitle: "2.1 表结构",
                charIndex: 2833
            }, {
                level: 3,
                title: "2.2 前端组件",
                slug: "_2-2-前端组件",
                normalizedTitle: "2.2 前端组件",
                charIndex: 4899
            }, {
                level: 2,
                title: "666. 常见问题？",
                slug: "_666-常见问题",
                normalizedTitle: "666. 常见问题？",
                charIndex: 5549
            }],
            headersStr: "1. 业务接入（流程表单） 1.1 第一步：定义流程 2. 第二步：发起流程 3. 第三步：审批流程 2. 菜单【流程表单】 2.1 表结构 2.2 前端组件 666. 常见问题？",
            content: '相关视频：\n\n * 02、如何实现动态的流程表单？\n * 03、如何实现流程表单的保存？\n * 04、如何实现流程表单的展示？\n\n项目基于 Flowable 实现了工作流的功能，提供两种方式接入：\n\n * ① 【流程表单】：在线配置动态表单，无需建表与开发\n * ② 【业务表单】：业务需建立独立的数据库表，并开发对应的表单、详情界面\n\n我们以“请假流程”为例子，讲解两种接入方式的差异，整个过程包括：\n\n 1. 定义流程：【管理员】新建流程、设计流程模型、并设置用户任务的审批人，最终发布流程\n 2. 发起流程：【员工】选择流程，并发起流程实例\n 3. 审批流程：【审批人】接收到流程任务，审批结果为通过或不通过\n\n\n\n本文，我们讲解的是「业务接入（流程表单）」的流程，复杂业务接入的流程请查看业务接入（业务表单）。\n\n\n# 1. 业务接入（流程表单）\n\n\n# 1.1 第一步：定义流程\n\n登录账号 admin、密码 admin123 的用户，扮演【管理员】的角色，进行流程的定义。\n\n# 1.1.1 新建流程\n\n访问 [工作流程 -> 流程管理 -> 流程模型] 菜单，点击「新建流程」按钮，填写流程标识、流程名称。如下图所示：\n\n\n\n * 流程标识：对应 BPMN 流程文件 XML 的 id 属性，不能重复，新建后不可修改。\n * 流程名称：对应 BPMN 流程文件 XML 的 name 属性。\n\n\x3c!-- 这是一个 BPMN XML 的示例，主要看 id 和 name 属性 --\x3e\n<?xml version="1.0" encoding="UTF-8"?>\n<bpmn2:definitions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:bpmn2="http://www.omg.org/spec/BPMN/20100524/MODEL" xmlns:bpmndi="http://www.omg.org/spec/BPMN/20100524/DI" id="diagram_Process_1647305370393" targetNamespace="http://activiti.org/bpmn">\n  <bpmn2:process id="common-form" name="通用表单流程" isExecutable="true" />\n  <bpmndi:BPMNDiagram id="BPMNDiagram_1">\n    <bpmndi:BPMNPlane id="common-form_di" bpmnElement="common-form" />\n  </bpmndi:BPMNDiagram>\n</bpmn2:definitions>\n\n\n# 1.1.2 新建表单\n\n① 访问 [工作流程 -> 流程管理 -> 流程表单] 菜单，点击「新增」按钮，新增一个名字为 leave-form 的表单。如下图所示：\n\n\n\n\n\n友情提示：如果感觉有点麻烦，随便设计下，保存就 OK 了。\n\n② 回到 [工作流程 -> 流程管理 -> 流程模型] 菜单，点击「修改流程」按钮，配置表单类型为流程表单，选择名字为 leave-form 的流程表单。如下图所示：\n\n\n\n# 1.1.3 设计流程\n\n① 点击「设计流程」按钮，在线设计请假流程模型，包含两个用户任务：领导审批、HR 审批。如下图所示：\n\n\n\n② 点击图中的“部门领导审批”，规则类型为“流程表达式”，流程表达式为 ${bpmTaskAssignLeaderExpression.calculateUsers(execution, 1)}。如下图所示：\n\n\n\n友情提示：该流程表达式的作用是，流程发起人的一级领导。\n\n为什么呢？这块我们在 《流程表达式》 详细讲解。\n\n点击图中的“HR 审批”，规则类型为“岗位”，指定岗位为“人力资源”。如下图所示：\n\n\n\n之后，点击右上角的「保存模型」按钮，完成流程模型的设计。\n\n③ 点击「发布流程」按钮，把定义的流程模型部署出去。部署成功后，就可以发起该流程了。如下图所示：\n\n\n\n修改流程后，需要重新发布流程吗？\n\n需要，必须重新发布才能生效。每次流程发布后，会生成一个新的流程定义，版本号从 v1 开始递增。\n\n发布成功后，会部署新版本的流程定义，旧版本的流程定义将被挂起。当然，已经发起的流程不会受到影响，还是走老的流程定义。\n\n\n# 2. 第二步：发起流程\n\n登录账号 admin、密码 admin123 的用户，扮演【员工】的角色，进行流程的发起。\n\n# 2.1 发起流程\n\n① 访问 [工作流程 -> 审批中心 -> 发起流程] 菜单，可以看到可以选择的流程定义的列表。\n\n\n\n② 选择名字为“通用表单”的流程定义，发起请假流程。填写请假表单信息如下：\n\n\n\n③ 点击提交成功后，可在 [工作流程 -> 审批中心 -> 我的流程]中，可看到该流程的状态、结果。\n\n\n\n# 2.2 查看流程\n\n点击「详情」按钮，可以查看申请的表单信息、审批记录、流程跟踪图。\n\n\n\n\n\n\n# 3. 第三步：审批流程\n\n# 3.1 部门领导审批\n\n登录账号 test、密码 test123 的用户，扮演【审批人】的角色，进行请假流程的【领导审批】任务。\n\n① 访问 [工作流程 -> 审批中心 -> 待办任务] 菜单，可以查询到需要审批的任务。\n\n\n\n② 点击「办理」按钮，填写审批建议，并点击「通过」按钮，这样任务的审批就完成了。\n\n\n\n③ 访问 [工作流程 -> 审批中心 -> 已办任务] 菜单，可以查询到已经审批的任务。\n\n\n\n----------------------------------------\n\n此时，使用【员工】的角色，访问 [工作流程 -> 审批中心 -> 我的流程] 菜单，可以看到流程流转到了【HR 审批】任务。\n\n\n\n# 3.2 HR 审批\n\n登录账号 hrmgr、密码 hr123 的用户，扮演【审批人】的角色，进行请假流程的【HR 审批】任务。\n\n① 访问 [工作流程 -> 审批中心 -> 待办任务] 菜单，点击「审批」按钮，填写审批建议，并点击「通过」按钮。\n\n----------------------------------------\n\n此时，使用【员工】的角色，访问 [工作流程 -> 审批中心 -> 我的流程] 菜单，可以看到流程处理结束，最终审批通过。\n\n\n\n\n# 2. 菜单【流程表单】\n\n本小节，我们单独讲解的是菜单 [工作流程 -> 流程管理 -> 流程表单] 的功能。\n\n\n\n该菜单主要用于流程表单的配置，不包括最终表单填写后的存储，由 BpmFormController 提供接口。\n\n\n# 2.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `bpm_form` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT \'编号\',\n  `name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \'表单名\',\n  `status` tinyint NOT NULL COMMENT \'开启状态\',\n  `conf` varchar(1000) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \'表单的配置\',\n  `fields` varchar(5000) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \'表单项的数组\',\n  `remark` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT \'备注\',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=28 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT=\'BPM 表单定义表\';\n\n\n关键就 2 个字段：\n\n① conf：表单的配置，是一个 JSON 字符串，包含表单的基本配置、按钮等。\n\n{\n    "form": {\n        "labelPosition": "right",\n        "size": "default",\n        "labelWidth": "125px",\n        "hideRequiredAsterisk": false,\n        "showMessage": true,\n        "inlineMessage": false\n    },\n    "submitBtn": {\n        "show": true,\n        "innerText": "提交"\n    },\n    "resetBtn": {\n        "show": false,\n        "innerText": "重置"\n    }\n}\n\n\n对应表单设计器的【表单配置】部分。如下图所示：\n\n\n\n② fields：表单项的数组，是一个 JSON 字符串，包含表单的所有字段。\n\n["{\\"type\\":\\"datePicker\\",\\"field\\":\\"startTime\\",\\"title\\":\\"开始时间\\",\\"info\\":\\"\\",\\"$required\\":true,\\"_fc_drag_tag\\":\\"datePicker\\",\\"hidden\\":false,\\"display\\":true}","{\\"type\\":\\"datePicker\\",\\"field\\":\\"Fm9i1onr8v6n68\\",\\"title\\":\\"结束时间\\",\\"info\\":\\"\\",\\"$required\\":true,\\"_fc_drag_tag\\":\\"datePicker\\",\\"hidden\\":false,\\"display\\":true}","{\\"type\\":\\"select\\",\\"field\\":\\"type\\",\\"title\\":\\"请假类型\\",\\"info\\":\\"\\",\\"effect\\":{\\"fetch\\":\\"\\"},\\"$required\\":false,\\"options\\":[{\\"label\\":\\"事假\\",\\"value\\":1},{\\"label\\":\\"年假\\",\\"value\\":2}],\\"_fc_drag_tag\\":\\"select\\",\\"hidden\\":false,\\"display\\":true}","{\\"type\\":\\"input\\",\\"field\\":\\"reason\\",\\"title\\":\\"请假原因\\",\\"info\\":\\"\\",\\"$required\\":false,\\"props\\":{\\"rows\\":0,\\"type\\":\\"textarea\\"},\\"_fc_drag_tag\\":\\"input\\",\\"hidden\\":false,\\"display\\":true}"]\n\n\n对应表单设计器的【组件配置】部分。如下图所示：\n\n\n\n\n# 2.2 前端组件\n\n基于 https://github.com/xaboy/form-create 实现，支持 element-plus、ant-design-vue、naive-ui、arco-design、tdesign 等前端组件，还是非常不错的！\n\n中文文档：https://www.form-create.com/v3/guide/\n\n# 2.2.1 表单设计器\n\n上文看到的“表单设计器”，在 bpm/form/editor/index.vue 实现，使用 form-create-designer 实现。\n\n# 2.2.2 表单预览\n\n点击「详情」按钮，可进行表单的预览，如下图所示：\n\n\n\n实现的逻辑，就是读取后端 bpm_form 表的 conf 和 fields 字段，然后使用 form-create 渲染。如下图所示：\n\n\n\n# 2.2.3 表单填写\n\n在 [工作流程 -> 审批中心 -> 发起流程] 菜单，点击「填写表单」按钮，可以填写表单。它也是基于 form-create 实现的，只是额外实现了 @submit 事件，用于提交表单。如下图所示：\n\n\n\n相比表单预览，它通过 v-model 获取表单的值，可通过 v-model:api 对应的 fApi 对象，进行表单的校验、重置等操作。\n\n友情提问：使用流程表单时，提交的表单数据是怎么存储的？\n\n存储到 Flowable 的 ProcessInstance 的 variables 中。如下图所示：\n\n\n\n\n# 666. 常见问题？\n\n① 流程中表单里面的附件上传，除了 pdf 这几种格式，可以支持别的格式的附件吗？\n\n回答：https://t.zsxq.com/bKzyd',
            normalizedContent: '相关视频：\n\n * 02、如何实现动态的流程表单？\n * 03、如何实现流程表单的保存？\n * 04、如何实现流程表单的展示？\n\n项目基于 flowable 实现了工作流的功能，提供两种方式接入：\n\n * ① 【流程表单】：在线配置动态表单，无需建表与开发\n * ② 【业务表单】：业务需建立独立的数据库表，并开发对应的表单、详情界面\n\n我们以“请假流程”为例子，讲解两种接入方式的差异，整个过程包括：\n\n 1. 定义流程：【管理员】新建流程、设计流程模型、并设置用户任务的审批人，最终发布流程\n 2. 发起流程：【员工】选择流程，并发起流程实例\n 3. 审批流程：【审批人】接收到流程任务，审批结果为通过或不通过\n\n\n\n本文，我们讲解的是「业务接入（流程表单）」的流程，复杂业务接入的流程请查看业务接入（业务表单）。\n\n\n# 1. 业务接入（流程表单）\n\n\n# 1.1 第一步：定义流程\n\n登录账号 admin、密码 admin123 的用户，扮演【管理员】的角色，进行流程的定义。\n\n# 1.1.1 新建流程\n\n访问 [工作流程 -> 流程管理 -> 流程模型] 菜单，点击「新建流程」按钮，填写流程标识、流程名称。如下图所示：\n\n\n\n * 流程标识：对应 bpmn 流程文件 xml 的 id 属性，不能重复，新建后不可修改。\n * 流程名称：对应 bpmn 流程文件 xml 的 name 属性。\n\n\x3c!-- 这是一个 bpmn xml 的示例，主要看 id 和 name 属性 --\x3e\n<?xml version="1.0" encoding="utf-8"?>\n<bpmn2:definitions xmlns:xsi="http://www.w3.org/2001/xmlschema-instance" xmlns:bpmn2="http://www.omg.org/spec/bpmn/20100524/model" xmlns:bpmndi="http://www.omg.org/spec/bpmn/20100524/di" id="diagram_process_1647305370393" targetnamespace="http://activiti.org/bpmn">\n  <bpmn2:process id="common-form" name="通用表单流程" isexecutable="true" />\n  <bpmndi:bpmndiagram id="bpmndiagram_1">\n    <bpmndi:bpmnplane id="common-form_di" bpmnelement="common-form" />\n  </bpmndi:bpmndiagram>\n</bpmn2:definitions>\n\n\n# 1.1.2 新建表单\n\n① 访问 [工作流程 -> 流程管理 -> 流程表单] 菜单，点击「新增」按钮，新增一个名字为 leave-form 的表单。如下图所示：\n\n\n\n\n\n友情提示：如果感觉有点麻烦，随便设计下，保存就 ok 了。\n\n② 回到 [工作流程 -> 流程管理 -> 流程模型] 菜单，点击「修改流程」按钮，配置表单类型为流程表单，选择名字为 leave-form 的流程表单。如下图所示：\n\n\n\n# 1.1.3 设计流程\n\n① 点击「设计流程」按钮，在线设计请假流程模型，包含两个用户任务：领导审批、hr 审批。如下图所示：\n\n\n\n② 点击图中的“部门领导审批”，规则类型为“流程表达式”，流程表达式为 ${bpmtaskassignleaderexpression.calculateusers(execution, 1)}。如下图所示：\n\n\n\n友情提示：该流程表达式的作用是，流程发起人的一级领导。\n\n为什么呢？这块我们在 《流程表达式》 详细讲解。\n\n点击图中的“hr 审批”，规则类型为“岗位”，指定岗位为“人力资源”。如下图所示：\n\n\n\n之后，点击右上角的「保存模型」按钮，完成流程模型的设计。\n\n③ 点击「发布流程」按钮，把定义的流程模型部署出去。部署成功后，就可以发起该流程了。如下图所示：\n\n\n\n修改流程后，需要重新发布流程吗？\n\n需要，必须重新发布才能生效。每次流程发布后，会生成一个新的流程定义，版本号从 v1 开始递增。\n\n发布成功后，会部署新版本的流程定义，旧版本的流程定义将被挂起。当然，已经发起的流程不会受到影响，还是走老的流程定义。\n\n\n# 2. 第二步：发起流程\n\n登录账号 admin、密码 admin123 的用户，扮演【员工】的角色，进行流程的发起。\n\n# 2.1 发起流程\n\n① 访问 [工作流程 -> 审批中心 -> 发起流程] 菜单，可以看到可以选择的流程定义的列表。\n\n\n\n② 选择名字为“通用表单”的流程定义，发起请假流程。填写请假表单信息如下：\n\n\n\n③ 点击提交成功后，可在 [工作流程 -> 审批中心 -> 我的流程]中，可看到该流程的状态、结果。\n\n\n\n# 2.2 查看流程\n\n点击「详情」按钮，可以查看申请的表单信息、审批记录、流程跟踪图。\n\n\n\n\n\n\n# 3. 第三步：审批流程\n\n# 3.1 部门领导审批\n\n登录账号 test、密码 test123 的用户，扮演【审批人】的角色，进行请假流程的【领导审批】任务。\n\n① 访问 [工作流程 -> 审批中心 -> 待办任务] 菜单，可以查询到需要审批的任务。\n\n\n\n② 点击「办理」按钮，填写审批建议，并点击「通过」按钮，这样任务的审批就完成了。\n\n\n\n③ 访问 [工作流程 -> 审批中心 -> 已办任务] 菜单，可以查询到已经审批的任务。\n\n\n\n----------------------------------------\n\n此时，使用【员工】的角色，访问 [工作流程 -> 审批中心 -> 我的流程] 菜单，可以看到流程流转到了【hr 审批】任务。\n\n\n\n# 3.2 hr 审批\n\n登录账号 hrmgr、密码 hr123 的用户，扮演【审批人】的角色，进行请假流程的【hr 审批】任务。\n\n① 访问 [工作流程 -> 审批中心 -> 待办任务] 菜单，点击「审批」按钮，填写审批建议，并点击「通过」按钮。\n\n----------------------------------------\n\n此时，使用【员工】的角色，访问 [工作流程 -> 审批中心 -> 我的流程] 菜单，可以看到流程处理结束，最终审批通过。\n\n\n\n\n# 2. 菜单【流程表单】\n\n本小节，我们单独讲解的是菜单 [工作流程 -> 流程管理 -> 流程表单] 的功能。\n\n\n\n该菜单主要用于流程表单的配置，不包括最终表单填写后的存储，由 bpmformcontroller 提供接口。\n\n\n# 2.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `bpm_form` (\n  `id` bigint not null auto_increment comment \'编号\',\n  `name` varchar(64) character set utf8mb4 collate utf8mb4_unicode_ci not null comment \'表单名\',\n  `status` tinyint not null comment \'开启状态\',\n  `conf` varchar(1000) character set utf8mb4 collate utf8mb4_unicode_ci not null comment \'表单的配置\',\n  `fields` varchar(5000) character set utf8mb4 collate utf8mb4_unicode_ci not null comment \'表单项的数组\',\n  `remark` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci default null comment \'备注\',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=28 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment=\'bpm 表单定义表\';\n\n\n关键就 2 个字段：\n\n① conf：表单的配置，是一个 json 字符串，包含表单的基本配置、按钮等。\n\n{\n    "form": {\n        "labelposition": "right",\n        "size": "default",\n        "labelwidth": "125px",\n        "hiderequiredasterisk": false,\n        "showmessage": true,\n        "inlinemessage": false\n    },\n    "submitbtn": {\n        "show": true,\n        "innertext": "提交"\n    },\n    "resetbtn": {\n        "show": false,\n        "innertext": "重置"\n    }\n}\n\n\n对应表单设计器的【表单配置】部分。如下图所示：\n\n\n\n② fields：表单项的数组，是一个 json 字符串，包含表单的所有字段。\n\n["{\\"type\\":\\"datepicker\\",\\"field\\":\\"starttime\\",\\"title\\":\\"开始时间\\",\\"info\\":\\"\\",\\"$required\\":true,\\"_fc_drag_tag\\":\\"datepicker\\",\\"hidden\\":false,\\"display\\":true}","{\\"type\\":\\"datepicker\\",\\"field\\":\\"fm9i1onr8v6n68\\",\\"title\\":\\"结束时间\\",\\"info\\":\\"\\",\\"$required\\":true,\\"_fc_drag_tag\\":\\"datepicker\\",\\"hidden\\":false,\\"display\\":true}","{\\"type\\":\\"select\\",\\"field\\":\\"type\\",\\"title\\":\\"请假类型\\",\\"info\\":\\"\\",\\"effect\\":{\\"fetch\\":\\"\\"},\\"$required\\":false,\\"options\\":[{\\"label\\":\\"事假\\",\\"value\\":1},{\\"label\\":\\"年假\\",\\"value\\":2}],\\"_fc_drag_tag\\":\\"select\\",\\"hidden\\":false,\\"display\\":true}","{\\"type\\":\\"input\\",\\"field\\":\\"reason\\",\\"title\\":\\"请假原因\\",\\"info\\":\\"\\",\\"$required\\":false,\\"props\\":{\\"rows\\":0,\\"type\\":\\"textarea\\"},\\"_fc_drag_tag\\":\\"input\\",\\"hidden\\":false,\\"display\\":true}"]\n\n\n对应表单设计器的【组件配置】部分。如下图所示：\n\n\n\n\n# 2.2 前端组件\n\n基于 https://github.com/xaboy/form-create 实现，支持 element-plus、ant-design-vue、naive-ui、arco-design、tdesign 等前端组件，还是非常不错的！\n\n中文文档：https://www.form-create.com/v3/guide/\n\n# 2.2.1 表单设计器\n\n上文看到的“表单设计器”，在 bpm/form/editor/index.vue 实现，使用 form-create-designer 实现。\n\n# 2.2.2 表单预览\n\n点击「详情」按钮，可进行表单的预览，如下图所示：\n\n\n\n实现的逻辑，就是读取后端 bpm_form 表的 conf 和 fields 字段，然后使用 form-create 渲染。如下图所示：\n\n\n\n# 2.2.3 表单填写\n\n在 [工作流程 -> 审批中心 -> 发起流程] 菜单，点击「填写表单」按钮，可以填写表单。它也是基于 form-create 实现的，只是额外实现了 @submit 事件，用于提交表单。如下图所示：\n\n\n\n相比表单预览，它通过 v-model 获取表单的值，可通过 v-model:api 对应的 fapi 对象，进行表单的校验、重置等操作。\n\n友情提问：使用流程表单时，提交的表单数据是怎么存储的？\n\n存储到 flowable 的 processinstance 的 variables 中。如下图所示：\n\n\n\n\n# 666. 常见问题？\n\n① 流程中表单里面的附件上传，除了 pdf 这几种格式，可以支持别的格式的附件吗？\n\n回答：https://t.zsxq.com/bkzyd',
            charsets: {
                cjk: !0
            }
        }, {
            title: "流程设计器（BPMN）",
            frontmatter: {
                title: "流程设计器（BPMN）",
                date: "2024-03-25T09:17:48.000Z",
                permalink: "/bpm/model-designer-bpmn"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/10.%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%89%8B%E5%86%8C/11.%E6%B5%81%E7%A8%8B%E8%AE%BE%E8%AE%A1%E5%99%A8%EF%BC%88BPMN%EF%BC%89.html",
            relativePath: "01.开发指南/10.工作流手册/11.流程设计器（BPMN）.md",
            key: "v-b58f8daa",
            path: "/bpm/model-designer-bpmn/",
            headers: [{
                level: 2,
                title: "1. 流程模型",
                slug: "_1-流程模型",
                normalizedTitle: "1. 流程模型",
                charIndex: 244
            }, {
                level: 3,
                title: "1.1 表结构",
                slug: "_1-1-表结构",
                normalizedTitle: "1.1 表结构",
                charIndex: 373
            }, {
                level: 3,
                title: "1.2 流程设计器",
                slug: "_1-2-流程设计器",
                normalizedTitle: "1.2 流程设计器",
                charIndex: 1543
            }, {
                level: 3,
                title: "1.3 任务（表单）",
                slug: "_1-3-任务-表单",
                normalizedTitle: "1.3 任务（表单）",
                charIndex: 1996
            }, {
                level: 3,
                title: "1.4 任务（审批人）",
                slug: "_1-4-任务-审批人",
                normalizedTitle: "1.4 任务（审批人）",
                charIndex: 2424
            }, {
                level: 3,
                title: "1.5 多实例（会签配置）",
                slug: "_1-5-多实例-会签配置",
                normalizedTitle: "1.5 多实例（会签配置）",
                charIndex: 2465
            }, {
                level: 3,
                title: "1.6 执行监听器",
                slug: "_1-6-执行监听器",
                normalizedTitle: "1.6 执行监听器",
                charIndex: 2507
            }, {
                level: 3,
                title: "1.7 任务监听器",
                slug: "_1-7-任务监听器",
                normalizedTitle: "1.7 任务监听器",
                charIndex: 2546
            }, {
                level: 2,
                title: "2. 流程定义",
                slug: "_2-流程定义",
                normalizedTitle: "2. 流程定义",
                charIndex: 2585
            }, {
                level: 3,
                title: "2.1 表结构",
                slug: "_2-1-表结构",
                normalizedTitle: "2.1 表结构",
                charIndex: 2768
            }, {
                level: 3,
                title: "2.2 流程定义列表（可发起流程）",
                slug: "_2-2-流程定义列表-可发起流程",
                normalizedTitle: "2.2 流程定义列表（可发起流程）",
                charIndex: 5627
            }],
            headersStr: "1. 流程模型 1.1 表结构 1.2 流程设计器 1.3 任务（表单） 1.4 任务（审批人） 1.5 多实例（会签配置） 1.6 执行监听器 1.7 任务监听器 2. 流程定义 2.1 表结构 2.2 流程定义列表（可发起流程）",
            content: "相关视频：\n\n * 05、如何实现流程模型的新建？\n * 06、如何实现流程模型的流程图的设计？\n * 07、如何实现流程模型的流程图的预览？\n * 09、如何实现流程模型的发布？\n * 10、如何实现流程定义的查询？\n * 21、如何实现流程的流程图的高亮？\n\n在 《审批接入（流程表单）》、《审批接入（业务表单）》 小节中，我们已经新建过流程模型，并发布为流程定义，如下图所示：\n\n\n\n本文，我们将进一步讲解【流程模型】、【流程定义】，特别是如何使用 BPMN 流程设计器。\n\n\n# 1. 流程模型\n\n流程模型，对应 [工作流程 -> 流程管理 -> 流程模型] 菜单，如下图所示：\n\n\n\n * 后端，由 BpmModelController 提供接口\n * 前端，由 /views/bpm/model/index.vue 实现界面\n\n\n# 1.1 表结构\n\n流程设计模型部署表，由 Flowable 提供的 ACT_RE_MODEL 表实现，如下所示：\n\n字段名称                            字段描述         数据类型            主键   为空   取值说明\nID_                             ID_          nvarchar(64)    √         ID_\nREV_                            乐观锁          int                  √    乐观锁\nNAME_                           名称           nvarchar(255)        √    名称\nKEY_                            KEY_         nvarchar(255)        √    key\nCATEGORY_                       分类           nvarchar(255)        √    分类\nCREATE_TIME_                    创建时间         datetime             √    创建时间\nLAST_UPDATE_TIME_               最新修改时间       datetime             √    最新修改时间\nVERSION_                        版本           int                  √    版本\nMETA_INFO_                      META_INFO_   nvarchar(255)        √    以 json 格式保存流程定义的信息\nDEPLOYMENT_ID_                  部署ID         nvarchar(255)        √    部署ID\nEDITOR_SOURCE_VALUE_ID_                      datetime             √    \nEDITOR_SOURCE_EXTRA_VALUE_ID_                datetime             √    \n\n我们可以通过 META_INFO 字段，额外拓展了 icon 图标、description 描述、formType、formId、formCustomCreatePath、formCustomViewPath 表单等信息。如下图所示：\n\n\n\n\n# 1.2 流程设计器\n\n① BPMN 流程设计器，由项目的 ProcessDesigner.vue 实现。\n\n\n\n它是基于 https://github.com/miyuesc/bpmn-process-designer 拓展，底层是 bpmn-js。\n\n补充说明：\n\nbpmn-process-designer 提供 Vue2 + ElementUI、Vue3 + NaiveUI 两个版本，而我们是 Vue3 + ElementPlus，是通过 Vue2 + ElementUI 迁移适配实现。\n\n② BPMN 预览，支持高亮，由 ProcessViewer.vue 实现。\n\n\n\n它是直接基于 bpmn-js 拓展，没有基于 bpmn-process-designer。\n\n----------------------------------------\n\n下面，我们将详细讲解 BPMN 流程设计器的各个配置项：任务（表单）、任务（审批人）、多实例（会签配置）、执行监听器、任务监听器等等。\n\n\n# 1.3 任务（表单）\n\n# 1.3.1 表单配置\n\n每个任务节点，有个 [表单] 配置项，用于配置任务审批时，补充填写表单信息。如下图所示：\n\n\n\n拓展知识：\n\n① 问题：配置的表单，最终是怎么存储的？\n\n回答：在 BPMN 的 UserTask 节点上，有个 formKey 属性，用于存储表单的 key，这里我们就存了【流程表单】的编号。\n\n② 问题：为什么只支持【流程表单】，不支持【业务表单】呢？\n\n回答：【业务表单】暂时没想到比较优雅的二次修改方案，因为它属于业务系统，无法在审批通过时，一起进行提交。\n\n③ 问题：表单设计器，怎么使用远程数据？\n\n回答：参见 https://docs.qq.com/doc/DZlNIVkZSTlVJVEd2 文档。\n\n# 1.3.2 表单效果\n\n在审批任务通过时，需要额外填写表单信息，如下图所示：\n\n\n\n填写的表单数据，会存储到 Flowable 任务的 variables 中，如下图所示：\n\n\n\n\n# 1.4 任务（审批人）\n\n\n\n详细见 《选择审批人、发起人自选》 文档。\n\n\n# 1.5 多实例（会签配置）\n\n\n\n详细见 《会签、或签、依次审批》 文档。\n\n\n# 1.6 执行监听器\n\n\n\n详细见 《执行监听器、任务监听器》 文档。\n\n\n# 1.7 任务监听器\n\n\n\n详细见 《执行监听器、任务监听器》 文档。\n\n\n# 2. 流程定义\n\n流程模型在部署后，会创建一个新版本的流程定义，并挂起老版本的流程定义。最终，我们点击某个流程模型的「流程定义」按钮，可以看到它对应的流程定义，如下图所示：\n\n\n\n * 后端，由 BpmProcessDefinitionController 提供接口\n * 前端，由 /views/bpm/definition/index.vue 实现界面\n\n\n# 2.1 表结构\n\n① 流程定义表，由 Flowable 提供的 ACT_RE_PROCDEF 表实现，如下所示：\n\n字段                        类型                主键   说明                备注\nID_                       NVARCHAR2(64)     Y    主键                \nREV_                      INTEGER           N    数据版本号             \nCATEGORY_                 NVARCHAR2(255)    N    流程定义分类            读取 xml 文件中程的 targetNamespace 值\nNAME_                     NVARCHAR2(255)    N    流程定义的名称           读取流程文件中 process元素的 name 属性\nKEY_                      NVARCHAR2(255)    N    流程定义key           读取流程文件中 process 元素的 id 属性\nVERSION_                  INTEGER           N    版本                \nDEPLOYMENT_ID_            NVARCHAR2(64)     N    部署ID              流程定义对应的部署数据 ID\nRESOURCE_NAME_            NVARCHAR2(2000)   N    bpmn文件名称          一般为流程文件的相对路径\nDGRM_RESOURCE_NAME_       VARCHAR2(4000)    N    流程定义对应的流程图资源名称    \nDESCRIPTION_              NVARCHAR2(2000)   N    说明                \nHAS_START_FORM_KEY_       NUMBER(1)         N    是否存在开始节点formKey   start 节点是否存在 formKey：0-否，1-是\nHAS_GRAPHICAL_NOTATION_   NUMBER(1)         N                      \nSUSPENSION_STATE_         INTEGER           N    流程定义状态            1-激活、2中止\nTENANT_ID_                NVARCHAR2(255)    N                      \nENGINE_VERSION_           NVARCHAR2(255)    N                      引擎版本\n\n② 由于 ACT_RE_PROCDEF 表没有类似 ACT_RE_MODEL 有 META_INFO_ 字段，所以我们额外创建了一个 BPM 流程定义的信息表，用于存储流程定义的额外信息。如下所示：\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `bpm_process_definition_info` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  `process_definition_id` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '流程定义的编号',\n  `model_id` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '流程模型的编号',\n  `icon` varchar(512) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '图标',\n  `description` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '描述',\n  `form_type` tinyint NOT NULL COMMENT '表单类型',\n  `form_id` bigint DEFAULT NULL COMMENT '表单编号',\n  `form_conf` varchar(1000) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '表单的配置',\n  `form_fields` varchar(5000) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '表单项的数组',\n  `form_custom_create_path` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '自定义表单的提交路径',\n  `form_custom_view_path` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '自定义表单的查看路径',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=246 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='BPM 流程定义的信息表';\n\n\n本质上，就是把 ACT_RE_MODEL 的 META_INFO_ 字段存储到 bpm_process_definition_info 表中。\n\n因此，最终每次流程模型在部署时，会往 Flowable 插入一条 ACT_RE_PROCDEF 记录，也会往 bpm_process_definition_info 表中插入一条记录。\n\n\n# 2.2 流程定义列表（可发起流程）\n\n注意！一个流程模型，有且仅有一个【激活】状态的流程定义。最终，用户发起流程时，选择的是【激活】状态的流程定义。如下图所示：\n\n",
            normalizedContent: "相关视频：\n\n * 05、如何实现流程模型的新建？\n * 06、如何实现流程模型的流程图的设计？\n * 07、如何实现流程模型的流程图的预览？\n * 09、如何实现流程模型的发布？\n * 10、如何实现流程定义的查询？\n * 21、如何实现流程的流程图的高亮？\n\n在 《审批接入（流程表单）》、《审批接入（业务表单）》 小节中，我们已经新建过流程模型，并发布为流程定义，如下图所示：\n\n\n\n本文，我们将进一步讲解【流程模型】、【流程定义】，特别是如何使用 bpmn 流程设计器。\n\n\n# 1. 流程模型\n\n流程模型，对应 [工作流程 -> 流程管理 -> 流程模型] 菜单，如下图所示：\n\n\n\n * 后端，由 bpmmodelcontroller 提供接口\n * 前端，由 /views/bpm/model/index.vue 实现界面\n\n\n# 1.1 表结构\n\n流程设计模型部署表，由 flowable 提供的 act_re_model 表实现，如下所示：\n\n字段名称                            字段描述         数据类型            主键   为空   取值说明\nid_                             id_          nvarchar(64)    √         id_\nrev_                            乐观锁          int                  √    乐观锁\nname_                           名称           nvarchar(255)        √    名称\nkey_                            key_         nvarchar(255)        √    key\ncategory_                       分类           nvarchar(255)        √    分类\ncreate_time_                    创建时间         datetime             √    创建时间\nlast_update_time_               最新修改时间       datetime             √    最新修改时间\nversion_                        版本           int                  √    版本\nmeta_info_                      meta_info_   nvarchar(255)        √    以 json 格式保存流程定义的信息\ndeployment_id_                  部署id         nvarchar(255)        √    部署id\neditor_source_value_id_                      datetime             √    \neditor_source_extra_value_id_                datetime             √    \n\n我们可以通过 meta_info 字段，额外拓展了 icon 图标、description 描述、formtype、formid、formcustomcreatepath、formcustomviewpath 表单等信息。如下图所示：\n\n\n\n\n# 1.2 流程设计器\n\n① bpmn 流程设计器，由项目的 processdesigner.vue 实现。\n\n\n\n它是基于 https://github.com/miyuesc/bpmn-process-designer 拓展，底层是 bpmn-js。\n\n补充说明：\n\nbpmn-process-designer 提供 vue2 + elementui、vue3 + naiveui 两个版本，而我们是 vue3 + elementplus，是通过 vue2 + elementui 迁移适配实现。\n\n② bpmn 预览，支持高亮，由 processviewer.vue 实现。\n\n\n\n它是直接基于 bpmn-js 拓展，没有基于 bpmn-process-designer。\n\n----------------------------------------\n\n下面，我们将详细讲解 bpmn 流程设计器的各个配置项：任务（表单）、任务（审批人）、多实例（会签配置）、执行监听器、任务监听器等等。\n\n\n# 1.3 任务（表单）\n\n# 1.3.1 表单配置\n\n每个任务节点，有个 [表单] 配置项，用于配置任务审批时，补充填写表单信息。如下图所示：\n\n\n\n拓展知识：\n\n① 问题：配置的表单，最终是怎么存储的？\n\n回答：在 bpmn 的 usertask 节点上，有个 formkey 属性，用于存储表单的 key，这里我们就存了【流程表单】的编号。\n\n② 问题：为什么只支持【流程表单】，不支持【业务表单】呢？\n\n回答：【业务表单】暂时没想到比较优雅的二次修改方案，因为它属于业务系统，无法在审批通过时，一起进行提交。\n\n③ 问题：表单设计器，怎么使用远程数据？\n\n回答：参见 https://docs.qq.com/doc/dzlnivkzstlvjved2 文档。\n\n# 1.3.2 表单效果\n\n在审批任务通过时，需要额外填写表单信息，如下图所示：\n\n\n\n填写的表单数据，会存储到 flowable 任务的 variables 中，如下图所示：\n\n\n\n\n# 1.4 任务（审批人）\n\n\n\n详细见 《选择审批人、发起人自选》 文档。\n\n\n# 1.5 多实例（会签配置）\n\n\n\n详细见 《会签、或签、依次审批》 文档。\n\n\n# 1.6 执行监听器\n\n\n\n详细见 《执行监听器、任务监听器》 文档。\n\n\n# 1.7 任务监听器\n\n\n\n详细见 《执行监听器、任务监听器》 文档。\n\n\n# 2. 流程定义\n\n流程模型在部署后，会创建一个新版本的流程定义，并挂起老版本的流程定义。最终，我们点击某个流程模型的「流程定义」按钮，可以看到它对应的流程定义，如下图所示：\n\n\n\n * 后端，由 bpmprocessdefinitioncontroller 提供接口\n * 前端，由 /views/bpm/definition/index.vue 实现界面\n\n\n# 2.1 表结构\n\n① 流程定义表，由 flowable 提供的 act_re_procdef 表实现，如下所示：\n\n字段                        类型                主键   说明                备注\nid_                       nvarchar2(64)     y    主键                \nrev_                      integer           n    数据版本号             \ncategory_                 nvarchar2(255)    n    流程定义分类            读取 xml 文件中程的 targetnamespace 值\nname_                     nvarchar2(255)    n    流程定义的名称           读取流程文件中 process元素的 name 属性\nkey_                      nvarchar2(255)    n    流程定义key           读取流程文件中 process 元素的 id 属性\nversion_                  integer           n    版本                \ndeployment_id_            nvarchar2(64)     n    部署id              流程定义对应的部署数据 id\nresource_name_            nvarchar2(2000)   n    bpmn文件名称          一般为流程文件的相对路径\ndgrm_resource_name_       varchar2(4000)    n    流程定义对应的流程图资源名称    \ndescription_              nvarchar2(2000)   n    说明                \nhas_start_form_key_       number(1)         n    是否存在开始节点formkey   start 节点是否存在 formkey：0-否，1-是\nhas_graphical_notation_   number(1)         n                      \nsuspension_state_         integer           n    流程定义状态            1-激活、2中止\ntenant_id_                nvarchar2(255)    n                      \nengine_version_           nvarchar2(255)    n                      引擎版本\n\n② 由于 act_re_procdef 表没有类似 act_re_model 有 meta_info_ 字段，所以我们额外创建了一个 bpm 流程定义的信息表，用于存储流程定义的额外信息。如下所示：\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `bpm_process_definition_info` (\n  `id` bigint not null auto_increment comment '编号',\n  `process_definition_id` varchar(64) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '流程定义的编号',\n  `model_id` varchar(64) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '流程模型的编号',\n  `icon` varchar(512) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '图标',\n  `description` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '描述',\n  `form_type` tinyint not null comment '表单类型',\n  `form_id` bigint default null comment '表单编号',\n  `form_conf` varchar(1000) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '表单的配置',\n  `form_fields` varchar(5000) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '表单项的数组',\n  `form_custom_create_path` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '自定义表单的提交路径',\n  `form_custom_view_path` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '自定义表单的查看路径',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=246 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='bpm 流程定义的信息表';\n\n\n本质上，就是把 act_re_model 的 meta_info_ 字段存储到 bpm_process_definition_info 表中。\n\n因此，最终每次流程模型在部署时，会往 flowable 插入一条 act_re_procdef 记录，也会往 bpm_process_definition_info 表中插入一条记录。\n\n\n# 2.2 流程定义列表（可发起流程）\n\n注意！一个流程模型，有且仅有一个【激活】状态的流程定义。最终，用户发起流程时，选择的是【激活】状态的流程定义。如下图所示：\n\n",
            charsets: {
                cjk: !0
            }
        }, {
            title: "流程设计器（钉钉、飞书）",
            frontmatter: {
                title: "流程设计器（钉钉、飞书）",
                date: "2024-03-25T11:11:52.000Z",
                permalink: "/bpm/model-designer-dingding"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/10.%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%89%8B%E5%86%8C/12.%E6%B5%81%E7%A8%8B%E8%AE%BE%E8%AE%A1%E5%99%A8%EF%BC%88%E9%92%89%E9%92%89%E3%80%81%E9%A3%9E%E4%B9%A6%EF%BC%89.html",
            relativePath: "01.开发指南/10.工作流手册/12.流程设计器（钉钉、飞书）.md",
            key: "v-74ea7ea9",
            path: "/bpm/model-designer-dingding/",
            headers: [{
                level: 2,
                title: "1. 如何体验？",
                slug: "_1-如何体验",
                normalizedTitle: "1. 如何体验？",
                charIndex: 213
            }, {
                level: 2,
                title: "2. 开发进展",
                slug: "_2-开发进展",
                normalizedTitle: "2. 开发进展",
                charIndex: 365
            }, {
                level: 3,
                title: "2.1 一期（已完成）",
                slug: "_2-1-一期-已完成",
                normalizedTitle: "2.1 一期（已完成）",
                charIndex: 409
            }, {
                level: 3,
                title: "2.2 二期（进行中）",
                slug: "_2-2-二期-进行中",
                normalizedTitle: "2.2 二期（进行中）",
                charIndex: 580
            }, {
                level: 3,
                title: "2.3 三期（未开始）",
                slug: "_2-3-三期-未开始",
                normalizedTitle: "2.3 三期（未开始）",
                charIndex: 901
            }],
            headersStr: "1. 如何体验？ 2. 开发进展 2.1 一期（已完成） 2.2 二期（进行中） 2.3 三期（未开始）",
            content: "友情提示：\n\n绝大部署功能，已经在 master 和 master-jdk17 分支体验。\n\n如下是我们的开发分支，感兴趣也可以关注：\n\n * 前端：https://gitee.com/yudaocode/yudao-ui-admin-vue3 的 feature/bpm 分支\n * 后端：https://gitee.com/zhijiantianya/ruoyi-vue-pro 的 feature/bpm 分支\n\n\n# 1. 如何体验？\n\n① 启动：参考 《工作流 —— 功能开启》 文档，前后端都切换成 feature/bpm 分支！\n\n② 使用：参考 《流程设计器（BPMN）》 文档，只是编辑器换成 [访钉钉设计流程]。新建流程时，选择 “SIMPLE” 设计器即可。后续点击【设计】按钮，就会出现下图：\n\n\n\n\n# 2. 开发进展\n\n目前正在开发“二期”部分，完成会合并到 master 分支。\n\n\n# 2.1 一期（已完成）\n\n功能             状态    进展\n流程节点 -> 发起人    已完成   100%\n流程节点 -> 审批人    已完成   100%\n流程节点 -> 抄送人    已完成   100%\n流程节点 -> 条件分支   已完成   100%\n流程节点 -> 并行分支   已完成   100%\n\n\n# 2.2 二期（进行中）\n\n功能                    状态    进展\n流程节点 -> 表单权限          已完成   100%\n流程节点 -> 包容分支          已完成   100%\n拓展设置 -> 自动去重          已完成   100%\n拓展设置 -> 撤销流程                \n流程节点 -> 延迟器                 \n流程节点 -> 同步/异步触发器            \n流程节点 -> 子流程                 \n流程节点 -> 动态路由                \n流程节点 -> 修改/删除数据（待定）         \n\n\n# 2.3 三期（未开始）\n\n功能                    状态   进展\n拓展设置 -> 前置校验               \n拓展设置 -> 前置/后置通知            \n流程设置 -> 流程报表               \n流程设置 -> 自定义打印模版            \n流程设置 -> 自定义流程编号            \n流程设置 -> 动态路由               \n流程节点 -> 修改/删除数据（待定）        ",
            normalizedContent: "友情提示：\n\n绝大部署功能，已经在 master 和 master-jdk17 分支体验。\n\n如下是我们的开发分支，感兴趣也可以关注：\n\n * 前端：https://gitee.com/yudaocode/yudao-ui-admin-vue3 的 feature/bpm 分支\n * 后端：https://gitee.com/zhijiantianya/ruoyi-vue-pro 的 feature/bpm 分支\n\n\n# 1. 如何体验？\n\n① 启动：参考 《工作流 —— 功能开启》 文档，前后端都切换成 feature/bpm 分支！\n\n② 使用：参考 《流程设计器（bpmn）》 文档，只是编辑器换成 [访钉钉设计流程]。新建流程时，选择 “simple” 设计器即可。后续点击【设计】按钮，就会出现下图：\n\n\n\n\n# 2. 开发进展\n\n目前正在开发“二期”部分，完成会合并到 master 分支。\n\n\n# 2.1 一期（已完成）\n\n功能             状态    进展\n流程节点 -> 发起人    已完成   100%\n流程节点 -> 审批人    已完成   100%\n流程节点 -> 抄送人    已完成   100%\n流程节点 -> 条件分支   已完成   100%\n流程节点 -> 并行分支   已完成   100%\n\n\n# 2.2 二期（进行中）\n\n功能                    状态    进展\n流程节点 -> 表单权限          已完成   100%\n流程节点 -> 包容分支          已完成   100%\n拓展设置 -> 自动去重          已完成   100%\n拓展设置 -> 撤销流程                \n流程节点 -> 延迟器                 \n流程节点 -> 同步/异步触发器            \n流程节点 -> 子流程                 \n流程节点 -> 动态路由                \n流程节点 -> 修改/删除数据（待定）         \n\n\n# 2.3 三期（未开始）\n\n功能                    状态   进展\n拓展设置 -> 前置校验               \n拓展设置 -> 前置/后置通知            \n流程设置 -> 流程报表               \n流程设置 -> 自定义打印模版            \n流程设置 -> 自定义流程编号            \n流程设置 -> 动态路由               \n流程节点 -> 修改/删除数据（待定）        ",
            charsets: {
                cjk: !0
            }
        }, {
            title: "选择审批人、发起人自选",
            frontmatter: {
                title: "选择审批人、发起人自选",
                date: "2024-03-25T14:19:23.000Z",
                permalink: "/bpm/assignee"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/10.%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%89%8B%E5%86%8C/20.%E9%80%89%E6%8B%A9%E5%AE%A1%E6%89%B9%E4%BA%BA%E3%80%81%E5%8F%91%E8%B5%B7%E4%BA%BA%E8%87%AA%E9%80%89.html",
            relativePath: "01.开发指南/10.工作流手册/20.选择审批人、发起人自选.md",
            key: "v-fd046d40",
            path: "/bpm/assignee/",
            headers: [{
                level: 2,
                title: "1. 审批人配置",
                slug: "_1-审批人配置",
                normalizedTitle: "1. 审批人配置",
                charIndex: 147
            }, {
                level: 2,
                title: "2. 选择审批人",
                slug: "_2-选择审批人",
                normalizedTitle: "2. 选择审批人",
                charIndex: 451
            }, {
                level: 2,
                title: "3. 自定义 BpmTaskCandidateStrategy 策略",
                slug: "_3-自定义-bpmtaskcandidatestrategy-策略",
                normalizedTitle: "3. 自定义 bpmtaskcandidatestrategy 策略",
                charIndex: 1242
            }, {
                level: 2,
                title: "3. 发起人自选",
                slug: "_3-发起人自选",
                normalizedTitle: "3. 发起人自选",
                charIndex: 1452
            }, {
                level: 3,
                title: "3.1 【流程表单】示例",
                slug: "_3-1-【流程表单】示例",
                normalizedTitle: "3.1 【流程表单】示例",
                charIndex: 1564
            }, {
                level: 3,
                title: "3.2 【业务表单】示例",
                slug: "_3-2-【业务表单】示例",
                normalizedTitle: "3.2 【业务表单】示例",
                charIndex: 1760
            }, {
                level: 3,
                title: "3.3 【流程表单】实现原理",
                slug: "_3-3-【流程表单】实现原理",
                normalizedTitle: "3.3 【流程表单】实现原理",
                charIndex: 1954
            }, {
                level: 3,
                title: "3.4 【业务表单】实现原理",
                slug: "_3-4-【业务表单】实现原理",
                normalizedTitle: "3.4 【业务表单】实现原理",
                charIndex: 2211
            }, {
                level: 2,
                title: "4. 流程表达式",
                slug: "_4-流程表达式",
                normalizedTitle: "4. 流程表达式",
                charIndex: 2400
            }],
            headersStr: "1. 审批人配置 2. 选择审批人 3. 自定义 BpmTaskCandidateStrategy 策略 3. 发起人自选 3.1 【流程表单】示例 3.2 【业务表单】示例 3.3 【流程表单】实现原理 3.4 【业务表单】实现原理 4. 流程表达式",
            content: "相关视频：\n\n * 08、如何实现流程模型的分配规则？\n * 14、如何实现流程的任务分配？\n\n当用户发起流程（审批）时，会根据【流程定义】创建对应的审批任务，审批任务会根据【审批人规则】，自动分配给对应的审批人。\n\n审批人可以是固定的角色（比如上级、HR 等），也可以是发起人自选。\n\n\n# 1. 审批人配置\n\n在 BPMN 流程设计器重，每个任务节点，有个 [任务（审批人）] 配置项，用于配置任务审批时，审批人的分配。如下图所示：\n\n\n\n在 BPMN 的 UserTask 节点上，没有合适的内置属性存储“规则类型”、“规则参数”的属性，所以是我们拓展了 candidateStrategy 和 candidateParam 属性，用于存储审批人的规则类型和参数。如下图所示：\n\n\n\n拓展知识：BPMN 的 UserTask 节点，是如何拓展 `candidateStrategy` 和 `candidateParam` 属性的呢？\n\n参见 feadd02、797fddf 提交的代码。\n\n\n# 2. 选择审批人\n\n在上图中，我们可以看到 8 种审批人规则类型，它们都是 BpmTaskCandidateStrategy 的一种实现，如下图所示：\n\n\n\npublic interface BpmTaskCandidateStrategy {\n\n    /**\n     * 对应策略\n     *\n     * @return 策略\n     */\n    BpmTaskCandidateStrategyEnum getStrategy();\n\n    /**\n     * 校验参数\n     *\n     * @param param 参数\n     */\n    void validateParam(String param);\n\n    /**\n     * 基于执行任务，获得任务的候选用户们\n     *\n     * @param execution 执行任务\n     * @return 用户编号集合\n     */\n    Set<Long> calculateUsers(DelegateExecution execution, String param);\n\n    /**\n     * 是否一定要输入参数\n     *\n     * @return 是否\n     */\n    default boolean isParamRequired() {\n        return true;\n    }\n\n}\n\n\n * 关键是 calculateUsers 方法，用于计算候选的审批人。\n\n最终，Flowable 在创建审批任务，分配审批人时，会通过 BpmUserTaskActivityBehavior => BpmTaskCandidateInvoker => BpmTaskCandidateStrategy，时序图如下：\n\n\n\n\n# 3. 自定义 BpmTaskCandidateStrategy 策略\n\n① 第一步，在 BpmTaskCandidateStrategyEnum 中，自定义一个枚举值。\n\n然后，在 bpm_task_candidate_strategy 数据字典中，配置对应的枚举值。\n\n② 第二步，创建一个 BpmTaskCandidateStrategy 的实现类，实现对应的逻辑，并注册成 Spring Bean 即可。\n\n\n# 3. 发起人自选\n\n上述的 8 种审批人规则类型中，有一种是【发起人自选】，它是一种特殊的审批人规则类型。在发起流程时，发起人需要选择对应任务的发起人。\n\n下面，我们分别来看看在【流程表单】、【业务表单】下的例子。\n\n\n# 3.1 【流程表单】示例\n\n① 第一步，设置在 《审批接入（流程表单）》 的“部门领导审批”任务的审批人规则为【发起人自选】。如下图所示：\n\n\n\n注意，需要保存流程，并进行发布流程。\n\n② 选择该流程，进行发起流程，则可以看到“指定审批人”的表单。如下图所示：\n\n\n\n选择“指定审批人”为“源码”，然后进行提交。\n\n③ 查看发起流程的详情，可以看到审批人为“源码”。如下图所示：\n\n\n\n\n# 3.2 【业务表单】示例\n\n① 第一步，设置在 《审批接入（业务表单）》 的“领导审批”任务的审批人规则为【发起人自选】。如下图所示：\n\n\n\n注意，需要保存流程，并进行发布流程。\n\n② 选择该流程，进行发起流程，则可以看到“指定审批人”的表单。如下图所示：\n\n\n\n选择“指定审批人”为“源码”，然后进行提交。\n\n③ 查看发起流程的详情，可以看到审批人为“源码”。如下图所示：\n\n\n\n\n# 3.3 【流程表单】实现原理\n\n① 在【流程表单】的流程发起界面 views/bpm/processInstance/create/index.vue 中，从后端读取【流程定义】时，发现有任务节点的审批人规则是【发起人自选】，则会增加一个“指定审批人”表单项。如下图所示：\n\n\n\n\n\n② 在提交流程时，会将选择的审批人，存储到 Flowable 的流程的 variables 中。如下图所示：\n\n\n\n③ 最终审批任务在分配审批人时，会读取这个 variables，然后分配给对应的审批人。如下图所示：\n\n\n\n\n# 3.4 【业务表单】实现原理\n\n① 在【业务表单】的流程发起界面 views/bpm/oa/leave/create.vue\n\n\n\n\n\n② 在提交流程时，会将选择的审批人，存储到 Flowable 的流程的 variables 中。如下图所示：\n\n\n\n后续的流程，和「3.3 【流程表单】实现原理」就是一致的！总结来说，就是创建流程指定审批人，创建任务使用指定审批人。\n\n\n# 4. 流程表达式\n\n除了自定义 BpmTaskCandidateStrategy 策略外，还可以使用流程表达式，实现审批人的动态分配。\n\n",
            normalizedContent: "相关视频：\n\n * 08、如何实现流程模型的分配规则？\n * 14、如何实现流程的任务分配？\n\n当用户发起流程（审批）时，会根据【流程定义】创建对应的审批任务，审批任务会根据【审批人规则】，自动分配给对应的审批人。\n\n审批人可以是固定的角色（比如上级、hr 等），也可以是发起人自选。\n\n\n# 1. 审批人配置\n\n在 bpmn 流程设计器重，每个任务节点，有个 [任务（审批人）] 配置项，用于配置任务审批时，审批人的分配。如下图所示：\n\n\n\n在 bpmn 的 usertask 节点上，没有合适的内置属性存储“规则类型”、“规则参数”的属性，所以是我们拓展了 candidatestrategy 和 candidateparam 属性，用于存储审批人的规则类型和参数。如下图所示：\n\n\n\n拓展知识：bpmn 的 usertask 节点，是如何拓展 `candidatestrategy` 和 `candidateparam` 属性的呢？\n\n参见 feadd02、797fddf 提交的代码。\n\n\n# 2. 选择审批人\n\n在上图中，我们可以看到 8 种审批人规则类型，它们都是 bpmtaskcandidatestrategy 的一种实现，如下图所示：\n\n\n\npublic interface bpmtaskcandidatestrategy {\n\n    /**\n     * 对应策略\n     *\n     * @return 策略\n     */\n    bpmtaskcandidatestrategyenum getstrategy();\n\n    /**\n     * 校验参数\n     *\n     * @param param 参数\n     */\n    void validateparam(string param);\n\n    /**\n     * 基于执行任务，获得任务的候选用户们\n     *\n     * @param execution 执行任务\n     * @return 用户编号集合\n     */\n    set<long> calculateusers(delegateexecution execution, string param);\n\n    /**\n     * 是否一定要输入参数\n     *\n     * @return 是否\n     */\n    default boolean isparamrequired() {\n        return true;\n    }\n\n}\n\n\n * 关键是 calculateusers 方法，用于计算候选的审批人。\n\n最终，flowable 在创建审批任务，分配审批人时，会通过 bpmusertaskactivitybehavior => bpmtaskcandidateinvoker => bpmtaskcandidatestrategy，时序图如下：\n\n\n\n\n# 3. 自定义 bpmtaskcandidatestrategy 策略\n\n① 第一步，在 bpmtaskcandidatestrategyenum 中，自定义一个枚举值。\n\n然后，在 bpm_task_candidate_strategy 数据字典中，配置对应的枚举值。\n\n② 第二步，创建一个 bpmtaskcandidatestrategy 的实现类，实现对应的逻辑，并注册成 spring bean 即可。\n\n\n# 3. 发起人自选\n\n上述的 8 种审批人规则类型中，有一种是【发起人自选】，它是一种特殊的审批人规则类型。在发起流程时，发起人需要选择对应任务的发起人。\n\n下面，我们分别来看看在【流程表单】、【业务表单】下的例子。\n\n\n# 3.1 【流程表单】示例\n\n① 第一步，设置在 《审批接入（流程表单）》 的“部门领导审批”任务的审批人规则为【发起人自选】。如下图所示：\n\n\n\n注意，需要保存流程，并进行发布流程。\n\n② 选择该流程，进行发起流程，则可以看到“指定审批人”的表单。如下图所示：\n\n\n\n选择“指定审批人”为“源码”，然后进行提交。\n\n③ 查看发起流程的详情，可以看到审批人为“源码”。如下图所示：\n\n\n\n\n# 3.2 【业务表单】示例\n\n① 第一步，设置在 《审批接入（业务表单）》 的“领导审批”任务的审批人规则为【发起人自选】。如下图所示：\n\n\n\n注意，需要保存流程，并进行发布流程。\n\n② 选择该流程，进行发起流程，则可以看到“指定审批人”的表单。如下图所示：\n\n\n\n选择“指定审批人”为“源码”，然后进行提交。\n\n③ 查看发起流程的详情，可以看到审批人为“源码”。如下图所示：\n\n\n\n\n# 3.3 【流程表单】实现原理\n\n① 在【流程表单】的流程发起界面 views/bpm/processinstance/create/index.vue 中，从后端读取【流程定义】时，发现有任务节点的审批人规则是【发起人自选】，则会增加一个“指定审批人”表单项。如下图所示：\n\n\n\n\n\n② 在提交流程时，会将选择的审批人，存储到 flowable 的流程的 variables 中。如下图所示：\n\n\n\n③ 最终审批任务在分配审批人时，会读取这个 variables，然后分配给对应的审批人。如下图所示：\n\n\n\n\n# 3.4 【业务表单】实现原理\n\n① 在【业务表单】的流程发起界面 views/bpm/oa/leave/create.vue\n\n\n\n\n\n② 在提交流程时，会将选择的审批人，存储到 flowable 的流程的 variables 中。如下图所示：\n\n\n\n后续的流程，和「3.3 【流程表单】实现原理」就是一致的！总结来说，就是创建流程指定审批人，创建任务使用指定审批人。\n\n\n# 4. 流程表达式\n\n除了自定义 bpmtaskcandidatestrategy 策略外，还可以使用流程表达式，实现审批人的动态分配。\n\n",
            charsets: {
                cjk: !0
            }
        }, {
            title: "会签、或签、依次审批",
            frontmatter: {
                title: "会签、或签、依次审批",
                date: "2024-03-25T06:03:58.000Z",
                permalink: "/bpm/multi-instance"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/10.%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%89%8B%E5%86%8C/21.%E4%BC%9A%E7%AD%BE%E3%80%81%E6%88%96%E7%AD%BE%E3%80%81%E4%BE%9D%E6%AC%A1%E5%AE%A1%E6%89%B9.html",
            relativePath: "01.开发指南/10.工作流手册/21.会签、或签、依次审批.md",
            key: "v-36616294",
            path: "/bpm/multi-instance/",
            headers: [{
                level: 2,
                title: "1. 多人审批",
                slug: "_1-多人审批",
                normalizedTitle: "1. 多人审批",
                charIndex: 248
            }, {
                level: 2,
                title: "1. 会签（并行会签）",
                slug: "_1-会签-并行会签",
                normalizedTitle: "1. 会签（并行会签）",
                charIndex: 260
            }, {
                level: 2,
                title: "2. 或签（并行或签）",
                slug: "_2-或签-并行或签",
                normalizedTitle: "2. 或签（并行或签）",
                charIndex: 576
            }, {
                level: 2,
                title: "3. 依次审批",
                slug: "_3-依次审批",
                normalizedTitle: "3. 依次审批",
                charIndex: 709
            }, {
                level: 2,
                title: "2. 实现原理",
                slug: "_2-实现原理",
                normalizedTitle: "2. 实现原理",
                charIndex: 1012
            }, {
                level: 3,
                title: "2.1 并行 BpmParallelMultiInstanceBehavior",
                slug: "_2-1-并行-bpmparallelmultiinstancebehavior",
                normalizedTitle: "2.1 并行 bpmparallelmultiinstancebehavior",
                charIndex: 1256
            }, {
                level: 3,
                title: "2.2 顺序 BpmSequentialMultiInstanceBehavior",
                slug: "_2-2-顺序-bpmsequentialmultiinstancebehavior",
                normalizedTitle: "2.2 顺序 bpmsequentialmultiinstancebehavior",
                charIndex: 1606
            }],
            headersStr: "1. 多人审批 1. 会签（并行会签） 2. 或签（并行或签） 3. 依次审批 2. 实现原理 2.1 并行 BpmParallelMultiInstanceBehavior 2.2 顺序 BpmSequentialMultiInstanceBehavior",
            content: "相关视频：\n\n * 15、如何实现会签、或签任务？\n\n支持多人审批，包括：\n\n * 会签（并行会签）：同一个审批节点设置多个人（如 A、B、C 三人，三人会同时收到待办任务），需全部同意之后，审批才可到下一审批节点\n * 或签（并行或签）：同一个审批节点设置多个人，任意一个人处理后，就能进入下一个节点\n * 依次审批（顺序会签）：同一个审批节点设置多个人（如 A、B、C 三人），三人按顺序依次收到待办，即 A 先审批，A 提交后 B 才能审批，需全部同意之后，审批才可到下一审批节点\n\n\n# 1. 多人审批\n\n\n# 1. 会签（并行会签）\n\n\n\n * 会签配置：并行多重事件，实现多个人同时审批\n * 完成条件：${ nrOfCompletedInstances >= nrOfInstances }，表示所有人都审批通过，才能进入下一个节点\n\n疑问：`nrOfCompletedInstances`、`nrOfInstances` 表示什么意思？\n\n * nrOfCompletedInstances：当前节点已完成的任务数量\n * nrOfInstances：当前节点总的任务数量\n\n因此，${ nrOfCompletedInstances >= nrOfInstances } 就是，“已完成”大于“总的”数量，即所有人都审批通过。\n\n\n# 2. 或签（并行或签）\n\n\n\n * 会签配置：并行多重事件，实现多个人同时审批\n * 完成条件：${ nrOfCompletedInstances == 1 }，表示只要有一个人审批通过，就能进入下一个节点\n\n因此，会签和或签的差异，就在于完成条件的不同。\n\n\n# 3. 依次审批\n\n\n\n * 依次审批配置：顺序多重事件，实现多个人按顺序审批\n * 循环数量：1，表示每次（“循环”）只有一个人审批\n * 完成条件：${ nrOfCompletedInstances >= nrOfInstances }，表示只要有一个人审批通过，就能进入下一个节点\n\n因此，依次审批和会签的差异，就在于是否并行审批。\n\n----------------------------------------\n\n按照这个思路，实现“票签”，是不是很简单？！\n\n友情提示：什么是“票签”？\n\n指同一个审批节点设置多个人，如 A、B、C 三人，当通过比例大于 50% 就能进入下一个节点。\n\n\n# 2. 实现原理\n\n在 《选择审批人、发起人自选》 小节中，我们看到使用 BpmUserTaskActivityBehavior 实现了审批任务的审批人分配。实际上，还有两个 Behavior 类，如下图所示：\n\n\n\n * BpmParallelMultiInstanceBehavior：并行 + 多实例（单节点多任务）的 Behavior 类\n * BpmSequentialMultiInstanceBehavior：顺序 + 多实例（单节点多任务）的 Behavior 类\n\n\n# 2.1 并行 BpmParallelMultiInstanceBehavior\n\n① BpmParallelMultiInstanceBehavior 实现 Flowable ParallelMultiInstanceBehavior 类，实现单节点多任务的审批人 “计算”。如下图所示：\n\n\n\n② BpmUserTaskActivityBehavior，判断是多实例的情况，则复用 BpmParallelMultiInstanceBehavior “计算”结果，直接设置审批人。如下图所示：\n\n\n\n所以，先是 BpmParallelMultiInstanceBehavior 计算审批任务数量 + 审批人列表，然后 BpmUserTaskActivityBehavior 直接设置审批人。\n\n\n# 2.2 顺序 BpmSequentialMultiInstanceBehavior\n\n① BpmSequentialMultiInstanceBehavior 实现 Flowable SequentialMultiInstanceBehavior 类，实现单节点多任务的审批人 “计算”。如下图所示：\n\n\n\n② 还是使用 BpmUserTaskActivityBehavior，逻辑是一模一样的。\n\n所以，BpmSequentialMultiInstanceBehavior 和 BpmParallelMultiInstanceBehavior 基本是一致的，差异只是前者返回的是 LinkedHashSet 有序集合。最终，还是交给 Flowable 到底是一次性创建多个审批任务，还是按照顺序创建多个审批任务。",
            normalizedContent: "相关视频：\n\n * 15、如何实现会签、或签任务？\n\n支持多人审批，包括：\n\n * 会签（并行会签）：同一个审批节点设置多个人（如 a、b、c 三人，三人会同时收到待办任务），需全部同意之后，审批才可到下一审批节点\n * 或签（并行或签）：同一个审批节点设置多个人，任意一个人处理后，就能进入下一个节点\n * 依次审批（顺序会签）：同一个审批节点设置多个人（如 a、b、c 三人），三人按顺序依次收到待办，即 a 先审批，a 提交后 b 才能审批，需全部同意之后，审批才可到下一审批节点\n\n\n# 1. 多人审批\n\n\n# 1. 会签（并行会签）\n\n\n\n * 会签配置：并行多重事件，实现多个人同时审批\n * 完成条件：${ nrofcompletedinstances >= nrofinstances }，表示所有人都审批通过，才能进入下一个节点\n\n疑问：`nrofcompletedinstances`、`nrofinstances` 表示什么意思？\n\n * nrofcompletedinstances：当前节点已完成的任务数量\n * nrofinstances：当前节点总的任务数量\n\n因此，${ nrofcompletedinstances >= nrofinstances } 就是，“已完成”大于“总的”数量，即所有人都审批通过。\n\n\n# 2. 或签（并行或签）\n\n\n\n * 会签配置：并行多重事件，实现多个人同时审批\n * 完成条件：${ nrofcompletedinstances == 1 }，表示只要有一个人审批通过，就能进入下一个节点\n\n因此，会签和或签的差异，就在于完成条件的不同。\n\n\n# 3. 依次审批\n\n\n\n * 依次审批配置：顺序多重事件，实现多个人按顺序审批\n * 循环数量：1，表示每次（“循环”）只有一个人审批\n * 完成条件：${ nrofcompletedinstances >= nrofinstances }，表示只要有一个人审批通过，就能进入下一个节点\n\n因此，依次审批和会签的差异，就在于是否并行审批。\n\n----------------------------------------\n\n按照这个思路，实现“票签”，是不是很简单？！\n\n友情提示：什么是“票签”？\n\n指同一个审批节点设置多个人，如 a、b、c 三人，当通过比例大于 50% 就能进入下一个节点。\n\n\n# 2. 实现原理\n\n在 《选择审批人、发起人自选》 小节中，我们看到使用 bpmusertaskactivitybehavior 实现了审批任务的审批人分配。实际上，还有两个 behavior 类，如下图所示：\n\n\n\n * bpmparallelmultiinstancebehavior：并行 + 多实例（单节点多任务）的 behavior 类\n * bpmsequentialmultiinstancebehavior：顺序 + 多实例（单节点多任务）的 behavior 类\n\n\n# 2.1 并行 bpmparallelmultiinstancebehavior\n\n① bpmparallelmultiinstancebehavior 实现 flowable parallelmultiinstancebehavior 类，实现单节点多任务的审批人 “计算”。如下图所示：\n\n\n\n② bpmusertaskactivitybehavior，判断是多实例的情况，则复用 bpmparallelmultiinstancebehavior “计算”结果，直接设置审批人。如下图所示：\n\n\n\n所以，先是 bpmparallelmultiinstancebehavior 计算审批任务数量 + 审批人列表，然后 bpmusertaskactivitybehavior 直接设置审批人。\n\n\n# 2.2 顺序 bpmsequentialmultiinstancebehavior\n\n① bpmsequentialmultiinstancebehavior 实现 flowable sequentialmultiinstancebehavior 类，实现单节点多任务的审批人 “计算”。如下图所示：\n\n\n\n② 还是使用 bpmusertaskactivitybehavior，逻辑是一模一样的。\n\n所以，bpmsequentialmultiinstancebehavior 和 bpmparallelmultiinstancebehavior 基本是一致的，差异只是前者返回的是 linkedhashset 有序集合。最终，还是交给 flowable 到底是一次性创建多个审批任务，还是按照顺序创建多个审批任务。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "审批通过、不通过、驳回",
            frontmatter: {
                title: "审批通过、不通过、驳回",
                date: "2024-03-25T17:07:59.000Z",
                permalink: "/bpm/task-todo-done"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/10.%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%89%8B%E5%86%8C/23.%E5%AE%A1%E6%89%B9%E9%80%9A%E8%BF%87%E3%80%81%E4%B8%8D%E9%80%9A%E8%BF%87%E3%80%81%E9%A9%B3%E5%9B%9E.html",
            relativePath: "01.开发指南/10.工作流手册/23.审批通过、不通过、驳回.md",
            key: "v-2ec9624a",
            path: "/bpm/task-todo-done/",
            headers: [{
                level: 2,
                title: "1. 待办任务",
                slug: "_1-待办任务",
                normalizedTitle: "1. 待办任务",
                charIndex: 172
            }, {
                level: 3,
                title: "1.1 表结构",
                slug: "_1-1-表结构",
                normalizedTitle: "1.1 表结构",
                charIndex: 334
            }, {
                level: 3,
                title: "1.2 任务状态",
                slug: "_1-2-任务状态",
                normalizedTitle: "1.2 任务状态",
                charIndex: 2664
            }, {
                level: 3,
                title: "1.3 审批通过",
                slug: "_1-3-审批通过",
                normalizedTitle: "1.3 审批通过",
                charIndex: 2720
            }, {
                level: 3,
                title: "1.4 审批不通过",
                slug: "_1-4-审批不通过",
                normalizedTitle: "1.4 审批不通过",
                charIndex: 2896
            }, {
                level: 3,
                title: "1.5 驳回",
                slug: "_1-5-驳回",
                normalizedTitle: "1.5 驳回",
                charIndex: 3011
            }, {
                level: 2,
                title: "2. 已办任务",
                slug: "_2-已办任务",
                normalizedTitle: "2. 已办任务",
                charIndex: 3299
            }, {
                level: 3,
                title: "2.1 表结构",
                slug: "_2-1-表结构",
                normalizedTitle: "2.1 表结构",
                charIndex: 3460
            }, {
                level: 2,
                title: "3. 流程任务",
                slug: "_3-流程任务",
                normalizedTitle: "3. 流程任务",
                charIndex: 6094
            }, {
                level: 2,
                title: "666. 更多功能",
                slug: "_666-更多功能",
                normalizedTitle: "666. 更多功能",
                charIndex: 6328
            }],
            headersStr: "1. 待办任务 1.1 表结构 1.2 任务状态 1.3 审批通过 1.4 审批不通过 1.5 驳回 2. 已办任务 2.1 表结构 3. 流程任务 666. 更多功能",
            content: "相关视频：\n\n * 16、如何实现我的待办任务列表？\n * 17、如何实现我的已办任务列表？\n * 18、如何实现任务的审批通过？\n * 19、如何实现任务的审批不通过？\n * 20、如何实现流程的审批记录？\n\n本文，我们围绕 [审批中心] 菜单下的 [待办任务]、[已办任务] 两个子菜单，讲解审批通过、审批不通过、驳回的操作流程。\n\n\n# 1. 待办任务\n\n待办任务，仅展示需要我审批的任务，对应 [审批中心 -> 待办任务] 菜单，如下图所示：\n\n\n\n * 后端，对应 BpmTaskController 的 #getTaskTodoPage(...) 提供接口\n * 前端，对应 /views/bpm/task/todo/index.vue 实现界面\n\n\n# 1.1 表结构\n\n① 流程任务表，由 Flowable 提供的 ACT_RU_TASK 表实现，如下所示：\n\n字段                  类型                主键   说明            备注\nID_                 NVARCHAR2(64)     Y    主键            \nREV_                INTEGER           N    数据版本          \nEXECUTION_ID_       NVARCHAR2(64)     N    任务所在的执行流 ID   \nPROC_INST_ID_       NVARCHAR2(64)     N    流程实例 ID       \nPROC_DEF_ID_        NVARCHAR2(64)     N    流程定义数据 ID     \nNAME_               NVARCHAR2(255)    N    任务名称          \nPARENT_TASK_ID_     NVARCHAR2(64)     N    父任务 ID        \nDESCRIPTION_        NVARCHAR2(2000)   N    说明            \nTASK_DEF_KEY_       NVARCHAR2(255)    N    任务定义的 ID 值    \nOWNER_              NVARCHAR2(255)    N    任务拥有人         \nASSIGNEE_           NVARCHAR2(255)    N    被指派执行该任务的人    \nDELEGATION_         NVARCHAR2(64)     N                  \nPRIORITY_           INTEGER           N                  \nCREATE_TIME_        TIMESTAMP(6)      N    创建时间          \nDUE_DATE_           TIMESTAMP(6)      N    耗时            \nCATEGORY_           NVARCHAR2(255)    N                  \nSUSPENSION_STATE_   INTEGER           N    是否挂起          1 代表激活 2 代表挂起\nTENANT_ID_          NVARCHAR2(255)    N                  \nFORM_KEY_           NVARCHAR2(255)    N                  \nCLAIM_TIME_         TIMESTAMP(6)      N                  \n\n② 流程参数表，由 Flowable 提供的 ACT_RU_VARIABLE 表实现，如下所示：\n\n字段              类型                主键   说明                    备注\nID_             NVARCHAR2(64)     Y    主键                    \nREV_            INTEGER           N    数据版本                  \nTYPE_           NVARCHAR2(255)    N    参数类型                  可以是基本的类型，也可以用户自行扩展\nNAME_           NVARCHAR2(255)    N    参数名称                  \nEXECUTION_ID_   NVARCHAR2(64)     N    参数执行 ID               \nPROC_INST_ID_   NVARCHAR2(64)     N    流程实例 ID               \nTASK_ID_        NVARCHAR2(64)     N    任务 ID                 \nBYTEARRAY_ID_   NVARCHAR2(64)     N    资源 ID                 \nDOUBLE_         NUMBER(*,10)      N    参数为 double，则保存在该字段中   \nLONG_           NUMBER(19)        N    参数为 long，则保存在该字段中     \nTEXT_           NVARCHAR2(2000)   N    用户保存文本类型的参数值          \nTEXT2_          NVARCHAR2(2000)   N    用户保存文本类型的参数值          \n\n在 Flowable 中，如果想给 Task 增加拓展字段，无法通过 ACT_RU_TASK 实现，而是通过 ACT_RU_VARIABLE 表实现。\n\n该表是一种 Key-Value 的形式，可以存储任意类型的数据。例如说，项目中给 Task 增加了一个 TASK_STATUS 字段，表示任务状态，如下图所示：\n\n\n\n\n# 1.2 任务状态\n\n任务状态，由 BpmTaskStatusEnum 目前有 8 种，如下图所示：\n\n\n\n\n# 1.3 审批通过\n\n审批通过，由 BpmTaskController 的 #approveTask(...) 提供接口，如下图所示：\n\n\n\n最核心的，就是调用 Flowable 的 TaskService#complete(...) 方法，完成任务。同时因为 Flowable 自身没有任务状态，所以需要我们自己维护任务状态。如下图所示：\n\n\n\n\n# 1.4 审批不通过\n\n审批不通过，由 BpmTaskController 的 #rejectTask(...) 提供接口，如下图所示：\n\n\n\n注意，任务只要审批不通过，整个流程都会被中止（审批不通过），即使在或签场景下！\n\n\n# 1.5 驳回\n\n驳回（退回），将审批重置发送给某节点，重新审批。如下图所示：\n\n\n\n① 获得可驳回的节点，由 BpmTaskController 的 #getTaskListByReturn(...) 提供接口，如下图所示：\n\n\n\n② 发起驳回，由 BpmTaskController 的 #returnTask(...) 提供接口，如下图所示：\n\n\n\n核心还是 Flowable 提供的 #moveActivityIdsToSingleActivityId(...) 方法，它是 Activiti 没有内置的方法，所以在 Activiti 实现驳回就略微麻烦一些。\n\n\n# 2. 已办任务\n\n已办任务，仅展示我审批过的任务，对应 [审批中心 -> 已办任务] 菜单，如下图所示：\n\n\n\n * 后端，对应 BpmTaskController 的 #getTaskDonePage(...) 提供接口\n * 前端，对应 /views/bpm/task/done/index.vue 实现界面\n\n\n# 2.1 表结构\n\n① 流程历史任务表，由 Flowable 提供的 ACT_HI_TASKINST 表实现，如下所示：\n\n字段                类型                主键   说明              备注\n字段                类型                主键   说明              备注\nID_               NVARCHAR2(64)     Y    主键              \nPROC_DEF_ID_      NVARCHAR2(64)     N    流程定义 ID         \nTASK_DEF_KEY_     NVARCHAR2(255)    N    任务定义的 ID 值      \nPROC_INST_ID_     NVARCHAR2(64)     N    流程实例 ID         \nEXECUTION_ID_     NVARCHAR2(64)     N    执行 ID           \nPARENT_TASK_ID_   NVARCHAR2(64)     N    父任务 ID          \nNAME_             NVARCHAR2(255)    N    名称              \nDESCRIPTION_      NVARCHAR2(2000)   N    说明              \nOWNER_            NVARCHAR2(255)    N    实际签收人 任务的拥有者    签收人（默认为空，只有在委托时才有值）\nASSIGNEE_         NVARCHAR2(255)    N    被指派执行该任务的人      \nSTART_TIME_       TIMESTAMP(6)      N    开始时间            \nCLAIM_TIME_       TIMESTAMP(6)      N    提醒时间            \nEND_TIME_         TIMESTAMP(6)      N    结束时间            \nDURATION_         NUMBER(19)        N    耗时              \nDELETE_REASON_    NVARCHAR2(2000)   N    删除原因            \nPRIORITY_         INTEGER           N    优先级别            \nDUE_DATE_         TIMESTAMP(6)      N    过期时间            \nFORM_KEY_         NVARCHAR2(255)    N    节点定义的 formkey   \nCATEGORY_         NVARCHAR2(255)    N    类别              \nTENANT_ID_        NVARCHAR2(255)    N                    \n\n在 Flowable 中，如果 Task 被完成（审批通过、不通过、取消等）时候，会从 ACT_RU_TASK 表中删除，只能在 ACT_HI_TASKINST 表查询到。这是一种“冷热分离”的设计思想，因为进行的任务访问比较频繁，数据量越小，性能会越好。\n\n② 流程历史参数表，由 Flowable 提供的 ACT_HI_VARINST 表实现，如下所示：\n\n字段                   类型                   主键   说明               备注\nID_                  NVARCHAR2(64)        Y    主键               \nPROC_INST_ID_        NVARCHAR2(64)        N    流程实例 ID          \nEXECUTION_ID_        NVARCHAR2(64)        N    指定 ID            \nTASK_ID_             NVARCHAR2(64)        N    任务 ID            \nNAME_                NVARCHAR2(255)       N    名称               \nVAR_TYPE_            NVARCHAR2(100)       N    参数类型             \nREV_                 INTEGER              N    数据版本             \nBYTEARRAY_ID_        NVARCHAR2(64)        N    字节表 ID           \nDOUBLE_              NUMBER(*,10)         N    存储 double 类型数据   \nLONG_                NUMBER(*,10)         N    存储 long 类型数据     \nTEXT_                NVARCHAR2(2000)      N                     \nTEXT2_               NVARCHAR2(2000)      N                     \nCREATE_TIME_         TIMESTAMP(6)(2000)   N                     \nLAST_UPDATED_TIME_   TIMESTAMP(6)(2000)   N                     \n\n在 Flowable 中，如果 Task 被完成（审批通过、不通过、取消等）时候，会从 ACT_RU_VARIABLE 表中删除，只能在 ACT_HI_VARINST 表查询到。这当然也是是一种“冷热分离”的设计思想~\n\n\n# 3. 流程任务\n\n流程任务，展示系统中所有的任务，一般用于管理员查询，对应 [流程管理 -> 流程任务] 菜单，如下图所示：\n\n\n\n * 后端，对应 BpmTaskController 的 #getTaskManagerPage(...) 提供接口\n * 前端，对应 /views/bpm/task/manager/index.vue 实现界面\n\n由于它查询的是所有任务，所以读取的是 ACT_HI_TASKINST 表，而不是 ACT_RU_TASK 表。\n\n\n# 666. 更多功能\n\n * 《自动跳过、自动审批》",
            normalizedContent: "相关视频：\n\n * 16、如何实现我的待办任务列表？\n * 17、如何实现我的已办任务列表？\n * 18、如何实现任务的审批通过？\n * 19、如何实现任务的审批不通过？\n * 20、如何实现流程的审批记录？\n\n本文，我们围绕 [审批中心] 菜单下的 [待办任务]、[已办任务] 两个子菜单，讲解审批通过、审批不通过、驳回的操作流程。\n\n\n# 1. 待办任务\n\n待办任务，仅展示需要我审批的任务，对应 [审批中心 -> 待办任务] 菜单，如下图所示：\n\n\n\n * 后端，对应 bpmtaskcontroller 的 #gettasktodopage(...) 提供接口\n * 前端，对应 /views/bpm/task/todo/index.vue 实现界面\n\n\n# 1.1 表结构\n\n① 流程任务表，由 flowable 提供的 act_ru_task 表实现，如下所示：\n\n字段                  类型                主键   说明            备注\nid_                 nvarchar2(64)     y    主键            \nrev_                integer           n    数据版本          \nexecution_id_       nvarchar2(64)     n    任务所在的执行流 id   \nproc_inst_id_       nvarchar2(64)     n    流程实例 id       \nproc_def_id_        nvarchar2(64)     n    流程定义数据 id     \nname_               nvarchar2(255)    n    任务名称          \nparent_task_id_     nvarchar2(64)     n    父任务 id        \ndescription_        nvarchar2(2000)   n    说明            \ntask_def_key_       nvarchar2(255)    n    任务定义的 id 值    \nowner_              nvarchar2(255)    n    任务拥有人         \nassignee_           nvarchar2(255)    n    被指派执行该任务的人    \ndelegation_         nvarchar2(64)     n                  \npriority_           integer           n                  \ncreate_time_        timestamp(6)      n    创建时间          \ndue_date_           timestamp(6)      n    耗时            \ncategory_           nvarchar2(255)    n                  \nsuspension_state_   integer           n    是否挂起          1 代表激活 2 代表挂起\ntenant_id_          nvarchar2(255)    n                  \nform_key_           nvarchar2(255)    n                  \nclaim_time_         timestamp(6)      n                  \n\n② 流程参数表，由 flowable 提供的 act_ru_variable 表实现，如下所示：\n\n字段              类型                主键   说明                    备注\nid_             nvarchar2(64)     y    主键                    \nrev_            integer           n    数据版本                  \ntype_           nvarchar2(255)    n    参数类型                  可以是基本的类型，也可以用户自行扩展\nname_           nvarchar2(255)    n    参数名称                  \nexecution_id_   nvarchar2(64)     n    参数执行 id               \nproc_inst_id_   nvarchar2(64)     n    流程实例 id               \ntask_id_        nvarchar2(64)     n    任务 id                 \nbytearray_id_   nvarchar2(64)     n    资源 id                 \ndouble_         number(*,10)      n    参数为 double，则保存在该字段中   \nlong_           number(19)        n    参数为 long，则保存在该字段中     \ntext_           nvarchar2(2000)   n    用户保存文本类型的参数值          \ntext2_          nvarchar2(2000)   n    用户保存文本类型的参数值          \n\n在 flowable 中，如果想给 task 增加拓展字段，无法通过 act_ru_task 实现，而是通过 act_ru_variable 表实现。\n\n该表是一种 key-value 的形式，可以存储任意类型的数据。例如说，项目中给 task 增加了一个 task_status 字段，表示任务状态，如下图所示：\n\n\n\n\n# 1.2 任务状态\n\n任务状态，由 bpmtaskstatusenum 目前有 8 种，如下图所示：\n\n\n\n\n# 1.3 审批通过\n\n审批通过，由 bpmtaskcontroller 的 #approvetask(...) 提供接口，如下图所示：\n\n\n\n最核心的，就是调用 flowable 的 taskservice#complete(...) 方法，完成任务。同时因为 flowable 自身没有任务状态，所以需要我们自己维护任务状态。如下图所示：\n\n\n\n\n# 1.4 审批不通过\n\n审批不通过，由 bpmtaskcontroller 的 #rejecttask(...) 提供接口，如下图所示：\n\n\n\n注意，任务只要审批不通过，整个流程都会被中止（审批不通过），即使在或签场景下！\n\n\n# 1.5 驳回\n\n驳回（退回），将审批重置发送给某节点，重新审批。如下图所示：\n\n\n\n① 获得可驳回的节点，由 bpmtaskcontroller 的 #gettasklistbyreturn(...) 提供接口，如下图所示：\n\n\n\n② 发起驳回，由 bpmtaskcontroller 的 #returntask(...) 提供接口，如下图所示：\n\n\n\n核心还是 flowable 提供的 #moveactivityidstosingleactivityid(...) 方法，它是 activiti 没有内置的方法，所以在 activiti 实现驳回就略微麻烦一些。\n\n\n# 2. 已办任务\n\n已办任务，仅展示我审批过的任务，对应 [审批中心 -> 已办任务] 菜单，如下图所示：\n\n\n\n * 后端，对应 bpmtaskcontroller 的 #gettaskdonepage(...) 提供接口\n * 前端，对应 /views/bpm/task/done/index.vue 实现界面\n\n\n# 2.1 表结构\n\n① 流程历史任务表，由 flowable 提供的 act_hi_taskinst 表实现，如下所示：\n\n字段                类型                主键   说明              备注\n字段                类型                主键   说明              备注\nid_               nvarchar2(64)     y    主键              \nproc_def_id_      nvarchar2(64)     n    流程定义 id         \ntask_def_key_     nvarchar2(255)    n    任务定义的 id 值      \nproc_inst_id_     nvarchar2(64)     n    流程实例 id         \nexecution_id_     nvarchar2(64)     n    执行 id           \nparent_task_id_   nvarchar2(64)     n    父任务 id          \nname_             nvarchar2(255)    n    名称              \ndescription_      nvarchar2(2000)   n    说明              \nowner_            nvarchar2(255)    n    实际签收人 任务的拥有者    签收人（默认为空，只有在委托时才有值）\nassignee_         nvarchar2(255)    n    被指派执行该任务的人      \nstart_time_       timestamp(6)      n    开始时间            \nclaim_time_       timestamp(6)      n    提醒时间            \nend_time_         timestamp(6)      n    结束时间            \nduration_         number(19)        n    耗时              \ndelete_reason_    nvarchar2(2000)   n    删除原因            \npriority_         integer           n    优先级别            \ndue_date_         timestamp(6)      n    过期时间            \nform_key_         nvarchar2(255)    n    节点定义的 formkey   \ncategory_         nvarchar2(255)    n    类别              \ntenant_id_        nvarchar2(255)    n                    \n\n在 flowable 中，如果 task 被完成（审批通过、不通过、取消等）时候，会从 act_ru_task 表中删除，只能在 act_hi_taskinst 表查询到。这是一种“冷热分离”的设计思想，因为进行的任务访问比较频繁，数据量越小，性能会越好。\n\n② 流程历史参数表，由 flowable 提供的 act_hi_varinst 表实现，如下所示：\n\n字段                   类型                   主键   说明               备注\nid_                  nvarchar2(64)        y    主键               \nproc_inst_id_        nvarchar2(64)        n    流程实例 id          \nexecution_id_        nvarchar2(64)        n    指定 id            \ntask_id_             nvarchar2(64)        n    任务 id            \nname_                nvarchar2(255)       n    名称               \nvar_type_            nvarchar2(100)       n    参数类型             \nrev_                 integer              n    数据版本             \nbytearray_id_        nvarchar2(64)        n    字节表 id           \ndouble_              number(*,10)         n    存储 double 类型数据   \nlong_                number(*,10)         n    存储 long 类型数据     \ntext_                nvarchar2(2000)      n                     \ntext2_               nvarchar2(2000)      n                     \ncreate_time_         timestamp(6)(2000)   n                     \nlast_updated_time_   timestamp(6)(2000)   n                     \n\n在 flowable 中，如果 task 被完成（审批通过、不通过、取消等）时候，会从 act_ru_variable 表中删除，只能在 act_hi_varinst 表查询到。这当然也是是一种“冷热分离”的设计思想~\n\n\n# 3. 流程任务\n\n流程任务，展示系统中所有的任务，一般用于管理员查询，对应 [流程管理 -> 流程任务] 菜单，如下图所示：\n\n\n\n * 后端，对应 bpmtaskcontroller 的 #gettaskmanagerpage(...) 提供接口\n * 前端，对应 /views/bpm/task/manager/index.vue 实现界面\n\n由于它查询的是所有任务，所以读取的是 act_hi_taskinst 表，而不是 act_ru_task 表。\n\n\n# 666. 更多功能\n\n * 《自动跳过、自动审批》",
            charsets: {
                cjk: !0
            }
        }, {
            title: "审批加签、减签",
            frontmatter: {
                title: "审批加签、减签",
                date: "2024-03-25T21:36:21.000Z",
                permalink: "/bpm/sign/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/10.%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%89%8B%E5%86%8C/24.%E5%AE%A1%E6%89%B9%E5%8A%A0%E7%AD%BE%E3%80%81%E5%87%8F%E7%AD%BE.html",
            relativePath: "01.开发指南/10.工作流手册/24.审批加签、减签.md",
            key: "v-206fa80a",
            path: "/bpm/sign/",
            headers: [{
                level: 2,
                title: "1. 向前加签",
                slug: "_1-向前加签",
                normalizedTitle: "1. 向前加签",
                charIndex: 304
            }, {
                level: 3,
                title: "1.1 发起向前加签",
                slug: "_1-1-发起向前加签",
                normalizedTitle: "1.1 发起向前加签",
                charIndex: 316
            }, {
                level: 3,
                title: "1.2 审批向前加签子任务",
                slug: "_1-2-审批向前加签子任务",
                normalizedTitle: "1.2 审批向前加签子任务",
                charIndex: 964
            }, {
                level: 2,
                title: "2. 向后加签",
                slug: "_2-向后加签",
                normalizedTitle: "2. 向后加签",
                charIndex: 1586
            }, {
                level: 3,
                title: "2.1 发起向后加签",
                slug: "_2-1-发起向后加签",
                normalizedTitle: "2.1 发起向后加签",
                charIndex: 1598
            }, {
                level: 3,
                title: "2.2 审批向后加签子任务",
                slug: "_2-2-审批向后加签子任务",
                normalizedTitle: "2.2 审批向后加签子任务",
                charIndex: 1745
            }, {
                level: 3,
                title: "2.2 审批当前（原）任务",
                slug: "_2-2-审批当前-原-任务",
                normalizedTitle: "2.2 审批当前（原）任务",
                charIndex: 2113
            }, {
                level: 3,
                title: "2.2.1 操作步骤",
                slug: "_2-2-1-操作步骤",
                normalizedTitle: "2.2.1 操作步骤",
                charIndex: 2131
            }, {
                level: 3,
                title: "2.2.2 后端实现",
                slug: "_2-2-2-后端实现",
                normalizedTitle: "2.2.2 后端实现",
                charIndex: 2262
            }, {
                level: 3,
                title: "2.3 审批向后加签子任务",
                slug: "_2-3-审批向后加签子任务",
                normalizedTitle: "2.3 审批向后加签子任务",
                charIndex: 2495
            }, {
                level: 2,
                title: "3. 减签",
                slug: "_3-减签",
                normalizedTitle: "3. 减签",
                charIndex: 2896
            }, {
                level: 3,
                title: "3.1 操作步骤",
                slug: "_3-1-操作步骤",
                normalizedTitle: "3.1 操作步骤",
                charIndex: 2514
            }, {
                level: 3,
                title: "3.2 后端实现",
                slug: "_3-2-后端实现",
                normalizedTitle: "3.2 后端实现",
                charIndex: 2657
            }],
            headersStr: "1. 向前加签 1.1 发起向前加签 1.2 审批向前加签子任务 2. 向后加签 2.1 发起向后加签 2.2 审批向后加签子任务 2.2 审批当前（原）任务 2.2.1 操作步骤 2.2.2 后端实现 2.3 审批向后加签子任务 3. 减签 3.1 操作步骤 3.2 后端实现",
            content: "本文，我们来讲解下审批加签、减签的功能：\n\n * 加签：添加其他审批人来共同审批，自己仍需参与审批。例如，不好判断当前审批时，可以添加其他人来共同审批\n * 减签：当以“加签”的方式添加了其他审批人时，可以操作减签进行移除，对方无需再审批。例如，加签有误时，可以通过减签来操作\n\n其中，加签分成两种：\n\n * 向前加签：在任务 A 之【前】添加 B、C、D 三个子任务，在 B、C、D 子任务都审批完成后，任务 A 才能继续审批\n * 向后加签：在任务 A 之【后】添加 B、C、D 三个子任务，在任务 A 审批通过（处于审批通过中），只有 B、C、D 三个子任务都审批通过，任务 A 才会审批通过\n\n\n# 1. 向前加签\n\n\n# 1.1 发起向前加签\n\n# 1.1.1 操作步骤\n\n① 首先，点击「加签」按钮，选择被加签的处理人，之后点击「向前加签」按钮，完成向前加签操作。如下图所示：\n\n\n\n② 之后，可以看到当前任务变成“待审核”状态，它有加签出来的一个子任务，该子任务的状态是“待审核”状态，如下图所示：\n\n\n\n# 1.1.2 后端实现\n\n对应 BpmTaskController 的 #createSignTask(...) 方法，如下图所示：\n\n\n\n * 红圈 ① 的 2.2 处：需要将当前任务的 assignee 置空，并保存到 owner 中，避免它被审批。因为它如何被审批，就会直接进入下一个节点，而不会等待加签的子任务审批完成，显然这不是我们所希望的\n * 红圈 ② 的 2.4 处：通过 scopeType 标记当前任务是向前还是向后加签，因为一个任务不能同时向前和向后加签。这里，我们将 scopeType 设置为 before，表示向前加签\n * 红圈 ③ 的 2.6 处：更新当前任务的状态为 WAITING，表示当前任务处于“待审核状态”\n * 红圈 ④ 的 3. 处：调用 #createSignTaskList(...) 方法，创建加签的子任务，如下图所示：\n\n\n\n * 红圈 ⑤ 的 1 处：创建加签的子任务，将当前任务的属性部分复制给改子任务\n * 红圈 ⑥ 的 2.1 处：设置向前加签的子任务的 assignee 审批人\n * 红圈 ⑦ 的 2.3 处：真正保存加签的子任务\n\n\n# 1.2 审批向前加签子任务\n\n# 1.2.1 操作步骤\n\n登录账号 test、密码 test123 的用户，审批加签任务。\n\n① 和普通审批一样，点击【通过】按钮，将子任务审批通过，如下图所示：\n\n\n\n② 之后，可以看到当前（原）任务又变回“待审核”状态，加签出来的子任务处于“审核通过”状态，如下图所示：\n\n\n\n后续，我们登录回之前的账号，继续审批当前（原）任务即可。\n\n# 1.2.2 后端实现\n\n因为和普通审批一样，所以对应的还是 BpmTaskController 的 #approveTask(...) 方法，如下图所示：\n\n\n\n关键还是 #handleParentTaskIfSign(...) 方法，在向前加签的情况下，需要将当前（原）任务又变回“待审核”状态。如下图所示：\n\n\n\n * 红圈 ① 的 1.1 处：由于可以加签多个子任务，所以需要全部审批通过后才能继续审批当前（原）任务\n * 红圈 ② 的 2. 处：清空当前（原）任务的 scopeType 属性，表示当前任务不再处于加签状态，这样它后续可以自由的向前或是向后继续加签\n * 红圈 ③ 的 3.1 处：恢复当前（原）任务的 assignee 审批人，并更新状态回 RUNNING 审批中\n * 红圈 ④ 的 4. 处：由于加签出来的子任务，自身可以继续被加签，所以需要递归向上处理。如果要体验一下，就在「1.2.1 操作步骤」时，不要审批通过，而是加签\n\n\n# 2. 向后加签\n\n\n# 2.1 发起向后加签\n\n# 2.1.1 操作步骤\n\n① 首先，点击「加签」按钮，选择被加签的处理人，之后点击「向后加签」按钮，完成向后加签操作。如下图所示：\n\n\n\n② 之后，可以看到当前任务变成“审核中”状态，它有加签出来的一个子任务，该子任务的状态是“待审核”状态，如下图所示：\n\n\n\n\n# 2.2 审批向后加签子任务\n\n对应 BpmTaskController 的 #createSignTask(...) 方法，如下图所示：\n\n\n\n * 相比于向前加签，向后加签的实现更加简单，因为它不需要处理当前（原）任务的状态，只需要创建加签的子任务即可\n\n调用 #createSignTaskList(...) 方法，创建加签的子任务，如下图所示：\n\n\n\n * 红圈 ① 的 1 处：创建的向后加签的子任务，只将 owner 设置为选择加签的处理人，不包括 assignee 审批人。原因是，需要等到当前（原）任务审批通过后，才会设置 assignee 审批人\n * 红圈 ② 的 2. 处：设置向后加签的子任务的状态为 WAITING 待审核状态。原因是，当前（原）任务审批通过后，才会设置子任务为 RUNNING 审批中\n\n\n# 2.2 审批当前（原）任务\n\n\n# 2.2.1 操作步骤\n\n不用切换账号！直接审批当前（原）任务即可。\n\n点击【通过】按钮，将当前（原）任务审批通过，如下图所示：\n\n\n\n可以看到当前（原）任务变成 APPROVING “审批通过中”状态，加签出来的子任务变成 RUNNING 审批中状态。\n\n\n# 2.2.2 后端实现\n\n对应 BpmTaskController 的 #createSignTask(...) 方法，如下图所示：\n\n\n\n核心实现在 #approveAfterSignTask(...) 方法，如下图所示：\n\n\n\n * 对于当前（原）任务来说，任务变成 APPROVING “审批通过中”状态\n * 对于被加签出来的子任务来说，任务变成 RUNNING “审批中”状态，并设置 assignee 审批人。也就是说，被加签的人可以开始审批啦~\n\n\n# 2.3 审批向后加签子任务\n\n# 2.3.1 操作步骤\n\n登录账号 test、密码 test123 的用户，审批加签任务。\n\n点击【通过】按钮，将后向加签的子任务审批通过，如下图所示：\n\n\n\n可以看到当前（原）任务变成 APPROVE “审批通过”状态，加签出来的子任务也变成 APPROVE “审批通过”状态。\n\n# 2.3.2 后端实现\n\n对应 BpmTaskController 的 #createSignTask(...) 方法，核心实现在 #handleParentTaskIfSign(...) 方法，如下图所示：\n\n\n\n * 红圈部分，当前（原）任务变成 APPROVE “审批通过”状态，并调用 TaskService#complete(...) 方法来完成\n\n友情提示：\n\n向前、向后加签的逻辑，整体可能有点弯弯绕绕~ 大家在理解的时候，可以找个纸头画一画，这样会更加清晰~\n\n\n# 3. 减签\n\n\n# 3.1 操作步骤\n\n① 点击【减签】按钮，获得可减钱的任务列表，如下图所示：\n\n\n\n② 选择需要减签的任务，点击【减签】按钮，完成减签操作。如下图所示：\n\n\n\n\n# 3.2 后端实现\n\n① 获得可减钱的任务列表，对应 BpmTaskController 的 #getTaskListByParentTaskId(...) 方法。如下图所示：\n\n\n\n② 执行减签操作，对应 BpmTaskController 的 #deleteSignTask(...) 方法。如下图所示：\n\n\n\n * 红圈 ① 的 2.1、2.2 处：获得所有的子任务列表，一方面更新它们为 CANCEL “已取消”状态，另一方面调用 TaskService#deleteTasks(...) 删除它们\n * 红圈 ② 的 4. 处：需要调用 #handleParentTaskIfSign(...) 方法，处理当前（原）任务的状态，不然该任务的状态就一直卡在加签的情况下了",
            normalizedContent: "本文，我们来讲解下审批加签、减签的功能：\n\n * 加签：添加其他审批人来共同审批，自己仍需参与审批。例如，不好判断当前审批时，可以添加其他人来共同审批\n * 减签：当以“加签”的方式添加了其他审批人时，可以操作减签进行移除，对方无需再审批。例如，加签有误时，可以通过减签来操作\n\n其中，加签分成两种：\n\n * 向前加签：在任务 a 之【前】添加 b、c、d 三个子任务，在 b、c、d 子任务都审批完成后，任务 a 才能继续审批\n * 向后加签：在任务 a 之【后】添加 b、c、d 三个子任务，在任务 a 审批通过（处于审批通过中），只有 b、c、d 三个子任务都审批通过，任务 a 才会审批通过\n\n\n# 1. 向前加签\n\n\n# 1.1 发起向前加签\n\n# 1.1.1 操作步骤\n\n① 首先，点击「加签」按钮，选择被加签的处理人，之后点击「向前加签」按钮，完成向前加签操作。如下图所示：\n\n\n\n② 之后，可以看到当前任务变成“待审核”状态，它有加签出来的一个子任务，该子任务的状态是“待审核”状态，如下图所示：\n\n\n\n# 1.1.2 后端实现\n\n对应 bpmtaskcontroller 的 #createsigntask(...) 方法，如下图所示：\n\n\n\n * 红圈 ① 的 2.2 处：需要将当前任务的 assignee 置空，并保存到 owner 中，避免它被审批。因为它如何被审批，就会直接进入下一个节点，而不会等待加签的子任务审批完成，显然这不是我们所希望的\n * 红圈 ② 的 2.4 处：通过 scopetype 标记当前任务是向前还是向后加签，因为一个任务不能同时向前和向后加签。这里，我们将 scopetype 设置为 before，表示向前加签\n * 红圈 ③ 的 2.6 处：更新当前任务的状态为 waiting，表示当前任务处于“待审核状态”\n * 红圈 ④ 的 3. 处：调用 #createsigntasklist(...) 方法，创建加签的子任务，如下图所示：\n\n\n\n * 红圈 ⑤ 的 1 处：创建加签的子任务，将当前任务的属性部分复制给改子任务\n * 红圈 ⑥ 的 2.1 处：设置向前加签的子任务的 assignee 审批人\n * 红圈 ⑦ 的 2.3 处：真正保存加签的子任务\n\n\n# 1.2 审批向前加签子任务\n\n# 1.2.1 操作步骤\n\n登录账号 test、密码 test123 的用户，审批加签任务。\n\n① 和普通审批一样，点击【通过】按钮，将子任务审批通过，如下图所示：\n\n\n\n② 之后，可以看到当前（原）任务又变回“待审核”状态，加签出来的子任务处于“审核通过”状态，如下图所示：\n\n\n\n后续，我们登录回之前的账号，继续审批当前（原）任务即可。\n\n# 1.2.2 后端实现\n\n因为和普通审批一样，所以对应的还是 bpmtaskcontroller 的 #approvetask(...) 方法，如下图所示：\n\n\n\n关键还是 #handleparenttaskifsign(...) 方法，在向前加签的情况下，需要将当前（原）任务又变回“待审核”状态。如下图所示：\n\n\n\n * 红圈 ① 的 1.1 处：由于可以加签多个子任务，所以需要全部审批通过后才能继续审批当前（原）任务\n * 红圈 ② 的 2. 处：清空当前（原）任务的 scopetype 属性，表示当前任务不再处于加签状态，这样它后续可以自由的向前或是向后继续加签\n * 红圈 ③ 的 3.1 处：恢复当前（原）任务的 assignee 审批人，并更新状态回 running 审批中\n * 红圈 ④ 的 4. 处：由于加签出来的子任务，自身可以继续被加签，所以需要递归向上处理。如果要体验一下，就在「1.2.1 操作步骤」时，不要审批通过，而是加签\n\n\n# 2. 向后加签\n\n\n# 2.1 发起向后加签\n\n# 2.1.1 操作步骤\n\n① 首先，点击「加签」按钮，选择被加签的处理人，之后点击「向后加签」按钮，完成向后加签操作。如下图所示：\n\n\n\n② 之后，可以看到当前任务变成“审核中”状态，它有加签出来的一个子任务，该子任务的状态是“待审核”状态，如下图所示：\n\n\n\n\n# 2.2 审批向后加签子任务\n\n对应 bpmtaskcontroller 的 #createsigntask(...) 方法，如下图所示：\n\n\n\n * 相比于向前加签，向后加签的实现更加简单，因为它不需要处理当前（原）任务的状态，只需要创建加签的子任务即可\n\n调用 #createsigntasklist(...) 方法，创建加签的子任务，如下图所示：\n\n\n\n * 红圈 ① 的 1 处：创建的向后加签的子任务，只将 owner 设置为选择加签的处理人，不包括 assignee 审批人。原因是，需要等到当前（原）任务审批通过后，才会设置 assignee 审批人\n * 红圈 ② 的 2. 处：设置向后加签的子任务的状态为 waiting 待审核状态。原因是，当前（原）任务审批通过后，才会设置子任务为 running 审批中\n\n\n# 2.2 审批当前（原）任务\n\n\n# 2.2.1 操作步骤\n\n不用切换账号！直接审批当前（原）任务即可。\n\n点击【通过】按钮，将当前（原）任务审批通过，如下图所示：\n\n\n\n可以看到当前（原）任务变成 approving “审批通过中”状态，加签出来的子任务变成 running 审批中状态。\n\n\n# 2.2.2 后端实现\n\n对应 bpmtaskcontroller 的 #createsigntask(...) 方法，如下图所示：\n\n\n\n核心实现在 #approveaftersigntask(...) 方法，如下图所示：\n\n\n\n * 对于当前（原）任务来说，任务变成 approving “审批通过中”状态\n * 对于被加签出来的子任务来说，任务变成 running “审批中”状态，并设置 assignee 审批人。也就是说，被加签的人可以开始审批啦~\n\n\n# 2.3 审批向后加签子任务\n\n# 2.3.1 操作步骤\n\n登录账号 test、密码 test123 的用户，审批加签任务。\n\n点击【通过】按钮，将后向加签的子任务审批通过，如下图所示：\n\n\n\n可以看到当前（原）任务变成 approve “审批通过”状态，加签出来的子任务也变成 approve “审批通过”状态。\n\n# 2.3.2 后端实现\n\n对应 bpmtaskcontroller 的 #createsigntask(...) 方法，核心实现在 #handleparenttaskifsign(...) 方法，如下图所示：\n\n\n\n * 红圈部分，当前（原）任务变成 approve “审批通过”状态，并调用 taskservice#complete(...) 方法来完成\n\n友情提示：\n\n向前、向后加签的逻辑，整体可能有点弯弯绕绕~ 大家在理解的时候，可以找个纸头画一画，这样会更加清晰~\n\n\n# 3. 减签\n\n\n# 3.1 操作步骤\n\n① 点击【减签】按钮，获得可减钱的任务列表，如下图所示：\n\n\n\n② 选择需要减签的任务，点击【减签】按钮，完成减签操作。如下图所示：\n\n\n\n\n# 3.2 后端实现\n\n① 获得可减钱的任务列表，对应 bpmtaskcontroller 的 #gettasklistbyparenttaskid(...) 方法。如下图所示：\n\n\n\n② 执行减签操作，对应 bpmtaskcontroller 的 #deletesigntask(...) 方法。如下图所示：\n\n\n\n * 红圈 ① 的 2.1、2.2 处：获得所有的子任务列表，一方面更新它们为 cancel “已取消”状态，另一方面调用 taskservice#deletetasks(...) 删除它们\n * 红圈 ② 的 4. 处：需要调用 #handleparenttaskifsign(...) 方法，处理当前（原）任务的状态，不然该任务的状态就一直卡在加签的情况下了",
            charsets: {
                cjk: !0
            }
        }, {
            title: "流程发起、取消、重新发起",
            frontmatter: {
                title: "流程发起、取消、重新发起",
                date: "2024-03-25T18:27:02.000Z",
                permalink: "/bpm/process-instance/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/10.%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%89%8B%E5%86%8C/22.%E6%B5%81%E7%A8%8B%E5%8F%91%E8%B5%B7%E3%80%81%E5%8F%96%E6%B6%88%E3%80%81%E9%87%8D%E6%96%B0%E5%8F%91%E8%B5%B7.html",
            relativePath: "01.开发指南/10.工作流手册/22.流程发起、取消、重新发起.md",
            key: "v-7bcb8f4d",
            path: "/bpm/process-instance/",
            headers: [{
                level: 2,
                title: "1. 发起流程",
                slug: "_1-发起流程",
                normalizedTitle: "1. 发起流程",
                charIndex: 131
            }, {
                level: 3,
                title: "1.1 表结构",
                slug: "_1-1-表结构",
                normalizedTitle: "1.1 表结构",
                charIndex: 179
            }, {
                level: 3,
                title: "1.2 流程状态",
                slug: "_1-2-流程状态",
                normalizedTitle: "1.2 流程状态",
                charIndex: 3162
            }, {
                level: 3,
                title: "1.3 具体实现",
                slug: "_1-3-具体实现",
                normalizedTitle: "1.3 具体实现",
                charIndex: 3229
            }, {
                level: 2,
                title: "2. 我的流程",
                slug: "_2-我的流程",
                normalizedTitle: "2. 我的流程",
                charIndex: 3501
            }, {
                level: 3,
                title: "2.1 表结构",
                slug: "_2-1-表结构",
                normalizedTitle: "2.1 表结构",
                charIndex: 3549
            }, {
                level: 3,
                title: "2.2 具体实现",
                slug: "_2-2-具体实现",
                normalizedTitle: "2.2 具体实现",
                charIndex: 5953
            }, {
                level: 3,
                title: "2.1 取消流程",
                slug: "_2-1-取消流程",
                normalizedTitle: "2.1 取消流程",
                charIndex: 6096
            }, {
                level: 3,
                title: "2.2 重新发起流程",
                slug: "_2-2-重新发起流程",
                normalizedTitle: "2.2 重新发起流程",
                charIndex: 6476
            }, {
                level: 2,
                title: "3. 流程实例",
                slug: "_3-流程实例",
                normalizedTitle: "3. 流程实例",
                charIndex: 6624
            }],
            headersStr: "1. 发起流程 1.1 表结构 1.2 流程状态 1.3 具体实现 2. 我的流程 2.1 表结构 2.2 具体实现 2.1 取消流程 2.2 重新发起流程 3. 流程实例",
            content: "相关视频：\n\n * 11、如何实现流程的发起？\n * 12、如何实现我的流程列表？\n * 13、如何实现流程的取消？\n\n本文的内容比较简单，主要围绕 [审批中心] 菜单下的 [我的流程]、[发起流程] 子菜单，讲解流程的发起、取消、重新发起的操作流程。\n\n\n# 1. 发起流程\n\n发起流程，对应 [审批中心 -> 发起流程] 菜单，如下图所示：\n\n\n\n\n# 1.1 表结构\n\n① 流程实例表，由 Flowable 提供的 ACT_RU_EXECUTION 表实现，如下所示：\n\n字段                      类型               主键   说明           备注\nID_                     NVARCHAR2(64)    Y    主键           \nREV_                    INTEGER          N    数据版本         \nPROC_INST_ID_           NVARCHAR2(64)    N    流程实例 ID      \nBUSINESS_KEY_           NVARCHAR2(255)   N    业务主键 ID      \nPARENT_ID_              NVARCHAR2(64)    N    父执行流的 ID     \nPROC_DEF_ID_            NVARCHAR2(64)    N    流程定义的数据 ID   \nSUPER_EXEC_             NVARCHAR2(64)    N                 \nROOT_PROC_INST_ID_      NVARCHAR2(64)    N                 \nACT_ID_                 NVARCHAR2(255)   N    节点实例 ID      \nIS_ACTIVE_              NUMBER(1)        N    是否存活         \nIS_CONCURRENT_          NUMBER(1)        N    执行流是否正在并行    \nIS_SCOPE_               NUMBER(1)        N                 \nIS_EVENT_SCOPE_         NUMBER(1)        N                 \nIS_MI_ROOT_             NUMBER(1)        N                 \nSUSPENSION_STATE_       INTEGER          N    流程终端状态       \nCACHED_ENT_STATE_       INTEGER          N                 \nTENANT_ID_              NVARCHAR2(255)   N                 \nNAME_                   NVARCHAR2(255)   N                 \nSTART_TIME_             TIMESTAMP(6)     N    开始时间         \nSTART_USER_ID_          NVARCHAR2(255)   N                 \nLOCK_TIME_              TIMESTAMP(6)     N                 \nIS_COUNT_ENABLED_       NUMBER(1)        N                 \nEVT_SUBSCR_COUNT_       INTEGER          N                 \nTASK_COUNT_             INTEGER          N                 \nJOB_COUNT_              INTEGER          N                 \nTIMER_JOB_COUNT_        INTEGER          N                 \nSUSP_JOB_COUNT_         INTEGER          N                 \nDEADLETTER_JOB_COUNT_   INTEGER          N                 \nVAR_COUNT_              INTEGER          N                 \nID_LINK_COUNT_          INTEGER          N                 \n\n② 流程参数表，由 Flowable 提供的 ACT_RU_VARIABLE 表实现，如下所示：\n\n字段              类型                主键   说明                    备注\nID_             NVARCHAR2(64)     Y    主键                    \nREV_            INTEGER           N    数据版本                  \nTYPE_           NVARCHAR2(255)    N    参数类型                  可以是基本的类型，也可以用户自行扩展\nNAME_           NVARCHAR2(255)    N    参数名称                  \nEXECUTION_ID_   NVARCHAR2(64)     N    参数执行 ID               \nPROC_INST_ID_   NVARCHAR2(64)     N    流程实例 ID               \nTASK_ID_        NVARCHAR2(64)     N    任务 ID                 \nBYTEARRAY_ID_   NVARCHAR2(64)     N    资源 ID                 \nDOUBLE_         NUMBER(*,10)      N    参数为 double，则保存在该字段中   \nLONG_           NUMBER(19)        N    参数为 long，则保存在该字段中     \nTEXT_           NVARCHAR2(2000)   N    用户保存文本类型的参数值          \nTEXT2_          NVARCHAR2(2000)   N    用户保存文本类型的参数值          \n\n在 Flowable 中，如果想给 Task 增加拓展字段，无法通过 ACT_RU_EXECUTION 实现，而是通过 ACT_RU_VARIABLE 表实现。\n\n该表是一种 Key-Value 的形式，可以存储任意类型的数据。例如说，项目中给 ProcessInstance 增加了一个 PROCESS_STATUS 字段，表示流程状态，如下图所示：\n\n\n\n\n# 1.2 流程状态\n\n流程状态，由 BpmProcessInstanceStatusEnum 目前有 4 种，如下图所示：\n\n\n\n\n# 1.3 具体实现\n\n * 前端，对应 /views/bpm/processInstance/create/index.vue 实现界面\n * 后端，对应 BpmProcessInstanceController 的 #createProcessInstance(...) 提供接口\n\n\n\n最核心的，就是调用 Flowable 的 RuntimeService#createProcessInstanceBuilder().start() 方法，创建流程实例。同时因为 Flowable 自身没有流程状态，所以需要我们自己维护任务状态。\n\n\n# 2. 我的流程\n\n我的流程，对应 [审批中心 -> 我的流程] 菜单，如下图所示：\n\n\n\n\n# 2.1 表结构\n\n① 历史流程实例表，由 Flowable 提供的 ACT_HI_PROCINST 表实现，如下所示：\n\n字段                           类型                主键   说明         备注\nID_                          NVARCHAR2(64)     Y    主键         \nPROC_INST_ID_                NVARCHAR2(64)     N    流程实例 ID    \nBUSINESS_KEY_                NVARCHAR2(255)    N    业务主键       \nPROC_DEF_ID_                 NVARCHAR2(64)     N    属性 ID      \nSTART_TIME_                  TIMESTAMP(6)      N    开始时间       \nEND_TIME_                    TIMESTAMP(6)      N    结束时间       \nDURATION_                    NUMBER(19)        N    耗时         \nSTART_USER_ID_               NVARCHAR2(255)    N    起始人        \nSTART_ACT_ID_                NVARCHAR2(255)    N    起始节点       \nEND_ACT_ID_                  NVARCHAR2(255)    N    结束节点       \nSUPER_PROCESS_INSTANCE_ID_   NVARCHAR2(64)     N    父流程实例 ID   \nDELETE_REASON_               NVARCHAR2(2000)   N    删除原因       \nTENANT_ID_                   NVARCHAR2(255)    N               \nNAME_                        NVARCHAR2(255)    N    名称         \n\n在 Flowable 中，如果 ProcessInstance 被完成（全部审批通过、不通过、取消等）时候，会从 ACT_RU_EXECUTION 表中删除，只能在 ACT_HI_PROCINST 表查询到。这是一种“冷热分离”的设计思想，因为进行的任务访问比较频繁，数据量越小，性能会越好。\n\n而 [我的流程] 需要查询进行中、已完成的流程，所以需要查询 ACT_HI_PROCINST 表，而不能使用 ACT_RU_EXECUTION 表。\n\n② 流程历史参数表，由 Flowable 提供的 ACT_HI_VARINST 表实现，如下所示：\n\n字段                   类型                   主键   说明               备注\nID_                  NVARCHAR2(64)        Y    主键               \nPROC_INST_ID_        NVARCHAR2(64)        N    流程实例 ID          \nEXECUTION_ID_        NVARCHAR2(64)        N    指定 ID            \nTASK_ID_             NVARCHAR2(64)        N    任务 ID            \nNAME_                NVARCHAR2(255)       N    名称               \nVAR_TYPE_            NVARCHAR2(100)       N    参数类型             \nREV_                 INTEGER              N    数据版本             \nBYTEARRAY_ID_        NVARCHAR2(64)        N    字节表 ID           \nDOUBLE_              NUMBER(*,10)         N    存储 double 类型数据   \nLONG_                NUMBER(*,10)         N    存储 long 类型数据     \nTEXT_                NVARCHAR2(2000)      N                     \nTEXT2_               NVARCHAR2(2000)      N                     \nCREATE_TIME_         TIMESTAMP(6)(2000)   N                     \nLAST_UPDATED_TIME_   TIMESTAMP(6)(2000)   N                     \n\n在 Flowable 中，如果 ProcessInstance 被完成（全部审批通过、不通过、取消等）时候，会从 ACT_RU_VARIABLE 表中删除，只能在 ACT_HI_VARINST 表查询到。这当然也是是一种“冷热分离”的设计思想~\n\n\n# 2.2 具体实现\n\n * 前端，对应 /views/bpm/processInstance/index.vue 实现界面\n * 后端，对应 BpmProcessInstanceController 的 #getProcessInstanceMyPage(...) 提供接口\n\n\n\n\n# 2.1 取消流程\n\n可点击某个流程的「取消」按钮，进行流程的取消，如下图所示：\n\n\n\n后端由 BpmProcessInstanceController 的 #cancelProcessInstance(...) 提供接口，如下图所示：\n\n\n\n * 最核心的，就是调用 Flowable 的 RuntimeService#deleteProcessInstance(...) 方法，取消流程实例。\n\n可能你会有疑问，哪里将流程状态更新为 CANCEL 已取消呢？答案在 BpmProcessInstanceEventListener 监听器，它会监听到流程实例变更为取消，然后调用 BpmProcessInstanceController 的 #updateProcessInstanceWhenCancel(...) 方法，进行更新。如下图所示：\n\n\n\n\n# 2.2 重新发起流程\n\n流程结束后，可点击它的「重新发起」按钮，进行流程的重新发起，如下图所示：\n\n\n\n它的效果是，跳转到 [发起流程] 页面，然后将之前的流程参数，填充到表单中，如下图所示：\n\n\n\n因此，它最终调用的还是「1. 发起流程」小节的发起流程接口，再次（重新）发起一个流程。\n\n\n# 3. 流程实例\n\n流程实例，展示系统中所有的流程，一般用于管理员查询，对应 [流程管理 -> 流程实例] 菜单，如下图所示：\n\n\n\n * 后端，对应 BpmProcessInstanceController 的 #getProcessInstanceManagerPage(...) 提供接口\n * 前端，对应 /views/bpm/processInstance/manager/index.vue 实现界面\n\n由于它查询的是所有流程，所以读取的是 ACT_HI_PROCINST 表，而不是 ACT_RU_EXECUTION 表。",
            normalizedContent: "相关视频：\n\n * 11、如何实现流程的发起？\n * 12、如何实现我的流程列表？\n * 13、如何实现流程的取消？\n\n本文的内容比较简单，主要围绕 [审批中心] 菜单下的 [我的流程]、[发起流程] 子菜单，讲解流程的发起、取消、重新发起的操作流程。\n\n\n# 1. 发起流程\n\n发起流程，对应 [审批中心 -> 发起流程] 菜单，如下图所示：\n\n\n\n\n# 1.1 表结构\n\n① 流程实例表，由 flowable 提供的 act_ru_execution 表实现，如下所示：\n\n字段                      类型               主键   说明           备注\nid_                     nvarchar2(64)    y    主键           \nrev_                    integer          n    数据版本         \nproc_inst_id_           nvarchar2(64)    n    流程实例 id      \nbusiness_key_           nvarchar2(255)   n    业务主键 id      \nparent_id_              nvarchar2(64)    n    父执行流的 id     \nproc_def_id_            nvarchar2(64)    n    流程定义的数据 id   \nsuper_exec_             nvarchar2(64)    n                 \nroot_proc_inst_id_      nvarchar2(64)    n                 \nact_id_                 nvarchar2(255)   n    节点实例 id      \nis_active_              number(1)        n    是否存活         \nis_concurrent_          number(1)        n    执行流是否正在并行    \nis_scope_               number(1)        n                 \nis_event_scope_         number(1)        n                 \nis_mi_root_             number(1)        n                 \nsuspension_state_       integer          n    流程终端状态       \ncached_ent_state_       integer          n                 \ntenant_id_              nvarchar2(255)   n                 \nname_                   nvarchar2(255)   n                 \nstart_time_             timestamp(6)     n    开始时间         \nstart_user_id_          nvarchar2(255)   n                 \nlock_time_              timestamp(6)     n                 \nis_count_enabled_       number(1)        n                 \nevt_subscr_count_       integer          n                 \ntask_count_             integer          n                 \njob_count_              integer          n                 \ntimer_job_count_        integer          n                 \nsusp_job_count_         integer          n                 \ndeadletter_job_count_   integer          n                 \nvar_count_              integer          n                 \nid_link_count_          integer          n                 \n\n② 流程参数表，由 flowable 提供的 act_ru_variable 表实现，如下所示：\n\n字段              类型                主键   说明                    备注\nid_             nvarchar2(64)     y    主键                    \nrev_            integer           n    数据版本                  \ntype_           nvarchar2(255)    n    参数类型                  可以是基本的类型，也可以用户自行扩展\nname_           nvarchar2(255)    n    参数名称                  \nexecution_id_   nvarchar2(64)     n    参数执行 id               \nproc_inst_id_   nvarchar2(64)     n    流程实例 id               \ntask_id_        nvarchar2(64)     n    任务 id                 \nbytearray_id_   nvarchar2(64)     n    资源 id                 \ndouble_         number(*,10)      n    参数为 double，则保存在该字段中   \nlong_           number(19)        n    参数为 long，则保存在该字段中     \ntext_           nvarchar2(2000)   n    用户保存文本类型的参数值          \ntext2_          nvarchar2(2000)   n    用户保存文本类型的参数值          \n\n在 flowable 中，如果想给 task 增加拓展字段，无法通过 act_ru_execution 实现，而是通过 act_ru_variable 表实现。\n\n该表是一种 key-value 的形式，可以存储任意类型的数据。例如说，项目中给 processinstance 增加了一个 process_status 字段，表示流程状态，如下图所示：\n\n\n\n\n# 1.2 流程状态\n\n流程状态，由 bpmprocessinstancestatusenum 目前有 4 种，如下图所示：\n\n\n\n\n# 1.3 具体实现\n\n * 前端，对应 /views/bpm/processinstance/create/index.vue 实现界面\n * 后端，对应 bpmprocessinstancecontroller 的 #createprocessinstance(...) 提供接口\n\n\n\n最核心的，就是调用 flowable 的 runtimeservice#createprocessinstancebuilder().start() 方法，创建流程实例。同时因为 flowable 自身没有流程状态，所以需要我们自己维护任务状态。\n\n\n# 2. 我的流程\n\n我的流程，对应 [审批中心 -> 我的流程] 菜单，如下图所示：\n\n\n\n\n# 2.1 表结构\n\n① 历史流程实例表，由 flowable 提供的 act_hi_procinst 表实现，如下所示：\n\n字段                           类型                主键   说明         备注\nid_                          nvarchar2(64)     y    主键         \nproc_inst_id_                nvarchar2(64)     n    流程实例 id    \nbusiness_key_                nvarchar2(255)    n    业务主键       \nproc_def_id_                 nvarchar2(64)     n    属性 id      \nstart_time_                  timestamp(6)      n    开始时间       \nend_time_                    timestamp(6)      n    结束时间       \nduration_                    number(19)        n    耗时         \nstart_user_id_               nvarchar2(255)    n    起始人        \nstart_act_id_                nvarchar2(255)    n    起始节点       \nend_act_id_                  nvarchar2(255)    n    结束节点       \nsuper_process_instance_id_   nvarchar2(64)     n    父流程实例 id   \ndelete_reason_               nvarchar2(2000)   n    删除原因       \ntenant_id_                   nvarchar2(255)    n               \nname_                        nvarchar2(255)    n    名称         \n\n在 flowable 中，如果 processinstance 被完成（全部审批通过、不通过、取消等）时候，会从 act_ru_execution 表中删除，只能在 act_hi_procinst 表查询到。这是一种“冷热分离”的设计思想，因为进行的任务访问比较频繁，数据量越小，性能会越好。\n\n而 [我的流程] 需要查询进行中、已完成的流程，所以需要查询 act_hi_procinst 表，而不能使用 act_ru_execution 表。\n\n② 流程历史参数表，由 flowable 提供的 act_hi_varinst 表实现，如下所示：\n\n字段                   类型                   主键   说明               备注\nid_                  nvarchar2(64)        y    主键               \nproc_inst_id_        nvarchar2(64)        n    流程实例 id          \nexecution_id_        nvarchar2(64)        n    指定 id            \ntask_id_             nvarchar2(64)        n    任务 id            \nname_                nvarchar2(255)       n    名称               \nvar_type_            nvarchar2(100)       n    参数类型             \nrev_                 integer              n    数据版本             \nbytearray_id_        nvarchar2(64)        n    字节表 id           \ndouble_              number(*,10)         n    存储 double 类型数据   \nlong_                number(*,10)         n    存储 long 类型数据     \ntext_                nvarchar2(2000)      n                     \ntext2_               nvarchar2(2000)      n                     \ncreate_time_         timestamp(6)(2000)   n                     \nlast_updated_time_   timestamp(6)(2000)   n                     \n\n在 flowable 中，如果 processinstance 被完成（全部审批通过、不通过、取消等）时候，会从 act_ru_variable 表中删除，只能在 act_hi_varinst 表查询到。这当然也是是一种“冷热分离”的设计思想~\n\n\n# 2.2 具体实现\n\n * 前端，对应 /views/bpm/processinstance/index.vue 实现界面\n * 后端，对应 bpmprocessinstancecontroller 的 #getprocessinstancemypage(...) 提供接口\n\n\n\n\n# 2.1 取消流程\n\n可点击某个流程的「取消」按钮，进行流程的取消，如下图所示：\n\n\n\n后端由 bpmprocessinstancecontroller 的 #cancelprocessinstance(...) 提供接口，如下图所示：\n\n\n\n * 最核心的，就是调用 flowable 的 runtimeservice#deleteprocessinstance(...) 方法，取消流程实例。\n\n可能你会有疑问，哪里将流程状态更新为 cancel 已取消呢？答案在 bpmprocessinstanceeventlistener 监听器，它会监听到流程实例变更为取消，然后调用 bpmprocessinstancecontroller 的 #updateprocessinstancewhencancel(...) 方法，进行更新。如下图所示：\n\n\n\n\n# 2.2 重新发起流程\n\n流程结束后，可点击它的「重新发起」按钮，进行流程的重新发起，如下图所示：\n\n\n\n它的效果是，跳转到 [发起流程] 页面，然后将之前的流程参数，填充到表单中，如下图所示：\n\n\n\n因此，它最终调用的还是「1. 发起流程」小节的发起流程接口，再次（重新）发起一个流程。\n\n\n# 3. 流程实例\n\n流程实例，展示系统中所有的流程，一般用于管理员查询，对应 [流程管理 -> 流程实例] 菜单，如下图所示：\n\n\n\n * 后端，对应 bpmprocessinstancecontroller 的 #getprocessinstancemanagerpage(...) 提供接口\n * 前端，对应 /views/bpm/processinstance/manager/index.vue 实现界面\n\n由于它查询的是所有流程，所以读取的是 act_hi_procinst 表，而不是 act_ru_execution 表。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "执行监听器、任务监听器",
            frontmatter: {
                title: "执行监听器、任务监听器",
                date: "2024-03-26T09:39:10.000Z",
                permalink: "/bpm/listener"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/10.%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%89%8B%E5%86%8C/30.%E6%89%A7%E8%A1%8C%E7%9B%91%E5%90%AC%E5%99%A8%E3%80%81%E4%BB%BB%E5%8A%A1%E7%9B%91%E5%90%AC%E5%99%A8.html",
            relativePath: "01.开发指南/10.工作流手册/30.执行监听器、任务监听器.md",
            key: "v-9101d9a2",
            path: "/bpm/listener/",
            headers: [{
                level: 2,
                title: "1. 执行监听器",
                slug: "_1-执行监听器",
                normalizedTitle: "1. 执行监听器",
                charIndex: 51
            }, {
                level: 3,
                title: "1.1 Java 类监听器",
                slug: "_1-1-java-类监听器",
                normalizedTitle: "1.1 java 类监听器",
                charIndex: 455
            }, {
                level: 3,
                title: "1.2 委托表达式监听器",
                slug: "_1-2-委托表达式监听器",
                normalizedTitle: "1.2 委托表达式监听器",
                charIndex: 740
            }, {
                level: 3,
                title: "1.3 Spring 表达式监听器",
                slug: "_1-3-spring-表达式监听器",
                normalizedTitle: "1.3 spring 表达式监听器",
                charIndex: 1038
            }, {
                level: 2,
                title: "2. 任务监听器",
                slug: "_2-任务监听器",
                normalizedTitle: "2. 任务监听器",
                charIndex: 1290
            }, {
                level: 3,
                title: "2.1 Java 类监听器",
                slug: "_2-1-java-类监听器",
                normalizedTitle: "2.1 java 类监听器",
                charIndex: 1607
            }, {
                level: 3,
                title: "2.2 委托表达式监听器",
                slug: "_2-2-委托表达式监听器",
                normalizedTitle: "2.2 委托表达式监听器",
                charIndex: 1878
            }, {
                level: 3,
                title: "2.3 Spring 表达式监听器",
                slug: "_2-3-spring-表达式监听器",
                normalizedTitle: "2.3 spring 表达式监听器",
                charIndex: 2166
            }, {
                level: 2,
                title: "3. 流程监听器的模版",
                slug: "_3-流程监听器的模版",
                normalizedTitle: "3. 流程监听器的模版",
                charIndex: 2402
            }, {
                level: 3,
                title: "3.1 使用场景",
                slug: "_3-1-使用场景",
                normalizedTitle: "3.1 使用场景",
                charIndex: 2570
            }, {
                level: 3,
                title: "3.2 表结构",
                slug: "_3-2-表结构",
                normalizedTitle: "3.2 表结构",
                charIndex: 2637
            }],
            headersStr: "1. 执行监听器 1.1 Java 类监听器 1.2 委托表达式监听器 1.3 Spring 表达式监听器 2. 任务监听器 2.1 Java 类监听器 2.2 委托表达式监听器 2.3 Spring 表达式监听器 3. 流程监听器的模版 3.1 使用场景 3.2 表结构",
            content: "友情提示：\n\n在 BPMN 设计流程图，配置完监听器后，一定要发布流程，否则监听器不会生效。\n\n\n# 1. 执行监听器\n\n执行监听器（execution listener），可以在流程执行中发生特定的事件时，执行外部 Java 代码或计算表达式。可以被捕获的事件有：\n\n * 流程实例的启动和结束\n * 流程执行转移\n * 活动的启动和结束\n * 网关的启动和结束\n * 中间事件的启动和结束\n * 启动事件的结束，和结束事件的启动\n\n总结来说，可以监听的事件只有 start 开始、end 结束。\n\n学习文档：\n\n * 《Flowable BPMN 用户手册 (v 6.3.0) —— 执行监听器》\n * 《Flowable 服务任务执行的三种方式》\n * 《Flowable 服务任务类，表达式，委托表达式（代理表达式）》\n\n我们可以在 BPMN 设计流程图时，给某个节点添加执行监听器，监听器可以是 Java 类、表达式、委托表达式。如下图所示：\n\n\n\n这三种监听器怎么使用呢？我们逐个来看看。\n\n\n# 1.1 Java 类监听器\n\n① 新建一个 DemoDelegateClassExecutionListener 类，需要实现 org.flowable.engine.delegate.JavaDelegate 接口，如下图所示：\n\n\n\n② 在 BPMN 流程图中，配置 Java 类监听器，如下图所示：\n\n\n\n注意，图中填写的是 cn.iocoder.yudao.module.bpm.framework.flowable.core.listener.demo.exection.DemoDelegateClassExecutionListener 全路径。\n\n\n# 1.2 委托表达式监听器\n\n① 新建一个 DemoDelegateExpressionExecutionListener 类，也需要实现 org.flowable.engine.delegate.JavaDelegate 接口，如下图所示：\n\n\n\n并且，需要声明成 Spring Bean！本质上，“委托表达式”是“Java 类”的特例，和 Spring 做了集成。\n\n② 在 BPMN 流程图中，配置委托表达式监听器，如下图所示：\n\n\n\n注意，图中填写的是 ${demoDelegateExpressionExecutionListener}，这个是 Spring Bean 的名称。\n\n\n# 1.3 Spring 表达式监听器\n\n① 新建一个 DemoSpringExpressionExecutionListener 类，只需要声明成 Spring Bean，如下图所示：\n\n\n\n② 在 BPMN 流程图中，配置 Spring 表达式监听器，如下图所示：\n\n\n\n注意，图中填写的是 ${demoSpringExpressionExecutionListener.execute(execution)}，这个就是通过 Spring EL 表达式，实现对某个 Bean 的某个方法的调用。\n\n\n# 2. 任务监听器\n\n任务监听器（task listener），用于在特定的任务相关事件发生时，执行自定义的 Java 逻辑或表达式。\n\n相比执行器来说，它只能监听 UserTask 用户任务，但是事件有 create 创建、assignment 指派、complete 完成、delete 删除、update 更新、timeout 超时。\n\n学习文档：\n\n * 《Flowable BPMN 用户手册 (v 6.3.0) —— 任务监听器》\n\n我们可以在 BPMN 设计流程图时，给某个节点添加任务监听器，监听器可以是 Java 类、表达式、委托表达式。如下图所示：\n\n友情提示：任务监听器，和执行监听器的使用基本是一致的。\n\n\n# 2.1 Java 类监听器\n\n① 新建一个 DemoDelegateClassTaskListener 类，需要实现 org.flowable.engine.delegate.TaskListener 接口，如下图所示：\n\n\n\n② 在 BPMN 流程图中，配置 Java 类监听器，如下图所示：\n\n\n\n注意，图中填写的是 cn.iocoder.yudao.module.bpm.framework.flowable.core.listener.demo.task.DemoDelegateClassTaskListener 全路径。\n\n\n# 2.2 委托表达式监听器\n\n① 新建一个 DemoDelegateExpressionTaskListener 类，也需要实现 org.flowable.engine.delegate.TaskListener 接口，如下图所示：\n\n\n\n并且，需要声明成 Spring Bean！本质上，“委托表达式”是“Java 类”的特例，和 Spring 做了集成。\n\n② 在 BPMN 流程图中，配置委托表达式监听器，如下图所示：\n\n\n\n注意，图中填写的是 ${demoDelegateExpressionTaskListener}，这个是 Spring Bean 的名称。\n\n\n# 2.3 Spring 表达式监听器\n\n① 新建一个 DemoSpringExpressionTaskListener 类，只需要声明成 Spring Bean，如下图所示：\n\n\n\n② 在 BPMN 流程图中，配置 Spring 表达式监听器，如下图所示：\n\n\n\n注意，图中填写的是 ${demoSpringExpressionTaskListener.notify(task)}，这个就是通过 Spring EL 表达式，实现对某个 Bean 的某个方法的调用。\n\n\n# 3. 流程监听器的模版\n\n在 [工作流程 -> 流程管理 -> 流程监控器] 菜单，可以配置执行监听器、任务监听器的模版。如下图所示：\n\n\n\n * 前端，对应 views/bpm/processListener/index.vue 提供界面\n * 后端，对应 BpmProcessListenerController 提供接口\n\n\n# 3.1 使用场景\n\n当我们在 BPMN 流程图中，配置监听器时，可以选择模版，而不需要每次都填写监听器信息。如下图所示：\n\n\n\n\n# 3.2 表结构\n\n流程监听器表，是我们自己定义的 bpm_process_listener 表，结构如下：\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `bpm_process_listener` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  `name` varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '监听器名字',\n  \n  `type` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '监听器类型',\n  \n  `status` tinyint NOT NULL COMMENT '监听器状态',\n  \n  `event` varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '监听事件',\n  \n  `value_type` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '监听器值类型',\n  `value` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '监听器值',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=119 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='BPM 流程监听器表';\n\n\n① type 字段，表示监听器类型，可以是 execution 执行监听器、task 任务监听器。\n\n② event 字段，表示监听事件，可以是执行监听器的 start 开始、end 结束，或者任务监听器的 create 创建、assignment 指派、complete 完成、delete 删除、update 更新、timeout 超时。\n\n③ value_type 字段，表示监听器值类型，可以是 class Java 类、expression 表达式、delegateExpression 委托表达式。\n\nvalue 字段，表示监听器值，可以是 Java 类的全路径、表达式、委托表达式。",
            normalizedContent: "友情提示：\n\n在 bpmn 设计流程图，配置完监听器后，一定要发布流程，否则监听器不会生效。\n\n\n# 1. 执行监听器\n\n执行监听器（execution listener），可以在流程执行中发生特定的事件时，执行外部 java 代码或计算表达式。可以被捕获的事件有：\n\n * 流程实例的启动和结束\n * 流程执行转移\n * 活动的启动和结束\n * 网关的启动和结束\n * 中间事件的启动和结束\n * 启动事件的结束，和结束事件的启动\n\n总结来说，可以监听的事件只有 start 开始、end 结束。\n\n学习文档：\n\n * 《flowable bpmn 用户手册 (v 6.3.0) —— 执行监听器》\n * 《flowable 服务任务执行的三种方式》\n * 《flowable 服务任务类，表达式，委托表达式（代理表达式）》\n\n我们可以在 bpmn 设计流程图时，给某个节点添加执行监听器，监听器可以是 java 类、表达式、委托表达式。如下图所示：\n\n\n\n这三种监听器怎么使用呢？我们逐个来看看。\n\n\n# 1.1 java 类监听器\n\n① 新建一个 demodelegateclassexecutionlistener 类，需要实现 org.flowable.engine.delegate.javadelegate 接口，如下图所示：\n\n\n\n② 在 bpmn 流程图中，配置 java 类监听器，如下图所示：\n\n\n\n注意，图中填写的是 cn.iocoder.yudao.module.bpm.framework.flowable.core.listener.demo.exection.demodelegateclassexecutionlistener 全路径。\n\n\n# 1.2 委托表达式监听器\n\n① 新建一个 demodelegateexpressionexecutionlistener 类，也需要实现 org.flowable.engine.delegate.javadelegate 接口，如下图所示：\n\n\n\n并且，需要声明成 spring bean！本质上，“委托表达式”是“java 类”的特例，和 spring 做了集成。\n\n② 在 bpmn 流程图中，配置委托表达式监听器，如下图所示：\n\n\n\n注意，图中填写的是 ${demodelegateexpressionexecutionlistener}，这个是 spring bean 的名称。\n\n\n# 1.3 spring 表达式监听器\n\n① 新建一个 demospringexpressionexecutionlistener 类，只需要声明成 spring bean，如下图所示：\n\n\n\n② 在 bpmn 流程图中，配置 spring 表达式监听器，如下图所示：\n\n\n\n注意，图中填写的是 ${demospringexpressionexecutionlistener.execute(execution)}，这个就是通过 spring el 表达式，实现对某个 bean 的某个方法的调用。\n\n\n# 2. 任务监听器\n\n任务监听器（task listener），用于在特定的任务相关事件发生时，执行自定义的 java 逻辑或表达式。\n\n相比执行器来说，它只能监听 usertask 用户任务，但是事件有 create 创建、assignment 指派、complete 完成、delete 删除、update 更新、timeout 超时。\n\n学习文档：\n\n * 《flowable bpmn 用户手册 (v 6.3.0) —— 任务监听器》\n\n我们可以在 bpmn 设计流程图时，给某个节点添加任务监听器，监听器可以是 java 类、表达式、委托表达式。如下图所示：\n\n友情提示：任务监听器，和执行监听器的使用基本是一致的。\n\n\n# 2.1 java 类监听器\n\n① 新建一个 demodelegateclasstasklistener 类，需要实现 org.flowable.engine.delegate.tasklistener 接口，如下图所示：\n\n\n\n② 在 bpmn 流程图中，配置 java 类监听器，如下图所示：\n\n\n\n注意，图中填写的是 cn.iocoder.yudao.module.bpm.framework.flowable.core.listener.demo.task.demodelegateclasstasklistener 全路径。\n\n\n# 2.2 委托表达式监听器\n\n① 新建一个 demodelegateexpressiontasklistener 类，也需要实现 org.flowable.engine.delegate.tasklistener 接口，如下图所示：\n\n\n\n并且，需要声明成 spring bean！本质上，“委托表达式”是“java 类”的特例，和 spring 做了集成。\n\n② 在 bpmn 流程图中，配置委托表达式监听器，如下图所示：\n\n\n\n注意，图中填写的是 ${demodelegateexpressiontasklistener}，这个是 spring bean 的名称。\n\n\n# 2.3 spring 表达式监听器\n\n① 新建一个 demospringexpressiontasklistener 类，只需要声明成 spring bean，如下图所示：\n\n\n\n② 在 bpmn 流程图中，配置 spring 表达式监听器，如下图所示：\n\n\n\n注意，图中填写的是 ${demospringexpressiontasklistener.notify(task)}，这个就是通过 spring el 表达式，实现对某个 bean 的某个方法的调用。\n\n\n# 3. 流程监听器的模版\n\n在 [工作流程 -> 流程管理 -> 流程监控器] 菜单，可以配置执行监听器、任务监听器的模版。如下图所示：\n\n\n\n * 前端，对应 views/bpm/processlistener/index.vue 提供界面\n * 后端，对应 bpmprocesslistenercontroller 提供接口\n\n\n# 3.1 使用场景\n\n当我们在 bpmn 流程图中，配置监听器时，可以选择模版，而不需要每次都填写监听器信息。如下图所示：\n\n\n\n\n# 3.2 表结构\n\n流程监听器表，是我们自己定义的 bpm_process_listener 表，结构如下：\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `bpm_process_listener` (\n  `id` bigint not null auto_increment comment '编号',\n  `name` varchar(30) character set utf8mb4 collate utf8mb4_unicode_ci not null default '' comment '监听器名字',\n  \n  `type` varchar(255) collate utf8mb4_unicode_ci not null comment '监听器类型',\n  \n  `status` tinyint not null comment '监听器状态',\n  \n  `event` varchar(30) character set utf8mb4 collate utf8mb4_unicode_ci not null default '' comment '监听事件',\n  \n  `value_type` varchar(64) character set utf8mb4 collate utf8mb4_unicode_ci not null default '' comment '监听器值类型',\n  `value` varchar(1024) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '监听器值',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=119 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='bpm 流程监听器表';\n\n\n① type 字段，表示监听器类型，可以是 execution 执行监听器、task 任务监听器。\n\n② event 字段，表示监听事件，可以是执行监听器的 start 开始、end 结束，或者任务监听器的 create 创建、assignment 指派、complete 完成、delete 删除、update 更新、timeout 超时。\n\n③ value_type 字段，表示监听器值类型，可以是 class java 类、expression 表达式、delegateexpression 委托表达式。\n\nvalue 字段，表示监听器值，可以是 java 类的全路径、表达式、委托表达式。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "审批转办、委派、抄送",
            frontmatter: {
                title: "审批转办、委派、抄送",
                date: "2024-03-26T09:36:54.000Z",
                permalink: "/bpm/task-delegation-and-cc"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/10.%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%89%8B%E5%86%8C/25.%E5%AE%A1%E6%89%B9%E8%BD%AC%E5%8A%9E%E3%80%81%E5%A7%94%E6%B4%BE%E3%80%81%E6%8A%84%E9%80%81.html",
            relativePath: "01.开发指南/10.工作流手册/25.审批转办、委派、抄送.md",
            key: "v-ffb49796",
            path: "/bpm/task-delegation-and-cc/",
            headers: [{
                level: 2,
                title: "1. 转办、委派",
                slug: "_1-转办、委派",
                normalizedTitle: "1. 转办、委派",
                charIndex: 2
            }, {
                level: 3,
                title: "1.1 转办",
                slug: "_1-1-转办",
                normalizedTitle: "1.1 转办",
                charIndex: 118
            }, {
                level: 3,
                title: "1.2 委派",
                slug: "_1-2-委派",
                normalizedTitle: "1.2 委派",
                charIndex: 328
            }, {
                level: 2,
                title: "2. 抄送",
                slug: "_2-抄送",
                normalizedTitle: "2. 抄送",
                charIndex: 786
            }, {
                level: 3,
                title: "2.1 表结构",
                slug: "_2-1-表结构",
                normalizedTitle: "2.1 表结构",
                charIndex: 819
            }, {
                level: 3,
                title: "2.2 发起抄送",
                slug: "_2-2-发起抄送",
                normalizedTitle: "2.2 发起抄送",
                charIndex: 1863
            }, {
                level: 3,
                title: "2.3 查看抄送",
                slug: "_2-3-查看抄送",
                normalizedTitle: "2.3 查看抄送",
                charIndex: 1924
            }],
            headersStr: "1. 转办、委派 1.1 转办 1.2 委派 2. 抄送 2.1 表结构 2.2 发起抄送 2.3 查看抄送",
            content: "# 1. 转办、委派\n\n转办和委托，两者的区别在于是不是真的转给对方，对比如下：\n\n * 转办：A 转给其 B 审批，B 审批后，进入下一节点\n * 委派：A 转给其 B 审批，B 审批后，转给 A，A 继续审批后进入下一节点\n\n\n# 1.1 转办\n\n转办，简单来说，就是 真的 换一个 assignee 审批人，对应界面如下：\n\n\n\n对应后端的 BpmTaskController 提供的 #transferTask(...) 接口。如下图所示：\n\n\n\n * 关键是红圈的 3.2 部分：通过调用 TaskService#setAssignee(...) 方法，修改审批人\n * 至于 3.1 部分：将原审批人设置为 owner，这其实是可选的\n\n\n# 1.2 委派\n\n委派，简单来说，只是 临时 换一个 assignee 审批人，干完活还要交回来，对应界面如下：\n\n\n\n它对应两个流程：\n\n * A 转给其 B 审批\n * B 审批后，转给 A\n\n① A 转给其 B 审批，对应后端的 BpmTaskController 提供的 #delegateTask(...) 接口。如下图所示：\n\n\n\n * 红圈的 3.1 部分：将原审批人设置为 owner，这个是必须的，因为委派是临时的，干完活还要交回来\n * 红圈的 3.2 部分：通过调用 TaskService#delegateTask(...) 方法，委派给新审批人\n\n② B 审批后，转给 A，对应后端的 BpmTaskController 提供的 #approveTask(...) 接口。如下图所示：\n\n\n\n * 红圈的 2.1 部分：通过调用 TaskService#resolveTask(...) 方法，将委派的任务交回给原审批人，表示任务已审批（已完成）。这样，后续原审批人就可以继续审批了\n\n\n# 2. 抄送\n\n抄送，将审批结果，通知给抄送列表对应的人。\n\n\n# 2.1 表结构\n\n抄送表，是我们自己定义的 bpm_process_instance_copy 表，结构如下：\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `bpm_process_instance_copy` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  `user_id` bigint NOT NULL DEFAULT '0' COMMENT '用户编号，被抄送人',\n  \n  `start_user_id` bigint NOT NULL DEFAULT '0' COMMENT '发起流程的用户编号',\n  `process_instance_id` varchar(64) COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '流程实例的id',\n  `process_instance_name` varchar(64) COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '流程实例的名字',\n  \n  `category` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '流程定义的分类',\n  \n  `task_id` varchar(64) COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '发起抄送的任务编号',\n  `task_name` varchar(64) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '任务的名字',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='BPM 流程实例抄送表';\n\n\n比较简单，就是存储下关联的 user_id、process_instance_id、task_id 等信息。\n\n\n# 2.2 发起抄送\n\n审批通过、不通过时，可以选择抄送的人，对应界面如下：\n\n\n\n对应的后端代码，如下图所示：\n\n\n\n\n# 2.3 查看抄送\n\n被抄送人，可以在 [工作流程 -> 审批中心 -> 抄送我的] 菜单，查看到抄送列表，对应界面如下：\n\n",
            normalizedContent: "# 1. 转办、委派\n\n转办和委托，两者的区别在于是不是真的转给对方，对比如下：\n\n * 转办：a 转给其 b 审批，b 审批后，进入下一节点\n * 委派：a 转给其 b 审批，b 审批后，转给 a，a 继续审批后进入下一节点\n\n\n# 1.1 转办\n\n转办，简单来说，就是 真的 换一个 assignee 审批人，对应界面如下：\n\n\n\n对应后端的 bpmtaskcontroller 提供的 #transfertask(...) 接口。如下图所示：\n\n\n\n * 关键是红圈的 3.2 部分：通过调用 taskservice#setassignee(...) 方法，修改审批人\n * 至于 3.1 部分：将原审批人设置为 owner，这其实是可选的\n\n\n# 1.2 委派\n\n委派，简单来说，只是 临时 换一个 assignee 审批人，干完活还要交回来，对应界面如下：\n\n\n\n它对应两个流程：\n\n * a 转给其 b 审批\n * b 审批后，转给 a\n\n① a 转给其 b 审批，对应后端的 bpmtaskcontroller 提供的 #delegatetask(...) 接口。如下图所示：\n\n\n\n * 红圈的 3.1 部分：将原审批人设置为 owner，这个是必须的，因为委派是临时的，干完活还要交回来\n * 红圈的 3.2 部分：通过调用 taskservice#delegatetask(...) 方法，委派给新审批人\n\n② b 审批后，转给 a，对应后端的 bpmtaskcontroller 提供的 #approvetask(...) 接口。如下图所示：\n\n\n\n * 红圈的 2.1 部分：通过调用 taskservice#resolvetask(...) 方法，将委派的任务交回给原审批人，表示任务已审批（已完成）。这样，后续原审批人就可以继续审批了\n\n\n# 2. 抄送\n\n抄送，将审批结果，通知给抄送列表对应的人。\n\n\n# 2.1 表结构\n\n抄送表，是我们自己定义的 bpm_process_instance_copy 表，结构如下：\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `bpm_process_instance_copy` (\n  `id` bigint not null auto_increment comment '编号',\n  `user_id` bigint not null default '0' comment '用户编号，被抄送人',\n  \n  `start_user_id` bigint not null default '0' comment '发起流程的用户编号',\n  `process_instance_id` varchar(64) collate utf8mb4_unicode_ci not null default '' comment '流程实例的id',\n  `process_instance_name` varchar(64) collate utf8mb4_unicode_ci not null default '' comment '流程实例的名字',\n  \n  `category` varchar(64) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '流程定义的分类',\n  \n  `task_id` varchar(64) collate utf8mb4_unicode_ci not null default '' comment '发起抄送的任务编号',\n  `task_name` varchar(64) collate utf8mb4_unicode_ci default null comment '任务的名字',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=12 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='bpm 流程实例抄送表';\n\n\n比较简单，就是存储下关联的 user_id、process_instance_id、task_id 等信息。\n\n\n# 2.2 发起抄送\n\n审批通过、不通过时，可以选择抄送的人，对应界面如下：\n\n\n\n对应的后端代码，如下图所示：\n\n\n\n\n# 2.3 查看抄送\n\n被抄送人，可以在 [工作流程 -> 审批中心 -> 抄送我的] 菜单，查看到抄送列表，对应界面如下：\n\n",
            charsets: {
                cjk: !0
            }
        }, {
            title: "流程表达式",
            frontmatter: {
                title: "流程表达式",
                date: "2024-03-26T09:40:05.000Z",
                permalink: "/bpm/expression"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/10.%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%89%8B%E5%86%8C/31.%E6%B5%81%E7%A8%8B%E8%A1%A8%E8%BE%BE%E5%BC%8F.html",
            relativePath: "01.开发指南/10.工作流手册/31.流程表达式.md",
            key: "v-15fe64f5",
            path: "/bpm/expression/",
            headers: [{
                level: 2,
                title: "1. 流程表达式",
                slug: "_1-流程表达式",
                normalizedTitle: "1. 流程表达式",
                charIndex: 2
            }, {
                level: 3,
                title: "1.1 BpmTaskAssignStartUserExpression",
                slug: "_1-1-bpmtaskassignstartuserexpression",
                normalizedTitle: "1.1 bpmtaskassignstartuserexpression",
                charIndex: 333
            }, {
                level: 3,
                title: "1.2 BpmTaskAssignLeaderExpression",
                slug: "_1-2-bpmtaskassignleaderexpression",
                normalizedTitle: "1.2 bpmtaskassignleaderexpression",
                charIndex: 583
            }, {
                level: 2,
                title: "2. 流程表达式的模版",
                slug: "_2-流程表达式的模版",
                normalizedTitle: "2. 流程表达式的模版",
                charIndex: 961
            }, {
                level: 3,
                title: "2.1 使用场景",
                slug: "_2-1-使用场景",
                normalizedTitle: "2.1 使用场景",
                charIndex: 1127
            }, {
                level: 3,
                title: "2.2 表结构",
                slug: "_2-2-表结构",
                normalizedTitle: "2.2 表结构",
                charIndex: 1194
            }],
            headersStr: "1. 流程表达式 1.1 BpmTaskAssignStartUserExpression 1.2 BpmTaskAssignLeaderExpression 2. 流程表达式的模版 2.1 使用场景 2.2 表结构",
            content: "# 1. 流程表达式\n\nFlowable 使用 UEL 进行表达式解析。UEL 代表 Unified Expression Language，是 EE6 规范的一部分。例如说：\n\n * 在 《会签、或签、依次审批》 看到的 ${ nrOfCompletedInstances >= nrOfInstances }、${ nrOfCompletedInstances == 1 } 等，就是 UEL 表达式\n * 在 《审批接入（流程表单）》 看到的流转条件 ${day > 3}，也是 UEL 表达式\n\n学习文档：\n\n * 《Flowable BPMN 用户手册 (v 6.3.0) —— 表达式》\n\n那么，具体怎么定义 UEL 表达式呢？我们逐个来看看。\n\n\n# 1.1 BpmTaskAssignStartUserExpression\n\nBpmTaskAssignStartUserExpression，分配给发起人审批的 Expression 流程表达式，需要声明成 Spring Bean，代码如下：\n\n\n\n使用时，可以在 BPMN 流程图中，配置表达式 ${bpmTaskAssignStartUserExpression.calculateUsers(execution)} ，如下图所示：\n\n\n\n这样，该任务节点的审批人，就会被分配给发起人。\n\n\n# 1.2 BpmTaskAssignLeaderExpression\n\nBpmTaskAssignLeaderExpression，分配给发起人的指定 level 级别 Leader 审批的 Expression 流程表达式，需要声明成 Spring Bean，代码如下：\n\n\n\n使用时，可以在 BPMN 流程图中，配置表达式 ${bpmTaskAssignLeaderExpression.calculateUsers(execution, 1)} 表示一级领导，如下图所示：\n\n\n\n这样，该任务节点的审批人，就会被分配给发起人的一级领导。\n\n如果想要分配给二级领导，可以使用 ${bpmTaskAssignLeaderExpression.calculateUsers(execution, 2)}。也就是说，level 参数，表示领导的级别。\n\n\n# 2. 流程表达式的模版\n\n在 [工作流程 -> 流程管理 -> 流程表达式] 菜单，可以配置执行表达式的模版。如下图所示：\n\n\n\n * 前端，对应 views/bpm/processExpression/index.vue 提供界面\n * 后端，对应 BpmProcessExpressionController 提供接口\n\n\n# 2.1 使用场景\n\n当我们在 BPMN 流程图中，配置表达式时，可以选择模版，而不需要每次都填写表达式信息。如下图所示：\n\n\n\n\n# 2.2 表结构\n\n流程表达式表，是我们自己定义的 bpm_process_expression 表，结构如下：\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `bpm_process_expression` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  `name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '表达式名字',\n  `status` tinyint NOT NULL COMMENT '表达式状态',\n  \n  `expression` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '表达式',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=120 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='BPM 流程表达式表';\n\n\n关键是 expression 字段，表示表达式的内容。",
            normalizedContent: "# 1. 流程表达式\n\nflowable 使用 uel 进行表达式解析。uel 代表 unified expression language，是 ee6 规范的一部分。例如说：\n\n * 在 《会签、或签、依次审批》 看到的 ${ nrofcompletedinstances >= nrofinstances }、${ nrofcompletedinstances == 1 } 等，就是 uel 表达式\n * 在 《审批接入（流程表单）》 看到的流转条件 ${day > 3}，也是 uel 表达式\n\n学习文档：\n\n * 《flowable bpmn 用户手册 (v 6.3.0) —— 表达式》\n\n那么，具体怎么定义 uel 表达式呢？我们逐个来看看。\n\n\n# 1.1 bpmtaskassignstartuserexpression\n\nbpmtaskassignstartuserexpression，分配给发起人审批的 expression 流程表达式，需要声明成 spring bean，代码如下：\n\n\n\n使用时，可以在 bpmn 流程图中，配置表达式 ${bpmtaskassignstartuserexpression.calculateusers(execution)} ，如下图所示：\n\n\n\n这样，该任务节点的审批人，就会被分配给发起人。\n\n\n# 1.2 bpmtaskassignleaderexpression\n\nbpmtaskassignleaderexpression，分配给发起人的指定 level 级别 leader 审批的 expression 流程表达式，需要声明成 spring bean，代码如下：\n\n\n\n使用时，可以在 bpmn 流程图中，配置表达式 ${bpmtaskassignleaderexpression.calculateusers(execution, 1)} 表示一级领导，如下图所示：\n\n\n\n这样，该任务节点的审批人，就会被分配给发起人的一级领导。\n\n如果想要分配给二级领导，可以使用 ${bpmtaskassignleaderexpression.calculateusers(execution, 2)}。也就是说，level 参数，表示领导的级别。\n\n\n# 2. 流程表达式的模版\n\n在 [工作流程 -> 流程管理 -> 流程表达式] 菜单，可以配置执行表达式的模版。如下图所示：\n\n\n\n * 前端，对应 views/bpm/processexpression/index.vue 提供界面\n * 后端，对应 bpmprocessexpressioncontroller 提供接口\n\n\n# 2.1 使用场景\n\n当我们在 bpmn 流程图中，配置表达式时，可以选择模版，而不需要每次都填写表达式信息。如下图所示：\n\n\n\n\n# 2.2 表结构\n\n流程表达式表，是我们自己定义的 bpm_process_expression 表，结构如下：\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `bpm_process_expression` (\n  `id` bigint not null auto_increment comment '编号',\n  `name` varchar(64) character set utf8mb4 collate utf8mb4_unicode_ci not null default '' comment '表达式名字',\n  `status` tinyint not null comment '表达式状态',\n  \n  `expression` varchar(1024) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '表达式',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=120 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='bpm 流程表达式表';\n\n\n关键是 expression 字段，表示表达式的内容。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "流程审批通知",
            frontmatter: {
                title: "流程审批通知",
                date: "2024-03-25T16:14:30.000Z",
                permalink: "/bpm/message/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/10.%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%89%8B%E5%86%8C/41.%E6%B5%81%E7%A8%8B%E5%AE%A1%E6%89%B9%E9%80%9A%E7%9F%A5.html",
            relativePath: "01.开发指南/10.工作流手册/41.流程审批通知.md",
            key: "v-e09374cc",
            path: "/bpm/message/",
            headersStr: null,
            content: "相关视频：\n\n * 22、如何实现工作流的短信通知？\n\n流程（审批）在发生变化时，会发送通知给相关的人。目前有三个场景会有通知，通过短信的方式。\n\n\n\n它是通过 BpmMessageService 调用 SmsSendApi 短信 API 所实现，如下图所示：\n\n\n\n① 如果想要接入其它通知方式，在 BpmMessageService 调用其它通知的 API 即可，例如说：\n\n * 《邮件配置》\n * 《站内信配置》\n\n② 如果想要更多场景的通知，可以考虑基于 《执行监听器、任务监听器》 实现，在监听器中调用通知 API。",
            normalizedContent: "相关视频：\n\n * 22、如何实现工作流的短信通知？\n\n流程（审批）在发生变化时，会发送通知给相关的人。目前有三个场景会有通知，通过短信的方式。\n\n\n\n它是通过 bpmmessageservice 调用 smssendapi 短信 api 所实现，如下图所示：\n\n\n\n① 如果想要接入其它通知方式，在 bpmmessageservice 调用其它通知的 api 即可，例如说：\n\n * 《邮件配置》\n * 《站内信配置》\n\n② 如果想要更多场景的通知，可以考虑基于 《执行监听器、任务监听器》 实现，在监听器中调用通知 api。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "报表设计器",
            frontmatter: {
                title: "报表设计器",
                date: "2022-07-29T13:24:29.000Z",
                permalink: "/report/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/11.%E5%A4%A7%E5%B1%8F%E6%89%8B%E5%86%8C/01.%E6%8A%A5%E8%A1%A8%E8%AE%BE%E8%AE%A1%E5%99%A8.html",
            relativePath: "01.开发指南/11.大屏手册/01.报表设计器.md",
            key: "v-51ece8cc",
            path: "/report/",
            headers: [{
                level: 2,
                title: "1. 功能开启",
                slug: "_1-功能开启",
                normalizedTitle: "1. 功能开启",
                charIndex: 309
            }, {
                level: 3,
                title: "1.1 第一步，开启模块",
                slug: "_1-1-第一步-开启模块",
                normalizedTitle: "1.1 第一步，开启模块",
                charIndex: 477
            }, {
                level: 3,
                title: "1.2 第二步，导入 SQL",
                slug: "_1-2-第二步-导入-sql",
                normalizedTitle: "1.2 第二步，导入 sql",
                charIndex: 680
            }, {
                level: 3,
                title: "1.3 第三步，启动后端项目",
                slug: "_1-3-第三步-启动后端项目",
                normalizedTitle: "1.3 第三步，启动后端项目",
                charIndex: 877
            }, {
                level: 3,
                title: "1.4 第四步，启动前端项目（AJ-Report）",
                slug: "_1-4-第四步-启动前端项目-aj-report",
                normalizedTitle: "1.4 第四步，启动前端项目（aj-report）",
                charIndex: 949
            }, {
                level: 3,
                title: "1.4 第四步，启动前端项目（JimuReport）",
                slug: "_1-4-第四步-启动前端项目-jimureport",
                normalizedTitle: "1.4 第四步，启动前端项目（jimureport）",
                charIndex: 1e3
            }, {
                level: 2,
                title: "2. 如何使用？",
                slug: "_2-如何使用",
                normalizedTitle: "2. 如何使用？",
                charIndex: 1146
            }, {
                level: 3,
                title: "2.1 AJ-Report 报表设计器",
                slug: "_2-1-aj-report-报表设计器",
                normalizedTitle: "2.1 aj-report 报表设计器",
                charIndex: 1159
            }, {
                level: 3,
                title: "2.2 JimuReport 报表设计器",
                slug: "_2-2-jimureport-报表设计器",
                normalizedTitle: "2.2 jimureport 报表设计器",
                charIndex: 1204
            }],
            headersStr: "1. 功能开启 1.1 第一步，开启模块 1.2 第二步，导入 SQL 1.3 第三步，启动后端项目 1.4 第四步，启动前端项目（AJ-Report） 1.4 第四步，启动前端项目（JimuReport） 2. 如何使用？ 2.1 AJ-Report 报表设计器 2.2 JimuReport 报表设计器",
            content: '数据可视化，一般可以通过报表设计器、或者大屏设计器来实现。本小节，我们来讲解报表设计器的功能开启。\n\n报表设计器，指的是使用 Web 版设计器，通过类似于 Excel 操作风格，通过拖拽完成报表设计。如下图所示：\n\n\n\n在项目中，通过集成市面上的报表引擎，实现了报表设计器的能力。目前使用如下：\n\n             是否集成   是否开源\nJimuReport   已集成    不开源\nAJ-Report    集成中    开源\nUReport2     不集成    开源\n\n为什么不使用 UReport2 报表引擎呢？\n\nUReport2 基本处于不维护的状态，最后发版时间是 2018 年！\n\n\n# 1. 功能开启\n\nyudao-module-report 实现了报表设计器的能力，考虑到编译速度，默认是关闭的。开启步骤如下：\n\n * 第一步，开启 yudao-report-report 模块\n * 第二步，导入报表的 SQL 数据库脚本\n * 第三步，启动后端项目，确认功能是否生效\n * 第四步，启动报表设计器的前端项目\n\n\n# 1.1 第一步，开启模块\n\n① 修改根目录的 pom.xml 文件，取消 yudao-module-report 模块的注释。\n\n\n\n② 修改 yudao-server 目录的 pom.xml 文件，引入 yudao-module-report 模块。如下图所示：\n\n\n\n③ 点击 IDEA 右上角的【Reload All Maven Projects】，刷新 Maven 依赖。如下图所示：\n\n\n\n\n# 1.2 第二步，导入 SQL\n\n下载 jimureport.mysql5.7.create.sql 脚本，并导入数据库，初始化 JimuReport 相关的表结构和数据。如果你是 Oracle、PostgreSQL 等其它数据库，需要自己使用 Navicat 进行转换。\n\n友情提示：↑↑↑ jimureport.mysql5.7.create.sql 是可以点击下载的！ ↑↑↑\n\n\n\n\n# 1.3 第三步，启动后端项目\n\n启动后端项目，看到 "Init JimuReport Config [ 线程池 ] " 说明开启成功。\n\n\n# 1.4 第四步，启动前端项目（AJ-Report）\n\nTODO 开发中，预计 4 月份左右。\n\n\n# 1.4 第四步，启动前端项目（JimuReport）\n\n① JimuReport 前端项目内置在后端项目中，无需启动。\n\n② 访问 [报表管理 -> 报表设计器] 菜单，可以查看对应的功能。如下图所示：\n\n\n\n可以看到，JimuReport 支持数据报表、图形报表、打印设计等能力。\n\n\n# 2. 如何使用？\n\n\n# 2.1 AJ-Report 报表设计器\n\nTODO 开发中，预计 4 月份左右。\n\n\n# 2.2 JimuReport 报表设计器\n\n可以查看 JimuReport 的官方文档，主要是：\n\n * 快速入门\n * 操作手册（报表设计器）\n\n注意，JimuReport 是商业化的产品，报表设计器的功能应该是免费的，大屏设计器的功能是收费的。\n\n集成 JimuReport 的代码实现？\n\n① 后端：在 jmreport 包下，进行 JimuReport 的集成。\n\n② 前端：在 @/views/report/jmreport 文件，通过 IFrame 嵌入 JimuReport 界面。\n\n----------------------------------------\n\n星球里，不错的问题：\n\n * 《我想问下积木报表集成里，官方的 yaml 配置参数维护在哪里呀？》',
            normalizedContent: '数据可视化，一般可以通过报表设计器、或者大屏设计器来实现。本小节，我们来讲解报表设计器的功能开启。\n\n报表设计器，指的是使用 web 版设计器，通过类似于 excel 操作风格，通过拖拽完成报表设计。如下图所示：\n\n\n\n在项目中，通过集成市面上的报表引擎，实现了报表设计器的能力。目前使用如下：\n\n             是否集成   是否开源\njimureport   已集成    不开源\naj-report    集成中    开源\nureport2     不集成    开源\n\n为什么不使用 ureport2 报表引擎呢？\n\nureport2 基本处于不维护的状态，最后发版时间是 2018 年！\n\n\n# 1. 功能开启\n\nyudao-module-report 实现了报表设计器的能力，考虑到编译速度，默认是关闭的。开启步骤如下：\n\n * 第一步，开启 yudao-report-report 模块\n * 第二步，导入报表的 sql 数据库脚本\n * 第三步，启动后端项目，确认功能是否生效\n * 第四步，启动报表设计器的前端项目\n\n\n# 1.1 第一步，开启模块\n\n① 修改根目录的 pom.xml 文件，取消 yudao-module-report 模块的注释。\n\n\n\n② 修改 yudao-server 目录的 pom.xml 文件，引入 yudao-module-report 模块。如下图所示：\n\n\n\n③ 点击 idea 右上角的【reload all maven projects】，刷新 maven 依赖。如下图所示：\n\n\n\n\n# 1.2 第二步，导入 sql\n\n下载 jimureport.mysql5.7.create.sql 脚本，并导入数据库，初始化 jimureport 相关的表结构和数据。如果你是 oracle、postgresql 等其它数据库，需要自己使用 navicat 进行转换。\n\n友情提示：↑↑↑ jimureport.mysql5.7.create.sql 是可以点击下载的！ ↑↑↑\n\n\n\n\n# 1.3 第三步，启动后端项目\n\n启动后端项目，看到 "init jimureport config [ 线程池 ] " 说明开启成功。\n\n\n# 1.4 第四步，启动前端项目（aj-report）\n\ntodo 开发中，预计 4 月份左右。\n\n\n# 1.4 第四步，启动前端项目（jimureport）\n\n① jimureport 前端项目内置在后端项目中，无需启动。\n\n② 访问 [报表管理 -> 报表设计器] 菜单，可以查看对应的功能。如下图所示：\n\n\n\n可以看到，jimureport 支持数据报表、图形报表、打印设计等能力。\n\n\n# 2. 如何使用？\n\n\n# 2.1 aj-report 报表设计器\n\ntodo 开发中，预计 4 月份左右。\n\n\n# 2.2 jimureport 报表设计器\n\n可以查看 jimureport 的官方文档，主要是：\n\n * 快速入门\n * 操作手册（报表设计器）\n\n注意，jimureport 是商业化的产品，报表设计器的功能应该是免费的，大屏设计器的功能是收费的。\n\n集成 jimureport 的代码实现？\n\n① 后端：在 jmreport 包下，进行 jimureport 的集成。\n\n② 前端：在 @/views/report/jmreport 文件，通过 iframe 嵌入 jimureport 界面。\n\n----------------------------------------\n\n星球里，不错的问题：\n\n * 《我想问下积木报表集成里，官方的 yaml 配置参数维护在哪里呀？》',
            charsets: {
                cjk: !0
            }
        }, {
            title: "功能开启",
            frontmatter: {
                title: "功能开启",
                date: "2023-07-07T19:27:29.000Z",
                permalink: "/pay/build"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/12.%E6%94%AF%E4%BB%98%E6%89%8B%E5%86%8C/01.%E5%8A%9F%E8%83%BD%E5%BC%80%E5%90%AF.html",
            relativePath: "01.开发指南/12.支付手册/01.功能开启.md",
            key: "v-387aeb79",
            path: "/pay/build/",
            headers: [{
                level: 2,
                title: "1. 概述",
                slug: "_1-概述",
                normalizedTitle: "1. 概述",
                charIndex: 71
            }, {
                level: 2,
                title: "2. 功能开启",
                slug: "_2-功能开启",
                normalizedTitle: "2. 功能开启",
                charIndex: 420
            }, {
                level: 3,
                title: "2.1 开启 yudao-module-pay 模块",
                slug: "_2-1-开启-yudao-module-pay-模块",
                normalizedTitle: "2.1 开启 yudao-module-pay 模块",
                charIndex: 580
            }, {
                level: 3,
                title: "2.2 第二步，导入 SQL",
                slug: "_2-2-第二步-导入-sql",
                normalizedTitle: "2.2 第二步，导入 sql",
                charIndex: 797
            }, {
                level: 3,
                title: "2.3 第三步，重启项目",
                slug: "_2-3-第三步-重启项目",
                normalizedTitle: "2.3 第三步，重启项目",
                charIndex: 904
            }, {
                level: 3,
                title: "2.4 第四步，开启支付 Job",
                slug: "_2-4-第四步-开启支付-job",
                normalizedTitle: "2.4 第四步，开启支付 job",
                charIndex: 980
            }, {
                level: 2,
                title: "3. 功能介绍",
                slug: "_3-功能介绍",
                normalizedTitle: "3. 功能介绍",
                charIndex: 1128
            }, {
                level: 3,
                title: "3.1 应用信息",
                slug: "_3-1-应用信息",
                normalizedTitle: "3.1 应用信息",
                charIndex: 1140
            }, {
                level: 3,
                title: "3.2 支付订单",
                slug: "_3-2-支付订单",
                normalizedTitle: "3.2 支付订单",
                charIndex: 1813
            }, {
                level: 3,
                title: "3.3 退款订单",
                slug: "_3-3-退款订单",
                normalizedTitle: "3.3 退款订单",
                charIndex: 1932
            }, {
                level: 3,
                title: "3.4 回调通知",
                slug: "_3-4-回调通知",
                normalizedTitle: "3.4 回调通知",
                charIndex: 2053
            }, {
                level: 3,
                title: "3.5 支付回调【重要】",
                slug: "_3-5-支付回调【重要】",
                normalizedTitle: "3.5 支付回调【重要】",
                charIndex: 2113
            }, {
                level: 3,
                title: "3.6 接入示例",
                slug: "_3-6-接入示例",
                normalizedTitle: "3.6 接入示例",
                charIndex: 2543
            }, {
                level: 3,
                title: "3.7 钱包充值、支付、退款",
                slug: "_3-7-钱包充值、支付、退款",
                normalizedTitle: "3.7 钱包充值、支付、退款",
                charIndex: 2657
            }, {
                level: 3,
                title: "3.8 模拟支付、退款",
                slug: "_3-8-模拟支付、退款",
                normalizedTitle: "3.8 模拟支付、退款",
                charIndex: 2698
            }],
            headersStr: "1. 概述 2. 功能开启 2.1 开启 yudao-module-pay 模块 2.2 第二步，导入 SQL 2.3 第三步，重启项目 2.4 第四步，开启支付 Job 3. 功能介绍 3.1 应用信息 3.2 支付订单 3.3 退款订单 3.4 回调通知 3.5 支付回调【重要】 3.6 接入示例 3.7 钱包充值、支付、退款 3.8 模拟支付、退款",
            content: "项目提供统一的支付中心，提供微信、支付宝等支付渠道的支付、退款等能力，方便业务模块进行快速接入，无需关注各种繁琐的支付 API。\n\n\n\n\n# 1. 概述\n\n它由如下 3 部分组成：\n\n① yudao-spring-boot-starter-biz-pay 组件：对接微信、支付宝等支付，提供统一的 PayClient 支付客户端。\n\n\n\n② yudao-module-pay 后端模块：实现支付中心的后端功能，包括支付、退款等能力。\n\n * 基于 PayClient 支付客户端，对接微信、支付宝等支付渠道。\n * 对内提供 PayOrderApi 统一支付 API 能力、PayRefundApi 统一退款 API 能力。\n\n③ 支付中心的前端，提供支付中心的管理后台，可进行支付渠道的配置、支付订单、退款单的查看等操作。\n\n * Vue2 版本：@/views/pay 目录\n * Vue3 版本：@/views/pay 目录\n\n\n# 2. 功能开启\n\n考虑到编译速度，默认 yudao-module-pay 模块是关闭的，需要手动开启。步骤如下：\n\n * 第一步，开启 yudao-module-pay 模块\n * 第二步，导入支付的 SQL 数据库脚本\n * 第三步，重启后端项目，确认功能是否生效\n * 第四步，开启支付相关的 Job 任务\n\n\n# 2.1 开启 yudao-module-pay 模块\n\n① 修改根目录的 pom.xml 文件，取消 yudao-module-pay 模块的注释。如下图所示：\n\n\n\n② 修改 yudao-server 目录的 pom.xml 文件，引入 yudao-module-pay 模块。如下图所示：\n\n\n\n③ 点击 IDEA 右上角的【Reload All Maven Projects】，刷新 Maven 依赖。如下图所示：\n\n\n\n\n# 2.2 第二步，导入 SQL\n\n点击 pay-2024-01-05.sql.zip 下载附件，解压出 SQL 文件，然后导入到数据库中。\n\n友情提示：↑↑↑ pay.sql 是可以点击下载的！ ↑↑↑\n\n\n\n\n# 2.3 第三步，重启项目\n\n重启后端项目，然后访问前端的支付菜单，确认功能是否生效。如下图所示：\n\n\n\n至此，我们就成功开启了支付的功能 🙂\n\n\n# 2.4 第四步，开启支付 Job\n\n① 参考 《定时任务》 文档，将 Job 定时任务开启。\n\n② 将 pay 开头的定时都进行开启，例如说：payNotifyJob、payOrderSyncJob、payOrderExpireJob、payRefundSyncJob。如下图所示：\n\n\n\n\n# 3. 功能介绍\n\n\n# 3.1 应用信息\n\n对应 [支付管理 -> 应用信息] 菜单，进行支付渠道、支付应用的管理。如下图所示：\n\n\n\n# 3.1.1 支付应用\n\n每个要接入支付中心的业务，对应一个支付应用。例如说：商城订单算一个应用，预约订单算一个应用。\n\n点击【新增】按钮，可以进行支付应用的配置，保存在 pay_app 表。如下图所示：\n\n\n\n * 应用标识：每个接入支付中心的应用（业务）标识，例如说现有项目中的商城订单使用 mall、会员钱包使用 wallet\n * 支付结果的回调地址：每个业务需要实现一个支付回调接口，在用户支付成功时，支付中心会进行回调。示例订单的支付回调、商城订单的支付回调\n * 退款结果的回调地址：每个业务需要实现一个退款回调接口，在用户退款成功时，支付中心会进行回调。示例订单的退款回调、商城订单的退款回调\n\n为什么要有支付应用？直接配置支付渠道不行吗？\n\n 1. 一个系统中，可能有多个业务需要，每个业务的支付、退款回调地址不同。\n 2. 同时，每个业务的订单编号可能重复，需要使用支付应用进行隔离，只要求在每个支付应用下保持唯一即可。\n 3. 另外，每个业务可能想要配置不同的支付渠道。\n\n# 3.1.2 支付渠道\n\n每个支付应用下，可以配置多个支付渠道。例如说：这里“示例应用”就配置了支付宝 PC 网站支付、支付宝 Wap 网站支付等等。\n\n点击【√】或者【×】图标，可以进行支付应用的配置，保存在 pay_channel 表。如下图所示：\n\n\n\n支付费率？\n\n参见 《第三方支付的费率、限额、通道分析》 文档。\n\n\n# 3.2 支付订单\n\n对应 [支付管理 -> 支付订单] 菜单，进行支付订单的查看。如下图所示：\n\n\n\n一般情况下，每个业务订单对应一条支付订单，保存在 pay_order 表，通过 merchant_order_id 字段关联。\n\n\n# 3.3 退款订单\n\n对应 [支付管理 -> 退款订单] 菜单，进行退款订单的查看。如下图所示：\n\n\n\n一般情况下，每个业务退款对应一条退款订单，保存在 pay_refund 表，通过 merchant_refund_no 字段关联。\n\n\n# 3.4 回调通知\n\n对应 [支付管理 -> 回调通知] 菜单，查看支付、退款的回调业务的结果。如下图所示：\n\n\n\n\n# 3.5 支付回调【重要】\n\n这里，我们要配置支付【中心】提供给支付【渠道】的回调地址，不同于上面支付【应用】的回调地址。整体的回调关系如下图所示：\n\n\n\n① 由于支付回调需要外网，可参考 《内网穿透》 文档，将本地的 48080 端口，转发到外网中。这里，我的域名是 http://yunai.natapp1.cc。\n\n② 在 application-local.yaml 配置文件中，修改 yudao.pay 配置项，设置为支付【中心】的回调地址。如下图所示：\n\n\n\n * yudao.pay.order-notify-url 配置项：对应 PayNotifyController 的 #notifyOrder(...) 方法\n * yudao.pay.refund-notify-url 配置项：对应 PayNotifyController 的 #notifyRefund(...) 方法\n\n如果你想理解的更深入，可以后续 debug 断条调试。\n\n\n# 3.6 接入示例\n\n对应 [支付管理 -> 接入示例 -> 支付&退款案例] 菜单，提供一个支付、退款的接入示例。如下图所示：\n\n\n\n详细说明，可见如下文档：\n\n * 《支付宝支付接入》\n * 《支付宝、微信退款接入》\n\n\n# 3.7 钱包充值、支付、退款\n\n详细可见 《钱包充值、支付、退款》 文档\n\n\n# 3.8 模拟支付、退款\n\n详细可见 《模拟支付、退款》 文档",
            normalizedContent: "项目提供统一的支付中心，提供微信、支付宝等支付渠道的支付、退款等能力，方便业务模块进行快速接入，无需关注各种繁琐的支付 api。\n\n\n\n\n# 1. 概述\n\n它由如下 3 部分组成：\n\n① yudao-spring-boot-starter-biz-pay 组件：对接微信、支付宝等支付，提供统一的 payclient 支付客户端。\n\n\n\n② yudao-module-pay 后端模块：实现支付中心的后端功能，包括支付、退款等能力。\n\n * 基于 payclient 支付客户端，对接微信、支付宝等支付渠道。\n * 对内提供 payorderapi 统一支付 api 能力、payrefundapi 统一退款 api 能力。\n\n③ 支付中心的前端，提供支付中心的管理后台，可进行支付渠道的配置、支付订单、退款单的查看等操作。\n\n * vue2 版本：@/views/pay 目录\n * vue3 版本：@/views/pay 目录\n\n\n# 2. 功能开启\n\n考虑到编译速度，默认 yudao-module-pay 模块是关闭的，需要手动开启。步骤如下：\n\n * 第一步，开启 yudao-module-pay 模块\n * 第二步，导入支付的 sql 数据库脚本\n * 第三步，重启后端项目，确认功能是否生效\n * 第四步，开启支付相关的 job 任务\n\n\n# 2.1 开启 yudao-module-pay 模块\n\n① 修改根目录的 pom.xml 文件，取消 yudao-module-pay 模块的注释。如下图所示：\n\n\n\n② 修改 yudao-server 目录的 pom.xml 文件，引入 yudao-module-pay 模块。如下图所示：\n\n\n\n③ 点击 idea 右上角的【reload all maven projects】，刷新 maven 依赖。如下图所示：\n\n\n\n\n# 2.2 第二步，导入 sql\n\n点击 pay-2024-01-05.sql.zip 下载附件，解压出 sql 文件，然后导入到数据库中。\n\n友情提示：↑↑↑ pay.sql 是可以点击下载的！ ↑↑↑\n\n\n\n\n# 2.3 第三步，重启项目\n\n重启后端项目，然后访问前端的支付菜单，确认功能是否生效。如下图所示：\n\n\n\n至此，我们就成功开启了支付的功能 🙂\n\n\n# 2.4 第四步，开启支付 job\n\n① 参考 《定时任务》 文档，将 job 定时任务开启。\n\n② 将 pay 开头的定时都进行开启，例如说：paynotifyjob、payordersyncjob、payorderexpirejob、payrefundsyncjob。如下图所示：\n\n\n\n\n# 3. 功能介绍\n\n\n# 3.1 应用信息\n\n对应 [支付管理 -> 应用信息] 菜单，进行支付渠道、支付应用的管理。如下图所示：\n\n\n\n# 3.1.1 支付应用\n\n每个要接入支付中心的业务，对应一个支付应用。例如说：商城订单算一个应用，预约订单算一个应用。\n\n点击【新增】按钮，可以进行支付应用的配置，保存在 pay_app 表。如下图所示：\n\n\n\n * 应用标识：每个接入支付中心的应用（业务）标识，例如说现有项目中的商城订单使用 mall、会员钱包使用 wallet\n * 支付结果的回调地址：每个业务需要实现一个支付回调接口，在用户支付成功时，支付中心会进行回调。示例订单的支付回调、商城订单的支付回调\n * 退款结果的回调地址：每个业务需要实现一个退款回调接口，在用户退款成功时，支付中心会进行回调。示例订单的退款回调、商城订单的退款回调\n\n为什么要有支付应用？直接配置支付渠道不行吗？\n\n 1. 一个系统中，可能有多个业务需要，每个业务的支付、退款回调地址不同。\n 2. 同时，每个业务的订单编号可能重复，需要使用支付应用进行隔离，只要求在每个支付应用下保持唯一即可。\n 3. 另外，每个业务可能想要配置不同的支付渠道。\n\n# 3.1.2 支付渠道\n\n每个支付应用下，可以配置多个支付渠道。例如说：这里“示例应用”就配置了支付宝 pc 网站支付、支付宝 wap 网站支付等等。\n\n点击【√】或者【×】图标，可以进行支付应用的配置，保存在 pay_channel 表。如下图所示：\n\n\n\n支付费率？\n\n参见 《第三方支付的费率、限额、通道分析》 文档。\n\n\n# 3.2 支付订单\n\n对应 [支付管理 -> 支付订单] 菜单，进行支付订单的查看。如下图所示：\n\n\n\n一般情况下，每个业务订单对应一条支付订单，保存在 pay_order 表，通过 merchant_order_id 字段关联。\n\n\n# 3.3 退款订单\n\n对应 [支付管理 -> 退款订单] 菜单，进行退款订单的查看。如下图所示：\n\n\n\n一般情况下，每个业务退款对应一条退款订单，保存在 pay_refund 表，通过 merchant_refund_no 字段关联。\n\n\n# 3.4 回调通知\n\n对应 [支付管理 -> 回调通知] 菜单，查看支付、退款的回调业务的结果。如下图所示：\n\n\n\n\n# 3.5 支付回调【重要】\n\n这里，我们要配置支付【中心】提供给支付【渠道】的回调地址，不同于上面支付【应用】的回调地址。整体的回调关系如下图所示：\n\n\n\n① 由于支付回调需要外网，可参考 《内网穿透》 文档，将本地的 48080 端口，转发到外网中。这里，我的域名是 http://yunai.natapp1.cc。\n\n② 在 application-local.yaml 配置文件中，修改 yudao.pay 配置项，设置为支付【中心】的回调地址。如下图所示：\n\n\n\n * yudao.pay.order-notify-url 配置项：对应 paynotifycontroller 的 #notifyorder(...) 方法\n * yudao.pay.refund-notify-url 配置项：对应 paynotifycontroller 的 #notifyrefund(...) 方法\n\n如果你想理解的更深入，可以后续 debug 断条调试。\n\n\n# 3.6 接入示例\n\n对应 [支付管理 -> 接入示例 -> 支付&退款案例] 菜单，提供一个支付、退款的接入示例。如下图所示：\n\n\n\n详细说明，可见如下文档：\n\n * 《支付宝支付接入》\n * 《支付宝、微信退款接入》\n\n\n# 3.7 钱包充值、支付、退款\n\n详细可见 《钱包充值、支付、退款》 文档\n\n\n# 3.8 模拟支付、退款\n\n详细可见 《模拟支付、退款》 文档",
            charsets: {
                cjk: !0
            }
        }, {
            title: "支付宝支付接入",
            frontmatter: {
                title: "支付宝支付接入",
                date: "2023-07-09T22:04:05.000Z",
                permalink: "/pay/alipay-pay-demo"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/12.%E6%94%AF%E4%BB%98%E6%89%8B%E5%86%8C/11.%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98%E6%8E%A5%E5%85%A5.html",
            relativePath: "01.开发指南/12.支付手册/11.支付宝支付接入.md",
            key: "v-90482726",
            path: "/pay/alipay-pay-demo/",
            headers: [{
                level: 2,
                title: "0. 概述",
                slug: "_0-概述",
                normalizedTitle: "0. 概述",
                charIndex: 2
            }, {
                level: 2,
                title: "1. 第一步，配置支付渠道",
                slug: "_1-第一步-配置支付渠道",
                normalizedTitle: "1. 第一步，配置支付渠道",
                charIndex: 320
            }, {
                level: 2,
                title: "2. 第二步，实现支付调用【重要】",
                slug: "_2-第二步-实现支付调用【重要】",
                normalizedTitle: "2. 第二步，实现支付调用【重要】",
                charIndex: 994
            }, {
                level: 2,
                title: "3. 第三步，实现回调接口【重要】",
                slug: "_3-第三步-实现回调接口【重要】",
                normalizedTitle: "3. 第三步，实现回调接口【重要】",
                charIndex: 1851
            }, {
                level: 2,
                title: "4. 第四步，支付功能测试",
                slug: "_4-第四步-支付功能测试",
                normalizedTitle: "4. 第四步，支付功能测试",
                charIndex: 2051
            }],
            headersStr: "0. 概述 1. 第一步，配置支付渠道 2. 第二步，实现支付调用【重要】 3. 第三步，实现回调接口【重要】 4. 第四步，支付功能测试",
            content: "# 0. 概述\n\n在 yudao-module-pay-biz 模块的 demo 模块，我们提供了一个 支付 接入的示例。\n\n它支持如下支付渠道：\n\n * 支付宝 电脑网站支付\n * 支付宝 手机网站支付\n * 支付宝 当面付（条码支付）\n * 支付宝 扫码支付\n * 微信 付款码支付\n * 微信 Native支付\n\n疑问：为什么不支持微信小程序、公众号支付？\n\n因为这 2 种微信支付方式，只能在微信环境中进行，而我们的接入示例使用 PC 浏览器，所以无法进行。\n\n你可以阅读 微信小程序支付接入 和 微信公众号支付接入 文档，进行相关的支付接入。\n\n下面，我们以 demo 模块为例子，讲解如何接入支付宝的 电脑网站 支付。\n\n\n# 1. 第一步，配置支付渠道\n\n① 在 [支付管理 -> 应用信息] 菜单，新建 demo 模块使用的支付应用。如下图所示：\n\n\n\n * 支付结果的回调地址：对应「2.4 第四步，实现回调接口」实现的接口。这里因为我们在本地演示，所以使用了 127.0.0.1 IP 地址，如果你部署到服务器上，要设置服务器可调用到的 IP 地址。\n\n因为 demo 模块的支付应用默认已经创建，所以你可以直接使用。注意，这里的应用编号 “7” 稍后会使用到。\n\n疑问：为什么应用上有回调地址，然后 `application.yaml` 配置文件中也有 `yudao.pay.order-notify-url` 回调地址呢？\n\n请详细阅读 《支付手册 —— 功能开启》 的「3.5 支付回调【重要】」小节。\n\n简单来说：\n\n * 配置文件的回调地址，是外部的支付渠道（支付宝、微信）回调 pay 支付模块（支付中心）的地址。\n * 应用的回调地址，是 pay 回调内部的各个 biz 模块（支付应用）的地址。例如收：trade 商城的订单、wallet 钱包的充值。\n\n因为内部会有多个业务模块，所以它们每个都有自己的回调地址，就是配置到对应的支付应用上！\n\n② 点击“示例用户”对应的【支付宝 PC 网站支付】，进入支付渠道的配置。如下图所示：\n\n\n\n友情提示：\n\n如果你还没有支付宝开放平台的账号，可以先参考 《沙箱环境》 文档，申请一个测试账号，我目前就是这么测试的。只需要阅读该文档的如下小节即可：\n\n\n\n最终在 沙箱应用 可以看到支付渠道的配置。\n\n\n# 2. 第二步，实现支付调用【重要】\n\n友情提示：由于 demo 模块的支付接入已经实现，这里你只要看懂什么意思即可，不用操作。\n\n① 【后端】在 demo 模块所在的 yudao-module-xx-biz 模块的 pom.xml 文件，引入 yudao-module-pay-api 依赖，这样才可以调用到 PayOrderApi 接口。代码如下：\n\n    <dependency>\n        <groupId>cn.iocoder.boot</groupId>\n        <artifactId>yudao-module-pay-api</artifactId>\n        <version>${revision}</version>\n    </dependency>\n\n\n② 【后端】在 demo 模块的下单逻辑中，需要调用 PayOrderApi 的 #createOrder(...) 方法，创建支付单。如下图所示：\n\n\n\n疑问：为什么 demo 模块在下单逻辑中，需要调用 PayOrderApi 接口来创建支付单？\n\n因为跳转公用的【收银台】，需要通过读取支付订单，展示支付信息。这样，才能和 demo 模块进行解耦。收银台如下图所示：\n\n\n\n③ 【前端】在 demo 模块下完单之后，前端需要跳转到【收银台】。前端接入代码在 /views/pay/demo/index.vue，如下图所示：\n\n\n\nthis.$router.push({\n  name: 'PayCashier',\n  query:{\n    id: row.payOrderId, // 支付单号\n    returnUrl: encodeURIComponent('/pay/demo-order?id=' + row.id) // 支付成功后，跳转的 URL\n  }\n})\n\n\n另外，收银台的前端代码，在 /views/pay/cashier/index.vue 里，已经实现，感兴趣可以看看。\n\n\n# 3. 第三步，实现回调接口【重要】\n\n友情提示：由于 demo 模块的支付接入已经实现，这里你只要看懂什么意思即可，不用操作。\n\n在 demo 模块所在的 yudao-module-xx-biz 模块，实现一个支付回调的接口，提供给支付【中心】回调。对应的代码在 PayDemoOrderController 的 #updateDemoOrderPaid(...) 方法中，如下图所示：\n\n\n\n\n# 4. 第四步，支付功能测试\n\n至此，我们已经完成了支付接入的所有步骤，接下来，我们来测试一下支付功能。\n\n① 打开 [支付管理 -> 接入示例 -> 支付&退款案例] 菜单，进入示例订单列表。点击【发起订单】按钮，选择一个商品，进行下单。如下图所示：\n\n\n\n此时，在 pay_order 表中，会新增一条支付订单记录。\n\n② 下单完成后，点击该订单对应的【支付】按钮，跳转到【收银台】。如下图所示：\n\n\n\n③ 选择【支付宝 PC 网站支付】支付渠道，跳转支付宝支付。如下图所示：\n\n\n\n友情提示：\n\n选择完支付【渠道】，会调用后端 PayOrderController 的 #submit(...) 方法，内部调用对应支付【渠道】的 PayClient 实现类，发起支付。\n\n④ 此时，我们会看到一个支付宝的二维码，使用 “沙箱环境” 的支付宝客户端，扫码完成支付。如下图所示：\n\n\n\n⑤ 支付完成后，先是支付【中心】的回调接口被回调，然后是 demo 模块的回调接口被回调。如下图所示：\n\n\n\n至此，我们已经完成支付接入的测试流程，可以试着多多 debug 调试整个流程，并不复杂噢。",
            normalizedContent: "# 0. 概述\n\n在 yudao-module-pay-biz 模块的 demo 模块，我们提供了一个 支付 接入的示例。\n\n它支持如下支付渠道：\n\n * 支付宝 电脑网站支付\n * 支付宝 手机网站支付\n * 支付宝 当面付（条码支付）\n * 支付宝 扫码支付\n * 微信 付款码支付\n * 微信 native支付\n\n疑问：为什么不支持微信小程序、公众号支付？\n\n因为这 2 种微信支付方式，只能在微信环境中进行，而我们的接入示例使用 pc 浏览器，所以无法进行。\n\n你可以阅读 微信小程序支付接入 和 微信公众号支付接入 文档，进行相关的支付接入。\n\n下面，我们以 demo 模块为例子，讲解如何接入支付宝的 电脑网站 支付。\n\n\n# 1. 第一步，配置支付渠道\n\n① 在 [支付管理 -> 应用信息] 菜单，新建 demo 模块使用的支付应用。如下图所示：\n\n\n\n * 支付结果的回调地址：对应「2.4 第四步，实现回调接口」实现的接口。这里因为我们在本地演示，所以使用了 127.0.0.1 ip 地址，如果你部署到服务器上，要设置服务器可调用到的 ip 地址。\n\n因为 demo 模块的支付应用默认已经创建，所以你可以直接使用。注意，这里的应用编号 “7” 稍后会使用到。\n\n疑问：为什么应用上有回调地址，然后 `application.yaml` 配置文件中也有 `yudao.pay.order-notify-url` 回调地址呢？\n\n请详细阅读 《支付手册 —— 功能开启》 的「3.5 支付回调【重要】」小节。\n\n简单来说：\n\n * 配置文件的回调地址，是外部的支付渠道（支付宝、微信）回调 pay 支付模块（支付中心）的地址。\n * 应用的回调地址，是 pay 回调内部的各个 biz 模块（支付应用）的地址。例如收：trade 商城的订单、wallet 钱包的充值。\n\n因为内部会有多个业务模块，所以它们每个都有自己的回调地址，就是配置到对应的支付应用上！\n\n② 点击“示例用户”对应的【支付宝 pc 网站支付】，进入支付渠道的配置。如下图所示：\n\n\n\n友情提示：\n\n如果你还没有支付宝开放平台的账号，可以先参考 《沙箱环境》 文档，申请一个测试账号，我目前就是这么测试的。只需要阅读该文档的如下小节即可：\n\n\n\n最终在 沙箱应用 可以看到支付渠道的配置。\n\n\n# 2. 第二步，实现支付调用【重要】\n\n友情提示：由于 demo 模块的支付接入已经实现，这里你只要看懂什么意思即可，不用操作。\n\n① 【后端】在 demo 模块所在的 yudao-module-xx-biz 模块的 pom.xml 文件，引入 yudao-module-pay-api 依赖，这样才可以调用到 payorderapi 接口。代码如下：\n\n    <dependency>\n        <groupid>cn.iocoder.boot</groupid>\n        <artifactid>yudao-module-pay-api</artifactid>\n        <version>${revision}</version>\n    </dependency>\n\n\n② 【后端】在 demo 模块的下单逻辑中，需要调用 payorderapi 的 #createorder(...) 方法，创建支付单。如下图所示：\n\n\n\n疑问：为什么 demo 模块在下单逻辑中，需要调用 payorderapi 接口来创建支付单？\n\n因为跳转公用的【收银台】，需要通过读取支付订单，展示支付信息。这样，才能和 demo 模块进行解耦。收银台如下图所示：\n\n\n\n③ 【前端】在 demo 模块下完单之后，前端需要跳转到【收银台】。前端接入代码在 /views/pay/demo/index.vue，如下图所示：\n\n\n\nthis.$router.push({\n  name: 'paycashier',\n  query:{\n    id: row.payorderid, // 支付单号\n    returnurl: encodeuricomponent('/pay/demo-order?id=' + row.id) // 支付成功后，跳转的 url\n  }\n})\n\n\n另外，收银台的前端代码，在 /views/pay/cashier/index.vue 里，已经实现，感兴趣可以看看。\n\n\n# 3. 第三步，实现回调接口【重要】\n\n友情提示：由于 demo 模块的支付接入已经实现，这里你只要看懂什么意思即可，不用操作。\n\n在 demo 模块所在的 yudao-module-xx-biz 模块，实现一个支付回调的接口，提供给支付【中心】回调。对应的代码在 paydemoordercontroller 的 #updatedemoorderpaid(...) 方法中，如下图所示：\n\n\n\n\n# 4. 第四步，支付功能测试\n\n至此，我们已经完成了支付接入的所有步骤，接下来，我们来测试一下支付功能。\n\n① 打开 [支付管理 -> 接入示例 -> 支付&退款案例] 菜单，进入示例订单列表。点击【发起订单】按钮，选择一个商品，进行下单。如下图所示：\n\n\n\n此时，在 pay_order 表中，会新增一条支付订单记录。\n\n② 下单完成后，点击该订单对应的【支付】按钮，跳转到【收银台】。如下图所示：\n\n\n\n③ 选择【支付宝 pc 网站支付】支付渠道，跳转支付宝支付。如下图所示：\n\n\n\n友情提示：\n\n选择完支付【渠道】，会调用后端 payordercontroller 的 #submit(...) 方法，内部调用对应支付【渠道】的 payclient 实现类，发起支付。\n\n④ 此时，我们会看到一个支付宝的二维码，使用 “沙箱环境” 的支付宝客户端，扫码完成支付。如下图所示：\n\n\n\n⑤ 支付完成后，先是支付【中心】的回调接口被回调，然后是 demo 模块的回调接口被回调。如下图所示：\n\n\n\n至此，我们已经完成支付接入的测试流程，可以试着多多 debug 调试整个流程，并不复杂噢。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "微信公众号支付接入",
            frontmatter: {
                title: "微信公众号支付接入",
                date: "2023-07-09T22:07:38.000Z",
                permalink: "/pay/wx-pub-pay-demo/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/12.%E6%94%AF%E4%BB%98%E6%89%8B%E5%86%8C/12.%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E6%94%AF%E4%BB%98%E6%8E%A5%E5%85%A5.html",
            relativePath: "01.开发指南/12.支付手册/12.微信公众号支付接入.md",
            key: "v-4da5e558",
            path: "/pay/wx-pub-pay-demo/",
            headers: [{
                level: 2,
                title: "1. 第一步，配置支付渠道",
                slug: "_1-第一步-配置支付渠道",
                normalizedTitle: "1. 第一步，配置支付渠道",
                charIndex: 424
            }, {
                level: 2,
                title: "2. 支付功能测试",
                slug: "_2-支付功能测试",
                normalizedTitle: "2. 支付功能测试",
                charIndex: 765
            }],
            headersStr: "1. 第一步，配置支付渠道 2. 支付功能测试",
            content: "前置阅读：\n\n① 阅读 《支付功能开启》 和 《支付宝支付接入》 文档，一定要先跑通支付宝支付流程！！！不跑通支付宝，微信公众号支付更跑不通。\n\n② 阅读 《微信公众号登录》 文档，因为微信公众号支付需要先微信公众号登录，超级麻烦的说！\n\n注意，微信公众号支付不能使用“测试公众号”，必须使用认证过的公众号。并且，在阅读《公众号登录》文档时，前端项目需要使用 《内网穿透》，因为微信公众号支付只能在手机微信上测试！！！\n\n微信公众号支付，使用 WxPubPayClient 客户端进行对接。\n\n下面，我们以 yudao-mall-uniapp 商城项目，演示微信公众号支付的接入流程。\n\n友情提示：\n\n * http://niubi.natapp1.cc 域名，是我前端项目的访问域名\n * http://yunai.natapp1.cc 域名，是我后端项目的访问域名\n\n所以，你的前后端项目也要分别使用 《内网穿透》 实现独立域名！！！\n\n\n# 1. 第一步，配置支付渠道\n\n① 访问 [支付管理 -> 应用信息] 菜单，点击“商城应用”对应的【微信 JSAPI 支付】，进入支付渠道的配置。如下图所示：\n\n\n\n * 在 https://pay.weixin.qq.com/index.php/core/account/info 地址，可获取微信支付商户号\n * 在 https://pay.weixin.qq.com/index.php/core/cert/api_cert#/ 地址，可获取 API 证书、密钥\n\n友情提示：\n\n可以简单阅读下 《微信官方文档 —— JSAPI 支付的接入前准备》 文章。\n\n② 访问微信支付的 开发配置 地址，设置 JSAPI 支付目录，设置为前端项目的访问域名。如下图所示：\n\n\n\n\n# 2. 支付功能测试\n\n① IDEA 打开前端项目，搜索 http://127.0.0.1:48080 关键字，都替换成后端项目的访问域名。例如说下图：\n\n\n\n② 使用手机微信，访问前端项目的域名。随便找个商品下单，一路往下走，可以进入“收银台”界面（对应前端项目的 pages/pay/index.vue 文件）。如下图所示：\n\n\n\n③ 选择“微信支付”，点击“立即支付”按钮，即可进行微信支付。如下图所示：\n\n\n\n * 前端代码的实现，可见 sheep/platform/pay.js 文件的 #wechatOfficialAccountPay(...) 方法\n * 后端代码的实现，可见 AppPayOrderController 提供的 #submitPayOrder(...) 接口\n\n④ 支付成功后，跳转到“支付结果”界面（对应前端项目的 pages/pay/result.vue 文件）。\n\n友情提示：\n\n如果这个过程中碰到问题，可以先使用「微信开发者工具」访问前端项目的域名，看看这个过程中有没什么报错。\n\n自查 30-60 分钟，如果还是无法解决，可以在星球发帖求助！但是注意，一定要先自查，因为这玩意没环境现场，很难搞啊！！！",
            normalizedContent: "前置阅读：\n\n① 阅读 《支付功能开启》 和 《支付宝支付接入》 文档，一定要先跑通支付宝支付流程！！！不跑通支付宝，微信公众号支付更跑不通。\n\n② 阅读 《微信公众号登录》 文档，因为微信公众号支付需要先微信公众号登录，超级麻烦的说！\n\n注意，微信公众号支付不能使用“测试公众号”，必须使用认证过的公众号。并且，在阅读《公众号登录》文档时，前端项目需要使用 《内网穿透》，因为微信公众号支付只能在手机微信上测试！！！\n\n微信公众号支付，使用 wxpubpayclient 客户端进行对接。\n\n下面，我们以 yudao-mall-uniapp 商城项目，演示微信公众号支付的接入流程。\n\n友情提示：\n\n * http://niubi.natapp1.cc 域名，是我前端项目的访问域名\n * http://yunai.natapp1.cc 域名，是我后端项目的访问域名\n\n所以，你的前后端项目也要分别使用 《内网穿透》 实现独立域名！！！\n\n\n# 1. 第一步，配置支付渠道\n\n① 访问 [支付管理 -> 应用信息] 菜单，点击“商城应用”对应的【微信 jsapi 支付】，进入支付渠道的配置。如下图所示：\n\n\n\n * 在 https://pay.weixin.qq.com/index.php/core/account/info 地址，可获取微信支付商户号\n * 在 https://pay.weixin.qq.com/index.php/core/cert/api_cert#/ 地址，可获取 api 证书、密钥\n\n友情提示：\n\n可以简单阅读下 《微信官方文档 —— jsapi 支付的接入前准备》 文章。\n\n② 访问微信支付的 开发配置 地址，设置 jsapi 支付目录，设置为前端项目的访问域名。如下图所示：\n\n\n\n\n# 2. 支付功能测试\n\n① idea 打开前端项目，搜索 http://127.0.0.1:48080 关键字，都替换成后端项目的访问域名。例如说下图：\n\n\n\n② 使用手机微信，访问前端项目的域名。随便找个商品下单，一路往下走，可以进入“收银台”界面（对应前端项目的 pages/pay/index.vue 文件）。如下图所示：\n\n\n\n③ 选择“微信支付”，点击“立即支付”按钮，即可进行微信支付。如下图所示：\n\n\n\n * 前端代码的实现，可见 sheep/platform/pay.js 文件的 #wechatofficialaccountpay(...) 方法\n * 后端代码的实现，可见 apppayordercontroller 提供的 #submitpayorder(...) 接口\n\n④ 支付成功后，跳转到“支付结果”界面（对应前端项目的 pages/pay/result.vue 文件）。\n\n友情提示：\n\n如果这个过程中碰到问题，可以先使用「微信开发者工具」访问前端项目的域名，看看这个过程中有没什么报错。\n\n自查 30-60 分钟，如果还是无法解决，可以在星球发帖求助！但是注意，一定要先自查，因为这玩意没环境现场，很难搞啊！！！",
            charsets: {
                cjk: !0
            }
        }, {
            title: "大屏设计器",
            frontmatter: {
                title: "大屏设计器",
                date: "2023-02-07T21:41:50.000Z",
                permalink: "/report/screen"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/11.%E5%A4%A7%E5%B1%8F%E6%89%8B%E5%86%8C/02.%E5%A4%A7%E5%B1%8F%E8%AE%BE%E8%AE%A1%E5%99%A8.html",
            relativePath: "01.开发指南/11.大屏手册/02.大屏设计器.md",
            key: "v-3a3955ca",
            path: "/report/screen/",
            headers: [{
                level: 2,
                title: "1. 功能开启",
                slug: "_1-功能开启",
                normalizedTitle: "1. 功能开启",
                charIndex: 314
            }, {
                level: 3,
                title: "1.1 第一步，开启模块",
                slug: "_1-1-第一步-开启模块",
                normalizedTitle: "1.1 第一步，开启模块",
                charIndex: 483
            }, {
                level: 3,
                title: "1.2 第二步，导入 SQL",
                slug: "_1-2-第二步-导入-sql",
                normalizedTitle: "1.2 第二步，导入 sql",
                charIndex: 686
            }, {
                level: 3,
                title: "1.3 第三步，启动后端项目",
                slug: "_1-3-第三步-启动后端项目",
                normalizedTitle: "1.3 第三步，启动后端项目",
                charIndex: 792
            }, {
                level: 3,
                title: "1.4 第四步，启动前端项目（AJ-Report）",
                slug: "_1-4-第四步-启动前端项目-aj-report",
                normalizedTitle: "1.4 第四步，启动前端项目（aj-report）",
                charIndex: 864
            }, {
                level: 3,
                title: "1.4 第四步，启动前端项目（Go-View）",
                slug: "_1-4-第四步-启动前端项目-go-view",
                normalizedTitle: "1.4 第四步，启动前端项目（go-view）",
                charIndex: 915
            }, {
                level: 2,
                title: "2. 如何使用？",
                slug: "_2-如何使用",
                normalizedTitle: "2. 如何使用？",
                charIndex: 1217
            }, {
                level: 3,
                title: "2.1 AJ-Report 大屏设计器",
                slug: "_2-1-aj-report-大屏设计器",
                normalizedTitle: "2.1 aj-report 大屏设计器",
                charIndex: 1230
            }, {
                level: 3,
                title: "2.2 Go-View 大屏设计器",
                slug: "_2-2-go-view-大屏设计器",
                normalizedTitle: "2.2 go-view 大屏设计器",
                charIndex: 1275
            }],
            headersStr: "1. 功能开启 1.1 第一步，开启模块 1.2 第二步，导入 SQL 1.3 第三步，启动后端项目 1.4 第四步，启动前端项目（AJ-Report） 1.4 第四步，启动前端项目（Go-View） 2. 如何使用？ 2.1 AJ-Report 大屏设计器 2.2 Go-View 大屏设计器",
            content: '数据可视化，一般可以通过报表设计器、或者大屏设计器来实现。本小节，我们来讲解大屏设计器的功能开启。\n\n大屏设计器，指的是通过拖拽图表或页面元素，无需编写代码即可制作数据大屏。如下图所示：\n\n\n\n在项目中，通过集成市面上的报表引擎，实现了大屏设计器的能力。目前使用如下：\n\n             是否集成   是否开源\nAJ-Report    集成中    开源\nGo-View      集成中    开源\nJimuReport   不集成    不开源\n\n为什么不使用 JimuReport 报表引擎呢？\n\n因为 JimuReport 的大屏设计器是商业化的，需要购买授权。我手头暂时没有授权，所以没办法集成~\n\n\n# 1. 功能开启\n\nyudao-module-report 也实现了大屏设计器的能力，考虑到编译速度，默认是关闭的。开启步骤如下：\n\n * 第一步，开启 yudao-report-report 模块\n * 第二步，导入报表的 SQL 数据库脚本\n * 第三步，启动后端项目，确认功能是否生效\n * 第四步，启动大屏设计器的前端项目\n\n\n# 1.1 第一步，开启模块\n\n① 修改根目录的 pom.xml 文件，取消 yudao-module-report 模块的注释。\n\n\n\n② 修改 yudao-server 目录的 pom.xml 文件，引入 yudao-module-report 模块。如下图所示：\n\n\n\n③ 点击 IDEA 右上角的【Reload All Maven Projects】，刷新 Maven 依赖。如下图所示：\n\n\n\n\n# 1.2 第二步，导入 SQL\n\n下载 go-view.sql 脚本，并导入数据库，初始化 Go-View 相关的表结构和数据。\n\n友情提示：↑↑↑ go-view.sql 是可以点击下载的！ ↑↑↑\n\n\n\n\n# 1.3 第三步，启动后端项目\n\n启动后端项目，看到 "Init JimuReport Config [ 线程池 ] " 说明开启成功。\n\n\n# 1.4 第四步，启动前端项目（AJ-Report）\n\nTODO 开发中，预计 4 月份左右。\n\n\n# 1.4 第四步，启动前端项目（Go-View）\n\n① 克隆 yudao-ui-go-view 项目，执行如下命令进行启动：\n\n# 安装 pnpm，提升依赖的安装速度\nnpm config set registry https://registry.npmmirror.com\nnpm install -g pnpm\n# 安装依赖\npnpm install\n\n# 启动服务\nnpm run dev\n\n\n② 启动完成后，浏览器会自动打开 http://127.0.0.1:3000 地址，可以看到前端界面。\n\n\n\n③ 访问 [报表管理 -> 大屏设计器] 菜单，可以查看对应的功能。如下图所示：\n\n\n\n\n# 2. 如何使用？\n\n\n# 2.1 AJ-Report 大屏设计器\n\nTODO 开发中，预计 4 月份左右。\n\n\n# 2.2 Go-View 大屏设计器\n\n可以查看 Go-View 的官方文档，主要是：\n\n * GoView 说明文档 —— 页面引导\n * GoView 说明文档 —— 常见问题\n\n如果你想了解在 Go-View 中，如何使用 SQL 或 HTTP 查询数据，可以查看内置的两个示例：\n\n\n\n集成 Go-View 的代码实现？\n\n① 后端：Go-View 的后端代码，主要在 go-view 包下实现。\n\n② 前端：在 @/views/report/go-view 文件，通过 IFrame 嵌入 Go-View 界面。',
            normalizedContent: '数据可视化，一般可以通过报表设计器、或者大屏设计器来实现。本小节，我们来讲解大屏设计器的功能开启。\n\n大屏设计器，指的是通过拖拽图表或页面元素，无需编写代码即可制作数据大屏。如下图所示：\n\n\n\n在项目中，通过集成市面上的报表引擎，实现了大屏设计器的能力。目前使用如下：\n\n             是否集成   是否开源\naj-report    集成中    开源\ngo-view      集成中    开源\njimureport   不集成    不开源\n\n为什么不使用 jimureport 报表引擎呢？\n\n因为 jimureport 的大屏设计器是商业化的，需要购买授权。我手头暂时没有授权，所以没办法集成~\n\n\n# 1. 功能开启\n\nyudao-module-report 也实现了大屏设计器的能力，考虑到编译速度，默认是关闭的。开启步骤如下：\n\n * 第一步，开启 yudao-report-report 模块\n * 第二步，导入报表的 sql 数据库脚本\n * 第三步，启动后端项目，确认功能是否生效\n * 第四步，启动大屏设计器的前端项目\n\n\n# 1.1 第一步，开启模块\n\n① 修改根目录的 pom.xml 文件，取消 yudao-module-report 模块的注释。\n\n\n\n② 修改 yudao-server 目录的 pom.xml 文件，引入 yudao-module-report 模块。如下图所示：\n\n\n\n③ 点击 idea 右上角的【reload all maven projects】，刷新 maven 依赖。如下图所示：\n\n\n\n\n# 1.2 第二步，导入 sql\n\n下载 go-view.sql 脚本，并导入数据库，初始化 go-view 相关的表结构和数据。\n\n友情提示：↑↑↑ go-view.sql 是可以点击下载的！ ↑↑↑\n\n\n\n\n# 1.3 第三步，启动后端项目\n\n启动后端项目，看到 "init jimureport config [ 线程池 ] " 说明开启成功。\n\n\n# 1.4 第四步，启动前端项目（aj-report）\n\ntodo 开发中，预计 4 月份左右。\n\n\n# 1.4 第四步，启动前端项目（go-view）\n\n① 克隆 yudao-ui-go-view 项目，执行如下命令进行启动：\n\n# 安装 pnpm，提升依赖的安装速度\nnpm config set registry https://registry.npmmirror.com\nnpm install -g pnpm\n# 安装依赖\npnpm install\n\n# 启动服务\nnpm run dev\n\n\n② 启动完成后，浏览器会自动打开 http://127.0.0.1:3000 地址，可以看到前端界面。\n\n\n\n③ 访问 [报表管理 -> 大屏设计器] 菜单，可以查看对应的功能。如下图所示：\n\n\n\n\n# 2. 如何使用？\n\n\n# 2.1 aj-report 大屏设计器\n\ntodo 开发中，预计 4 月份左右。\n\n\n# 2.2 go-view 大屏设计器\n\n可以查看 go-view 的官方文档，主要是：\n\n * goview 说明文档 —— 页面引导\n * goview 说明文档 —— 常见问题\n\n如果你想了解在 go-view 中，如何使用 sql 或 http 查询数据，可以查看内置的两个示例：\n\n\n\n集成 go-view 的代码实现？\n\n① 后端：go-view 的后端代码，主要在 go-view 包下实现。\n\n② 前端：在 @/views/report/go-view 文件，通过 iframe 嵌入 go-view 界面。',
            charsets: {
                cjk: !0
            }
        }, {
            title: "微信小程序支付接入",
            frontmatter: {
                title: "微信小程序支付接入",
                date: "2023-07-09T22:07:38.000Z",
                permalink: "/pay/wx-lite-pay-demo/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/12.%E6%94%AF%E4%BB%98%E6%89%8B%E5%86%8C/13.%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%94%AF%E4%BB%98%E6%8E%A5%E5%85%A5.html",
            relativePath: "01.开发指南/12.支付手册/13.微信小程序支付接入.md",
            key: "v-18b6abc1",
            path: "/pay/wx-lite-pay-demo/",
            headers: [{
                level: 2,
                title: "1. 第一步，配置支付渠道",
                slug: "_1-第一步-配置支付渠道",
                normalizedTitle: "1. 第一步，配置支付渠道",
                charIndex: 324
            }, {
                level: 2,
                title: "2. 支付功能测试",
                slug: "_2-支付功能测试",
                normalizedTitle: "2. 支付功能测试",
                charIndex: 656
            }],
            headersStr: "1. 第一步，配置支付渠道 2. 支付功能测试",
            content: "前置阅读：\n\n① 阅读 《支付功能开启》 和 《支付宝支付接入》 文档，一定要先跑通支付宝支付流程！！！不跑通支付宝，微信小程序支付更跑不通。\n\n② 阅读 《微信小程序登录》 文档，因为微信小程序支付需要先微信小程序登录，超级麻烦的说！\n\n注意，微信小程序支付不能使用“测试小程序”，必须使用认证过的小程序。\n\n微信小程序支付，使用 WxLitePayClient 客户端进行对接。\n\n下面，我们以 yudao-mall-uniapp 商城项目，演示微信小程序支付的接入流程。\n\n友情提示：\n\n * http://yunai.natapp1.cc 域名，是我后端项目的访问域名\n\n所以，你的后端项目要使用 《内网穿透》 实现独立域名！！！\n\n\n# 1. 第一步，配置支付渠道\n\n访问 [支付管理 -> 应用信息] 菜单，点击“商城应用”对应的【微信 JSAPI 支付】，进入支付渠道的配置。如下图所示：\n\n\n\n * 在 https://pay.weixin.qq.com/index.php/core/account/info 地址，可获取微信支付商户号\n * 在 https://pay.weixin.qq.com/index.php/core/cert/api_cert#/ 地址，可获取 API 证书、密钥\n * 注意！上图的“公众号 APPID”，实际指的是 “小程序 APPID” 哈，不要弄错了！\n\n友情提示：\n\n可以简单阅读下 《微信官方文档 —— JSAPI 支付的接入前准备》 文章。\n\n\n# 2. 支付功能测试\n\n① 使用微信开发者工具，访问小程序。随便找个商品下单，一路往下走，可以进入“收银台”界面（对应前端项目的 pages/pay/index.vue 文件）。如下图所示：\n\n\n\n② 选择“微信支付”，点击“立即支付”按钮，即可进行微信支付。如下图所示：\n\n\n\n * 前端代码的实现，可见 sheep/platform/pay.js 文件的 #wechatMiniProgramPay(...) 方法\n * 后端代码的实现，可见 AppPayOrderController 提供的 #submitPayOrder(...) 接口\n\n④ 支付成功后，跳转到“支付结果”界面（对应前端项目的 pages/pay/result.vue 文件）。\n\n友情提示：\n\n如果这个过程中碰到问题，可以先使用「微信开发者工具」，看看这个过程中有没什么报错。\n\n自查 30-60 分钟，如果还是无法解决，可以在星球发帖求助！但是注意，一定要先自查，因为这玩意没环境现场，很难搞啊！！！",
            normalizedContent: "前置阅读：\n\n① 阅读 《支付功能开启》 和 《支付宝支付接入》 文档，一定要先跑通支付宝支付流程！！！不跑通支付宝，微信小程序支付更跑不通。\n\n② 阅读 《微信小程序登录》 文档，因为微信小程序支付需要先微信小程序登录，超级麻烦的说！\n\n注意，微信小程序支付不能使用“测试小程序”，必须使用认证过的小程序。\n\n微信小程序支付，使用 wxlitepayclient 客户端进行对接。\n\n下面，我们以 yudao-mall-uniapp 商城项目，演示微信小程序支付的接入流程。\n\n友情提示：\n\n * http://yunai.natapp1.cc 域名，是我后端项目的访问域名\n\n所以，你的后端项目要使用 《内网穿透》 实现独立域名！！！\n\n\n# 1. 第一步，配置支付渠道\n\n访问 [支付管理 -> 应用信息] 菜单，点击“商城应用”对应的【微信 jsapi 支付】，进入支付渠道的配置。如下图所示：\n\n\n\n * 在 https://pay.weixin.qq.com/index.php/core/account/info 地址，可获取微信支付商户号\n * 在 https://pay.weixin.qq.com/index.php/core/cert/api_cert#/ 地址，可获取 api 证书、密钥\n * 注意！上图的“公众号 appid”，实际指的是 “小程序 appid” 哈，不要弄错了！\n\n友情提示：\n\n可以简单阅读下 《微信官方文档 —— jsapi 支付的接入前准备》 文章。\n\n\n# 2. 支付功能测试\n\n① 使用微信开发者工具，访问小程序。随便找个商品下单，一路往下走，可以进入“收银台”界面（对应前端项目的 pages/pay/index.vue 文件）。如下图所示：\n\n\n\n② 选择“微信支付”，点击“立即支付”按钮，即可进行微信支付。如下图所示：\n\n\n\n * 前端代码的实现，可见 sheep/platform/pay.js 文件的 #wechatminiprogrampay(...) 方法\n * 后端代码的实现，可见 apppayordercontroller 提供的 #submitpayorder(...) 接口\n\n④ 支付成功后，跳转到“支付结果”界面（对应前端项目的 pages/pay/result.vue 文件）。\n\n友情提示：\n\n如果这个过程中碰到问题，可以先使用「微信开发者工具」，看看这个过程中有没什么报错。\n\n自查 30-60 分钟，如果还是无法解决，可以在星球发帖求助！但是注意，一定要先自查，因为这玩意没环境现场，很难搞啊！！！",
            charsets: {
                cjk: !0
            }
        }, {
            title: "钱包充值、支付、退款",
            frontmatter: {
                title: "钱包充值、支付、退款",
                date: "2024-09-18T08:52:19.000Z",
                permalink: "/pay/wallet"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/12.%E6%94%AF%E4%BB%98%E6%89%8B%E5%86%8C/30.%E9%92%B1%E5%8C%85%E5%85%85%E5%80%BC%E3%80%81%E6%94%AF%E4%BB%98%E3%80%81%E9%80%80%E6%AC%BE.html",
            relativePath: "01.开发指南/12.支付手册/30.钱包充值、支付、退款.md",
            key: "v-5e7d42dd",
            path: "/pay/wallet/",
            headers: [{
                level: 2,
                title: "1. 钱包信息",
                slug: "_1-钱包信息",
                normalizedTitle: "1. 钱包信息",
                charIndex: 382
            }, {
                level: 3,
                title: "1.1 钱包表",
                slug: "_1-1-钱包表",
                normalizedTitle: "1.1 钱包表",
                charIndex: 426
            }, {
                level: 3,
                title: "1.2 钱包流水表",
                slug: "_1-2-钱包流水表",
                normalizedTitle: "1.2 钱包流水表",
                charIndex: 1766
            }, {
                level: 2,
                title: "2. 钱包充值",
                slug: "_2-钱包充值",
                normalizedTitle: "2. 钱包充值",
                charIndex: 3095
            }, {
                level: 3,
                title: "2.1 钱包套餐表",
                slug: "_2-1-钱包套餐表",
                normalizedTitle: "2.1 钱包套餐表",
                charIndex: 3174
            }, {
                level: 3,
                title: "2.2 钱包充值表",
                slug: "_2-2-钱包充值表",
                normalizedTitle: "2.2 钱包充值表",
                charIndex: 4035
            }, {
                level: 3,
                title: "2.3 充值流程",
                slug: "_2-3-充值流程",
                normalizedTitle: "2.3 充值流程",
                charIndex: 6117
            }, {
                level: 2,
                title: "3. 钱包支付与退款",
                slug: "_3-钱包支付与退款",
                normalizedTitle: "3. 钱包支付与退款",
                charIndex: 6819
            }, {
                level: 3,
                title: "3.1 钱包支付",
                slug: "_3-1-钱包支付",
                normalizedTitle: "3.1 钱包支付",
                charIndex: 6994
            }, {
                level: 3,
                title: "3.2 钱包退款",
                slug: "_3-2-钱包退款",
                normalizedTitle: "3.2 钱包退款",
                charIndex: 7115
            }],
            headersStr: "1. 钱包信息 1.1 钱包表 1.2 钱包流水表 2. 钱包充值 2.1 钱包套餐表 2.2 钱包充值表 2.3 充值流程 3. 钱包支付与退款 3.1 钱包支付 3.2 钱包退款",
            content: "前置阅读：\n\n需要先阅读如下文档，对支付、退款功能有一定了解：\n\n * 《支付功能开启》\n * 《支付宝支付接入》\n * 《支付宝、微信退款接入》\n\n在 yudao-module-pay-biz 模块的 wallet 模块，实现了钱包，包括了如下功能：\n\n * 充值：可见 PayWalletRechargeService 类\n * 支付：可见 WalletPayClient 类的 #doUnifiedOrder(...) 方法\n * 退款：可见 WalletRefundClient 类的 #doUnifiedRefund(...) 方法\n * 流水：可见 PayWalletTransactionService 类\n\n疑问：为什么没有钱包的提现功能呢？\n\n功能正在建设中，未来会支持提现到支付宝、微信、银行卡等渠道。\n\n下面，我们逐个功能进行介绍。\n\n\n# 1. 钱包信息\n\n本小节，我们先来看看钱包的信息部分，包括钱包表、钱包流水表。\n\n\n# 1.1 钱包表\n\npay_wallet 表，会员钱包表，由 PayWalletService 实现。表结构如下：\n\nCREATE TABLE `pay_wallet` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  \n  `user_id` bigint NOT NULL COMMENT '用户编号',\n  `user_type` tinyint NOT NULL DEFAULT '0' COMMENT '用户类型',\n  \n  `balance` int NOT NULL DEFAULT '0' COMMENT '余额，单位分',\n  \n  `total_expense` int NOT NULL DEFAULT '0' COMMENT '累计支出，单位分',\n  `total_recharge` int NOT NULL DEFAULT '0' COMMENT '累计充值，单位分',\n  `freeze_price` int NOT NULL DEFAULT '0' COMMENT '冻结金额，单位分',\n  \n) ENGINE=InnoDB AUTO_INCREMENT=20 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='会员钱包表';\n\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\n① user_id、user_type 字段：关联的用户编号、用户类型，例如说“商城”的会员用户。\n\n② balance 字段：余额，单位分。支付时，会从这里扣除。\n\n * total_expense 字段，累计支出，单位分。每次支付时，会增加该字段。\n * total_recharge 字段：累计充值，单位分。每次充值时，会增加该字段。\n\n③ freeze_price 字段：冻结金额，单位分。目前用于钱包充值时的退款，可暂时不用了解。\n\n# 1.1.1 钱包创建\n\n一般情况下，用户创建后，自动进行关联的钱包创建。但是考虑到 pay 模块是可选模块，需要进行结构。\n\n所以，目前是通过 PayWalletService 的 #getOrCreateWallet(userId, userType) 方法来进行“创建”：不存在则进行创建，存在则直接查询返回。\n\n# 1.1.2 管理后台\n\n在 [支付管理 -> 钱包管理 -> 钱包余额] 菜单，对应 yudao-ui-admin-vue3/src/views/pay/wallet/balance/index.vue 界面，可以查看钱包列表。如下图所示：\n\n\n\n# 1.1.3 修改余额\n\n在 [会员中心 -> 会员管理] 菜单，点击 [>> 更多 -> 修改余额]，对应 yudao-ui-admin-vue3/src/views/member/user/components/UserBalanceUpdateForm.vue 界面，可以修改钱包余额。如下图所示：\n\n\n\n\n# 1.2 钱包流水表\n\npay_wallet 表，会员钱包表，由 PayWalletService 实现。表结构如下：\n\nCREATE TABLE `pay_wallet_transaction` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n\n  `wallet_id` bigint NOT NULL COMMENT '会员钱包 id',\n  \n  `biz_type` tinyint NOT NULL COMMENT '关联类型',\n  `biz_id` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '关联业务编号',\n  `title` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '流水标题',\n  \n  `no` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '流水号',\n    \n  `price` int NOT NULL COMMENT '交易金额, 单位分',\n  `balance` int NOT NULL COMMENT '余额, 单位分',\n\n) ENGINE=InnoDB AUTO_INCREMENT=29 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='会员钱包流水表';\n\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\n① wallet_id 字段：关联的钱包编号，即 pay_wallet 表的 id 字段。\n\n② biz_type、biz_id 字段：关联的业务类型、业务编号。目前 biz_type 由 PayWalletBizTypeEnum 枚举，目前有充值、充值退款、支付、支付退款、更新余额等。\n\ntitle 字段：流水标题，例如说：充值、支付、退款等。主要用于展示，没有什么特殊逻辑。\n\n③ no 字段：流水号，全局唯一，例如说：W202408011306351。它通过 PayNoRedisDAO 生成，前缀是 W。\n\n④ price 字段：本次交易的金额，单位分：\n\n * 正数表示收入：例如说充值、支付退款\n * 负数表示支出：例如说支付、充值退款\n\nbalance 字段：交易后的钱包余额，单位分。\n\n# 1.2.1 管理后台\n\n在 [支付管理 -> 钱包管理 -> 钱包余额] 菜单，点击钱包后的 [详情] 按钮，对应 yudao-ui-admin-vue3/src/views/pay/wallet/transaction/WalletTransactionList.vue 界面，可以查看钱包流水。如下图所示：\n\n\n\n\n# 2. 钱包充值\n\n本小节，我们先来看看钱包的充值部分，包括钱包充值表、钱包充值套餐表。\n\n一般情况下，钱包的余额是通过充值来进行的，稍后会进行演示。\n\n\n# 2.1 钱包套餐表\n\npay_wallet_recharge_package 表，充值套餐表，由 PayWalletRechargePackageService 实现。表结构如下：\n\nCREATE TABLE `pay_wallet_recharge_package` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  `name` varchar(64) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '套餐名',\n  `status` tinyint NOT NULL COMMENT '状态',\n\n  `pay_price` int NOT NULL COMMENT '支付金额',\n  `bonus_price` int NOT NULL COMMENT '赠送金额',\n  \n) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='充值套餐表';\n\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\n比较关键的就 pay_price、bonus_price 字段：\n\n① pay_price 字段：支付金额，单位分。购买该套餐需要支付的金额。\n\n② bonus_price 字段：赠送金额，单位分。购买该套餐，额外赠送的金额。\n\n最终充值到钱包的余额，是 pay_price + bonus_price。\n\n# 2.1.1 管理后台\n\n在 [支付管理 -> 钱包管理 -> 充值套餐] 菜单，对应 yudao-ui-admin-vue3/src/views/pay/wallet/rechargePackage/index.vue 界面，可以查看钱包充值套餐。如下图所示：\n\n\n\n\n# 2.2 钱包充值表\n\npay_wallet_recharge 表，会员钱包充值表，由 PayWalletRechargeService 实现。表结构如下：\n\nCREATE TABLE `pay_wallet_recharge` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n\n  `wallet_id` bigint NOT NULL COMMENT '会员钱包 id',\n  \n  `total_price` int NOT NULL COMMENT '用户实际到账余额，例如充 100 送 20，则该值是 120',\n  `pay_price` int NOT NULL COMMENT '实际支付金额',\n  `bonus_price` int NOT NULL COMMENT '钱包赠送金额',\n  \n  `package_id` bigint DEFAULT NULL COMMENT '充值套餐编号',\n  \n  `pay_status` bit(1) NOT NULL DEFAULT b'0' COMMENT '是否已支付：[0:未支付 1:已经支付过]',\n  `pay_order_id` bigint DEFAULT NULL COMMENT '支付订单编号',\n  `pay_channel_code` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '支付成功的支付渠道',\n  `pay_time` datetime DEFAULT NULL COMMENT '订单支付时间',\n  \n  `pay_refund_id` bigint DEFAULT NULL COMMENT '支付退款单编号',\n  `refund_total_price` int NOT NULL DEFAULT '0' COMMENT '退款金额，包含赠送金额',\n  `refund_pay_price` int NOT NULL DEFAULT '0' COMMENT '退款支付金额',\n  `refund_bonus_price` int NOT NULL DEFAULT '0' COMMENT '退款钱包赠送金额',\n  `refund_time` datetime DEFAULT NULL COMMENT '退款时间',\n  `refund_status` int NOT NULL DEFAULT '0' COMMENT '退款状态',\n\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=31 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC COMMENT='会员钱包充值';\n\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\n本质上，钱包的充值，和商城的订单是类似的，只是没有商品信息而已。因此它也有 pay_ 开头的支付相关的字段，和 refund_ 开头的退款相关的字段。\n\n① wallet_id 字段：关联的钱包编号，即 pay_wallet 表的 id 字段。\n\n② total_price 字段：用户实际到账余额，例如充 100 送 20，则该值是 120。\n\n * pay_price 字段：实际支付金额。\n * bonus_price 字段：钱包赠送金额。一般情况下，只有选择了 package_id 的套餐，才会有赠送金额。当然，也可以不选择套餐，直接充值。\n\n③ pay_ 开头的支付相关字段：钱包充值，可选择支付宝、微信等支付渠道，进行支付。\n\n * pay_status 字段：是否已支付。\n * pay_order_id 字段：支付订单编号，关联 pay_order 表的 id 字段。\n * pay_channel_code 字段：支付成功的支付渠道，例如说支付宝、微信。\n * pay_time 字段：订单支付时间。\n\n④ refund_ 开头的退款相关字段：钱包充值，可选择退款。\n\n * refund_status 字段：退款状态，通过 PayRefundStatusEnum 枚举，目前有未退款、退款成功、退款失败。\n * pay_refund_id 字段：支付退款单编号，关联 pay_refund 表的 id 字段。\n * refund_total_price、refund_pay_price、refund_bonus_price 字段：退款金额，包含赠送金额、退款支付金额、退款钱包赠送金额。\n * refund_time 字段：退款时间。\n\n\n# 2.3 充值流程\n\n下面，我们来演示下钱包的充值流程。目前，只有 商城 的 uni-app 端，可以进行充值。步骤如下：\n\n① 在管理后台的 [支付管理 -> 应用信息] 菜单，将钱包对应的支付应用 wallet 进行开启（开启状态为打开）。如下图所示：\n\n\n\n一般情况下，需要将钱包的支付宝、微信等支付渠道也进行配置。这里，我们为了演示方便，直接使用上图的“模拟支付”。\n\n另外，钱包也有对应的的支付、退款回调地址，如下图所示：\n\n\n\n * 支付回调地址：由 PayWalletRechargeController 的 #updateWalletRechargerPaid(...) 方法实现\n * 退款回调地址：由 PayWalletRefundController 的 #updateWalletRechargeRefunded(...) 方法实现\n\n友情提示：上述两个回调地址的逻辑，可以等后续再看，不影响充值流程的理解。\n\n② 在商城 uni-app 端，访问 http://127.0.0.1:3000/pages/pay/recharge 地址，进入 [充值] 界面，对应 <yudao-mall-uniapp/pages/pay/recharge.vue> 界面。如下图所示：\n\n\n\n随便选择一个充值套餐，或者你想充值的金额，然后点击 [确认充值] 按钮，进入支付界面。\n\n选择“模拟支付”，完成支付后，可点击“查看订单”按钮，跳转到 [充值记录] 界面，对应 <yudao-mall-uniapp/pages/pay/recharge-log.vue> 界面。如下图所示：\n\n\n\n\n# 3. 钱包支付与退款\n\n从本质上来说，钱包支付和支付宝、微信支付一样，可以认为是一个支付渠道。因此，我们定义了 WalletPayClient 客户端，实现了钱包的支付与退款。\n\n这样，在每个业务想要使用钱包支付时，就可以在它的支付应用上，开启钱包支付即可。例如说，我们只需要把“商城”的支付应用开启，就可以使用钱包支付了。如下图所示：\n\n\n\n\n# 3.1 钱包支付\n\n在商城 uni-app 收银台，选择“余额支付”时，内部会调用 WalletPayClient 的 #doUnifiedOrder(...) 方法，发起支付。\n\n\n\n它的整体流程和 《支付宝支付接入》 是一致的。\n\n\n# 3.2 钱包退款\n\n钱包支付后，如果发起退款，则会退回到钱包中，内部会调用 WalletRefundClient 的 #doUnifiedRefund(...) 方法，发起退款。\n\n它的整体流程和 《支付宝、微信退款接入》 是一致的。",
            normalizedContent: "前置阅读：\n\n需要先阅读如下文档，对支付、退款功能有一定了解：\n\n * 《支付功能开启》\n * 《支付宝支付接入》\n * 《支付宝、微信退款接入》\n\n在 yudao-module-pay-biz 模块的 wallet 模块，实现了钱包，包括了如下功能：\n\n * 充值：可见 paywalletrechargeservice 类\n * 支付：可见 walletpayclient 类的 #dounifiedorder(...) 方法\n * 退款：可见 walletrefundclient 类的 #dounifiedrefund(...) 方法\n * 流水：可见 paywallettransactionservice 类\n\n疑问：为什么没有钱包的提现功能呢？\n\n功能正在建设中，未来会支持提现到支付宝、微信、银行卡等渠道。\n\n下面，我们逐个功能进行介绍。\n\n\n# 1. 钱包信息\n\n本小节，我们先来看看钱包的信息部分，包括钱包表、钱包流水表。\n\n\n# 1.1 钱包表\n\npay_wallet 表，会员钱包表，由 paywalletservice 实现。表结构如下：\n\ncreate table `pay_wallet` (\n  `id` bigint not null auto_increment comment '编号',\n  \n  `user_id` bigint not null comment '用户编号',\n  `user_type` tinyint not null default '0' comment '用户类型',\n  \n  `balance` int not null default '0' comment '余额，单位分',\n  \n  `total_expense` int not null default '0' comment '累计支出，单位分',\n  `total_recharge` int not null default '0' comment '累计充值，单位分',\n  `freeze_price` int not null default '0' comment '冻结金额，单位分',\n  \n) engine=innodb auto_increment=20 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='会员钱包表';\n\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\n① user_id、user_type 字段：关联的用户编号、用户类型，例如说“商城”的会员用户。\n\n② balance 字段：余额，单位分。支付时，会从这里扣除。\n\n * total_expense 字段，累计支出，单位分。每次支付时，会增加该字段。\n * total_recharge 字段：累计充值，单位分。每次充值时，会增加该字段。\n\n③ freeze_price 字段：冻结金额，单位分。目前用于钱包充值时的退款，可暂时不用了解。\n\n# 1.1.1 钱包创建\n\n一般情况下，用户创建后，自动进行关联的钱包创建。但是考虑到 pay 模块是可选模块，需要进行结构。\n\n所以，目前是通过 paywalletservice 的 #getorcreatewallet(userid, usertype) 方法来进行“创建”：不存在则进行创建，存在则直接查询返回。\n\n# 1.1.2 管理后台\n\n在 [支付管理 -> 钱包管理 -> 钱包余额] 菜单，对应 yudao-ui-admin-vue3/src/views/pay/wallet/balance/index.vue 界面，可以查看钱包列表。如下图所示：\n\n\n\n# 1.1.3 修改余额\n\n在 [会员中心 -> 会员管理] 菜单，点击 [>> 更多 -> 修改余额]，对应 yudao-ui-admin-vue3/src/views/member/user/components/userbalanceupdateform.vue 界面，可以修改钱包余额。如下图所示：\n\n\n\n\n# 1.2 钱包流水表\n\npay_wallet 表，会员钱包表，由 paywalletservice 实现。表结构如下：\n\ncreate table `pay_wallet_transaction` (\n  `id` bigint not null auto_increment comment '编号',\n\n  `wallet_id` bigint not null comment '会员钱包 id',\n  \n  `biz_type` tinyint not null comment '关联类型',\n  `biz_id` varchar(64) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '关联业务编号',\n  `title` varchar(128) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '流水标题',\n  \n  `no` varchar(64) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '流水号',\n    \n  `price` int not null comment '交易金额, 单位分',\n  `balance` int not null comment '余额, 单位分',\n\n) engine=innodb auto_increment=29 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='会员钱包流水表';\n\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\n① wallet_id 字段：关联的钱包编号，即 pay_wallet 表的 id 字段。\n\n② biz_type、biz_id 字段：关联的业务类型、业务编号。目前 biz_type 由 paywalletbiztypeenum 枚举，目前有充值、充值退款、支付、支付退款、更新余额等。\n\ntitle 字段：流水标题，例如说：充值、支付、退款等。主要用于展示，没有什么特殊逻辑。\n\n③ no 字段：流水号，全局唯一，例如说：w202408011306351。它通过 paynoredisdao 生成，前缀是 w。\n\n④ price 字段：本次交易的金额，单位分：\n\n * 正数表示收入：例如说充值、支付退款\n * 负数表示支出：例如说支付、充值退款\n\nbalance 字段：交易后的钱包余额，单位分。\n\n# 1.2.1 管理后台\n\n在 [支付管理 -> 钱包管理 -> 钱包余额] 菜单，点击钱包后的 [详情] 按钮，对应 yudao-ui-admin-vue3/src/views/pay/wallet/transaction/wallettransactionlist.vue 界面，可以查看钱包流水。如下图所示：\n\n\n\n\n# 2. 钱包充值\n\n本小节，我们先来看看钱包的充值部分，包括钱包充值表、钱包充值套餐表。\n\n一般情况下，钱包的余额是通过充值来进行的，稍后会进行演示。\n\n\n# 2.1 钱包套餐表\n\npay_wallet_recharge_package 表，充值套餐表，由 paywalletrechargepackageservice 实现。表结构如下：\n\ncreate table `pay_wallet_recharge_package` (\n  `id` bigint not null auto_increment comment '编号',\n  `name` varchar(64) collate utf8mb4_unicode_ci not null comment '套餐名',\n  `status` tinyint not null comment '状态',\n\n  `pay_price` int not null comment '支付金额',\n  `bonus_price` int not null comment '赠送金额',\n  \n) engine=innodb auto_increment=3 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='充值套餐表';\n\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\n比较关键的就 pay_price、bonus_price 字段：\n\n① pay_price 字段：支付金额，单位分。购买该套餐需要支付的金额。\n\n② bonus_price 字段：赠送金额，单位分。购买该套餐，额外赠送的金额。\n\n最终充值到钱包的余额，是 pay_price + bonus_price。\n\n# 2.1.1 管理后台\n\n在 [支付管理 -> 钱包管理 -> 充值套餐] 菜单，对应 yudao-ui-admin-vue3/src/views/pay/wallet/rechargepackage/index.vue 界面，可以查看钱包充值套餐。如下图所示：\n\n\n\n\n# 2.2 钱包充值表\n\npay_wallet_recharge 表，会员钱包充值表，由 paywalletrechargeservice 实现。表结构如下：\n\ncreate table `pay_wallet_recharge` (\n  `id` bigint not null auto_increment comment '编号',\n\n  `wallet_id` bigint not null comment '会员钱包 id',\n  \n  `total_price` int not null comment '用户实际到账余额，例如充 100 送 20，则该值是 120',\n  `pay_price` int not null comment '实际支付金额',\n  `bonus_price` int not null comment '钱包赠送金额',\n  \n  `package_id` bigint default null comment '充值套餐编号',\n  \n  `pay_status` bit(1) not null default b'0' comment '是否已支付：[0:未支付 1:已经支付过]',\n  `pay_order_id` bigint default null comment '支付订单编号',\n  `pay_channel_code` varchar(16) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '支付成功的支付渠道',\n  `pay_time` datetime default null comment '订单支付时间',\n  \n  `pay_refund_id` bigint default null comment '支付退款单编号',\n  `refund_total_price` int not null default '0' comment '退款金额，包含赠送金额',\n  `refund_pay_price` int not null default '0' comment '退款支付金额',\n  `refund_bonus_price` int not null default '0' comment '退款钱包赠送金额',\n  `refund_time` datetime default null comment '退款时间',\n  `refund_status` int not null default '0' comment '退款状态',\n\n  primary key (`id`) using btree\n) engine=innodb auto_increment=31 default charset=utf8mb4 collate=utf8mb4_unicode_ci row_format=dynamic comment='会员钱包充值';\n\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\n本质上，钱包的充值，和商城的订单是类似的，只是没有商品信息而已。因此它也有 pay_ 开头的支付相关的字段，和 refund_ 开头的退款相关的字段。\n\n① wallet_id 字段：关联的钱包编号，即 pay_wallet 表的 id 字段。\n\n② total_price 字段：用户实际到账余额，例如充 100 送 20，则该值是 120。\n\n * pay_price 字段：实际支付金额。\n * bonus_price 字段：钱包赠送金额。一般情况下，只有选择了 package_id 的套餐，才会有赠送金额。当然，也可以不选择套餐，直接充值。\n\n③ pay_ 开头的支付相关字段：钱包充值，可选择支付宝、微信等支付渠道，进行支付。\n\n * pay_status 字段：是否已支付。\n * pay_order_id 字段：支付订单编号，关联 pay_order 表的 id 字段。\n * pay_channel_code 字段：支付成功的支付渠道，例如说支付宝、微信。\n * pay_time 字段：订单支付时间。\n\n④ refund_ 开头的退款相关字段：钱包充值，可选择退款。\n\n * refund_status 字段：退款状态，通过 payrefundstatusenum 枚举，目前有未退款、退款成功、退款失败。\n * pay_refund_id 字段：支付退款单编号，关联 pay_refund 表的 id 字段。\n * refund_total_price、refund_pay_price、refund_bonus_price 字段：退款金额，包含赠送金额、退款支付金额、退款钱包赠送金额。\n * refund_time 字段：退款时间。\n\n\n# 2.3 充值流程\n\n下面，我们来演示下钱包的充值流程。目前，只有 商城 的 uni-app 端，可以进行充值。步骤如下：\n\n① 在管理后台的 [支付管理 -> 应用信息] 菜单，将钱包对应的支付应用 wallet 进行开启（开启状态为打开）。如下图所示：\n\n\n\n一般情况下，需要将钱包的支付宝、微信等支付渠道也进行配置。这里，我们为了演示方便，直接使用上图的“模拟支付”。\n\n另外，钱包也有对应的的支付、退款回调地址，如下图所示：\n\n\n\n * 支付回调地址：由 paywalletrechargecontroller 的 #updatewalletrechargerpaid(...) 方法实现\n * 退款回调地址：由 paywalletrefundcontroller 的 #updatewalletrechargerefunded(...) 方法实现\n\n友情提示：上述两个回调地址的逻辑，可以等后续再看，不影响充值流程的理解。\n\n② 在商城 uni-app 端，访问 http://127.0.0.1:3000/pages/pay/recharge 地址，进入 [充值] 界面，对应 <yudao-mall-uniapp/pages/pay/recharge.vue> 界面。如下图所示：\n\n\n\n随便选择一个充值套餐，或者你想充值的金额，然后点击 [确认充值] 按钮，进入支付界面。\n\n选择“模拟支付”，完成支付后，可点击“查看订单”按钮，跳转到 [充值记录] 界面，对应 <yudao-mall-uniapp/pages/pay/recharge-log.vue> 界面。如下图所示：\n\n\n\n\n# 3. 钱包支付与退款\n\n从本质上来说，钱包支付和支付宝、微信支付一样，可以认为是一个支付渠道。因此，我们定义了 walletpayclient 客户端，实现了钱包的支付与退款。\n\n这样，在每个业务想要使用钱包支付时，就可以在它的支付应用上，开启钱包支付即可。例如说，我们只需要把“商城”的支付应用开启，就可以使用钱包支付了。如下图所示：\n\n\n\n\n# 3.1 钱包支付\n\n在商城 uni-app 收银台，选择“余额支付”时，内部会调用 walletpayclient 的 #dounifiedorder(...) 方法，发起支付。\n\n\n\n它的整体流程和 《支付宝支付接入》 是一致的。\n\n\n# 3.2 钱包退款\n\n钱包支付后，如果发起退款，则会退回到钱包中，内部会调用 walletrefundclient 的 #dounifiedrefund(...) 方法，发起退款。\n\n它的整体流程和 《支付宝、微信退款接入》 是一致的。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "支付宝、微信退款接入",
            frontmatter: {
                title: "支付宝、微信退款接入",
                date: "2023-07-09T22:04:05.000Z",
                permalink: "/pay/refund-demo"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/12.%E6%94%AF%E4%BB%98%E6%89%8B%E5%86%8C/21.%E6%94%AF%E4%BB%98%E5%AE%9D%E3%80%81%E5%BE%AE%E4%BF%A1%E9%80%80%E6%AC%BE%E6%8E%A5%E5%85%A5.html",
            relativePath: "01.开发指南/12.支付手册/21.支付宝、微信退款接入.md",
            key: "v-74d1fe05",
            path: "/pay/refund-demo/",
            headers: [{
                level: 2,
                title: "0. 概述",
                slug: "_0-概述",
                normalizedTitle: "0. 概述",
                charIndex: 2
            }, {
                level: 2,
                title: "1. 第一步，创建支付订单",
                slug: "_1-第一步-创建支付订单",
                normalizedTitle: "1. 第一步，创建支付订单",
                charIndex: 113
            }, {
                level: 2,
                title: "2. 第二步，实现退款调用【重要】",
                slug: "_2-第二步-实现退款调用【重要】",
                normalizedTitle: "2. 第二步，实现退款调用【重要】",
                charIndex: 276
            }, {
                level: 2,
                title: "3. 第三步，实现回调接口【重要】",
                slug: "_3-第三步-实现回调接口【重要】",
                normalizedTitle: "3. 第三步，实现回调接口【重要】",
                charIndex: 709
            }, {
                level: 2,
                title: "4. 第四步，退款功能测试",
                slug: "_4-第四步-退款功能测试",
                normalizedTitle: "4. 第四步，退款功能测试",
                charIndex: 913
            }],
            headersStr: "0. 概述 1. 第一步，创建支付订单 2. 第二步，实现退款调用【重要】 3. 第三步，实现回调接口【重要】 4. 第四步，退款功能测试",
            content: "# 0. 概述\n\n在 yudao-module-pay-biz 模块的 demo 模块，我们提供了一个 退款 接入的示例，它已支持支付宝、微信的所有退款方式。\n\n下面，我们以 demo 模块为例子，讲解如何接入退款。\n\n\n# 1. 第一步，创建支付订单\n\n① 如果你是看支付宝退款接入，则需要先看完 《支付宝支付接入》 文档\n\n② 如果你是看微信退款接入，则需要先看完 《微信小程序支付接入》 或 《微信公众号支付接入》 文档\n\n③ 然后，我们在 [支付管理 -> 支付&退款案例] 菜单，可以看到一个可以“发起退款”的订单。如下图所示：\n\n\n\n\n# 2. 第二步，实现退款调用【重要】\n\n友情提示：由于 demo 模块的退款接入已经实现，这里你只要看懂什么意思即可，不用操作。\n\n① 【后端】在 demo 模块所在的 yudao-module-xx-biz 模块的 pom.xml 文件，引入 yudao-module-pay-api 依赖，这样才可以调用到 PayOrderApi 接口。代码如下：\n\n    <dependency>\n        <groupId>cn.iocoder.boot</groupId>\n        <artifactId>yudao-module-pay-api</artifactId>\n        <version>${revision}</version>\n    </dependency>\n\n\n② 【后端】在 demo 模块的下单逻辑中，需要调用 PayRefundApi 的 #createRefund(...) 方法，创建退款单。如下图所示：\n\n\n\n\n# 3. 第三步，实现回调接口【重要】\n\n友情提示：由于 demo 模块的退款接入已经实现，这里你只要看懂什么意思即可，不用操作。\n\n在 demo 模块所在的 yudao-module-xx-biz 模块，实现一个支付回调的接口，提供给支付【中心】回调。对应的代码在 PayDemoOrderController 的 #updateDemoOrderRefunded(...) 方法中，如下图所示：\n\n\n\n\n# 4. 第四步，退款功能测试\n\n至此，我们已经完成了退款接入的所有步骤，接下来，我们来测试一下退款功能。\n\n① 点击“发起退款”按钮，发起刚支付订单的退款流程。\n\n\n\n此时，在 pay_refund 表中，会新增一条退款订单记录。\n\n② 退款成功后，先是支付【中心】的回调接口被回调，然后是 demo 模块的回调接口被回调。如下图所示：\n\n\n\n注意\n\n * 支付宝发起退款时，它是直接返回退款成功，所以它没有支付【中心】 PayNotifyController 的异步回调，只有 demo 模块的回调接口被回调。\n * 微信发起退款时，它是可能返回退款成功，也可能返回退款处理中。微信退款是有支付【中心】 PayNotifyController 的异步回调，也有 demo 模块的回调接口被回调。\n\n至此，我们已经完成退款接入的测试流程，可以试着多多 debug 调试整个流程，并不复杂噢。",
            normalizedContent: "# 0. 概述\n\n在 yudao-module-pay-biz 模块的 demo 模块，我们提供了一个 退款 接入的示例，它已支持支付宝、微信的所有退款方式。\n\n下面，我们以 demo 模块为例子，讲解如何接入退款。\n\n\n# 1. 第一步，创建支付订单\n\n① 如果你是看支付宝退款接入，则需要先看完 《支付宝支付接入》 文档\n\n② 如果你是看微信退款接入，则需要先看完 《微信小程序支付接入》 或 《微信公众号支付接入》 文档\n\n③ 然后，我们在 [支付管理 -> 支付&退款案例] 菜单，可以看到一个可以“发起退款”的订单。如下图所示：\n\n\n\n\n# 2. 第二步，实现退款调用【重要】\n\n友情提示：由于 demo 模块的退款接入已经实现，这里你只要看懂什么意思即可，不用操作。\n\n① 【后端】在 demo 模块所在的 yudao-module-xx-biz 模块的 pom.xml 文件，引入 yudao-module-pay-api 依赖，这样才可以调用到 payorderapi 接口。代码如下：\n\n    <dependency>\n        <groupid>cn.iocoder.boot</groupid>\n        <artifactid>yudao-module-pay-api</artifactid>\n        <version>${revision}</version>\n    </dependency>\n\n\n② 【后端】在 demo 模块的下单逻辑中，需要调用 payrefundapi 的 #createrefund(...) 方法，创建退款单。如下图所示：\n\n\n\n\n# 3. 第三步，实现回调接口【重要】\n\n友情提示：由于 demo 模块的退款接入已经实现，这里你只要看懂什么意思即可，不用操作。\n\n在 demo 模块所在的 yudao-module-xx-biz 模块，实现一个支付回调的接口，提供给支付【中心】回调。对应的代码在 paydemoordercontroller 的 #updatedemoorderrefunded(...) 方法中，如下图所示：\n\n\n\n\n# 4. 第四步，退款功能测试\n\n至此，我们已经完成了退款接入的所有步骤，接下来，我们来测试一下退款功能。\n\n① 点击“发起退款”按钮，发起刚支付订单的退款流程。\n\n\n\n此时，在 pay_refund 表中，会新增一条退款订单记录。\n\n② 退款成功后，先是支付【中心】的回调接口被回调，然后是 demo 模块的回调接口被回调。如下图所示：\n\n\n\n注意\n\n * 支付宝发起退款时，它是直接返回退款成功，所以它没有支付【中心】 paynotifycontroller 的异步回调，只有 demo 模块的回调接口被回调。\n * 微信发起退款时，它是可能返回退款成功，也可能返回退款处理中。微信退款是有支付【中心】 paynotifycontroller 的异步回调，也有 demo 模块的回调接口被回调。\n\n至此，我们已经完成退款接入的测试流程，可以试着多多 debug 调试整个流程，并不复杂噢。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "功能开启",
            frontmatter: {
                title: "功能开启",
                date: "2023-12-24T19:22:45.000Z",
                permalink: "/member/build/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/13.%E4%BC%9A%E5%91%98%E6%89%8B%E5%86%8C/01.%E5%8A%9F%E8%83%BD%E5%BC%80%E5%90%AF.html",
            relativePath: "01.开发指南/13.会员手册/01.功能开启.md",
            key: "v-6807e4c0",
            path: "/member/build/",
            headers: [{
                level: 2,
                title: "1. 概述",
                slug: "_1-概述",
                normalizedTitle: "1. 概述",
                charIndex: 2
            }, {
                level: 2,
                title: "2. 后端启动",
                slug: "_2-后端启动",
                normalizedTitle: "2. 后端启动",
                charIndex: 163
            }, {
                level: 3,
                title: "2.1 开启模块",
                slug: "_2-1-开启模块",
                normalizedTitle: "2.1 开启模块",
                charIndex: 307
            }, {
                level: 3,
                title: "2.2 第二步，导入 SQL",
                slug: "_2-2-第二步-导入-sql",
                normalizedTitle: "2.2 第二步，导入 sql",
                charIndex: 512
            }, {
                level: 3,
                title: "2.3 第三步，重启项目",
                slug: "_2-3-第三步-重启项目",
                normalizedTitle: "2.3 第三步，重启项目",
                charIndex: 623
            }, {
                level: 2,
                title: "3. 前端（商城）启动",
                slug: "_3-前端-商城-启动",
                normalizedTitle: "3. 前端（商城）启动",
                charIndex: 701
            }],
            headersStr: "1. 概述 2. 后端启动 2.1 开启模块 2.2 第二步，导入 SQL 2.3 第三步，重启项目 3. 前端（商城）启动",
            content: "# 1. 概述\n\n会员中心，围绕“会员”建设，包括会员用户、VIP 等级、经验、积分、签到等一系列的功能。\n\n疑问：什么是会员？\n\n对于管理系统来说，管理员是它的用户，也就是项目中的 system_users 表\n\n而对于商城、论坛、博客等前台系统来说，会员是它的用户，也就是会员中心的 member_user 表。\n\n\n# 2. 后端启动\n\n考虑到编译速度，默认 yudao-module-member 模块是关闭的，需要手动开启。步骤如下：\n\n * 第一步，开启 yudao-module-member 模块\n * 第二步，导入会员的 SQL 数据库脚本\n * 第三步，重启后端项目，确认功能是否生效\n\n\n# 2.1 开启模块\n\n① 修改根目录的 pom.xml 文件，取消 yudao-module-member 模块的注释。如下图所示：\n\n\n\n② 修改 yudao-server 目录的 pom.xml 文件，引入 yudao-module-member 模块。如下图所示：\n\n\n\n③ 点击 IDEA 右上角的【Reload All Maven Projects】，刷新 Maven 依赖。如下图所示：\n\n\n\n\n# 2.2 第二步，导入 SQL\n\n点击 member-2024-01-18.sql.zip 下载附件，解压出 SQL 文件，然后导入到数据库中。\n\n友情提示：↑↑↑ member.sql 是可以点击下载的！ ↑↑↑\n\n\n# 2.3 第三步，重启项目\n\n重启后端项目，然后访问前端的会员菜单，确认功能是否生效。如下图所示：\n\n\n\n至此，我们就成功开启了会员中心的功能 🙂\n\n\n# 3. 前端（商城）启动\n\n可阅读 《商城 - 功能开启》 文档，目前商城 uni-app 接入会员中心进行购物。",
            normalizedContent: "# 1. 概述\n\n会员中心，围绕“会员”建设，包括会员用户、vip 等级、经验、积分、签到等一系列的功能。\n\n疑问：什么是会员？\n\n对于管理系统来说，管理员是它的用户，也就是项目中的 system_users 表\n\n而对于商城、论坛、博客等前台系统来说，会员是它的用户，也就是会员中心的 member_user 表。\n\n\n# 2. 后端启动\n\n考虑到编译速度，默认 yudao-module-member 模块是关闭的，需要手动开启。步骤如下：\n\n * 第一步，开启 yudao-module-member 模块\n * 第二步，导入会员的 sql 数据库脚本\n * 第三步，重启后端项目，确认功能是否生效\n\n\n# 2.1 开启模块\n\n① 修改根目录的 pom.xml 文件，取消 yudao-module-member 模块的注释。如下图所示：\n\n\n\n② 修改 yudao-server 目录的 pom.xml 文件，引入 yudao-module-member 模块。如下图所示：\n\n\n\n③ 点击 idea 右上角的【reload all maven projects】，刷新 maven 依赖。如下图所示：\n\n\n\n\n# 2.2 第二步，导入 sql\n\n点击 member-2024-01-18.sql.zip 下载附件，解压出 sql 文件，然后导入到数据库中。\n\n友情提示：↑↑↑ member.sql 是可以点击下载的！ ↑↑↑\n\n\n# 2.3 第三步，重启项目\n\n重启后端项目，然后访问前端的会员菜单，确认功能是否生效。如下图所示：\n\n\n\n至此，我们就成功开启了会员中心的功能 🙂\n\n\n# 3. 前端（商城）启动\n\n可阅读 《商城 - 功能开启》 文档，目前商城 uni-app 接入会员中心进行购物。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "微信小程序登录",
            frontmatter: {
                title: "微信小程序登录",
                date: "2023-12-24T21:29:13.000Z",
                permalink: "/member/weixin-lite-login/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/13.%E4%BC%9A%E5%91%98%E6%89%8B%E5%86%8C/03.%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%99%BB%E5%BD%95.html",
            relativePath: "01.开发指南/13.会员手册/03.微信小程序登录.md",
            key: "v-17169eb9",
            path: "/member/weixin-lite-login/",
            headers: [{
                level: 2,
                title: "1. 小程序准备",
                slug: "_1-小程序准备",
                normalizedTitle: "1. 小程序准备",
                charIndex: 93
            }, {
                level: 2,
                title: "2. 代码实现",
                slug: "_2-代码实现",
                normalizedTitle: "2. 代码实现",
                charIndex: 361
            }, {
                level: 3,
                title: "2.1 项目启动",
                slug: "_2-1-项目启动",
                normalizedTitle: "2.1 项目启动",
                charIndex: 373
            }, {
                level: 3,
                title: "2.2 登录流程",
                slug: "_2-2-登录流程",
                normalizedTitle: "2.2 登录流程",
                charIndex: 737
            }],
            headersStr: "1. 小程序准备 2. 代码实现 2.1 项目启动 2.2 登录流程",
            content: "前置阅读文章：\n\n * 《用户体系》\n * 《三方登录》\n\n本文是 《三方登录》 的延伸，讲解 yudao-mall-uniapp 商城小程序如何实现微信 小程序 登录的功能。\n\n\n# 1. 小程序准备\n\n友情提示：\n\n本文，我们以“测试小程序”举例子，方便大家操作，认证一个小程序太难了！！！\n\n① 参考 微信小程序测试号申请 链接，申请一个测试小程序。\n\n② 将 AppID 和 AppSecret 配置，设置到后端项目 application-local.yaml 的 wx.miniapp 配置项中。如下图所示：\n\n\n\n\n\n③ 使用 HBuilder 打开 yudao-mall-uniapp 项目根目录的 manifest.json 文件，将微信小程序配置的 AppID 改成你自己的。如下图所示：\n\n\n\n\n# 2. 代码实现\n\n\n# 2.1 项目启动\n\n① 下载 微信开发者工具，并进行安装。\n\n② 参考 《快速启动【前端】》 文档的「2. uni-app 商城移动端」小节，将 yudao-mall-uniapp 商城项目跑起来。\n\n不过要注意，HBuilder 运行时，选择「微信开发者工具」。如下图所示：\n\n\n\n③ 运行成功后，可以在微信开发者工具中，看到如下界面：\n\n\n\n如果请求报错，注意勾选下“不校验合法域名、web-view（业务域名）”选项。\n\n补充说明：如果你是正式的小程序，需要额外看下这部分的内容：\n\n① 在小程序的 [管理 -> 成员管理] 菜单，添加自己微信号为开发者。如下图所示：\n\n\n\n否则，使用 HBuilder 运行时，会报“[微信小程序开发者工具] [error] Error: Fail to open IDE”！\n\n\n# 2.2 登录流程\n\n① 点击「我的」菜单，再随便点个子菜单，例如说“拼团订单”，触发弹出“登录窗口”，对应前端 sheep/components/s-auth-modal/s-auth-modal.vue 组件。如下图所示：\n\n\n\n有两种登录方式：微信小程序登录、手机快速验证登录\n\n② 方式一：【微信小程序登录】点击「微信登录」图标，触发微信小程序登录。前端核心实现都在 sheep/platform/provider/wechat/miniProgram.js 的 #login(...) 方法中。\n\n此时，前端调用微信小程序获得“临时” code 授权码参数，之后调用后端的 AppAuthController 的 #socialLogin(...) 方法，进行登录逻辑。注意：\n\n * 情况一：如果该微信用户已经绑定会员用户，则直接进行登录\n * 情况二：如果该微信用户没有绑定会员用户，则会自动创建一个会员用户，并进行登录。下次重新登录时，就走【情况一】的逻辑。\n\n之后，会弹出“授权信息”窗口，对应 sheep/components/s-auth-modal/components/mp-authorization.vue 组件。如下图所示：\n\n\n\n * 注意：该弹窗仅仅用于微信小程序的昵称、头像的获取，用户实际已经登录成功了。\n\n③ 方式二：【手机快速验证登录】点击「快捷登录」按钮，触发一键登录。前端核心实现都在 sheep/platform/provider/wechat/miniProgram.js 的 #mobileLogin(...) 方法中。\n\n此时，前端调用用微信小程序获得“临时” code 授权参数 + “手机” code 授权参数，之后调用后端的 AppAuthController 的 #weixinMiniAppLogin(...) 方法，进行登录逻辑。注意：\n\n * 情况一：如果该手机已经注册用户，则直接进行登录\n * 情况二：如果该手机没有注册用户，则会自动创建一个会员用户，并进行登录。下次重新登录时，就走【情况一】的逻辑。\n\n为什么此时要获得“临时” code 授权参数呢？主要想把微信小程序的 openid 和用户绑定起来，毕竟方式二【手机快速验证登录】是需要收费的！！！",
            normalizedContent: "前置阅读文章：\n\n * 《用户体系》\n * 《三方登录》\n\n本文是 《三方登录》 的延伸，讲解 yudao-mall-uniapp 商城小程序如何实现微信 小程序 登录的功能。\n\n\n# 1. 小程序准备\n\n友情提示：\n\n本文，我们以“测试小程序”举例子，方便大家操作，认证一个小程序太难了！！！\n\n① 参考 微信小程序测试号申请 链接，申请一个测试小程序。\n\n② 将 appid 和 appsecret 配置，设置到后端项目 application-local.yaml 的 wx.miniapp 配置项中。如下图所示：\n\n\n\n\n\n③ 使用 hbuilder 打开 yudao-mall-uniapp 项目根目录的 manifest.json 文件，将微信小程序配置的 appid 改成你自己的。如下图所示：\n\n\n\n\n# 2. 代码实现\n\n\n# 2.1 项目启动\n\n① 下载 微信开发者工具，并进行安装。\n\n② 参考 《快速启动【前端】》 文档的「2. uni-app 商城移动端」小节，将 yudao-mall-uniapp 商城项目跑起来。\n\n不过要注意，hbuilder 运行时，选择「微信开发者工具」。如下图所示：\n\n\n\n③ 运行成功后，可以在微信开发者工具中，看到如下界面：\n\n\n\n如果请求报错，注意勾选下“不校验合法域名、web-view（业务域名）”选项。\n\n补充说明：如果你是正式的小程序，需要额外看下这部分的内容：\n\n① 在小程序的 [管理 -> 成员管理] 菜单，添加自己微信号为开发者。如下图所示：\n\n\n\n否则，使用 hbuilder 运行时，会报“[微信小程序开发者工具] [error] error: fail to open ide”！\n\n\n# 2.2 登录流程\n\n① 点击「我的」菜单，再随便点个子菜单，例如说“拼团订单”，触发弹出“登录窗口”，对应前端 sheep/components/s-auth-modal/s-auth-modal.vue 组件。如下图所示：\n\n\n\n有两种登录方式：微信小程序登录、手机快速验证登录\n\n② 方式一：【微信小程序登录】点击「微信登录」图标，触发微信小程序登录。前端核心实现都在 sheep/platform/provider/wechat/miniprogram.js 的 #login(...) 方法中。\n\n此时，前端调用微信小程序获得“临时” code 授权码参数，之后调用后端的 appauthcontroller 的 #sociallogin(...) 方法，进行登录逻辑。注意：\n\n * 情况一：如果该微信用户已经绑定会员用户，则直接进行登录\n * 情况二：如果该微信用户没有绑定会员用户，则会自动创建一个会员用户，并进行登录。下次重新登录时，就走【情况一】的逻辑。\n\n之后，会弹出“授权信息”窗口，对应 sheep/components/s-auth-modal/components/mp-authorization.vue 组件。如下图所示：\n\n\n\n * 注意：该弹窗仅仅用于微信小程序的昵称、头像的获取，用户实际已经登录成功了。\n\n③ 方式二：【手机快速验证登录】点击「快捷登录」按钮，触发一键登录。前端核心实现都在 sheep/platform/provider/wechat/miniprogram.js 的 #mobilelogin(...) 方法中。\n\n此时，前端调用用微信小程序获得“临时” code 授权参数 + “手机” code 授权参数，之后调用后端的 appauthcontroller 的 #weixinminiapplogin(...) 方法，进行登录逻辑。注意：\n\n * 情况一：如果该手机已经注册用户，则直接进行登录\n * 情况二：如果该手机没有注册用户，则会自动创建一个会员用户，并进行登录。下次重新登录时，就走【情况一】的逻辑。\n\n为什么此时要获得“临时” code 授权参数呢？主要想把微信小程序的 openid 和用户绑定起来，毕竟方式二【手机快速验证登录】是需要收费的！！！",
            charsets: {
                cjk: !0
            }
        }, {
            title: "模拟支付、退款",
            frontmatter: {
                title: "模拟支付、退款",
                date: "2024-09-19T09:38:48.000Z",
                permalink: "/pay/mock"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/12.%E6%94%AF%E4%BB%98%E6%89%8B%E5%86%8C/31.%E6%A8%A1%E6%8B%9F%E6%94%AF%E4%BB%98%E3%80%81%E9%80%80%E6%AC%BE.html",
            relativePath: "01.开发指南/12.支付手册/31.模拟支付、退款.md",
            key: "v-579c34cc",
            path: "/pay/mock/",
            headers: [{
                level: 2,
                title: "1. 模拟支付的开启",
                slug: "_1-模拟支付的开启",
                normalizedTitle: "1. 模拟支付的开启",
                charIndex: 287
            }, {
                level: 2,
                title: "2. 模拟支付的使用",
                slug: "_2-模拟支付的使用",
                normalizedTitle: "2. 模拟支付的使用",
                charIndex: 367
            }, {
                level: 2,
                title: "3. 模拟退款的使用",
                slug: "_3-模拟退款的使用",
                normalizedTitle: "3. 模拟退款的使用",
                charIndex: 493
            }],
            headersStr: "1. 模拟支付的开启 2. 模拟支付的使用 3. 模拟退款的使用",
            content: "前置阅读：\n\n需要先阅读如下文档，对支付、退款功能有一定了解：\n\n * 《支付功能开启》\n * 《支付宝支付接入》\n * 《支付宝、微信退款接入》\n\n考虑到支付、退款功能的接入，需要依赖支付宝、微信等支付渠道，会比较麻烦。所以，我们提供了模拟支付、退款的功能，方便开发者进行接入。\n\n具体的实现，可见 MockPayClient 客户端：\n\n * 在 #doUnifiedOrder(...) 方法中，直接返回支付【成功】\n * 在 #doUnifiedRefund(...) 方法中，直接返回退款【成功】\n\n下面，我们以“商城”为例子，讲解模拟支付的开启、使用。\n\n\n# 1. 模拟支付的开启\n\n在管理后台的 [支付管理 -> 应用信息] 菜单，将商城对应的支付应用 mall 进行开启（开启状态为打开）。如下图所示：\n\n\n\n\n# 2. 模拟支付的使用\n\n在商城 uni-app 收银台，选择“模拟支付”时，内部会调用 MockPayClient 的 #doUnifiedOrder(...) 方法，发起支付，直接成功。\n\n它的整体流程和 《支付宝支付接入》 是类似的。\n\n\n\n\n# 3. 模拟退款的使用\n\n模拟支付后，如果发起退款，内部会调用 MockPayClient 的 #doUnifiedRefund(...) 方法，发起退款，直接成功。\n\n它的整体流程和 《支付宝、微信退款接入》 是类似的。",
            normalizedContent: "前置阅读：\n\n需要先阅读如下文档，对支付、退款功能有一定了解：\n\n * 《支付功能开启》\n * 《支付宝支付接入》\n * 《支付宝、微信退款接入》\n\n考虑到支付、退款功能的接入，需要依赖支付宝、微信等支付渠道，会比较麻烦。所以，我们提供了模拟支付、退款的功能，方便开发者进行接入。\n\n具体的实现，可见 mockpayclient 客户端：\n\n * 在 #dounifiedorder(...) 方法中，直接返回支付【成功】\n * 在 #dounifiedrefund(...) 方法中，直接返回退款【成功】\n\n下面，我们以“商城”为例子，讲解模拟支付的开启、使用。\n\n\n# 1. 模拟支付的开启\n\n在管理后台的 [支付管理 -> 应用信息] 菜单，将商城对应的支付应用 mall 进行开启（开启状态为打开）。如下图所示：\n\n\n\n\n# 2. 模拟支付的使用\n\n在商城 uni-app 收银台，选择“模拟支付”时，内部会调用 mockpayclient 的 #dounifiedorder(...) 方法，发起支付，直接成功。\n\n它的整体流程和 《支付宝支付接入》 是类似的。\n\n\n\n\n# 3. 模拟退款的使用\n\n模拟支付后，如果发起退款，内部会调用 mockpayclient 的 #dounifiedrefund(...) 方法，发起退款，直接成功。\n\n它的整体流程和 《支付宝、微信退款接入》 是类似的。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "微信小程序订阅消息",
            frontmatter: {
                title: "微信小程序订阅消息",
                date: "2024-08-01T13:48:35.000Z",
                permalink: "/member/weixin-lite-subscribe-message/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/13.%E4%BC%9A%E5%91%98%E6%89%8B%E5%86%8C/04.%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%AE%A2%E9%98%85%E6%B6%88%E6%81%AF.html",
            relativePath: "01.开发指南/13.会员手册/04.微信小程序订阅消息.md",
            key: "v-4ee82b66",
            path: "/member/weixin-lite-subscribe-message/",
            headers: [{
                level: 2,
                title: "1. 小程序准备",
                slug: "_1-小程序准备",
                normalizedTitle: "1. 小程序准备",
                charIndex: 151
            }, {
                level: 3,
                title: "1.1 模版申请",
                slug: "_1-1-模版申请",
                normalizedTitle: "1.1 模版申请",
                charIndex: 164
            }, {
                level: 3,
                title: "1.2 后端配置",
                slug: "_1-2-后端配置",
                normalizedTitle: "1.2 后端配置",
                charIndex: 422
            }, {
                level: 2,
                title: "2. 功能演示 & 代码实现",
                slug: "_2-功能演示-代码实现",
                normalizedTitle: "2. 功能演示 &amp; 代码实现",
                charIndex: null
            }, {
                level: 3,
                title: "2.1 uni-app 获取订阅模版列表",
                slug: "_2-1-uni-app-获取订阅模版列表",
                normalizedTitle: "2.1 uni-app 获取订阅模版列表",
                charIndex: 898
            }, {
                level: 3,
                title: "2.2 uni-app 发起订阅消息",
                slug: "_2-2-uni-app-发起订阅消息",
                normalizedTitle: "2.2 uni-app 发起订阅消息",
                charIndex: 1202
            }, {
                level: 3,
                title: "2.3 后端发送订阅消息",
                slug: "_2-3-后端发送订阅消息",
                normalizedTitle: "2.3 后端发送订阅消息",
                charIndex: 1464
            }, {
                level: 2,
                title: "3. 其它业务如何接入？",
                slug: "_3-其它业务如何接入",
                normalizedTitle: "3. 其它业务如何接入？",
                charIndex: 1772
            }],
            headersStr: "1. 小程序准备 1.1 模版申请 1.2 后端配置 2. 功能演示 & 代码实现 2.1 uni-app 获取订阅模版列表 2.2 uni-app 发起订阅消息 2.3 后端发送订阅消息 3. 其它业务如何接入？",
            content: "前置阅读文章：\n\n * 《用户体系》\n * 《三方登录》\n\n本文是 《三方登录》 的延伸，讲解 yudao-mall-uniapp 商城小程序如何实现微信 小程序 订阅消息的功能。对应的官方文档如下：\n\n * 《【开发指南】订阅消息》\n * 《【前端】订阅消息》\n * 《【服务端】订阅消息》\n\n\n# 1. 小程序准备\n\n\n# 1.1 模版申请\n\n目前订阅消息，无法使用之前的“测试小程序”，必须进行正式小程序的申请！\n\n申请后，可以在 [微信小程序 -> 功能 -> 订阅消息] 菜单，申请对应的订阅消息模版。如下图所示：\n\n\n\n上图可以看到三个模版，是目前项目已经接入的订阅消息：\n\n * 【商城】订单发货通知：管理员在后台发货后，通知用户\n\n * 【商城】拼团结果通知：用户拼团成功后，通知用户\n\n * 【支付】充值成功通知：用户充值成功后，通知用户\n\n而这些模版，我们是无法编辑，而是在【公共模板库】选用后，进入【我的模版】。\n\n\n# 1.2 后端配置\n\n在后端 发送订阅消息 时，需要传递 miniprogram_state 参数，用于区分跳转小程序类型：\n\n * developer 为开发版\n * trial 为体验版\n * formal 为正式版\n\n因此，在 application-${profile}.yaml 配置文件中，有对应的 yudao.wxa-subscribe-message.miniprogram-state 配置项，如下图所示：\n\n\n\n一般情况下，如果是开发测试，不用修改，直接使用默认的 developer 即可。\n\n\n# 2. 功能演示 & 代码实现\n\n本小节，我们以【商城】订单发货通知为例，演示如何实现订阅消息的功能。在开始之前，你需要做如下事情：\n\n * 参考 《快速启动【前端】》 文档，把 yudao-uniapp-mall 商城项目跑起来，并使用 HBuilderX + 微信开发者工具进行调试\n * 参考 《商城功能开启》 文档，开启商城功能\n * 在 [微信小程序 -> 功能 -> 订阅消息] 菜单，配置好“订单发货通知”模版\n\n\n# 2.1 uni-app 获取订阅模版列表\n\n在 uni-app 打开时，会调用后端的 AppSocialUserController 的 #getSubscribeTemplateList() 方法，获取订阅消息模版列表。\n\n目的是，uni-app 在调用 wx.requestSubscribeMessage(Object object) 发起订阅消息时，需要传递 tmplIds 消息模版的编号。\n\n友情提示：\n\n由于暂时没做微信小程序的订阅消息的模版管理，所以暂时通过它的模版名称来匹配的。算是约定大于配置吧~\n\n不过因为小程序的订阅消息模版是只能 选用，标题是固定的，所以这个约定是可行的。\n\n\n# 2.2 uni-app 发起订阅消息\n\n第一步，在 uni-app 中，下单并完成支付，然后会进入支付成功页。如下图所示：\n\n\n\n第二步，点击【立即订阅】按钮，发起对“订单发货通知”的订阅消息。如下图所示：\n\n\n\n它的实现，通过调用项目的 sheep/platform/provider/wechat/miniProgram.js 的 #subscribeMessage(...) 方法，从而调用微信的 wx.requestSubscribeMessage(Object object) 方法，发起订阅消息的请求。\n\n\n# 2.3 后端发送订阅消息\n\n第一步，在管理后台，点击 [商城系统 -> 订单中心 -> 订单列表] 菜单，找到对应的订单，点击【发货】按钮，发起对订单的发货操作。如下图所示：\n\n\n\n它的内部，通过调用项目的 SocialClientApi 的 #sendWxaSubscribeMessage(...) 方法，从而调用微信的 发送订阅消息 接口，发送订阅消息的请求。\n\n第二步，拿出手机微信（PC 电脑上看不到），在【服务通知】中，可以看到对应的订阅消息。如下图所示：\n\n\n\n如果没有收到订阅消息，可以在 IDEA 控制台，搜 [sendSubscribeMessage] 关键字，查看是否有异常日志输出。\n\n\n# 3. 其它业务如何接入？\n\n参考上述小节的内容：\n\n * 第一步，在 uni-app 项目中，需要调用项目的 sheep/platform/provider/wechat/miniProgram.js 的 #subscribeMessage(...) 方法，发起订阅\n * 第二步，在后端项目中，需要调用 SocialClientApi 的 #sendWxaSubscribeMessage(...) 方法，发送订阅消息\n\n当然，肯定需要在微信小程序那，配置对应的订阅消息模版。",
            normalizedContent: "前置阅读文章：\n\n * 《用户体系》\n * 《三方登录》\n\n本文是 《三方登录》 的延伸，讲解 yudao-mall-uniapp 商城小程序如何实现微信 小程序 订阅消息的功能。对应的官方文档如下：\n\n * 《【开发指南】订阅消息》\n * 《【前端】订阅消息》\n * 《【服务端】订阅消息》\n\n\n# 1. 小程序准备\n\n\n# 1.1 模版申请\n\n目前订阅消息，无法使用之前的“测试小程序”，必须进行正式小程序的申请！\n\n申请后，可以在 [微信小程序 -> 功能 -> 订阅消息] 菜单，申请对应的订阅消息模版。如下图所示：\n\n\n\n上图可以看到三个模版，是目前项目已经接入的订阅消息：\n\n * 【商城】订单发货通知：管理员在后台发货后，通知用户\n\n * 【商城】拼团结果通知：用户拼团成功后，通知用户\n\n * 【支付】充值成功通知：用户充值成功后，通知用户\n\n而这些模版，我们是无法编辑，而是在【公共模板库】选用后，进入【我的模版】。\n\n\n# 1.2 后端配置\n\n在后端 发送订阅消息 时，需要传递 miniprogram_state 参数，用于区分跳转小程序类型：\n\n * developer 为开发版\n * trial 为体验版\n * formal 为正式版\n\n因此，在 application-${profile}.yaml 配置文件中，有对应的 yudao.wxa-subscribe-message.miniprogram-state 配置项，如下图所示：\n\n\n\n一般情况下，如果是开发测试，不用修改，直接使用默认的 developer 即可。\n\n\n# 2. 功能演示 & 代码实现\n\n本小节，我们以【商城】订单发货通知为例，演示如何实现订阅消息的功能。在开始之前，你需要做如下事情：\n\n * 参考 《快速启动【前端】》 文档，把 yudao-uniapp-mall 商城项目跑起来，并使用 hbuilderx + 微信开发者工具进行调试\n * 参考 《商城功能开启》 文档，开启商城功能\n * 在 [微信小程序 -> 功能 -> 订阅消息] 菜单，配置好“订单发货通知”模版\n\n\n# 2.1 uni-app 获取订阅模版列表\n\n在 uni-app 打开时，会调用后端的 appsocialusercontroller 的 #getsubscribetemplatelist() 方法，获取订阅消息模版列表。\n\n目的是，uni-app 在调用 wx.requestsubscribemessage(object object) 发起订阅消息时，需要传递 tmplids 消息模版的编号。\n\n友情提示：\n\n由于暂时没做微信小程序的订阅消息的模版管理，所以暂时通过它的模版名称来匹配的。算是约定大于配置吧~\n\n不过因为小程序的订阅消息模版是只能 选用，标题是固定的，所以这个约定是可行的。\n\n\n# 2.2 uni-app 发起订阅消息\n\n第一步，在 uni-app 中，下单并完成支付，然后会进入支付成功页。如下图所示：\n\n\n\n第二步，点击【立即订阅】按钮，发起对“订单发货通知”的订阅消息。如下图所示：\n\n\n\n它的实现，通过调用项目的 sheep/platform/provider/wechat/miniprogram.js 的 #subscribemessage(...) 方法，从而调用微信的 wx.requestsubscribemessage(object object) 方法，发起订阅消息的请求。\n\n\n# 2.3 后端发送订阅消息\n\n第一步，在管理后台，点击 [商城系统 -> 订单中心 -> 订单列表] 菜单，找到对应的订单，点击【发货】按钮，发起对订单的发货操作。如下图所示：\n\n\n\n它的内部，通过调用项目的 socialclientapi 的 #sendwxasubscribemessage(...) 方法，从而调用微信的 发送订阅消息 接口，发送订阅消息的请求。\n\n第二步，拿出手机微信（pc 电脑上看不到），在【服务通知】中，可以看到对应的订阅消息。如下图所示：\n\n\n\n如果没有收到订阅消息，可以在 idea 控制台，搜 [sendsubscribemessage] 关键字，查看是否有异常日志输出。\n\n\n# 3. 其它业务如何接入？\n\n参考上述小节的内容：\n\n * 第一步，在 uni-app 项目中，需要调用项目的 sheep/platform/provider/wechat/miniprogram.js 的 #subscribemessage(...) 方法，发起订阅\n * 第二步，在后端项目中，需要调用 socialclientapi 的 #sendwxasubscribemessage(...) 方法，发送订阅消息\n\n当然，肯定需要在微信小程序那，配置对应的订阅消息模版。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "微信公众号登录",
            frontmatter: {
                title: "微信公众号登录",
                date: "2023-12-24T17:26:46.000Z",
                permalink: "/member/weixin-mp-login/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/13.%E4%BC%9A%E5%91%98%E6%89%8B%E5%86%8C/02.%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E7%99%BB%E5%BD%95.html",
            relativePath: "01.开发指南/13.会员手册/02.微信公众号登录.md",
            key: "v-6462c10c",
            path: "/member/weixin-mp-login/",
            headers: [{
                level: 2,
                title: "1. 公众号准备",
                slug: "_1-公众号准备",
                normalizedTitle: "1. 公众号准备",
                charIndex: 93
            }, {
                level: 2,
                title: "2. 代码实现",
                slug: "_2-代码实现",
                normalizedTitle: "2. 代码实现",
                charIndex: 690
            }, {
                level: 3,
                title: "2.1 项目启动",
                slug: "_2-1-项目启动",
                normalizedTitle: "2.1 项目启动",
                charIndex: 702
            }, {
                level: 3,
                title: "2.2 微信 JSSDK",
                slug: "_2-2-微信-jssdk",
                normalizedTitle: "2.2 微信 jssdk",
                charIndex: 830
            }, {
                level: 3,
                title: "2.3 登录流程",
                slug: "_2-3-登录流程",
                normalizedTitle: "2.3 登录流程",
                charIndex: 1044
            }],
            headersStr: "1. 公众号准备 2. 代码实现 2.1 项目启动 2.2 微信 JSSDK 2.3 登录流程",
            content: "前置阅读文章：\n\n * 《用户体系》\n * 《三方登录》\n\n本文是 《三方登录》 的延伸，讲解 yudao-mall-uniapp 商城小程序如何实现微信 公众号 登录的功能。\n\n\n# 1. 公众号准备\n\n友情提示：\n\n本文，我们以“测试公众号”举例子，方便大家操作，认证一个公众号太难了！！！\n\n① 参考 微信公众平台接口测试帐号申请 链接，申请一个测试公众号。\n\n② 将 appID 和 appSecret 配置，设置到后端项目 application-local.yaml 的 wx.mp 配置项中。如下图所示：\n\n\n\n\n\n③ 修改“JS接口安全域名”，设置为前端的访问地址。例如说，现在本地是 http://127.0.0.1:3000。如下图所示：\n\n\n\n注意：自己需要关注下自己的测试公众号！！！\n\n④ 修改“网页授权获取用户基本信息”，设置为前端的访问地址。例如说，现在本地是 http://127.0.0.1:3000。如下图所示：\n\n\n\n补充说明：如果你是正式的公众号，需要额外看下这部分的内容：\n\n① 设置“IP白名单”，在公众号的 [设置与开发 - 安全中心] 菜单，如下图所示：\n\n\n\n② 在公众号的 [设置与开发 - 公众号设置] 菜单，设置“JS接口安全域名”、“JS接口安全域名”、“网页授权域名”，如下图所示：\n\n\n\n * 设置时，需要外网可访问，可以需要使用 natapp 进行内网穿透\n * 上图的 MP_verify_XXXXXXXXXXXXXXXX.txt 文件，可以直接放在 yudao-mall-uniapp 商城项目的根目录\n\n\n# 2. 代码实现\n\n\n# 2.1 项目启动\n\n① 参考 《快速启动【前端】》 文档的「2. uni-app 商城移动端」小节，将 yudao-mall-uniapp 商城项目跑起来。\n\n② 下载 微信开发者工具，并进行安装。安装后，选择「公众号网页项目」。如下图所示：\n\n\n\n\n# 2.2 微信 JSSDK\n\n访问 http://127.0.0.1:3000/ 地址（其它地址也可以），它会触发 微信 JSSDK 初始化的逻辑，对应前端 sheep/libs/sdk-h5-weixin.js 文件的 #init(...) 方法中。\n\n微信 JSSDK 所需要的签名，由后端的 AppAuthController 的 #createWeixinMpJsapiSignature(...) 方法所提供。\n\n\n# 2.3 登录流程\n\n友情提示：\n\n可以简单阅读下 《微信官方文档 —— 网页授权》 文章。\n\n① 访问 http://127.0.0.1:3000/#/pages/user/info 地址，触发弹出“登录窗口”，对应前端 sheep/components/s-auth-modal/s-auth-modal.vue 组件。如下图所示：\n\n\n\n② 点击「微信登录」图标，触发微信公众号登录。前端核心实现都在 sheep/platform/provider/wechat/officialAccount.js 的 #login(...) 方法中。它一共包含 2 个步骤。\n\n③ 【第一步】前端调用后端的 AppAuthController 的 #socialAuthRedirect(...) 方法，获得微信公众号的登录地址，并进行跳转。效果如下图：\n\n\n\nps：为了在微信登录成功后，可以回到登陆前的 URL 地址，会将该 URL 存储到 uni.setStorageSync('returnUrl', location.href) 中。\n\n④ 【第二步】点击「同意」按钮，跳转回前端的 pages/index/login.vue 页面，进行 真正的 微信登录逻辑。\n\n此时，前端从 URL 中解析到微信回调提供的 code 授权码参数，调用后端的 AppAuthController 的 #socialLogin(...) 方法，进行登录逻辑。注意：\n\n * 情况一：如果该微信用户已经绑定会员用户，则直接进行登录\n * 情况二：如果该微信用户没有绑定会员用户，则会自动创建一个会员用户，并进行登录。下次重新登录时，就走【情况一】的逻辑。\n\nps：登录成功后，通过 uni.getStorageSync('returnUrl') 获得登录前的 URL 地址，进行跳转。",
            normalizedContent: "前置阅读文章：\n\n * 《用户体系》\n * 《三方登录》\n\n本文是 《三方登录》 的延伸，讲解 yudao-mall-uniapp 商城小程序如何实现微信 公众号 登录的功能。\n\n\n# 1. 公众号准备\n\n友情提示：\n\n本文，我们以“测试公众号”举例子，方便大家操作，认证一个公众号太难了！！！\n\n① 参考 微信公众平台接口测试帐号申请 链接，申请一个测试公众号。\n\n② 将 appid 和 appsecret 配置，设置到后端项目 application-local.yaml 的 wx.mp 配置项中。如下图所示：\n\n\n\n\n\n③ 修改“js接口安全域名”，设置为前端的访问地址。例如说，现在本地是 http://127.0.0.1:3000。如下图所示：\n\n\n\n注意：自己需要关注下自己的测试公众号！！！\n\n④ 修改“网页授权获取用户基本信息”，设置为前端的访问地址。例如说，现在本地是 http://127.0.0.1:3000。如下图所示：\n\n\n\n补充说明：如果你是正式的公众号，需要额外看下这部分的内容：\n\n① 设置“ip白名单”，在公众号的 [设置与开发 - 安全中心] 菜单，如下图所示：\n\n\n\n② 在公众号的 [设置与开发 - 公众号设置] 菜单，设置“js接口安全域名”、“js接口安全域名”、“网页授权域名”，如下图所示：\n\n\n\n * 设置时，需要外网可访问，可以需要使用 natapp 进行内网穿透\n * 上图的 mp_verify_xxxxxxxxxxxxxxxx.txt 文件，可以直接放在 yudao-mall-uniapp 商城项目的根目录\n\n\n# 2. 代码实现\n\n\n# 2.1 项目启动\n\n① 参考 《快速启动【前端】》 文档的「2. uni-app 商城移动端」小节，将 yudao-mall-uniapp 商城项目跑起来。\n\n② 下载 微信开发者工具，并进行安装。安装后，选择「公众号网页项目」。如下图所示：\n\n\n\n\n# 2.2 微信 jssdk\n\n访问 http://127.0.0.1:3000/ 地址（其它地址也可以），它会触发 微信 jssdk 初始化的逻辑，对应前端 sheep/libs/sdk-h5-weixin.js 文件的 #init(...) 方法中。\n\n微信 jssdk 所需要的签名，由后端的 appauthcontroller 的 #createweixinmpjsapisignature(...) 方法所提供。\n\n\n# 2.3 登录流程\n\n友情提示：\n\n可以简单阅读下 《微信官方文档 —— 网页授权》 文章。\n\n① 访问 http://127.0.0.1:3000/#/pages/user/info 地址，触发弹出“登录窗口”，对应前端 sheep/components/s-auth-modal/s-auth-modal.vue 组件。如下图所示：\n\n\n\n② 点击「微信登录」图标，触发微信公众号登录。前端核心实现都在 sheep/platform/provider/wechat/officialaccount.js 的 #login(...) 方法中。它一共包含 2 个步骤。\n\n③ 【第一步】前端调用后端的 appauthcontroller 的 #socialauthredirect(...) 方法，获得微信公众号的登录地址，并进行跳转。效果如下图：\n\n\n\nps：为了在微信登录成功后，可以回到登陆前的 url 地址，会将该 url 存储到 uni.setstoragesync('returnurl', location.href) 中。\n\n④ 【第二步】点击「同意」按钮，跳转回前端的 pages/index/login.vue 页面，进行 真正的 微信登录逻辑。\n\n此时，前端从 url 中解析到微信回调提供的 code 授权码参数，调用后端的 appauthcontroller 的 #sociallogin(...) 方法，进行登录逻辑。注意：\n\n * 情况一：如果该微信用户已经绑定会员用户，则直接进行登录\n * 情况二：如果该微信用户没有绑定会员用户，则会自动创建一个会员用户，并进行登录。下次重新登录时，就走【情况一】的逻辑。\n\nps：登录成功后，通过 uni.getstoragesync('returnurl') 获得登录前的 url 地址，进行跳转。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "功能开启",
            frontmatter: {
                title: "功能开启",
                permalink: "/mall/build",
                date: "2023-02-04T13:38:26.000Z"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/14.%E5%95%86%E5%9F%8E%E6%89%8B%E5%86%8C/02.%E5%8A%9F%E8%83%BD%E5%BC%80%E5%90%AF.html",
            relativePath: "01.开发指南/14.商城手册/02.功能开启.md",
            key: "v-1561b62d",
            path: "/mall/build/",
            headers: [{
                level: 2,
                title: "1. 功能介绍",
                slug: "_1-功能介绍",
                normalizedTitle: "1. 功能介绍",
                charIndex: 422
            }, {
                level: 2,
                title: "2. 后端开启",
                slug: "_2-后端开启",
                normalizedTitle: "2. 后端开启",
                charIndex: 473
            }, {
                level: 3,
                title: "2.1 开启模块",
                slug: "_2-1-开启模块",
                normalizedTitle: "2.1 开启模块",
                charIndex: 694
            }, {
                level: 3,
                title: "2.2 第二步，导入 SQL",
                slug: "_2-2-第二步-导入-sql",
                normalizedTitle: "2.2 第二步，导入 sql",
                charIndex: 895
            }, {
                level: 3,
                title: "2.3 第三步，重启项目",
                slug: "_2-3-第三步-重启项目",
                normalizedTitle: "2.3 第三步，重启项目",
                charIndex: 1002
            }, {
                level: 2,
                title: "3. 前端开启",
                slug: "_3-前端开启",
                normalizedTitle: "3. 前端开启",
                charIndex: 1206
            }, {
                level: 2,
                title: "4. 推荐阅读",
                slug: "_4-推荐阅读",
                normalizedTitle: "4. 推荐阅读",
                charIndex: 1260
            }, {
                level: 2,
                title: "5. 部署说明",
                slug: "_5-部署说明",
                normalizedTitle: "5. 部署说明",
                charIndex: 1350
            }, {
                level: 3,
                title: "5.1 静态资源",
                slug: "_5-1-静态资源",
                normalizedTitle: "5.1 静态资源",
                charIndex: 1362
            }],
            headersStr: "1. 功能介绍 2. 后端开启 2.1 开启模块 2.2 第二步，导入 SQL 2.3 第三步，重启项目 3. 前端开启 4. 推荐阅读 5. 部署说明 5.1 静态资源",
            content: "项目地址：\n\n * uni-app 商城前端，已经基于 Vue3 重构，对应 https://gitee.com/yudaocode/yudao-mall-uniapp 仓库的 master 分支\n * 管理后台，请使用 https://gitee.com/yudaocode/yudao-ui-admin-vue3 仓库的 master 分支\n * 后端项目，请使用 https://gitee.com/zhijiantianya/ruoyi-vue-pro 仓库的 master（JDK8） 或 master-jdk17（JDK17/21） 分支\n\n商城的功能，由三部分代码组成：\n\n\n\n * 后端实现，对应 yudao-module-mall 模块\n * 管理后台，对应 @/views/mall 目录\n * 用户前台，对应 https://github.com/yudaocode/yudao-mall-uniapp 项目\n\n\n\n\n# 1. 功能介绍\n\n主要拆分四大模块：商品中心、交易中心、营销中心、会员中心。如下图所示：\n\n\n\n\n# 2. 后端开启\n\n友情提示：\n\n① 商城使用到支付，所以需要参考 《支付手册》 文档，将支付功能开启。\n\n② 商城使用到会员，所以需要参考 《会员手册》 文档，将会员功能开启。\n\n考虑到编译速度，默认 yudao-module-mall 模块是关闭的，需要手动开启。步骤如下：\n\n * 第一步，开启 yudao-module-mall 模块\n * 第二步，导入商城的 SQL 数据库脚本\n * 第三步，重启后端项目，确认功能是否生效\n\n\n# 2.1 开启模块\n\n① 修改根目录的 pom.xml 文件，取消 yudao-module-mall 模块的注释。如下图所示：\n\n\n\n② 修改 yudao-server 目录的 pom.xml 文件，引入 yudao-module-mall 模块。如下图所示：\n\n\n\n③ 点击 IDEA 右上角的【Reload All Maven Projects】，刷新 Maven 依赖。如下图所示：\n\n\n\n\n# 2.2 第二步，导入 SQL\n\n点击 mall-2024-01-17.sql.zip 下载附件，解压出 SQL 文件，然后导入到数据库中。\n\n友情提示：↑↑↑ mall.sql 是可以点击下载的！ ↑↑↑\n\n\n# 2.3 第三步，重启项目\n\n重启后端项目，然后访问前端的商城菜单，确认功能是否生效。如下图所示：\n\n\n\n至此，我们就成功开启了商城的功能 🙂\n\n常见问题：\n\n① 为什么会报 Cannot resolve cn.iocoder.boot:yudao-module-member-api:2.2.0-jdk8-snapshot 错误？\n\n参见 https://t.zsxq.com/QvNHv 解决。\n\n\n# 3. 前端开启\n\n参考 《快速启动（前端项目）》 文档的「2. uni-app 商城移动端」小节。\n\n\n# 4. 推荐阅读\n\n微信公众号相关：\n\n * 《微信公众号登录》\n * 《微信公众号支付接入》\n\n微信小程序相关：\n\n * 《微信小程序登录》\n * 《微信小程序支付接入》\n\n\n# 5. 部署说明\n\n\n# 5.1 静态资源\n\n在 .env 配置文件中，有 SHOPRO_STATIC_URL 配置项，用于配置商城的静态资源地址，默认是 http://test.yudao.iocoder.cn。\n\n部署时，你必须改成你自己的静态资源地址，不然会导致商城的静态资源无法加载。\n\n① 将 https://gitee.com/yudaocode/yudao-demo/tree/2d0024ad71489e5b263ca1cec07e82abdc61d45f/yudao-static/mall 的 static 目录下的图片，上传到你的静态资源服务器的 static 目录上。\n\n如果你使用七牛 CDN，可以使用 Kodo Browser 批量上传。\n\n② 将 SHOPRO_STATIC_URL 配置项，改成你的静态资源地址。\n\n③ 重启前端项目，并通过 Chrome 开发者工具的【Network】标签页，查看是不是你的静态资源地址。",
            normalizedContent: "项目地址：\n\n * uni-app 商城前端，已经基于 vue3 重构，对应 https://gitee.com/yudaocode/yudao-mall-uniapp 仓库的 master 分支\n * 管理后台，请使用 https://gitee.com/yudaocode/yudao-ui-admin-vue3 仓库的 master 分支\n * 后端项目，请使用 https://gitee.com/zhijiantianya/ruoyi-vue-pro 仓库的 master（jdk8） 或 master-jdk17（jdk17/21） 分支\n\n商城的功能，由三部分代码组成：\n\n\n\n * 后端实现，对应 yudao-module-mall 模块\n * 管理后台，对应 @/views/mall 目录\n * 用户前台，对应 https://github.com/yudaocode/yudao-mall-uniapp 项目\n\n\n\n\n# 1. 功能介绍\n\n主要拆分四大模块：商品中心、交易中心、营销中心、会员中心。如下图所示：\n\n\n\n\n# 2. 后端开启\n\n友情提示：\n\n① 商城使用到支付，所以需要参考 《支付手册》 文档，将支付功能开启。\n\n② 商城使用到会员，所以需要参考 《会员手册》 文档，将会员功能开启。\n\n考虑到编译速度，默认 yudao-module-mall 模块是关闭的，需要手动开启。步骤如下：\n\n * 第一步，开启 yudao-module-mall 模块\n * 第二步，导入商城的 sql 数据库脚本\n * 第三步，重启后端项目，确认功能是否生效\n\n\n# 2.1 开启模块\n\n① 修改根目录的 pom.xml 文件，取消 yudao-module-mall 模块的注释。如下图所示：\n\n\n\n② 修改 yudao-server 目录的 pom.xml 文件，引入 yudao-module-mall 模块。如下图所示：\n\n\n\n③ 点击 idea 右上角的【reload all maven projects】，刷新 maven 依赖。如下图所示：\n\n\n\n\n# 2.2 第二步，导入 sql\n\n点击 mall-2024-01-17.sql.zip 下载附件，解压出 sql 文件，然后导入到数据库中。\n\n友情提示：↑↑↑ mall.sql 是可以点击下载的！ ↑↑↑\n\n\n# 2.3 第三步，重启项目\n\n重启后端项目，然后访问前端的商城菜单，确认功能是否生效。如下图所示：\n\n\n\n至此，我们就成功开启了商城的功能 🙂\n\n常见问题：\n\n① 为什么会报 cannot resolve cn.iocoder.boot:yudao-module-member-api:2.2.0-jdk8-snapshot 错误？\n\n参见 https://t.zsxq.com/qvnhv 解决。\n\n\n# 3. 前端开启\n\n参考 《快速启动（前端项目）》 文档的「2. uni-app 商城移动端」小节。\n\n\n# 4. 推荐阅读\n\n微信公众号相关：\n\n * 《微信公众号登录》\n * 《微信公众号支付接入》\n\n微信小程序相关：\n\n * 《微信小程序登录》\n * 《微信小程序支付接入》\n\n\n# 5. 部署说明\n\n\n# 5.1 静态资源\n\n在 .env 配置文件中，有 shopro_static_url 配置项，用于配置商城的静态资源地址，默认是 http://test.yudao.iocoder.cn。\n\n部署时，你必须改成你自己的静态资源地址，不然会导致商城的静态资源无法加载。\n\n① 将 https://gitee.com/yudaocode/yudao-demo/tree/2d0024ad71489e5b263ca1cec07e82abdc61d45f/yudao-static/mall 的 static 目录下的图片，上传到你的静态资源服务器的 static 目录上。\n\n如果你使用七牛 cdn，可以使用 kodo browser 批量上传。\n\n② 将 shopro_static_url 配置项，改成你的静态资源地址。\n\n③ 重启前端项目，并通过 chrome 开发者工具的【network】标签页，查看是不是你的静态资源地址。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "微信小程序码",
            frontmatter: {
                title: "微信小程序码",
                date: "2024-08-01T23:24:13.000Z",
                permalink: "/member/weixin-lite-qrcode/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/13.%E4%BC%9A%E5%91%98%E6%89%8B%E5%86%8C/05.%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%A0%81.html",
            relativePath: "01.开发指南/13.会员手册/05.微信小程序码.md",
            key: "v-667d3c15",
            path: "/member/weixin-lite-qrcode/",
            headers: [{
                level: 2,
                title: "1. 小程序准备",
                slug: "_1-小程序准备",
                normalizedTitle: "1. 小程序准备",
                charIndex: 118
            }, {
                level: 2,
                title: "2. 功能演示 & 代码实现",
                slug: "_2-功能演示-代码实现",
                normalizedTitle: "2. 功能演示 &amp; 代码实现",
                charIndex: null
            }],
            headersStr: "1. 小程序准备 2. 功能演示 & 代码实现",
            content: "前置阅读文章：\n\n * 《用户体系》\n * 《三方登录》\n\n本文是 《三方登录》 的延伸，讲解 yudao-mall-uniapp 商城小程序如何实现微信 小程序 码的功能。对应的官方文档如下：\n\n * 《【服务端】小程序码》\n\n\n# 1. 小程序准备\n\n在后端 生成小程序码 时，需要传递 env_version 参数，要打开的小程序版本：\n\n * release 为正式版为\n * trial 为体验版\n * develop 为开发版\n\n因此，在 application-${profile}.yaml 配置文件中，有对应的 yudao.wxa-code.env-version 配置项，如下图所示：\n\n\n\n一般情况下，如果是开发测试，不用修改，直接使用默认的 develop 即可。\n\n\n# 2. 功能演示 & 代码实现\n\n本小节，我们以【商城】分销的分享二维码为例，演示如何实现小程序码的功能。在开始之前，你需要做如下事情：\n\n * 参考 《快速启动【前端】》 文档，把 yudao-uniapp-mall 商城项目跑起来，并使用 HBuilderX + 微信开发者工具进行调试\n * 参考 《商城功能开启》 文档，开启商城功能\n\n点击 uni-app 的【分销中心】，然后点击【邀请海报】按钮，之后点击【生成海报】按钮，即可生成小程序码。如下图所示：\n\n\n\n这里，它调用的是 AppSocialUserController 的 #getWxaQrcode(...) 方法，提供的 HTTP 接口。它的内部，调用 SocialClientApi 的 #getWxaQrcode(...) 方法，从而调用微信的 生成小程序码 接口，生成小程序码。",
            normalizedContent: "前置阅读文章：\n\n * 《用户体系》\n * 《三方登录》\n\n本文是 《三方登录》 的延伸，讲解 yudao-mall-uniapp 商城小程序如何实现微信 小程序 码的功能。对应的官方文档如下：\n\n * 《【服务端】小程序码》\n\n\n# 1. 小程序准备\n\n在后端 生成小程序码 时，需要传递 env_version 参数，要打开的小程序版本：\n\n * release 为正式版为\n * trial 为体验版\n * develop 为开发版\n\n因此，在 application-${profile}.yaml 配置文件中，有对应的 yudao.wxa-code.env-version 配置项，如下图所示：\n\n\n\n一般情况下，如果是开发测试，不用修改，直接使用默认的 develop 即可。\n\n\n# 2. 功能演示 & 代码实现\n\n本小节，我们以【商城】分销的分享二维码为例，演示如何实现小程序码的功能。在开始之前，你需要做如下事情：\n\n * 参考 《快速启动【前端】》 文档，把 yudao-uniapp-mall 商城项目跑起来，并使用 hbuilderx + 微信开发者工具进行调试\n * 参考 《商城功能开启》 文档，开启商城功能\n\n点击 uni-app 的【分销中心】，然后点击【邀请海报】按钮，之后点击【生成海报】按钮，即可生成小程序码。如下图所示：\n\n\n\n这里，它调用的是 appsocialusercontroller 的 #getwxaqrcode(...) 方法，提供的 http 接口。它的内部，调用 socialclientapi 的 #getwxaqrcode(...) 方法，从而调用微信的 生成小程序码 接口，生成小程序码。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "会员用户、标签、分组",
            frontmatter: {
                title: "会员用户、标签、分组",
                date: "2024-01-18T20:02:56.000Z",
                permalink: "/member/user"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/13.%E4%BC%9A%E5%91%98%E6%89%8B%E5%86%8C/11.%E4%BC%9A%E5%91%98%E7%94%A8%E6%88%B7%E3%80%81%E6%A0%87%E7%AD%BE%E3%80%81%E5%88%86%E7%BB%84.html",
            relativePath: "01.开发指南/13.会员手册/11.会员用户、标签、分组.md",
            key: "v-21105448",
            path: "/member/user/",
            headers: [{
                level: 2,
                title: "1. 会员用户",
                slug: "_1-会员用户",
                normalizedTitle: "1. 会员用户",
                charIndex: 38
            }, {
                level: 3,
                title: "1.1 表结构",
                slug: "_1-1-表结构",
                normalizedTitle: "1.1 表结构",
                charIndex: 80
            }, {
                level: 3,
                title: "1.2 管理后台",
                slug: "_1-2-管理后台",
                normalizedTitle: "1.2 管理后台",
                charIndex: 2087
            }, {
                level: 3,
                title: "1.3 移动端",
                slug: "_1-3-移动端",
                normalizedTitle: "1.3 移动端",
                charIndex: 2279
            }, {
                level: 2,
                title: "2. 会员标签",
                slug: "_2-会员标签",
                normalizedTitle: "2. 会员标签",
                charIndex: 2425
            }, {
                level: 3,
                title: "2.1 表结构",
                slug: "_2-1-表结构",
                normalizedTitle: "2.1 表结构",
                charIndex: 2466
            }, {
                level: 3,
                title: "2.2 管理后台",
                slug: "_2-2-管理后台",
                normalizedTitle: "2.2 管理后台",
                charIndex: 2869
            }, {
                level: 3,
                title: "2.3 移动端",
                slug: "_2-3-移动端",
                normalizedTitle: "2.3 移动端",
                charIndex: 2978
            }, {
                level: 2,
                title: "3. 会员分组",
                slug: "_3-会员分组",
                normalizedTitle: "3. 会员分组",
                charIndex: 3005
            }, {
                level: 3,
                title: "3.1 表结构",
                slug: "_3-1-表结构",
                normalizedTitle: "3.1 表结构",
                charIndex: 3048
            }, {
                level: 3,
                title: "3.2 管理后台",
                slug: "_3-2-管理后台",
                normalizedTitle: "3.2 管理后台",
                charIndex: 3612
            }, {
                level: 3,
                title: "3.3 移动端",
                slug: "_3-3-移动端",
                normalizedTitle: "3.3 移动端",
                charIndex: 3723
            }],
            headersStr: "1. 会员用户 1.1 表结构 1.2 管理后台 1.3 移动端 2. 会员标签 2.1 表结构 2.2 管理后台 2.3 移动端 3. 会员分组 3.1 表结构 3.2 管理后台 3.3 移动端",
            content: "本小节，我们主要看看会员用户、标签、分组相关的表。如下图所示：\n\n\n\n\n# 1. 会员用户\n\n会员用户，由 MemberUserService 实现。\n\n\n# 1.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `member_user` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  `mobile` varchar(11) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '手机号',\n  `password` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '密码',\n  `status` tinyint NOT NULL COMMENT '状态',\n  `register_ip` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '注册 IP',\n  `register_terminal` tinyint DEFAULT NULL COMMENT '注册终端',\n  `login_ip` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT '' COMMENT '最后登录IP',\n  `login_date` datetime DEFAULT NULL COMMENT '最后登录时间',\n  `nickname` varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '用户昵称',\n  `avatar` varchar(512) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '头像',\n  `name` varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT '' COMMENT '真实名字',\n  `sex` tinyint DEFAULT '0' COMMENT '用户性别',\n  `area_id` bigint DEFAULT NULL COMMENT '所在地',\n  `birthday` datetime DEFAULT NULL COMMENT '出生日期',\n  `mark` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '会员备注',\n  \n  `tag_ids` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '用户标签编号列表，以逗号分隔',\n  `group_id` bigint DEFAULT NULL COMMENT '用户分组编号',\n  \n  `level_id` bigint DEFAULT NULL COMMENT '等级编号',\n  `experience` int NOT NULL DEFAULT '0' COMMENT '经验',\n  \n  `point` int NOT NULL DEFAULT '0' COMMENT '积分',\n\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=286 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT='会员用户';\n\n\n① id 到 mark 字段，是用户的基本信息。\n\n② tag_ids 字段，是用户的标签编号列表，以逗号分隔。由于会员标签暂时没有大的业务需求，所以暂时没有独立关联表。\n\ngroup_id 字段，是用户的分组编号。目前也没有大的用途。\n\n③ 【会员等级】level_id 字段，是用户的 VIP 等级编号。experience 字段，是用户的经验值。相关的内容，可见 《会员等级、积分、签到》 文档。\n\n④ 【会员积分】point 字段，是用户的积分。相关的内容，可见 《会员等级、积分、签到》 文档。\n\n\n# 1.2 管理后台\n\n① 对应 [会员系统 -> 会员中心 -> 会员列表] 菜单，对应 yudao-ui-admin-vue3 项目的 views/member/user/index.vue 目录。如下图所示：\n\n\n\n可以给用户「编辑」「发优惠劵」「修改等级」「修改余额」等操作。\n\n② 点击「详情」按钮，可以查看该会员用户的基本信息、账户信息、相关明细等。如下图所示：\n\n\n\n\n# 1.3 移动端\n\n① 会员登录，可见 《微信公众号登录》、《微信小程序登录》 文档。\n\n② 点击 uni-app 底部的 [我的] 导航，点击顶部头像，进入会员信息界面，对应 yudao-mall-uniapp 项目的 pages/user/info.vue 页面。如下图所示：\n\n\n\n\n# 2. 会员标签\n\n会员标签，由 MemberTagService 实现。\n\n\n# 2.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `member_tag` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  `name` varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '标签名称',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='会员标签';\n\n\n\n# 2.2 管理后台\n\n对应 [会员系统 -> 会员中心 -> 会员标签] 菜单，对应 yudao-ui-admin-vue3 项目的 views/member/tag/index.vue 目录。如下图所示：\n\n\n\n\n# 2.3 移动端\n\n暂时没有移动端的相关操作。\n\n\n# 3. 会员分组\n\n会员分组，由 MemberGroupService 实现。\n\n\n# 3.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `member_group` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  `name` varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '名称',\n  `status` tinyint NOT NULL DEFAULT '0' COMMENT '状态',\n  `remark` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '备注',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='用户分组';\n\n\n\n# 3.2 管理后台\n\n对应 [会员系统 -> 会员中心 -> 会员分组] 菜单，对应 yudao-ui-admin-vue3 项目的 views/member/group/index.vue 目录。如下图所示：\n\n\n\n\n# 3.3 移动端\n\n暂时没有移动端的相关操作。",
            normalizedContent: "本小节，我们主要看看会员用户、标签、分组相关的表。如下图所示：\n\n\n\n\n# 1. 会员用户\n\n会员用户，由 memberuserservice 实现。\n\n\n# 1.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `member_user` (\n  `id` bigint not null auto_increment comment '编号',\n  `mobile` varchar(11) character set utf8mb4 collate utf8mb4_general_ci default null comment '手机号',\n  `password` varchar(100) character set utf8mb4 collate utf8mb4_general_ci not null default '' comment '密码',\n  `status` tinyint not null comment '状态',\n  `register_ip` varchar(32) character set utf8mb4 collate utf8mb4_general_ci not null comment '注册 ip',\n  `register_terminal` tinyint default null comment '注册终端',\n  `login_ip` varchar(50) character set utf8mb4 collate utf8mb4_unicode_ci default '' comment '最后登录ip',\n  `login_date` datetime default null comment '最后登录时间',\n  `nickname` varchar(30) character set utf8mb4 collate utf8mb4_general_ci not null default '' comment '用户昵称',\n  `avatar` varchar(512) character set utf8mb4 collate utf8mb4_general_ci not null default '' comment '头像',\n  `name` varchar(30) character set utf8mb4 collate utf8mb4_general_ci default '' comment '真实名字',\n  `sex` tinyint default '0' comment '用户性别',\n  `area_id` bigint default null comment '所在地',\n  `birthday` datetime default null comment '出生日期',\n  `mark` varchar(255) character set utf8mb4 collate utf8mb4_general_ci default null comment '会员备注',\n  \n  `tag_ids` varchar(255) character set utf8mb4 collate utf8mb4_general_ci default null comment '用户标签编号列表，以逗号分隔',\n  `group_id` bigint default null comment '用户分组编号',\n  \n  `level_id` bigint default null comment '等级编号',\n  `experience` int not null default '0' comment '经验',\n  \n  `point` int not null default '0' comment '积分',\n\n  primary key (`id`) using btree\n) engine=innodb auto_increment=286 default charset=utf8mb4 collate=utf8mb4_general_ci comment='会员用户';\n\n\n① id 到 mark 字段，是用户的基本信息。\n\n② tag_ids 字段，是用户的标签编号列表，以逗号分隔。由于会员标签暂时没有大的业务需求，所以暂时没有独立关联表。\n\ngroup_id 字段，是用户的分组编号。目前也没有大的用途。\n\n③ 【会员等级】level_id 字段，是用户的 vip 等级编号。experience 字段，是用户的经验值。相关的内容，可见 《会员等级、积分、签到》 文档。\n\n④ 【会员积分】point 字段，是用户的积分。相关的内容，可见 《会员等级、积分、签到》 文档。\n\n\n# 1.2 管理后台\n\n① 对应 [会员系统 -> 会员中心 -> 会员列表] 菜单，对应 yudao-ui-admin-vue3 项目的 views/member/user/index.vue 目录。如下图所示：\n\n\n\n可以给用户「编辑」「发优惠劵」「修改等级」「修改余额」等操作。\n\n② 点击「详情」按钮，可以查看该会员用户的基本信息、账户信息、相关明细等。如下图所示：\n\n\n\n\n# 1.3 移动端\n\n① 会员登录，可见 《微信公众号登录》、《微信小程序登录》 文档。\n\n② 点击 uni-app 底部的 [我的] 导航，点击顶部头像，进入会员信息界面，对应 yudao-mall-uniapp 项目的 pages/user/info.vue 页面。如下图所示：\n\n\n\n\n# 2. 会员标签\n\n会员标签，由 membertagservice 实现。\n\n\n# 2.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `member_tag` (\n  `id` bigint not null auto_increment comment '编号',\n  `name` varchar(30) character set utf8mb4 collate utf8mb4_unicode_ci not null default '' comment '标签名称',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=3 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='会员标签';\n\n\n\n# 2.2 管理后台\n\n对应 [会员系统 -> 会员中心 -> 会员标签] 菜单，对应 yudao-ui-admin-vue3 项目的 views/member/tag/index.vue 目录。如下图所示：\n\n\n\n\n# 2.3 移动端\n\n暂时没有移动端的相关操作。\n\n\n# 3. 会员分组\n\n会员分组，由 membergroupservice 实现。\n\n\n# 3.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `member_group` (\n  `id` bigint not null auto_increment comment '编号',\n  `name` varchar(30) character set utf8mb4 collate utf8mb4_unicode_ci not null default '' comment '名称',\n  `status` tinyint not null default '0' comment '状态',\n  `remark` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci not null default '' comment '备注',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=2 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='用户分组';\n\n\n\n# 3.2 管理后台\n\n对应 [会员系统 -> 会员中心 -> 会员分组] 菜单，对应 yudao-ui-admin-vue3 项目的 views/member/group/index.vue 目录。如下图所示：\n\n\n\n\n# 3.3 移动端\n\n暂时没有移动端的相关操作。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "会员等级、积分、签到",
            frontmatter: {
                title: "会员等级、积分、签到",
                date: "2024-01-18T21:41:05.000Z",
                permalink: "/member/level"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/13.%E4%BC%9A%E5%91%98%E6%89%8B%E5%86%8C/12.%E4%BC%9A%E5%91%98%E7%AD%89%E7%BA%A7%E3%80%81%E7%A7%AF%E5%88%86%E3%80%81%E7%AD%BE%E5%88%B0.html",
            relativePath: "01.开发指南/13.会员手册/12.会员等级、积分、签到.md",
            key: "v-efc01664",
            path: "/member/level/",
            headers: [{
                level: 2,
                title: "1. 会员等级",
                slug: "_1-会员等级",
                normalizedTitle: "1. 会员等级",
                charIndex: 30
            }, {
                level: 3,
                title: "1.1 表结构",
                slug: "_1-1-表结构",
                normalizedTitle: "1.1 表结构",
                charIndex: 130
            }, {
                level: 3,
                title: "1.2 管理后台",
                slug: "_1-2-管理后台",
                normalizedTitle: "1.2 管理后台",
                charIndex: 3563
            }, {
                level: 3,
                title: "1.3 移动端",
                slug: "_1-3-移动端",
                normalizedTitle: "1.3 移动端",
                charIndex: 3803
            }, {
                level: 2,
                title: "2. 会员积分",
                slug: "_2-会员积分",
                normalizedTitle: "2. 会员积分",
                charIndex: 3914
            }, {
                level: 3,
                title: "2.1 表结构",
                slug: "_2-1-表结构",
                normalizedTitle: "2.1 表结构",
                charIndex: 4022
            }, {
                level: 3,
                title: "2.2 管理后台",
                slug: "_2-2-管理后台",
                normalizedTitle: "2.2 管理后台",
                charIndex: 5062
            }, {
                level: 3,
                title: "2.3 移动端",
                slug: "_2-3-移动端",
                normalizedTitle: "2.3 移动端",
                charIndex: 5277
            }, {
                level: 2,
                title: "3. 会员签到",
                slug: "_3-会员签到",
                normalizedTitle: "3. 会员签到",
                charIndex: 5398
            }, {
                level: 3,
                title: "3.1 表结构",
                slug: "_3-1-表结构",
                normalizedTitle: "3.1 表结构",
                charIndex: 5465
            }, {
                level: 3,
                title: "3.2 管理后台",
                slug: "_3-2-管理后台",
                normalizedTitle: "3.2 管理后台",
                charIndex: 6870
            }, {
                level: 3,
                title: "3.3 移动端",
                slug: "_3-3-移动端",
                normalizedTitle: "3.3 移动端",
                charIndex: 7201
            }],
            headersStr: "1. 会员等级 1.1 表结构 1.2 管理后台 1.3 移动端 2. 会员积分 2.1 表结构 2.2 管理后台 2.3 移动端 3. 会员签到 3.1 表结构 3.2 管理后台 3.3 移动端",
            content: "本小节，我们主要看看会员等级、积分、签到相关的表。\n\n\n# 1. 会员等级\n\n会员等级，将会员分成不同的等级，给予相应的折扣。例如说：商城下单时，会员等级为 1 的用户，可以享受 9 折优惠。\n\n它的后端由 level 包实现，表关系如下图所示：\n\n\n\n\n# 1.1 表结构\n\nmember_level 表，会员等级（配置）表，由 MemberLevelService 实现。表结构如下：\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `member_level` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  `name` varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '等级名称',\n  `level` int NOT NULL DEFAULT '0' COMMENT '等级',\n  `experience` int NOT NULL DEFAULT '0' COMMENT '升级经验',\n  `discount_percent` tinyint NOT NULL DEFAULT '100' COMMENT '享受折扣',\n  `icon` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '等级图标',\n  `background_url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '等级背景图',\n  `status` tinyint NOT NULL DEFAULT '0' COMMENT '状态',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='会员等级';\n\n\n① level 字段：会员等级，从 1 开始，越大等级越高。\n\n② experience 字段：升级经验，当用户的经验值达到此值时，会员等级自动升级。\n\n③ discount_percent 字段：享受折扣，例如说：100 表示不打折，90 表示 9 折，80 表示 8 折。\n\n----------------------------------------\n\nmember_level_record 表，会员等级记录变更表，由 MemberLevelRecordService 实现。表结构如下：\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `member_level_record` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  `user_id` bigint NOT NULL DEFAULT '0' COMMENT '用户编号',\n  `level_id` bigint NOT NULL DEFAULT '0' COMMENT '等级编号',\n  `level` int NOT NULL DEFAULT '0' COMMENT '会员等级',\n  `discount_percent` tinyint NOT NULL DEFAULT '100' COMMENT '享受折扣',\n  `experience` int NOT NULL DEFAULT '0' COMMENT '升级经验',\n  `remark` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '备注',\n  `description` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '描述',\n  \n  `user_experience` int NOT NULL DEFAULT '0' COMMENT '会员此时的经验',\n  PRIMARY KEY (`id`) USING BTREE,\n  KEY `idx_user_id` (`user_id`) USING BTREE COMMENT '会员等级记录-用户编号'\n) ENGINE=InnoDB AUTO_INCREMENT=33 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='会员等级记录';\n\n\n每次会员等级变更时，都会记录到此表中。并且，会记录 user_experience 字段，表示会员此时的经验值。\n\n----------------------------------------\n\nmember_experience_record 表，会员经验变更记录表，由 MemberExperienceRecordService 实现。表结构如下：\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `member_experience_record` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  `user_id` bigint NOT NULL DEFAULT '0' COMMENT '用户编号',\n  `biz_id` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '业务编号',\n  `biz_type` tinyint NOT NULL DEFAULT '0' COMMENT '业务类型',\n  `title` varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '标题',\n  `description` varchar(512) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '描述',\n  `experience` int NOT NULL DEFAULT '0' COMMENT '经验',\n  `total_experience` int NOT NULL DEFAULT '0' COMMENT '变更后的经验',\n  PRIMARY KEY (`id`) USING BTREE,\n  KEY `idx_user_id` (`user_id`) USING BTREE COMMENT '会员经验记录-用户编号',\n  KEY `idx_user_biz_type` (`user_id`,`biz_type`) USING BTREE COMMENT '会员经验记录-用户业务类型'\n) ENGINE=InnoDB AUTO_INCREMENT=63 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='会员经验记录';\n\n\n每次会员经验变更时，都会记录到此表中。并且，会记录 total_experience 字段，表示变更后的经验值。\n\n另外，biz_type 字段，表示业务类型，对应 MemberExperienceBizTypeEnum 枚举，目前有管理员调整、签到奖励、下单奖励等等。\n\n\n# 1.2 管理后台\n\n① 会员等级，对应 [会员系统 -> 会员中心 -> 会员等级] 菜单，对应 yudao-ui-admin-vue3 项目的 views/member/level/index.vue 目录。如下图所示：\n\n\n\n② 会员详情的 [成长值] 标签，可以查看 member_experience_record 表的记录，对应 views/member/user/detail/UserExperienceRecordList.vue 组件。如下图所示：\n\n\n\n\n# 1.3 移动端\n\n① 会员等级、经验信息，在 yudao-mall-uniapp 暂时没有展示。\n\n② 商城下单时，会员等级的折扣计算，通过 TradeMemberLevelPriceCalculator 实现。\n\n\n# 2. 会员积分\n\n会员积分，一般用于积分抵扣金额。例如说：商城下单时，会员积分为 100 的用户，可以抵扣 1 元。\n\n它的后端由 point 包的 MemberPointRecordService 实现。\n\n\n# 2.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `member_point_record` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '自增主键',\n  \n  `user_id` bigint NOT NULL COMMENT '用户编号',\n  \n  `biz_id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '业务编码',\n  `biz_type` tinyint NOT NULL COMMENT '业务类型',\n  `title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '积分标题',\n  `description` varchar(5000) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '积分描述',\n  \n  `point` int NOT NULL COMMENT '积分',\n  `total_point` int NOT NULL COMMENT '变动后的积分',\n  PRIMARY KEY (`id`) USING BTREE,\n  KEY `index_userId` (`user_id`) USING BTREE,\n  KEY `index_title` (`title`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=89 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='用户积分记录';\n\n\n① user_id 字段：用户编号，属于哪个会员用户。\n\n② biz_type 字段：业务类型，对应 MemberPointBizTypeEnum 枚举，目前有管理员调整、签到奖励、下单奖励等等。\n\n③ point、total_point 字段：积分、变动后的积分。所以会员积分变更时，都会记录到此表中。\n\n\n# 2.2 管理后台\n\n① 对应 [会员系统 -> 会员中心 -> 会员积分] 菜单，对应 yudao-ui-admin-vue3 项目的 views/member/point/record 目录。如下图所示：\n\n\n\n② 会员详情的 [积分] 标签，可以查看 member_point_record 表的记录，对应 views/member/user/detail/UserPointList.vue 组件。如下图所示：\n\n\n\n\n# 2.3 移动端\n\n点击 uni-app 底部的 [我的] 导航，点击 [积分] 菜单，进入积分信息界面，对应 yudao-mall-uniapp 项目的 pages/user/wallet/score.vue 页面。如下图所示：\n\n\n\n\n# 3. 会员签到\n\n会员签到，通过每日签到，获得积分、经验等奖励。\n\n它的后端由 signin 包实现，表关系如下图所示：\n\n\n\n\n# 3.1 表结构\n\nmember_sign_in_config 表，会员签到配置表，由 MemberSignInConfigService 实现。表结构如下：\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `member_sign_in_config` (\n  `id` int NOT NULL AUTO_INCREMENT COMMENT '编号',\n  `day` int NOT NULL COMMENT '第几天',\n  `point` int NOT NULL COMMENT '奖励积分',\n  `experience` int NOT NULL DEFAULT '0' COMMENT '奖励经验',\n  `status` tinyint NOT NULL COMMENT '状态',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='签到规则';\n\n\n① day 字段：第几天，例如说：第 1 天、第 2 天、第 3 天等等。\n\n② point、experience 字段：奖励积分、奖励经验。\n\n----------------------------------------\n\nmember_sign_in_record 表，会员签到记录表，由 MemberSignInRecordService 实现。表结构如下：\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `member_sign_in_record` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '签到自增id',\n  \n  `user_id` int DEFAULT NULL COMMENT '签到用户',\n  \n  `day` int DEFAULT NULL COMMENT '第几天签到',\n  \n  `point` int NOT NULL DEFAULT '0' COMMENT '签到的分数',\n  `experience` int NOT NULL DEFAULT '0' COMMENT '奖励经验',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='签到记录';\n\n\n① user_id 字段：用户编号，属于哪个会员用户。\n\n② day 字段：第几天签到，例如说：第 1 天、第 2 天、第 3 天等等。\n\n③ point、experience 字段：签到的分数、奖励经验。冗余的原因，是 member_sign_in_config 表的 point、experience 字段，可能会变更。\n\n\n# 3.2 管理后台\n\n① 对应 [会员系统 -> 会员中心 -> 会员签到 -> 签到配置] 菜单，对应 yudao-ui-admin-vue3 项目的 views/member/signin/config 目录。如下图所示：\n\n\n\n② 对应 [会员系统 -> 会员中心 -> 会员签到 -> 签到记录] 菜单，对应 yudao-ui-admin-vue3 项目的 views/member/signin/record 目录。如下图所示：\n\n\n\n③ 会员详情的 [签到] 标签，可以查看 member_sign_in_record 表的记录，对应 views/member/user/detail/UserSignList.vue 组件。如下图所示：\n\n\n\n\n# 3.3 移动端\n\n点击 uni-app 底部的 [我的] 导航，点击 [签到] 菜单，进入签到界面，对应 yudao-mall-uniapp 项目的 pages/app/sign.vue 页面。如下图所示：\n\n",
            normalizedContent: "本小节，我们主要看看会员等级、积分、签到相关的表。\n\n\n# 1. 会员等级\n\n会员等级，将会员分成不同的等级，给予相应的折扣。例如说：商城下单时，会员等级为 1 的用户，可以享受 9 折优惠。\n\n它的后端由 level 包实现，表关系如下图所示：\n\n\n\n\n# 1.1 表结构\n\nmember_level 表，会员等级（配置）表，由 memberlevelservice 实现。表结构如下：\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `member_level` (\n  `id` bigint not null auto_increment comment '编号',\n  `name` varchar(30) character set utf8mb4 collate utf8mb4_unicode_ci not null default '' comment '等级名称',\n  `level` int not null default '0' comment '等级',\n  `experience` int not null default '0' comment '升级经验',\n  `discount_percent` tinyint not null default '100' comment '享受折扣',\n  `icon` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci not null default '' comment '等级图标',\n  `background_url` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci not null default '' comment '等级背景图',\n  `status` tinyint not null default '0' comment '状态',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=4 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='会员等级';\n\n\n① level 字段：会员等级，从 1 开始，越大等级越高。\n\n② experience 字段：升级经验，当用户的经验值达到此值时，会员等级自动升级。\n\n③ discount_percent 字段：享受折扣，例如说：100 表示不打折，90 表示 9 折，80 表示 8 折。\n\n----------------------------------------\n\nmember_level_record 表，会员等级记录变更表，由 memberlevelrecordservice 实现。表结构如下：\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `member_level_record` (\n  `id` bigint not null auto_increment comment '编号',\n  `user_id` bigint not null default '0' comment '用户编号',\n  `level_id` bigint not null default '0' comment '等级编号',\n  `level` int not null default '0' comment '会员等级',\n  `discount_percent` tinyint not null default '100' comment '享受折扣',\n  `experience` int not null default '0' comment '升级经验',\n  `remark` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci not null default '' comment '备注',\n  `description` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci not null default '' comment '描述',\n  \n  `user_experience` int not null default '0' comment '会员此时的经验',\n  primary key (`id`) using btree,\n  key `idx_user_id` (`user_id`) using btree comment '会员等级记录-用户编号'\n) engine=innodb auto_increment=33 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='会员等级记录';\n\n\n每次会员等级变更时，都会记录到此表中。并且，会记录 user_experience 字段，表示会员此时的经验值。\n\n----------------------------------------\n\nmember_experience_record 表，会员经验变更记录表，由 memberexperiencerecordservice 实现。表结构如下：\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `member_experience_record` (\n  `id` bigint not null auto_increment comment '编号',\n  `user_id` bigint not null default '0' comment '用户编号',\n  `biz_id` varchar(64) character set utf8mb4 collate utf8mb4_unicode_ci not null default '' comment '业务编号',\n  `biz_type` tinyint not null default '0' comment '业务类型',\n  `title` varchar(30) character set utf8mb4 collate utf8mb4_unicode_ci not null default '' comment '标题',\n  `description` varchar(512) character set utf8mb4 collate utf8mb4_unicode_ci not null default '' comment '描述',\n  `experience` int not null default '0' comment '经验',\n  `total_experience` int not null default '0' comment '变更后的经验',\n  primary key (`id`) using btree,\n  key `idx_user_id` (`user_id`) using btree comment '会员经验记录-用户编号',\n  key `idx_user_biz_type` (`user_id`,`biz_type`) using btree comment '会员经验记录-用户业务类型'\n) engine=innodb auto_increment=63 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='会员经验记录';\n\n\n每次会员经验变更时，都会记录到此表中。并且，会记录 total_experience 字段，表示变更后的经验值。\n\n另外，biz_type 字段，表示业务类型，对应 memberexperiencebiztypeenum 枚举，目前有管理员调整、签到奖励、下单奖励等等。\n\n\n# 1.2 管理后台\n\n① 会员等级，对应 [会员系统 -> 会员中心 -> 会员等级] 菜单，对应 yudao-ui-admin-vue3 项目的 views/member/level/index.vue 目录。如下图所示：\n\n\n\n② 会员详情的 [成长值] 标签，可以查看 member_experience_record 表的记录，对应 views/member/user/detail/userexperiencerecordlist.vue 组件。如下图所示：\n\n\n\n\n# 1.3 移动端\n\n① 会员等级、经验信息，在 yudao-mall-uniapp 暂时没有展示。\n\n② 商城下单时，会员等级的折扣计算，通过 tradememberlevelpricecalculator 实现。\n\n\n# 2. 会员积分\n\n会员积分，一般用于积分抵扣金额。例如说：商城下单时，会员积分为 100 的用户，可以抵扣 1 元。\n\n它的后端由 point 包的 memberpointrecordservice 实现。\n\n\n# 2.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `member_point_record` (\n  `id` bigint not null auto_increment comment '自增主键',\n  \n  `user_id` bigint not null comment '用户编号',\n  \n  `biz_id` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '业务编码',\n  `biz_type` tinyint not null comment '业务类型',\n  `title` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '积分标题',\n  `description` varchar(5000) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '积分描述',\n  \n  `point` int not null comment '积分',\n  `total_point` int not null comment '变动后的积分',\n  primary key (`id`) using btree,\n  key `index_userid` (`user_id`) using btree,\n  key `index_title` (`title`) using btree\n) engine=innodb auto_increment=89 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='用户积分记录';\n\n\n① user_id 字段：用户编号，属于哪个会员用户。\n\n② biz_type 字段：业务类型，对应 memberpointbiztypeenum 枚举，目前有管理员调整、签到奖励、下单奖励等等。\n\n③ point、total_point 字段：积分、变动后的积分。所以会员积分变更时，都会记录到此表中。\n\n\n# 2.2 管理后台\n\n① 对应 [会员系统 -> 会员中心 -> 会员积分] 菜单，对应 yudao-ui-admin-vue3 项目的 views/member/point/record 目录。如下图所示：\n\n\n\n② 会员详情的 [积分] 标签，可以查看 member_point_record 表的记录，对应 views/member/user/detail/userpointlist.vue 组件。如下图所示：\n\n\n\n\n# 2.3 移动端\n\n点击 uni-app 底部的 [我的] 导航，点击 [积分] 菜单，进入积分信息界面，对应 yudao-mall-uniapp 项目的 pages/user/wallet/score.vue 页面。如下图所示：\n\n\n\n\n# 3. 会员签到\n\n会员签到，通过每日签到，获得积分、经验等奖励。\n\n它的后端由 signin 包实现，表关系如下图所示：\n\n\n\n\n# 3.1 表结构\n\nmember_sign_in_config 表，会员签到配置表，由 membersigninconfigservice 实现。表结构如下：\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `member_sign_in_config` (\n  `id` int not null auto_increment comment '编号',\n  `day` int not null comment '第几天',\n  `point` int not null comment '奖励积分',\n  `experience` int not null default '0' comment '奖励经验',\n  `status` tinyint not null comment '状态',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=13 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='签到规则';\n\n\n① day 字段：第几天，例如说：第 1 天、第 2 天、第 3 天等等。\n\n② point、experience 字段：奖励积分、奖励经验。\n\n----------------------------------------\n\nmember_sign_in_record 表，会员签到记录表，由 membersigninrecordservice 实现。表结构如下：\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `member_sign_in_record` (\n  `id` bigint not null auto_increment comment '签到自增id',\n  \n  `user_id` int default null comment '签到用户',\n  \n  `day` int default null comment '第几天签到',\n  \n  `point` int not null default '0' comment '签到的分数',\n  `experience` int not null default '0' comment '奖励经验',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=12 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='签到记录';\n\n\n① user_id 字段：用户编号，属于哪个会员用户。\n\n② day 字段：第几天签到，例如说：第 1 天、第 2 天、第 3 天等等。\n\n③ point、experience 字段：签到的分数、奖励经验。冗余的原因，是 member_sign_in_config 表的 point、experience 字段，可能会变更。\n\n\n# 3.2 管理后台\n\n① 对应 [会员系统 -> 会员中心 -> 会员签到 -> 签到配置] 菜单，对应 yudao-ui-admin-vue3 项目的 views/member/signin/config 目录。如下图所示：\n\n\n\n② 对应 [会员系统 -> 会员中心 -> 会员签到 -> 签到记录] 菜单，对应 yudao-ui-admin-vue3 项目的 views/member/signin/record 目录。如下图所示：\n\n\n\n③ 会员详情的 [签到] 标签，可以查看 member_sign_in_record 表的记录，对应 views/member/user/detail/usersignlist.vue 组件。如下图所示：\n\n\n\n\n# 3.3 移动端\n\n点击 uni-app 底部的 [我的] 导航，点击 [签到] 菜单，进入签到界面，对应 yudao-mall-uniapp 项目的 pages/app/sign.vue 页面。如下图所示：\n\n",
            charsets: {
                cjk: !0
            }
        }, {
            title: "商城演示",
            frontmatter: {
                title: "商城演示",
                permalink: "/mall-preview",
                date: "2023-09-11T13:38:26.000Z"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/14.%E5%95%86%E5%9F%8E%E6%89%8B%E5%86%8C/01.%E5%95%86%E5%9F%8E%E6%BC%94%E7%A4%BA.html",
            relativePath: "01.开发指南/14.商城手册/01.商城演示.md",
            key: "v-6909fb9a",
            path: "/mall-preview/",
            headers: [{
                level: 2,
                title: "1. 演示地址",
                slug: "_1-演示地址",
                normalizedTitle: "1. 演示地址",
                charIndex: 2
            }, {
                level: 3,
                title: "1.1 商城移动端",
                slug: "_1-1-商城移动端",
                normalizedTitle: "1.1 商城移动端",
                charIndex: 14
            }, {
                level: 3,
                title: "1.2 商城管理后台",
                slug: "_1-2-商城管理后台",
                normalizedTitle: "1.2 商城管理后台",
                charIndex: 185
            }, {
                level: 3,
                title: "1.3 商城后端",
                slug: "_1-3-商城后端",
                normalizedTitle: "1.3 商城后端",
                charIndex: 373
            }, {
                level: 2,
                title: "2. 商城启动",
                slug: "_2-商城启动",
                normalizedTitle: "2. 商城启动",
                charIndex: 522
            }, {
                level: 2,
                title: "3. 商城交流",
                slug: "_3-商城交流",
                normalizedTitle: "3. 商城交流",
                charIndex: 572
            }, {
                level: 2,
                title: "4. 功能概述",
                slug: "_4-功能概述",
                normalizedTitle: "4. 功能概述",
                charIndex: 602
            }, {
                level: 3,
                title: "4.1 商城管理后台",
                slug: "_4-1-商城管理后台",
                normalizedTitle: "4.1 商城管理后台",
                charIndex: 695
            }, {
                level: 3,
                title: "4.2 商城移动端",
                slug: "_4-2-商城移动端",
                normalizedTitle: "4.2 商城移动端",
                charIndex: 712
            }, {
                level: 2,
                title: "5. 表结构",
                slug: "_5-表结构",
                normalizedTitle: "5. 表结构",
                charIndex: 728
            }, {
                level: 3,
                title: "5.1 商品模块（中心）",
                slug: "_5-1-商品模块-中心",
                normalizedTitle: "5.1 商品模块（中心）",
                charIndex: 793
            }, {
                level: 3,
                title: "5.2 交易模块（中心）",
                slug: "_5-2-交易模块-中心",
                normalizedTitle: "5.2 交易模块（中心）",
                charIndex: 911
            }, {
                level: 3,
                title: "5.3 营销模块（中心）",
                slug: "_5-3-营销模块-中心",
                normalizedTitle: "5.3 营销模块（中心）",
                charIndex: 1046
            }, {
                level: 3,
                title: "5.4 统计模块（中心）",
                slug: "_5-4-统计模块-中心",
                normalizedTitle: "5.4 统计模块（中心）",
                charIndex: 1222
            }, {
                level: 3,
                title: "5.5 会员模块（中心）",
                slug: "_5-5-会员模块-中心",
                normalizedTitle: "5.5 会员模块（中心）",
                charIndex: 1291
            }, {
                level: 3,
                title: "5.6 支付模块（中心）",
                slug: "_5-6-支付模块-中心",
                normalizedTitle: "5.6 支付模块（中心）",
                charIndex: 1335
            }],
            headersStr: "1. 演示地址 1.1 商城移动端 1.2 商城管理后台 1.3 商城后端 2. 商城启动 3. 商城交流 4. 功能概述 4.1 商城管理后台 4.2 商城移动端 5. 表结构 5.1 商品模块（中心） 5.2 交易模块（中心） 5.3 营销模块（中心） 5.4 统计模块（中心） 5.5 会员模块（中心） 5.6 支付模块（中心）",
            content: "# 1. 演示地址\n\n\n# 1.1 商城移动端\n\n * 演示地址：http://mall.yudao.iocoder.cn/\n * 账号：可使用账号 15601691300，验证码 9999 进行登录\n * 仓库：https://github.com/yudaocode/yudao-mall-uniapp 仓库，目前是基于 Vue3 + uni-app 实现\n\n\n# 1.2 商城管理后台\n\n * 演示地址：http://dashboard-vue3.yudao.iocoder.cn/\n * 菜单：「会员中心」「商品中心」「订单中心」「营销中心」「统计中心」「支付中心」\n * 仓库：https://github.com/yudaocode/yudao-ui-admin-vue3，基于 Vue3 + Element Plus 实现\n\n\n# 1.3 商城后端\n\n支持 Spring Boot 单体、Spring Cloud 微服务架构\n\n * 单体仓库： https://github.com/YunaiV/ruoyi-vue-pro\n * 微服务仓库： https://github.com/YunaiV/yudao-cloud\n\n\n# 2. 商城启动\n\n参见 《商城手册 —— 功能开启》 文档，一般 3 分钟就可以启动完成。\n\n\n# 3. 商城交流\n\n专属交流社区，欢迎扫码加入。\n\n\n\n\n# 4. 功能概述\n\n主要分为 4 个核心模块（商品、订单、营销、统计）、2 个基础模块（会员、支付）。\n\n目前已经比较完善，可以支持一整套电商流程，不少公司已经在生产中使用。\n\n\n\n\n# 4.1 商城管理后台\n\n\n\n\n# 4.2 商城移动端\n\n\n\n\n# 5. 表结构\n\n商城一共有 70+ 张表，具备一定的业务复杂度，对提升技术能力会有不错的帮助，平时做项目也可以参考参考。\n\n\n# 5.1 商品模块（中心）\n\n以 product_ 作为前缀的表，表结构如下：\n\n\n\n可学习文档：\n\n * 《【商品】商品分类》\n * 《【商品】商品属性》\n * 《【商品】商品 SPU 与 SKU》\n * 《【商品】商品评价》\n\n\n# 5.2 交易模块（中心）\n\n以 trade_ 作为前缀的表，表结构如下：\n\n\n\n可学习文档：\n\n * 《【交易】购物车》\n * 《【交易】商品订单》\n * 《【交易】售后退款》\n * 《【交易】快递发货》\n * 《【交易】门店自提》\n * 《【交易】分销返佣》\n\n\n# 5.3 营销模块（中心）\n\n以 promotion_ 作为前缀的表，表结构如下：\n\n\n\n可学习文档：\n\n * 《店铺装修》\n * 《【营销】优惠劵》\n * 《【营销】积分商城》\n * 《【营销】拼团活动》\n * 《【营销】秒杀活动》\n * 《【营销】砍价活动》\n * 《【营销】满减送》\n * 《【营销】限时折扣》\n * 《【营销】内容管理》\n\n\n# 5.4 统计模块（中心）\n\n以 _statistics 作为后缀的表，表结构如下：\n\n\n\n * 《【统计】会员、商品、交易统计》\n\n\n# 5.5 会员模块（中心）\n\n以 member_ 作为前缀的表，表结构如下：\n\n\n\n\n# 5.6 支付模块（中心）\n\n以 pay_ 作为前缀的表，表结构如下：\n\n",
            normalizedContent: "# 1. 演示地址\n\n\n# 1.1 商城移动端\n\n * 演示地址：http://mall.yudao.iocoder.cn/\n * 账号：可使用账号 15601691300，验证码 9999 进行登录\n * 仓库：https://github.com/yudaocode/yudao-mall-uniapp 仓库，目前是基于 vue3 + uni-app 实现\n\n\n# 1.2 商城管理后台\n\n * 演示地址：http://dashboard-vue3.yudao.iocoder.cn/\n * 菜单：「会员中心」「商品中心」「订单中心」「营销中心」「统计中心」「支付中心」\n * 仓库：https://github.com/yudaocode/yudao-ui-admin-vue3，基于 vue3 + element plus 实现\n\n\n# 1.3 商城后端\n\n支持 spring boot 单体、spring cloud 微服务架构\n\n * 单体仓库： https://github.com/yunaiv/ruoyi-vue-pro\n * 微服务仓库： https://github.com/yunaiv/yudao-cloud\n\n\n# 2. 商城启动\n\n参见 《商城手册 —— 功能开启》 文档，一般 3 分钟就可以启动完成。\n\n\n# 3. 商城交流\n\n专属交流社区，欢迎扫码加入。\n\n\n\n\n# 4. 功能概述\n\n主要分为 4 个核心模块（商品、订单、营销、统计）、2 个基础模块（会员、支付）。\n\n目前已经比较完善，可以支持一整套电商流程，不少公司已经在生产中使用。\n\n\n\n\n# 4.1 商城管理后台\n\n\n\n\n# 4.2 商城移动端\n\n\n\n\n# 5. 表结构\n\n商城一共有 70+ 张表，具备一定的业务复杂度，对提升技术能力会有不错的帮助，平时做项目也可以参考参考。\n\n\n# 5.1 商品模块（中心）\n\n以 product_ 作为前缀的表，表结构如下：\n\n\n\n可学习文档：\n\n * 《【商品】商品分类》\n * 《【商品】商品属性》\n * 《【商品】商品 spu 与 sku》\n * 《【商品】商品评价》\n\n\n# 5.2 交易模块（中心）\n\n以 trade_ 作为前缀的表，表结构如下：\n\n\n\n可学习文档：\n\n * 《【交易】购物车》\n * 《【交易】商品订单》\n * 《【交易】售后退款》\n * 《【交易】快递发货》\n * 《【交易】门店自提》\n * 《【交易】分销返佣》\n\n\n# 5.3 营销模块（中心）\n\n以 promotion_ 作为前缀的表，表结构如下：\n\n\n\n可学习文档：\n\n * 《店铺装修》\n * 《【营销】优惠劵》\n * 《【营销】积分商城》\n * 《【营销】拼团活动》\n * 《【营销】秒杀活动》\n * 《【营销】砍价活动》\n * 《【营销】满减送》\n * 《【营销】限时折扣》\n * 《【营销】内容管理》\n\n\n# 5.4 统计模块（中心）\n\n以 _statistics 作为后缀的表，表结构如下：\n\n\n\n * 《【统计】会员、商品、交易统计》\n\n\n# 5.5 会员模块（中心）\n\n以 member_ 作为前缀的表，表结构如下：\n\n\n\n\n# 5.6 支付模块（中心）\n\n以 pay_ 作为前缀的表，表结构如下：\n\n",
            charsets: {
                cjk: !0
            }
        }, {
            title: "商城装修",
            frontmatter: {
                title: "商城装修",
                permalink: "/mall/diy",
                date: "2023-12-19T20:25:26.000Z"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/14.%E5%95%86%E5%9F%8E%E6%89%8B%E5%86%8C/03.%E5%BA%97%E9%93%BA%E8%A3%85%E4%BF%AE.html",
            relativePath: "01.开发指南/14.商城手册/03.店铺装修.md",
            key: "v-5f89bd8e",
            path: "/mall/diy/",
            headers: [{
                level: 2,
                title: "1. 功能介绍",
                slug: "_1-功能介绍",
                normalizedTitle: "1. 功能介绍",
                charIndex: 2
            }, {
                level: 3,
                title: "1.1 装修模版",
                slug: "_1-1-装修模版",
                normalizedTitle: "1.1 装修模版",
                charIndex: 126
            }, {
                level: 3,
                title: "1.2 装修页面",
                slug: "_1-2-装修页面",
                normalizedTitle: "1.2 装修页面",
                charIndex: 255
            }, {
                level: 2,
                title: "2. 实现原理",
                slug: "_2-实现原理",
                normalizedTitle: "2. 实现原理",
                charIndex: 484
            }, {
                level: 3,
                title: "2.1 uni-app",
                slug: "_2-1-uni-app",
                normalizedTitle: "2.1 uni-app",
                charIndex: 542
            }, {
                level: 3,
                title: "2.2 管理后台",
                slug: "_2-2-管理后台",
                normalizedTitle: "2.2 管理后台",
                charIndex: 909
            }, {
                level: 3,
                title: "2.3 后端存储",
                slug: "_2-3-后端存储",
                normalizedTitle: "2.3 后端存储",
                charIndex: 1521
            }, {
                level: 2,
                title: "附录：组件对应关系",
                slug: "附录-组件对应关系",
                normalizedTitle: "附录：组件对应关系",
                charIndex: 6883
            }, {
                level: 3,
                title: "布局组件",
                slug: "布局组件",
                normalizedTitle: "布局组件",
                charIndex: 6930
            }, {
                level: 3,
                title: "基础组件",
                slug: "基础组件",
                normalizedTitle: "基础组件",
                charIndex: 6845
            }, {
                level: 3,
                title: "图文组件",
                slug: "图文组件",
                normalizedTitle: "图文组件",
                charIndex: 6852
            }, {
                level: 3,
                title: "商品组件",
                slug: "商品组件",
                normalizedTitle: "商品组件",
                charIndex: 6859
            }, {
                level: 3,
                title: "用户组件",
                slug: "用户组件",
                normalizedTitle: "用户组件",
                charIndex: 6866
            }, {
                level: 3,
                title: "营销组件",
                slug: "营销组件",
                normalizedTitle: "营销组件",
                charIndex: 6873
            }],
            headersStr: "1. 功能介绍 1.1 装修模版 1.2 装修页面 2. 实现原理 2.1 uni-app 2.2 管理后台 2.3 后端存储 附录：组件对应关系 布局组件 基础组件 图文组件 商品组件 用户组件 营销组件",
            content: '# 1. 功能介绍\n\n项目支持商城装修，通过简单的拖拉拽，即可进行 uni-app 页面的制作，最终可以在 H5、小程序进行展示。\n\n对应管理后台的 [商城系统 -> 营销中心 -> 商城装修] 菜单。目前它有两个子菜单：装修模版、装修页面。\n\n\n# 1.1 装修模版\n\n装修模版，实现对 uni-app 的首页、个人中心进行配置。\n\n① 可以新建多个装修模版，点击「使用」后，设置为当前 uni-app 默认使用。如下图所示：\n\n\n\n② 点击「装修」后，可以进行首页、个人中心设计。如下图所示：\n\n\n\n\n# 1.2 装修页面\n\n装修模版，可以简单理解它由两个装修页面组成：首页、个人中心。所以装修页面的「装修」功能，和装修模版是一致的。如下图所示：\n\n\n\n② 那么装修页面为什么要独立一个菜单呢？在某些场景下，需要制作一个广告业、活动页等等，可以通过它来实现。\n\n例如说，我们先「新建」一个装修页面，然后进行「装修」后，然后使用 uni-app 进行直接访问。访问的地址示例，/pages/index/page?id=${pageId} 。如下图所示：\n\n\n\n\n# 2. 实现原理\n\n店铺装修的实现原理并不复杂，我们将分成三部分来讲解：uni-app、管理后台、后端存储。\n\n\n# 2.1 uni-app\n\n本质上来说，uni-app 就是读取到装修配置，for 循环创建对应的组件，使用该组件对应的配置，进行渲染即可。\n\n① uni-app 前台打开时，在 sheep/index.js 的 ShoproInit 方法中，会调用后端接口，获取到默认的装修模版。这样，它就获取到了装修配置。如下图所示：\n\n\n\n② 有了装修配置后，首页（pages/index/index.vue）、个人中心（pages/index/user.vue）就可以进行渲染展示。以首页举例子，它会包含多个“装修组件”，每个“装修组件”由 s-block-item 进行渲染。如下图所示：\n\n\n\n例如说，s-title-block.vue 它用于“标题栏”的展示。拿到它对应的 data 装修配置，就可以进行展示了。如下图所示：\n\n\n\n\n# 2.2 管理后台\n\n① 管理后台的 components/DiyEditor 组件，实现了商城装修功能，它被装修模版的「装修」（views/mall/promotion/diy/template/decorate.vue）和装修页面的「装修」（views/mall/promotion/diy/page/decorate.vue）所使用。如下图所示：\n\n\n\n它可以分成如下三个部分所组成：\n\n * 【左边】组件区域：可选中的“装修组件”列表，由 components/DiyEditor/components/ComponentLibrary.vue 实现\n * 【中间】设计区域：由选中的多个 components/DiyEditor/components/ComponentContainer.vue “装修组件”所组成\n * 【右边】属性面板：设置当前选中的“装修组件”属性，由 components/DiyEditor/components/ComponentContainerProperty.vue 实现\n\n② 在 components/DiyEditor/components/mobile 目录下，可以看到每个“装修组件”的实现。如下图所示：\n\n\n\n③ 点击右上角的「保存」按钮，每个“装修组件”的属性会存储成对应的 JSON 格式，那么一个页面其实就是多个 JSON 组成的数组。具体的存储格式，我们放在「2.3 后端存储」小节来看。\n\n\n# 2.3 后端存储\n\n后端由 yudao-module-promotion-biz 模块的 diy 包下来实现。它有两个表：\n\n① promotion_diy_template 装修模版表，关键字段如下所示：\n\nCREATE TABLE `promotion_diy_template` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT \'装修模板编号\',\n  `name` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'模板名称\',\n  `used` bit(1) NOT NULL DEFAULT b\'0\' COMMENT \'是否使用\',\n  `property` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci COMMENT \'模板属性，JSON 格式\',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci ROW_FORMAT=DYNAMIC COMMENT=\'装修模板\';\n\n\n其中 property 是最关键字段，存储了整个 uni-app 全局的界面配置，如下所示：\n\n{\n    "page": {\n        "description": "", \n        "backgroundColor": "#f5f5f5", \n        "backgroundImage": ""\n    }, \n    "navigationBar": {\n        "title": "页面标题", \n        "description": "", \n        "navBarHeight": 35, \n        "backgroundColor": "#f5f5f5", \n        "backgroundImage": "", \n        "styleType": "default", \n        "alwaysShow": true, \n        "showGoBack": true\n    }, \n    "tabBar": {\n        "theme": "orange", \n        "style": {\n            "backgroundType": "img", \n            "background": "", \n            "color": "#282828", \n            "activeColor": "#f37b1d"\n        }, \n        "items": [\n            {\n                "name": "首页1", \n                "link": "/", \n                "iconUrl": "http://mall.yudao.iocoder.cn/static/images/1-001.png", \n                "activeIconUrl": "http://mall.yudao.iocoder.cn/static/images/1-002.png"\n            }, \n            {\n                "name": "分类", \n                "link": "/pages/goods_cate/goods_cate", \n                "iconUrl": "http://mall.yudao.iocoder.cn/static/images/2-001.png", \n                "activeIconUrl": "http://mall.yudao.iocoder.cn/static/images/2-002.png"\n            }, \n            {\n                "name": "购物车", \n                "link": "/pages/order_addcart/order_addcart", \n                "iconUrl": "http://mall.yudao.iocoder.cn/static/images/3-001.png", \n                "activeIconUrl": "http://mall.yudao.iocoder.cn/static/images/3-002.png"\n            }, \n            {\n                "name": "我的", \n                "link": "/pages/user/index", \n                "iconUrl": "http://mall.yudao.iocoder.cn/static/images/4-001.png", \n                "activeIconUrl": "http://mall.yudao.iocoder.cn/static/images/4-002.png"\n            }\n        ]\n    }, \n    "components": [ ]\n}\n\n\n * page 属性：对应「附录」小节的“页面设置”组件，定义了整个 uni-app 页面的背景色、背景图等等\n * navigationBar 属性：对应「附录」小节的“顶部导航栏”组件，定义了 uni-app 顶部导航的背景色、高度等等\n * tabBar 属性：对应「附录」小节的“底部导航栏”组件，定义了 uni-app 底部导航（菜单）的名字、链接、icon 等等\n\n注意，后端仅仅进行存储，具体每个组件有哪些属性，本质上是前端自己所决定。\n\n那么，uni-app 首页、个人中心的装修页面，存储在哪里呢？答案在 promotion_diy_page 表。\n\n② promotion_diy_page 装修页面表，关键字段如下所示：\n\nCREATE TABLE `promotion_diy_page` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT \'装修页面编号\',\n  `template_id` bigint DEFAULT NULL COMMENT \'装修模板编号\',\n  `name` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT \'页面名称\',\n  `property` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci COMMENT \'页面属性，JSON 格式\',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci ROW_FORMAT=DYNAMIC COMMENT=\'装修页面\';\n\n\n * template_id 字段，关联对应的装修模版。当然，如果直接创建的装修页面，不会进行关联，该字段的值为空\n\n其中 property 也是最关键字段，存储了单个 uni-app 页面的界面配置，如下所示：\n\n{\n    "page": {\n        "description": "", \n        "backgroundColor": "#f5f5f5", \n        "backgroundImage": ""\n    }, \n    "navigationBar": {\n        "title": "双 11 购物节", \n        "description": "", \n        "navBarHeight": 35, \n        "backgroundColor": "#fff", \n        "backgroundImage": "", \n        "styleType": "default", \n        "alwaysShow": true, \n        "showGoBack": true\n    }, \n    "components": [\n        {\n            "id": "TitleBar", \n            "property": {\n                "title": "一个不错的活动！！！", \n                "description": "副标题", \n                "titleSize": 16, \n                "descriptionSize": 12, \n                "titleWeight": 400, \n                "textAlign": "left", \n                "descriptionWeight": 200, \n                "titleColor": "rgba(50, 50, 51, 10)", \n                "descriptionColor": "rgba(150, 151, 153, 10)", \n                "more": {\n                    "show": false, \n                    "type": "icon", \n                    "text": "查看更多", \n                    "url": ""\n                }, \n                "style": {\n                    "bgType": "color", \n                    "bgColor": "#fff"\n                }\n            }\n        },\n        {\n            "id": "CouponCard", \n            "property": {\n                "columns": 1, \n                "bgImg": "", \n                "textColor": "#E9B461", \n                "button": {\n                    "color": "#434343", \n                    "bgColor": ""\n                }, \n                "space": 0, \n                "couponIds": [\n                    2\n                ], \n                "style": {\n                    "bgType": "color", \n                    "bgColor": "", \n                    "marginBottom": 8\n                }\n            }\n        }\n    ]\n}\n\n\n * page 和 navigationBar 属性，和 promotion_diy_template 表的类似。但是，没有 tabBar 属性，因为该属性属于全局配置\n * components 属性，存储每个“装修组件”的 JSON 配置，注意它是一个数组。对应到「附录」小节的话，就是『基础组件』、『图文组件』、『商品组件』、『用户组件』、『营销组件』\n\n\n# 附录：组件对应关系\n\n管理后台与 uni-app 组件的对应关系，方便你学习研究~~\n\n\n# 布局组件\n\n        UNI-APP 地址                                       管理后台地址\n页面设置    pages/index/index.vue 或 /pages/index/user.vue    DiyEditor/components/mobile/PageConfig\n顶部导航栏   components/s-custom-navbar/s-custom-navbar.vue   DiyEditor/components/mobile/NavigationBar\n底部导航栏   ui/su-tabbar/su-tabbar.vue                       DiyEditor/components/mobile/TabBar\n\n“顶部导航栏”会有遮挡问题？\n\n如果你选择他的样式是「沉浸式」，就会出现这个情况，这个是符合预期的。想要解决，就换成「标准」。具体如下几个帖子，也有提到：\n\n * https://t.zsxq.com/o7s2Y\n * https://t.zsxq.com/DhPZF\n\n另外，顶部导航是常态存在的，不会随着滚动下面进行隐藏。如果需要隐藏，需要自己二次开发。\n\n\n# 基础组件\n\n       UNI-APP 地址                                     管理后台地址\n搜索框    components/s-search-block/s-search-block.vue   DiyEditor/components/mobile/SearchBar\n公告栏    components/s-notice-block/s-notice-block.vue   DiyEditor/components/mobile/NoticeBar\n菜单导航   components/s-menu-button/s-menu-button.vue     DiyEditor/components/mobile/MenuSwiper\n宫格导航   components/s-menu-grid/s-menu-grid.vue         DiyEditor/components/mobile/MenuGrid\n列表导航   components/s-menu-list/s-menu-list.vue         DiyEditor/components/mobile/MenuList\n弹窗广告   components/s-popup-image/s-popup-image.vue     DiyEditor/components/mobile/Popover\n悬浮按钮   components/s-float-menu/s-float-menu.vue       DiyEditor/components/mobile/FloatingActionButton\n\n\n# 图文组件\n\n       UNI-APP 地址                                       管理后台地址\n图片展示   components/s-image-block/s-image-block.vue       DiyEditor/components/mobile/ImageBar\n轮播图    components/s-image-banner/s-image-banner.vue     DiyEditor/components/mobile/Carousel\n标题栏    components/s-title-block/s-title-block.vue       DiyEditor/components/mobile/TitleBar\n视频播放   components/s-video-block/s-video-block.vue       DiyEditor/components/mobile/VideoPlayer\n分割线    components/s-line-block/s-line-block.vue         DiyEditor/components/mobile/Divider\n广告魔方   components/s-image-cube/s-image-cube.vue         DiyEditor/components/mobile/MagicCube\n热区     components/s-hotzone-block/s-hotzone-block.vue   DiyEditor/components/mobile/HotZone\n\n\n# 商品组件\n\n       UNI-APP 地址                                       管理后台地址\n商品卡片   components/s-goods-card/s-goods-card.vue         DiyEditor/components/mobile/ProductCard\n商品栏    components/s-goods-shelves/s-goods-shelves.vue   DiyEditor/components/mobile/ProductList\n\n\n# 用户组件\n\n       UNI-APP 地址                                   管理后台地址\n用户卡片   components/s-user-card/s-user-card.vue       DiyEditor/components/mobile/UserCard\n用户订单   components/s-order-card/s-order-card.vue     DiyEditor/components/mobile/UserOrder\n用户资产   components/s-wallet-card/s-wallet-card.vue   DiyEditor/components/mobile/UserWallet\n用户卡券   components/s-coupon-card/s-coupon-card.vue   DiyEditor/components/mobile/UserCoupon\n\n\n# 营销组件\n\n       UNI-APP 地址                                         管理后台地址\n拼团     components/s-groupon-block/s-groupon-block.vue     DiyEditor/components/mobile/PromotionCombination\n秒杀     components/s-seckill-block/s-seckill-block.vue     DiyEditor/components/mobile/PromotionSeckill\n优惠劵    components/s-coupon-block/s-coupon-block.vue       DiyEditor/components/mobile/CouponCard\n营销文章   components/s-richtext-block/s-richtext-block.vue   DiyEditor/components/mobile/PromotionArticle',
            normalizedContent: '# 1. 功能介绍\n\n项目支持商城装修，通过简单的拖拉拽，即可进行 uni-app 页面的制作，最终可以在 h5、小程序进行展示。\n\n对应管理后台的 [商城系统 -> 营销中心 -> 商城装修] 菜单。目前它有两个子菜单：装修模版、装修页面。\n\n\n# 1.1 装修模版\n\n装修模版，实现对 uni-app 的首页、个人中心进行配置。\n\n① 可以新建多个装修模版，点击「使用」后，设置为当前 uni-app 默认使用。如下图所示：\n\n\n\n② 点击「装修」后，可以进行首页、个人中心设计。如下图所示：\n\n\n\n\n# 1.2 装修页面\n\n装修模版，可以简单理解它由两个装修页面组成：首页、个人中心。所以装修页面的「装修」功能，和装修模版是一致的。如下图所示：\n\n\n\n② 那么装修页面为什么要独立一个菜单呢？在某些场景下，需要制作一个广告业、活动页等等，可以通过它来实现。\n\n例如说，我们先「新建」一个装修页面，然后进行「装修」后，然后使用 uni-app 进行直接访问。访问的地址示例，/pages/index/page?id=${pageid} 。如下图所示：\n\n\n\n\n# 2. 实现原理\n\n店铺装修的实现原理并不复杂，我们将分成三部分来讲解：uni-app、管理后台、后端存储。\n\n\n# 2.1 uni-app\n\n本质上来说，uni-app 就是读取到装修配置，for 循环创建对应的组件，使用该组件对应的配置，进行渲染即可。\n\n① uni-app 前台打开时，在 sheep/index.js 的 shoproinit 方法中，会调用后端接口，获取到默认的装修模版。这样，它就获取到了装修配置。如下图所示：\n\n\n\n② 有了装修配置后，首页（pages/index/index.vue）、个人中心（pages/index/user.vue）就可以进行渲染展示。以首页举例子，它会包含多个“装修组件”，每个“装修组件”由 s-block-item 进行渲染。如下图所示：\n\n\n\n例如说，s-title-block.vue 它用于“标题栏”的展示。拿到它对应的 data 装修配置，就可以进行展示了。如下图所示：\n\n\n\n\n# 2.2 管理后台\n\n① 管理后台的 components/diyeditor 组件，实现了商城装修功能，它被装修模版的「装修」（views/mall/promotion/diy/template/decorate.vue）和装修页面的「装修」（views/mall/promotion/diy/page/decorate.vue）所使用。如下图所示：\n\n\n\n它可以分成如下三个部分所组成：\n\n * 【左边】组件区域：可选中的“装修组件”列表，由 components/diyeditor/components/componentlibrary.vue 实现\n * 【中间】设计区域：由选中的多个 components/diyeditor/components/componentcontainer.vue “装修组件”所组成\n * 【右边】属性面板：设置当前选中的“装修组件”属性，由 components/diyeditor/components/componentcontainerproperty.vue 实现\n\n② 在 components/diyeditor/components/mobile 目录下，可以看到每个“装修组件”的实现。如下图所示：\n\n\n\n③ 点击右上角的「保存」按钮，每个“装修组件”的属性会存储成对应的 json 格式，那么一个页面其实就是多个 json 组成的数组。具体的存储格式，我们放在「2.3 后端存储」小节来看。\n\n\n# 2.3 后端存储\n\n后端由 yudao-module-promotion-biz 模块的 diy 包下来实现。它有两个表：\n\n① promotion_diy_template 装修模版表，关键字段如下所示：\n\ncreate table `promotion_diy_template` (\n  `id` bigint not null auto_increment comment \'装修模板编号\',\n  `name` varchar(100) character set utf8mb4 collate utf8mb4_general_ci not null comment \'模板名称\',\n  `used` bit(1) not null default b\'0\' comment \'是否使用\',\n  `property` text character set utf8mb4 collate utf8mb4_general_ci comment \'模板属性，json 格式\',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=6 default charset=utf8mb4 collate=utf8mb4_general_ci row_format=dynamic comment=\'装修模板\';\n\n\n其中 property 是最关键字段，存储了整个 uni-app 全局的界面配置，如下所示：\n\n{\n    "page": {\n        "description": "", \n        "backgroundcolor": "#f5f5f5", \n        "backgroundimage": ""\n    }, \n    "navigationbar": {\n        "title": "页面标题", \n        "description": "", \n        "navbarheight": 35, \n        "backgroundcolor": "#f5f5f5", \n        "backgroundimage": "", \n        "styletype": "default", \n        "alwaysshow": true, \n        "showgoback": true\n    }, \n    "tabbar": {\n        "theme": "orange", \n        "style": {\n            "backgroundtype": "img", \n            "background": "", \n            "color": "#282828", \n            "activecolor": "#f37b1d"\n        }, \n        "items": [\n            {\n                "name": "首页1", \n                "link": "/", \n                "iconurl": "http://mall.yudao.iocoder.cn/static/images/1-001.png", \n                "activeiconurl": "http://mall.yudao.iocoder.cn/static/images/1-002.png"\n            }, \n            {\n                "name": "分类", \n                "link": "/pages/goods_cate/goods_cate", \n                "iconurl": "http://mall.yudao.iocoder.cn/static/images/2-001.png", \n                "activeiconurl": "http://mall.yudao.iocoder.cn/static/images/2-002.png"\n            }, \n            {\n                "name": "购物车", \n                "link": "/pages/order_addcart/order_addcart", \n                "iconurl": "http://mall.yudao.iocoder.cn/static/images/3-001.png", \n                "activeiconurl": "http://mall.yudao.iocoder.cn/static/images/3-002.png"\n            }, \n            {\n                "name": "我的", \n                "link": "/pages/user/index", \n                "iconurl": "http://mall.yudao.iocoder.cn/static/images/4-001.png", \n                "activeiconurl": "http://mall.yudao.iocoder.cn/static/images/4-002.png"\n            }\n        ]\n    }, \n    "components": [ ]\n}\n\n\n * page 属性：对应「附录」小节的“页面设置”组件，定义了整个 uni-app 页面的背景色、背景图等等\n * navigationbar 属性：对应「附录」小节的“顶部导航栏”组件，定义了 uni-app 顶部导航的背景色、高度等等\n * tabbar 属性：对应「附录」小节的“底部导航栏”组件，定义了 uni-app 底部导航（菜单）的名字、链接、icon 等等\n\n注意，后端仅仅进行存储，具体每个组件有哪些属性，本质上是前端自己所决定。\n\n那么，uni-app 首页、个人中心的装修页面，存储在哪里呢？答案在 promotion_diy_page 表。\n\n② promotion_diy_page 装修页面表，关键字段如下所示：\n\ncreate table `promotion_diy_page` (\n  `id` bigint not null auto_increment comment \'装修页面编号\',\n  `template_id` bigint default null comment \'装修模板编号\',\n  `name` varchar(100) character set utf8mb4 collate utf8mb4_general_ci not null comment \'页面名称\',\n  `property` text character set utf8mb4 collate utf8mb4_general_ci comment \'页面属性，json 格式\',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=10 default charset=utf8mb4 collate=utf8mb4_general_ci row_format=dynamic comment=\'装修页面\';\n\n\n * template_id 字段，关联对应的装修模版。当然，如果直接创建的装修页面，不会进行关联，该字段的值为空\n\n其中 property 也是最关键字段，存储了单个 uni-app 页面的界面配置，如下所示：\n\n{\n    "page": {\n        "description": "", \n        "backgroundcolor": "#f5f5f5", \n        "backgroundimage": ""\n    }, \n    "navigationbar": {\n        "title": "双 11 购物节", \n        "description": "", \n        "navbarheight": 35, \n        "backgroundcolor": "#fff", \n        "backgroundimage": "", \n        "styletype": "default", \n        "alwaysshow": true, \n        "showgoback": true\n    }, \n    "components": [\n        {\n            "id": "titlebar", \n            "property": {\n                "title": "一个不错的活动！！！", \n                "description": "副标题", \n                "titlesize": 16, \n                "descriptionsize": 12, \n                "titleweight": 400, \n                "textalign": "left", \n                "descriptionweight": 200, \n                "titlecolor": "rgba(50, 50, 51, 10)", \n                "descriptioncolor": "rgba(150, 151, 153, 10)", \n                "more": {\n                    "show": false, \n                    "type": "icon", \n                    "text": "查看更多", \n                    "url": ""\n                }, \n                "style": {\n                    "bgtype": "color", \n                    "bgcolor": "#fff"\n                }\n            }\n        },\n        {\n            "id": "couponcard", \n            "property": {\n                "columns": 1, \n                "bgimg": "", \n                "textcolor": "#e9b461", \n                "button": {\n                    "color": "#434343", \n                    "bgcolor": ""\n                }, \n                "space": 0, \n                "couponids": [\n                    2\n                ], \n                "style": {\n                    "bgtype": "color", \n                    "bgcolor": "", \n                    "marginbottom": 8\n                }\n            }\n        }\n    ]\n}\n\n\n * page 和 navigationbar 属性，和 promotion_diy_template 表的类似。但是，没有 tabbar 属性，因为该属性属于全局配置\n * components 属性，存储每个“装修组件”的 json 配置，注意它是一个数组。对应到「附录」小节的话，就是『基础组件』、『图文组件』、『商品组件』、『用户组件』、『营销组件』\n\n\n# 附录：组件对应关系\n\n管理后台与 uni-app 组件的对应关系，方便你学习研究~~\n\n\n# 布局组件\n\n        uni-app 地址                                       管理后台地址\n页面设置    pages/index/index.vue 或 /pages/index/user.vue    diyeditor/components/mobile/pageconfig\n顶部导航栏   components/s-custom-navbar/s-custom-navbar.vue   diyeditor/components/mobile/navigationbar\n底部导航栏   ui/su-tabbar/su-tabbar.vue                       diyeditor/components/mobile/tabbar\n\n“顶部导航栏”会有遮挡问题？\n\n如果你选择他的样式是「沉浸式」，就会出现这个情况，这个是符合预期的。想要解决，就换成「标准」。具体如下几个帖子，也有提到：\n\n * https://t.zsxq.com/o7s2y\n * https://t.zsxq.com/dhpzf\n\n另外，顶部导航是常态存在的，不会随着滚动下面进行隐藏。如果需要隐藏，需要自己二次开发。\n\n\n# 基础组件\n\n       uni-app 地址                                     管理后台地址\n搜索框    components/s-search-block/s-search-block.vue   diyeditor/components/mobile/searchbar\n公告栏    components/s-notice-block/s-notice-block.vue   diyeditor/components/mobile/noticebar\n菜单导航   components/s-menu-button/s-menu-button.vue     diyeditor/components/mobile/menuswiper\n宫格导航   components/s-menu-grid/s-menu-grid.vue         diyeditor/components/mobile/menugrid\n列表导航   components/s-menu-list/s-menu-list.vue         diyeditor/components/mobile/menulist\n弹窗广告   components/s-popup-image/s-popup-image.vue     diyeditor/components/mobile/popover\n悬浮按钮   components/s-float-menu/s-float-menu.vue       diyeditor/components/mobile/floatingactionbutton\n\n\n# 图文组件\n\n       uni-app 地址                                       管理后台地址\n图片展示   components/s-image-block/s-image-block.vue       diyeditor/components/mobile/imagebar\n轮播图    components/s-image-banner/s-image-banner.vue     diyeditor/components/mobile/carousel\n标题栏    components/s-title-block/s-title-block.vue       diyeditor/components/mobile/titlebar\n视频播放   components/s-video-block/s-video-block.vue       diyeditor/components/mobile/videoplayer\n分割线    components/s-line-block/s-line-block.vue         diyeditor/components/mobile/divider\n广告魔方   components/s-image-cube/s-image-cube.vue         diyeditor/components/mobile/magiccube\n热区     components/s-hotzone-block/s-hotzone-block.vue   diyeditor/components/mobile/hotzone\n\n\n# 商品组件\n\n       uni-app 地址                                       管理后台地址\n商品卡片   components/s-goods-card/s-goods-card.vue         diyeditor/components/mobile/productcard\n商品栏    components/s-goods-shelves/s-goods-shelves.vue   diyeditor/components/mobile/productlist\n\n\n# 用户组件\n\n       uni-app 地址                                   管理后台地址\n用户卡片   components/s-user-card/s-user-card.vue       diyeditor/components/mobile/usercard\n用户订单   components/s-order-card/s-order-card.vue     diyeditor/components/mobile/userorder\n用户资产   components/s-wallet-card/s-wallet-card.vue   diyeditor/components/mobile/userwallet\n用户卡券   components/s-coupon-card/s-coupon-card.vue   diyeditor/components/mobile/usercoupon\n\n\n# 营销组件\n\n       uni-app 地址                                         管理后台地址\n拼团     components/s-groupon-block/s-groupon-block.vue     diyeditor/components/mobile/promotioncombination\n秒杀     components/s-seckill-block/s-seckill-block.vue     diyeditor/components/mobile/promotionseckill\n优惠劵    components/s-coupon-block/s-coupon-block.vue       diyeditor/components/mobile/couponcard\n营销文章   components/s-richtext-block/s-richtext-block.vue   diyeditor/components/mobile/promotionarticle',
            charsets: {
                cjk: !0
            }
        }, {
            title: "在线客服",
            frontmatter: {
                title: "在线客服",
                permalink: "/mall/kefu",
                date: "2024-07-22T09:55:04.000Z"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/14.%E5%95%86%E5%9F%8E%E6%89%8B%E5%86%8C/04.%E5%9C%A8%E7%BA%BF%E5%AE%A2%E6%9C%8D.html",
            relativePath: "01.开发指南/14.商城手册/04.在线客服.md",
            key: "v-2961facf",
            path: "/mall/kefu/",
            headers: [{
                level: 2,
                title: "1. 功能介绍",
                slug: "_1-功能介绍",
                normalizedTitle: "1. 功能介绍",
                charIndex: 81
            }, {
                level: 3,
                title: "1.1 uni-app",
                slug: "_1-1-uni-app",
                normalizedTitle: "1.1 uni-app",
                charIndex: 155
            }, {
                level: 3,
                title: "1.2 管理后台",
                slug: "_1-2-管理后台",
                normalizedTitle: "1.2 管理后台",
                charIndex: 254
            }, {
                level: 2,
                title: "2. 实现原理",
                slug: "_2-实现原理",
                normalizedTitle: "2. 实现原理",
                charIndex: 309
            }, {
                level: 3,
                title: "2.1 消息通信",
                slug: "_2-1-消息通信",
                normalizedTitle: "2.1 消息通信",
                charIndex: 358
            }, {
                level: 3,
                title: "2.2 消息存储",
                slug: "_2-2-消息存储",
                normalizedTitle: "2.2 消息存储",
                charIndex: 868
            }],
            headersStr: "1. 功能介绍 1.1 uni-app 1.2 管理后台 2. 实现原理 2.1 消息通信 2.2 消息存储",
            content: "友情提示：\n\n该功能会在 V2.2.0 版本上线，提供一个基础的在线客服功能。\n\n预计在 V2.4.0 版本上，会重点打磨下界面，现在做的比较朴素~~~\n\n\n# 1. 功能介绍\n\n项目支持在线客服，实现会员和管理员之间的实时聊天。\n\n聊天消息的内容，可以是文字、图标、表情，也可以是商品、订单等信息。\n\n\n# 1.1 uni-app\n\n会员的在线客服界面，可以访问商品详情的右下角的【客服】按钮，如下图所示：\n\n\n\n该界面对应 uni-app 的 /pages/chat/index.vue 路径。\n\n\n# 1.2 管理后台\n\n管理员的在线客服界面，对应 [商城系统 -> 客服中心] 菜单，如下图所示：\n\n\n\n\n# 2. 实现原理\n\n本小节，我们主要讲解在线客服的实现原理，主要涉及消息的通信、存储。\n\n\n\n\n# 2.1 消息通信\n\n友情提示：\n\n你需要先阅读 《WebSocket 实时通信》 文档。\n\n在线客服采用 WebSocket + HTTP 的方式，实现消息的实时通信：\n\n * 消息上行：指的是“前端”发送消息给“后端”，使用 HTTP。\n * 消息下行：指的是“后端”发送消息给“前端”，使用 WebSocket。\n\n① 消息上行（消息发送）：\n\n * 会员调用 AppKeFuMessageController 的 #send(...) 方法，发送消息给管理员。\n * 管理员调用 KeFuMessageController 的 #send(...) 方法，发送消息给会员。\n\n② 消息下行（消息推送）：\n\n后端在被前端 HTTP 调用发送消息后，会通过 WebSocket 推送消息给对端的前端。如下图所示：\n\n\n\n\n\n无论是推送给会员，还是推送给管理员，都是通过 WebSocketSenderApi 的 #sendObject(...) 方法，实现消息的推送。\n\nps：不过有一点要注意，目前一个会员的消息，是所有管理员都可以回复，所以在推送给管理员时，没有指定具体的管理员编号，而是所有管理员！！！\n\n\n# 2.2 消息存储\n\n后端由 yudao-module-promotion-biz 模块的 kefu 包下来实现。它有两个表：\n\n * promotion_kefu_conversation 表：客服会话\n * promotion_kefu_message 表：客服消息\n\n# 2.2.1 客服会话表\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `promotion_kefu_conversation` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  \n  `user_id` bigint NOT NULL COMMENT '会话所属用户',\n  \n  `last_message_time` datetime NOT NULL COMMENT '最后聊天时间',\n  `last_message_content` varchar(2048) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '最后聊天内容',\n  `last_message_content_type` int NOT NULL COMMENT '最后发送的消息类型',\n  \n  `admin_pinned` bit(1) NOT NULL DEFAULT b'0' COMMENT '管理端置顶',\n  \n  `user_deleted` bit(1) NOT NULL DEFAULT b'0' COMMENT '用户是否可见',\n  `admin_deleted` bit(1) NOT NULL DEFAULT b'0' COMMENT '管理员是否可见',\n  \n  `admin_unread_message_count` int NOT NULL COMMENT '管理员未读消息数',\n  \n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC COMMENT='客服会话';\n\n\n① user_id 字段：表示会话所属会员用户，即会员的编号。简单来说，每个会员用户，对应一个会话。\n\n② last_message_time、last_message_content、last_message_content_type 字段：表示最后一条消息的时间、内容、类型。目的是，用于会话列表的展示。\n\n\n\n③ admin_pinned 字段：表示管理员是否置顶。如果置顶，那么会话列表中，会优先展示。\n\n\n\n由于会员就一个会话，所以他无法置顶，也就没有对应的这个字段！\n\n④ user_deleted、admin_deleted 字段：分别表示用户、管理员是否删除。如果删除，那么会话列表中，不再展示。\n\n⑤ admin_unread_message_count 字段：表示管理员未读消息数。如果有未读消息，那么会话列表中，会显示未读消息数。\n\n\n\n由于会员就一个会话，暂时没有未读消息数的展示，所以对应的这个字段！\n\n# 2.2.2 客服消息表\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `promotion_kefu_message` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  \n  `conversation_id` bigint NOT NULL COMMENT '会话编号',\n  \n  `sender_id` bigint NOT NULL COMMENT '发送人编号',\n  `sender_type` int NOT NULL COMMENT '发送人类型',\n  \n  `receiver_id` bigint DEFAULT NULL COMMENT '接收人编号',\n  `receiver_type` int DEFAULT NULL COMMENT '接收人类型',\n  \n  `content_type` int NOT NULL COMMENT '消息类型',\n  `content` varchar(2048) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '消息',\n  \n  `read_status` bit(1) NOT NULL DEFAULT b'0' COMMENT '是否已读',\n\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=25 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC COMMENT='客服消息';\n\n\n① conversation_id 字段：表示消息所属会话，即会话的编号。简单来说，每个会话，对应多条消息。\n\n② sender_id、sender_type 字段：表示发送人的编号、类型。发送人有两种类型，分别是会员和管理员。\n\n③ receiver_id、receiver_type 字段：表示接收人的编号、类型。接收人有两种类型，分别是会员和管理员。\n\n④ content_type 字段：表示消息的类型，对应 KeFuMessageContentTypeEnum 枚举类。目前支持文本、图片、商品、订单等类型。\n\ncontent 字段：表示消息的内容，根据消息类型的不同，内容也不同。\n\n⑤ read_status 字段：表示消息是否已读。如果未读，那么会话列表中，会显示未读消息数。",
            normalizedContent: "友情提示：\n\n该功能会在 v2.2.0 版本上线，提供一个基础的在线客服功能。\n\n预计在 v2.4.0 版本上，会重点打磨下界面，现在做的比较朴素~~~\n\n\n# 1. 功能介绍\n\n项目支持在线客服，实现会员和管理员之间的实时聊天。\n\n聊天消息的内容，可以是文字、图标、表情，也可以是商品、订单等信息。\n\n\n# 1.1 uni-app\n\n会员的在线客服界面，可以访问商品详情的右下角的【客服】按钮，如下图所示：\n\n\n\n该界面对应 uni-app 的 /pages/chat/index.vue 路径。\n\n\n# 1.2 管理后台\n\n管理员的在线客服界面，对应 [商城系统 -> 客服中心] 菜单，如下图所示：\n\n\n\n\n# 2. 实现原理\n\n本小节，我们主要讲解在线客服的实现原理，主要涉及消息的通信、存储。\n\n\n\n\n# 2.1 消息通信\n\n友情提示：\n\n你需要先阅读 《websocket 实时通信》 文档。\n\n在线客服采用 websocket + http 的方式，实现消息的实时通信：\n\n * 消息上行：指的是“前端”发送消息给“后端”，使用 http。\n * 消息下行：指的是“后端”发送消息给“前端”，使用 websocket。\n\n① 消息上行（消息发送）：\n\n * 会员调用 appkefumessagecontroller 的 #send(...) 方法，发送消息给管理员。\n * 管理员调用 kefumessagecontroller 的 #send(...) 方法，发送消息给会员。\n\n② 消息下行（消息推送）：\n\n后端在被前端 http 调用发送消息后，会通过 websocket 推送消息给对端的前端。如下图所示：\n\n\n\n\n\n无论是推送给会员，还是推送给管理员，都是通过 websocketsenderapi 的 #sendobject(...) 方法，实现消息的推送。\n\nps：不过有一点要注意，目前一个会员的消息，是所有管理员都可以回复，所以在推送给管理员时，没有指定具体的管理员编号，而是所有管理员！！！\n\n\n# 2.2 消息存储\n\n后端由 yudao-module-promotion-biz 模块的 kefu 包下来实现。它有两个表：\n\n * promotion_kefu_conversation 表：客服会话\n * promotion_kefu_message 表：客服消息\n\n# 2.2.1 客服会话表\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `promotion_kefu_conversation` (\n  `id` bigint not null auto_increment comment '编号',\n  \n  `user_id` bigint not null comment '会话所属用户',\n  \n  `last_message_time` datetime not null comment '最后聊天时间',\n  `last_message_content` varchar(2048) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '最后聊天内容',\n  `last_message_content_type` int not null comment '最后发送的消息类型',\n  \n  `admin_pinned` bit(1) not null default b'0' comment '管理端置顶',\n  \n  `user_deleted` bit(1) not null default b'0' comment '用户是否可见',\n  `admin_deleted` bit(1) not null default b'0' comment '管理员是否可见',\n  \n  `admin_unread_message_count` int not null comment '管理员未读消息数',\n  \n  primary key (`id`) using btree\n) engine=innodb auto_increment=3 default charset=utf8mb4 collate=utf8mb4_unicode_ci row_format=dynamic comment='客服会话';\n\n\n① user_id 字段：表示会话所属会员用户，即会员的编号。简单来说，每个会员用户，对应一个会话。\n\n② last_message_time、last_message_content、last_message_content_type 字段：表示最后一条消息的时间、内容、类型。目的是，用于会话列表的展示。\n\n\n\n③ admin_pinned 字段：表示管理员是否置顶。如果置顶，那么会话列表中，会优先展示。\n\n\n\n由于会员就一个会话，所以他无法置顶，也就没有对应的这个字段！\n\n④ user_deleted、admin_deleted 字段：分别表示用户、管理员是否删除。如果删除，那么会话列表中，不再展示。\n\n⑤ admin_unread_message_count 字段：表示管理员未读消息数。如果有未读消息，那么会话列表中，会显示未读消息数。\n\n\n\n由于会员就一个会话，暂时没有未读消息数的展示，所以对应的这个字段！\n\n# 2.2.2 客服消息表\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `promotion_kefu_message` (\n  `id` bigint not null auto_increment comment '编号',\n  \n  `conversation_id` bigint not null comment '会话编号',\n  \n  `sender_id` bigint not null comment '发送人编号',\n  `sender_type` int not null comment '发送人类型',\n  \n  `receiver_id` bigint default null comment '接收人编号',\n  `receiver_type` int default null comment '接收人类型',\n  \n  `content_type` int not null comment '消息类型',\n  `content` varchar(2048) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '消息',\n  \n  `read_status` bit(1) not null default b'0' comment '是否已读',\n\n  primary key (`id`) using btree\n) engine=innodb auto_increment=25 default charset=utf8mb4 collate=utf8mb4_unicode_ci row_format=dynamic comment='客服消息';\n\n\n① conversation_id 字段：表示消息所属会话，即会话的编号。简单来说，每个会话，对应多条消息。\n\n② sender_id、sender_type 字段：表示发送人的编号、类型。发送人有两种类型，分别是会员和管理员。\n\n③ receiver_id、receiver_type 字段：表示接收人的编号、类型。接收人有两种类型，分别是会员和管理员。\n\n④ content_type 字段：表示消息的类型，对应 kefumessagecontenttypeenum 枚举类。目前支持文本、图片、商品、订单等类型。\n\ncontent 字段：表示消息的内容，根据消息类型的不同，内容也不同。\n\n⑤ read_status 字段：表示消息是否已读。如果未读，那么会话列表中，会显示未读消息数。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【商品】商品分类",
            frontmatter: {
                title: "【商品】商品分类",
                date: "2024-01-13T22:59:06.000Z",
                permalink: "/mall/product-category/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/14.%E5%95%86%E5%9F%8E%E6%89%8B%E5%86%8C/10.%E3%80%90%E5%95%86%E5%93%81%E3%80%91%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB.html",
            relativePath: "01.开发指南/14.商城手册/10.【商品】商品分类.md",
            key: "v-2f67cc3d",
            path: "/mall/product-category/",
            headers: [{
                level: 2,
                title: "1. 表结构",
                slug: "_1-表结构",
                normalizedTitle: "1. 表结构",
                charIndex: 2
            }, {
                level: 2,
                title: "2. 管理后台",
                slug: "_2-管理后台",
                normalizedTitle: "2. 管理后台",
                charIndex: 773
            }, {
                level: 2,
                title: "3. 移动端",
                slug: "_3-移动端",
                normalizedTitle: "3. 移动端",
                charIndex: 878
            }],
            headersStr: "1. 表结构 2. 管理后台 3. 移动端",
            content: "# 1. 表结构\n\n商品分类，由 yudao-module-product-biz 后端模块的 category 包实现。表结构如下：\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `product_category` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '分类编号',\n  `parent_id` bigint NOT NULL COMMENT '父分类编号',\n  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '分类名称',\n  `pic_url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '移动端分类图',\n  `sort` int DEFAULT '0' COMMENT '分类排序',\n  `status` tinyint NOT NULL COMMENT '开启状态',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=60 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='商品分类';\n\n\n① 分类目前支持 2 级分类，即 parent_id 为 0 的是一级分类，否则是二级分类。\n\n② pic_url 分类图片，一级、二级分类都需要设置。\n\n\n# 2. 管理后台\n\n对应 [商城系统 -> 商品中心 -> 商品分类] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/mall/product/category 目录。\n\n\n\n\n# 3. 移动端\n\n对应 uni-app 底部的 [分类] 导航，对应 yudao-mall-uniapp 项目的 pages/index/category.vue 页面。\n\n\n\n分类目前有 first_one、first_two、second_one 三种展示风格，可以手动进行修改。如下图所示：\n\n",
            normalizedContent: "# 1. 表结构\n\n商品分类，由 yudao-module-product-biz 后端模块的 category 包实现。表结构如下：\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `product_category` (\n  `id` bigint not null auto_increment comment '分类编号',\n  `parent_id` bigint not null comment '父分类编号',\n  `name` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '分类名称',\n  `pic_url` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '移动端分类图',\n  `sort` int default '0' comment '分类排序',\n  `status` tinyint not null comment '开启状态',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=60 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='商品分类';\n\n\n① 分类目前支持 2 级分类，即 parent_id 为 0 的是一级分类，否则是二级分类。\n\n② pic_url 分类图片，一级、二级分类都需要设置。\n\n\n# 2. 管理后台\n\n对应 [商城系统 -> 商品中心 -> 商品分类] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/mall/product/category 目录。\n\n\n\n\n# 3. 移动端\n\n对应 uni-app 底部的 [分类] 导航，对应 yudao-mall-uniapp 项目的 pages/index/category.vue 页面。\n\n\n\n分类目前有 first_one、first_two、second_one 三种展示风格，可以手动进行修改。如下图所示：\n\n",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【商品】商品属性",
            frontmatter: {
                title: "【商品】商品属性",
                date: "2024-01-13T23:24:47.000Z",
                permalink: "/mall/product-property/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/14.%E5%95%86%E5%9F%8E%E6%89%8B%E5%86%8C/11.%E3%80%90%E5%95%86%E5%93%81%E3%80%91%E5%95%86%E5%93%81%E5%B1%9E%E6%80%A7.html",
            relativePath: "01.开发指南/14.商城手册/11.【商品】商品属性.md",
            key: "v-05be4724",
            path: "/mall/product-property/",
            headers: [{
                level: 2,
                title: "1. 表结构",
                slug: "_1-表结构",
                normalizedTitle: "1. 表结构",
                charIndex: 2
            }, {
                level: 3,
                title: "1.1 属性项",
                slug: "_1-1-属性项",
                normalizedTitle: "1.1 属性项",
                charIndex: 110
            }, {
                level: 3,
                title: "1.2 属性值",
                slug: "_1-2-属性值",
                normalizedTitle: "1.2 属性值",
                charIndex: 774
            }, {
                level: 2,
                title: "2. 管理后台",
                slug: "_2-管理后台",
                normalizedTitle: "2. 管理后台",
                charIndex: 1364
            }, {
                level: 3,
                title: "1.1 属性项",
                slug: "_1-1-属性项-2",
                normalizedTitle: "1.1 属性项",
                charIndex: 110
            }, {
                level: 3,
                title: "1.2 属性值",
                slug: "_1-2-属性值-2",
                normalizedTitle: "1.2 属性值",
                charIndex: 774
            }, {
                level: 2,
                title: "3. 移动端",
                slug: "_3-移动端",
                normalizedTitle: "3. 移动端",
                charIndex: 1829
            }],
            headersStr: "1. 表结构 1.1 属性项 1.2 属性值 2. 管理后台 1.1 属性项 1.2 属性值 3. 移动端",
            content: "# 1. 表结构\n\n商品属性，由 yudao-module-product-biz 后端模块的 property 包实现，分成属性【项】和属性【值】两个表。\n\n\n\n整体的设计上，参考有赞、淘宝等电商平台的设计。\n\n\n# 1.1 属性项\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `product_property` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  `name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '名称',\n  `status` tinyint DEFAULT NULL COMMENT '状态',\n  `remark` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '备注',\n  PRIMARY KEY (`id`) USING BTREE,\n  KEY `idx_name` (`name`(32)) USING BTREE COMMENT '规格名称索引'\n) ENGINE=InnoDB AUTO_INCREMENT=14 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT='商品属性项';\n\n\n属性【项】只是基于 name 字段存储一条唯一记录，具体商品怎么使用它，可以看 《【商品】商品信息》 文档。\n\n\n# 1.2 属性值\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `product_property_value` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  `property_id` bigint DEFAULT NULL COMMENT '属性项的编号',\n  `name` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '名称',\n  `status` tinyint DEFAULT NULL COMMENT '状态',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=26 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT='商品属性值';\n\n\n属性【值】只是基于 property_id + name 字段存储一条唯一记录，具体商品怎么使用它，可以看 《【【商品】商品 SPU 与 SKU》 文档。\n\n\n\n\n# 2. 管理后台\n\n\n# 1.1 属性项\n\n对应 [商城系统 -> 商品中心 -> 商品属性] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/mall/product/property 目录。\n\n\n\n注意，如果修改了属性【项】的名字，使用到该属性【项】的商品也会跟着改变，这也是为什么属性【项】统一维护的原因。\n\n例如说，修改了 颜色 属性【项】的名字为 颜色分类，那么使用到 颜色 属性【项】的商品，都会变成 颜色分类 属性【项】。\n\n\n# 1.2 属性值\n\n点击属性【项】的 「属性值」 按钮，进入属性【值】管理页面，对应 yudao-ui-admin-vue3 项目的 @/views/mall/product/property/value 目录。\n\n\n\n注意，如果修改了属性【值】的名字，使用到该属性【值】的商品也会跟着改变，这也是为什么属性【值】统一维护的原因。\n\n例如说，修改了 红色 属性【值】的名字为 淡红色，那么使用到 红色 属性【值】的商品，都会变成 淡红色 属性【值】。\n\n\n# 3. 移动端\n\n商品属性在移动端，主要是在商品详情页展示，如下图所示：\n\n\n\n暂时没有对应的具体 Vue 页面或是组件，后续放在 《【商品】商品 SPU 与 SKU》 文档中进行说明。",
            normalizedContent: "# 1. 表结构\n\n商品属性，由 yudao-module-product-biz 后端模块的 property 包实现，分成属性【项】和属性【值】两个表。\n\n\n\n整体的设计上，参考有赞、淘宝等电商平台的设计。\n\n\n# 1.1 属性项\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `product_property` (\n  `id` bigint not null auto_increment comment '编号',\n  `name` varchar(64) character set utf8mb4 collate utf8mb4_general_ci default null comment '名称',\n  `status` tinyint default null comment '状态',\n  `remark` varchar(128) character set utf8mb4 collate utf8mb4_general_ci default null comment '备注',\n  primary key (`id`) using btree,\n  key `idx_name` (`name`(32)) using btree comment '规格名称索引'\n) engine=innodb auto_increment=14 default charset=utf8mb4 collate=utf8mb4_general_ci comment='商品属性项';\n\n\n属性【项】只是基于 name 字段存储一条唯一记录，具体商品怎么使用它，可以看 《【商品】商品信息》 文档。\n\n\n# 1.2 属性值\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `product_property_value` (\n  `id` bigint not null auto_increment comment '编号',\n  `property_id` bigint default null comment '属性项的编号',\n  `name` varchar(128) character set utf8mb4 collate utf8mb4_general_ci default null comment '名称',\n  `status` tinyint default null comment '状态',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=26 default charset=utf8mb4 collate=utf8mb4_general_ci comment='商品属性值';\n\n\n属性【值】只是基于 property_id + name 字段存储一条唯一记录，具体商品怎么使用它，可以看 《【【商品】商品 spu 与 sku》 文档。\n\n\n\n\n# 2. 管理后台\n\n\n# 1.1 属性项\n\n对应 [商城系统 -> 商品中心 -> 商品属性] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/mall/product/property 目录。\n\n\n\n注意，如果修改了属性【项】的名字，使用到该属性【项】的商品也会跟着改变，这也是为什么属性【项】统一维护的原因。\n\n例如说，修改了 颜色 属性【项】的名字为 颜色分类，那么使用到 颜色 属性【项】的商品，都会变成 颜色分类 属性【项】。\n\n\n# 1.2 属性值\n\n点击属性【项】的 「属性值」 按钮，进入属性【值】管理页面，对应 yudao-ui-admin-vue3 项目的 @/views/mall/product/property/value 目录。\n\n\n\n注意，如果修改了属性【值】的名字，使用到该属性【值】的商品也会跟着改变，这也是为什么属性【值】统一维护的原因。\n\n例如说，修改了 红色 属性【值】的名字为 淡红色，那么使用到 红色 属性【值】的商品，都会变成 淡红色 属性【值】。\n\n\n# 3. 移动端\n\n商品属性在移动端，主要是在商品详情页展示，如下图所示：\n\n\n\n暂时没有对应的具体 vue 页面或是组件，后续放在 《【商品】商品 spu 与 sku》 文档中进行说明。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【商品】商品 SPU 与 SKU",
            frontmatter: {
                title: "【商品】商品 SPU 与 SKU",
                date: "2024-01-14T00:04:00.000Z",
                permalink: "/mall/product-spu-sku/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/14.%E5%95%86%E5%9F%8E%E6%89%8B%E5%86%8C/12.%E3%80%90%E5%95%86%E5%93%81%E3%80%91%E5%95%86%E5%93%81%20SPU%20%E4%B8%8E%20SKU.html",
            relativePath: "01.开发指南/14.商城手册/12.【商品】商品 SPU 与 SKU.md",
            key: "v-37a586a9",
            path: "/mall/product-spu-sku/",
            headers: [{
                level: 2,
                title: "1. 表结构",
                slug: "_1-表结构",
                normalizedTitle: "1. 表结构",
                charIndex: 38
            }, {
                level: 3,
                title: "1.1 商品 SKU",
                slug: "_1-1-商品-sku",
                normalizedTitle: "1.1 商品 sku",
                charIndex: 132
            }, {
                level: 3,
                title: "1.2 商品 SPU",
                slug: "_1-2-商品-spu",
                normalizedTitle: "1.2 商品 spu",
                charIndex: 2311
            }, {
                level: 2,
                title: "2. 管理后台",
                slug: "_2-管理后台",
                normalizedTitle: "2. 管理后台",
                charIndex: 5293
            }, {
                level: 3,
                title: "2.1 商品列表",
                slug: "_2-1-商品列表",
                normalizedTitle: "2.1 商品列表",
                charIndex: 5305
            }, {
                level: 3,
                title: "2.2 商品发布",
                slug: "_2-2-商品发布",
                normalizedTitle: "2.2 商品发布",
                charIndex: 5406
            }, {
                level: 2,
                title: "3. 移动端",
                slug: "_3-移动端",
                normalizedTitle: "3. 移动端",
                charIndex: 5822
            }, {
                level: 3,
                title: "3.1 商品列表",
                slug: "_3-1-商品列表",
                normalizedTitle: "3.1 商品列表",
                charIndex: 5900
            }, {
                level: 3,
                title: "3.2 商品详情",
                slug: "_3-2-商品详情",
                normalizedTitle: "3.2 商品详情",
                charIndex: 5961
            }, {
                level: 2,
                title: "4. 社区贡献的商品相关",
                slug: "_4-社区贡献的商品相关",
                normalizedTitle: "4. 社区贡献的商品相关",
                charIndex: 6222
            }],
            headersStr: "1. 表结构 1.1 商品 SKU 1.2 商品 SPU 2. 管理后台 2.1 商品列表 2.2 商品发布 3. 移动端 3.1 商品列表 3.2 商品详情 4. 社区贡献的商品相关",
            content: "> 参考 《产品 SKU 是什么意思？与之相关的还有哪些？》 整理\n\n\n# 1. 表结构\n\n商品 SPU 与 SKU，由 yudao-module-product-biz 后端模块的 spu、sku 包实现，分成商品 SPU 和商品 SKU 两个表。\n\n\n\n\n# 1.1 商品 SKU\n\nSKU：Stock Keeping Unit\n\n中文翻译为库存单位。SKU 从库存视角，以库存进出为单位，可以是件、瓶、箱等等。\n\n例如，iPhone 手机，按照规格( 颜色 + 内存 )可以组合出如下多个 SKU ：\n\nSKU   颜色   内存\nA     白色   16G\nB     白色   64G\nC     黑色   16G\nD     黑色   64G\n\n可以看出，颜色（白色、黑色）与内存（16G、64G）组合排列出四种 iPhone SKU。\n\n最终 SKU 表结构如下：\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `product_sku` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键',\n  \n  `spu_id` bigint NOT NULL COMMENT 'spu编号',\n  \n  `properties` varchar(512) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '属性数组，JSON 格式 [{propertId: , valueId: }, {propertId: , valueId: }]',\n  \n  `price` int NOT NULL DEFAULT '-1' COMMENT '商品价格，单位：分',\n  `market_price` int DEFAULT NULL COMMENT '市场价，单位：分',\n  `cost_price` int NOT NULL DEFAULT '-1' COMMENT '成本价，单位： 分',\n  `bar_code` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT 'SKU 的条形码',\n  `pic_url` varchar(256) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '图片地址',\n  `stock` int DEFAULT NULL COMMENT '库存',\n  `weight` double DEFAULT NULL COMMENT '商品重量，单位：kg 千克',\n  `volume` double DEFAULT NULL COMMENT '商品体积，单位：m^3 平米',\n  \n  `first_brokerage_price` int DEFAULT NULL COMMENT '一级分销的佣金，单位：分',\n  `second_brokerage_price` int DEFAULT NULL COMMENT '二级分销的佣金，单位：分',\n  \n  `sales_count` int DEFAULT NULL COMMENT '商品销量',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=30 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='商品sku';\n\n\n① spu_id 字段：商品 SPU 的编号，关联 product_spu 表的 id 字段。\n\n② properties 字段：商品属性，JSON 格式，例如：\n\n\n\n[\n  {\n    \"propertyId\": 1,\n    \"propertyName\": \"颜色\",\n    \"valueId\": 5,\n    \"valueName\": \"黑色\"\n  },\n  {\n    \"propertyId\": 3,\n    \"propertyName\": \"版本\",\n    \"valueId\": 8,\n    \"valueName\": \"CH510\"\n  }\n]\n\n\n很明显，property_id 对应 product_property 表的 id 字段，value_id 对应 product_property_value 表的 id 字段。\n\n那么为什么要冗余 propertyName、valueName 字段呢？主要是为了方便查询，不用再关联 product_property、product_property_value 表，嘿嘿~\n\n③ price、market_price、cost_price、bar_code、weight、volume、pic_url 字段，都是商品 SKU 的基本信息。\n\n④ sales_count 字段：商品销量，每次用户下单时，更新该字段。\n\n⑤ first_brokerage_price、second_brokerage_price 字段：一级分销、二级分销的佣金，可能未来会挪到【营销】模块下，目前不用特别关注。\n\n\n# 1.2 商品 SPU\n\nSPU：Standard Product Unit\n\n中文翻译为标准产品单位。SPU 从产品视角，是产品信息聚合的最小单位，是一组可复用、易检索的标准化信息的集合，该集合描述了一个产品的特性。通俗点讲，属性值、特性相同的商品就可以被称为一个 SPU。\n\n例如 iPhone 14 就是一个 SPU，iPhone 14 Plus 也是一个 SPU ，这个与商家无关，与颜色、款式、套餐等规格无关。\n\n商家出售某个 SPU，那么这就是一个商品。商品在 SPU 之上，增加了销售价格、运费等等信息。另外，一个商品可以包含多个 SKU。\n\n最终 SPU 表结构如下：\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `product_spu` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '商品 SPU 编号，自增',\n  `name` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '商品名称',\n  `keyword` varchar(256) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '关键字',\n  `introduction` varchar(256) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '商品简介',\n  `description` text CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci COMMENT '商品详情',\n  `category_id` bigint NOT NULL COMMENT '商品分类编号',\n  `brand_id` int DEFAULT NULL COMMENT '商品品牌编号',\n  `pic_url` varchar(256) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '商品封面图',\n  `slider_pic_urls` varchar(2000) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT '' COMMENT '商品轮播图地址\\n 数组，以逗号分隔\\n 最多上传15张',\n  \n  `status` tinyint NOT NULL COMMENT '商品状态: 0 上架（开启） 1 下架（禁用）-1 回收',\n  \n  `spec_type` bit(1) DEFAULT NULL COMMENT '规格类型：0 单规格 1 多规格',\n  `price` int NOT NULL DEFAULT '-1' COMMENT '商品价格，单位使用：分',\n  `market_price` int DEFAULT NULL COMMENT '市场价，单位使用：分',\n  `cost_price` int NOT NULL DEFAULT '-1' COMMENT '成本价，单位： 分',\n  `stock` int NOT NULL DEFAULT '0' COMMENT '库存',\n  \n  `delivery_types` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '配送方式数组',\n  `delivery_template_id` bigint DEFAULT NULL COMMENT '物流配置模板编号',\n  \n  `give_integral` int NOT NULL DEFAULT '0' COMMENT '赠送积分',\n  `sales_count` int DEFAULT '0' COMMENT '商品销量',\n  `virtual_sales_count` int DEFAULT '0' COMMENT '虚拟销量',\n  `browse_count` int DEFAULT '0' COMMENT '商品点击量',\n  `sort` int NOT NULL DEFAULT '0' COMMENT '排序字段',\n\n  `sub_commission_type` bit(1) DEFAULT NULL COMMENT '分销类型',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=640 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='商品spu';\n\n\n① 【基础设置】name、keyword、introduction、description、category_id、brand_id、pic_url、slider_pic_urls 字段：商品 SPU 的基本信息。\n\n\n\n② status 字段：商品状态，1 上架（开启）、0 下架（禁用）、-1 回收，用户在 uni-app 看到的商品，只有 status 为 1 的商品。\n\n③ 【库存价格】spec_type 字段：规格类型，false 单规格、true 多规格。要注意，即使是单规格，也会创建一个 SKU，这个 SKU 的 properties 字段为“默认”数组 [{\"propertyId\":0,\"propertyName\":\"默认\",\"valueId\":0,\"valueName\":\"默认\"}]。\n\nprice、market_price、cost_price 字段：取对应 SKU 的最小值。stock 字段：取对应 SKU 库存的累加值。\n\n\n\n④ 【物流设置】delivery_types 字段：配送方式数组，目前有 1 快递发货、2 门店自提。\n\ndelivery_template_id 字段：物流配置模板编号，仅当 delivery_types 为 1 时，才会有值。\n\n\n\n⑤ 【其它设置】give_integral 字段：赠送积分，用户购买该商品，赠送的积分。\n\nsales_count 字段：商品销量，每次用户下单时，更新该字段。virtual_sales_count 字段：虚拟销量，最终展示给用户的销量是 sales_count + virtual_sales_count 。\n\nbrowse_count 字段：商品点击量，每次用户点击商品时，更新该字段。另外，也会往 product_browse_history 插入一条浏览记录。\n\n\n\n\n# 2. 管理后台\n\n\n# 2.1 商品列表\n\n对应 [商城系统 -> 商品中心 -> 商品列表] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/mall/product/spu 目录。\n\n\n\n\n# 2.2 商品发布\n\n商品的新增、修改、详情界面，都对应 yudao-ui-admin-vue3 项目的 @/views/mall/product/spu/form 目录。\n\n\n\n考虑到前端代码的维护性，每个 Tab 对应一个组件，这样修改某个 Tab 的代码，不会影响到其它 Tab 的代码。如下图所示：\n\n\n\n * 基础设置：views/mall/product/spu/form/InfoForm.vue\n * 库存价格：views/mall/product/spu/form/SkuForm.vue\n * 物流设置：views/mall/product/spu/form/DeliveryForm.vue\n * 商品描述：views/mall/product/spu/form/DescriptionForm.vue\n * 其它设置：views/mall/product/spu/form/OtherForm.vue\n\n\n# 3. 移动端\n\n商品在 uni-app 的代码，主要在 yudao-ui-uniapp 项目的 @/pages/goods 目录。如下图所示：\n\n\n\n\n# 3.1 商品列表\n\n商品列表，对应 @/pages/goods/list.vue 文件。界面效果如下图所示：\n\n\n\n\n# 3.2 商品详情\n\n商品详情，对应 @/pages/goods/index.vue 文件。界面效果如下图所示：\n\n\n\n考虑到商品详情界面的复杂性，所以将其拆分成多个组件，如下图所示：\n\n\n\n另外，如果你想看商品 SKU 选择的代码，可以看 /sheep/components/s-select-sku/s-select-sku.vue 文件。\n\n注意，拼团、秒杀商品的界面展示不同，所以单独分别对应了 @/pages/goods/groupon.vue、@/pages/goods/seckill.vue 文件。\n\n\n# 4. 社区贡献的商品相关\n\n * 新增基于 SPU id 复制商品的功能：#517、#49",
            normalizedContent: "> 参考 《产品 sku 是什么意思？与之相关的还有哪些？》 整理\n\n\n# 1. 表结构\n\n商品 spu 与 sku，由 yudao-module-product-biz 后端模块的 spu、sku 包实现，分成商品 spu 和商品 sku 两个表。\n\n\n\n\n# 1.1 商品 sku\n\nsku：stock keeping unit\n\n中文翻译为库存单位。sku 从库存视角，以库存进出为单位，可以是件、瓶、箱等等。\n\n例如，iphone 手机，按照规格( 颜色 + 内存 )可以组合出如下多个 sku ：\n\nsku   颜色   内存\na     白色   16g\nb     白色   64g\nc     黑色   16g\nd     黑色   64g\n\n可以看出，颜色（白色、黑色）与内存（16g、64g）组合排列出四种 iphone sku。\n\n最终 sku 表结构如下：\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `product_sku` (\n  `id` bigint not null auto_increment comment '主键',\n  \n  `spu_id` bigint not null comment 'spu编号',\n  \n  `properties` varchar(512) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '属性数组，json 格式 [{propertid: , valueid: }, {propertid: , valueid: }]',\n  \n  `price` int not null default '-1' comment '商品价格，单位：分',\n  `market_price` int default null comment '市场价，单位：分',\n  `cost_price` int not null default '-1' comment '成本价，单位： 分',\n  `bar_code` varchar(64) character set utf8mb4 collate utf8mb4_unicode_ci default null comment 'sku 的条形码',\n  `pic_url` varchar(256) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '图片地址',\n  `stock` int default null comment '库存',\n  `weight` double default null comment '商品重量，单位：kg 千克',\n  `volume` double default null comment '商品体积，单位：m^3 平米',\n  \n  `first_brokerage_price` int default null comment '一级分销的佣金，单位：分',\n  `second_brokerage_price` int default null comment '二级分销的佣金，单位：分',\n  \n  `sales_count` int default null comment '商品销量',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=30 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='商品sku';\n\n\n① spu_id 字段：商品 spu 的编号，关联 product_spu 表的 id 字段。\n\n② properties 字段：商品属性，json 格式，例如：\n\n\n\n[\n  {\n    \"propertyid\": 1,\n    \"propertyname\": \"颜色\",\n    \"valueid\": 5,\n    \"valuename\": \"黑色\"\n  },\n  {\n    \"propertyid\": 3,\n    \"propertyname\": \"版本\",\n    \"valueid\": 8,\n    \"valuename\": \"ch510\"\n  }\n]\n\n\n很明显，property_id 对应 product_property 表的 id 字段，value_id 对应 product_property_value 表的 id 字段。\n\n那么为什么要冗余 propertyname、valuename 字段呢？主要是为了方便查询，不用再关联 product_property、product_property_value 表，嘿嘿~\n\n③ price、market_price、cost_price、bar_code、weight、volume、pic_url 字段，都是商品 sku 的基本信息。\n\n④ sales_count 字段：商品销量，每次用户下单时，更新该字段。\n\n⑤ first_brokerage_price、second_brokerage_price 字段：一级分销、二级分销的佣金，可能未来会挪到【营销】模块下，目前不用特别关注。\n\n\n# 1.2 商品 spu\n\nspu：standard product unit\n\n中文翻译为标准产品单位。spu 从产品视角，是产品信息聚合的最小单位，是一组可复用、易检索的标准化信息的集合，该集合描述了一个产品的特性。通俗点讲，属性值、特性相同的商品就可以被称为一个 spu。\n\n例如 iphone 14 就是一个 spu，iphone 14 plus 也是一个 spu ，这个与商家无关，与颜色、款式、套餐等规格无关。\n\n商家出售某个 spu，那么这就是一个商品。商品在 spu 之上，增加了销售价格、运费等等信息。另外，一个商品可以包含多个 sku。\n\n最终 spu 表结构如下：\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `product_spu` (\n  `id` bigint not null auto_increment comment '商品 spu 编号，自增',\n  `name` varchar(128) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '商品名称',\n  `keyword` varchar(256) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '关键字',\n  `introduction` varchar(256) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '商品简介',\n  `description` text character set utf8mb4 collate utf8mb4_unicode_ci comment '商品详情',\n  `category_id` bigint not null comment '商品分类编号',\n  `brand_id` int default null comment '商品品牌编号',\n  `pic_url` varchar(256) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '商品封面图',\n  `slider_pic_urls` varchar(2000) character set utf8mb4 collate utf8mb4_unicode_ci default '' comment '商品轮播图地址\\n 数组，以逗号分隔\\n 最多上传15张',\n  \n  `status` tinyint not null comment '商品状态: 0 上架（开启） 1 下架（禁用）-1 回收',\n  \n  `spec_type` bit(1) default null comment '规格类型：0 单规格 1 多规格',\n  `price` int not null default '-1' comment '商品价格，单位使用：分',\n  `market_price` int default null comment '市场价，单位使用：分',\n  `cost_price` int not null default '-1' comment '成本价，单位： 分',\n  `stock` int not null default '0' comment '库存',\n  \n  `delivery_types` varchar(32) character set utf8mb4 collate utf8mb4_unicode_ci not null default '' comment '配送方式数组',\n  `delivery_template_id` bigint default null comment '物流配置模板编号',\n  \n  `give_integral` int not null default '0' comment '赠送积分',\n  `sales_count` int default '0' comment '商品销量',\n  `virtual_sales_count` int default '0' comment '虚拟销量',\n  `browse_count` int default '0' comment '商品点击量',\n  `sort` int not null default '0' comment '排序字段',\n\n  `sub_commission_type` bit(1) default null comment '分销类型',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=640 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='商品spu';\n\n\n① 【基础设置】name、keyword、introduction、description、category_id、brand_id、pic_url、slider_pic_urls 字段：商品 spu 的基本信息。\n\n\n\n② status 字段：商品状态，1 上架（开启）、0 下架（禁用）、-1 回收，用户在 uni-app 看到的商品，只有 status 为 1 的商品。\n\n③ 【库存价格】spec_type 字段：规格类型，false 单规格、true 多规格。要注意，即使是单规格，也会创建一个 sku，这个 sku 的 properties 字段为“默认”数组 [{\"propertyid\":0,\"propertyname\":\"默认\",\"valueid\":0,\"valuename\":\"默认\"}]。\n\nprice、market_price、cost_price 字段：取对应 sku 的最小值。stock 字段：取对应 sku 库存的累加值。\n\n\n\n④ 【物流设置】delivery_types 字段：配送方式数组，目前有 1 快递发货、2 门店自提。\n\ndelivery_template_id 字段：物流配置模板编号，仅当 delivery_types 为 1 时，才会有值。\n\n\n\n⑤ 【其它设置】give_integral 字段：赠送积分，用户购买该商品，赠送的积分。\n\nsales_count 字段：商品销量，每次用户下单时，更新该字段。virtual_sales_count 字段：虚拟销量，最终展示给用户的销量是 sales_count + virtual_sales_count 。\n\nbrowse_count 字段：商品点击量，每次用户点击商品时，更新该字段。另外，也会往 product_browse_history 插入一条浏览记录。\n\n\n\n\n# 2. 管理后台\n\n\n# 2.1 商品列表\n\n对应 [商城系统 -> 商品中心 -> 商品列表] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/mall/product/spu 目录。\n\n\n\n\n# 2.2 商品发布\n\n商品的新增、修改、详情界面，都对应 yudao-ui-admin-vue3 项目的 @/views/mall/product/spu/form 目录。\n\n\n\n考虑到前端代码的维护性，每个 tab 对应一个组件，这样修改某个 tab 的代码，不会影响到其它 tab 的代码。如下图所示：\n\n\n\n * 基础设置：views/mall/product/spu/form/infoform.vue\n * 库存价格：views/mall/product/spu/form/skuform.vue\n * 物流设置：views/mall/product/spu/form/deliveryform.vue\n * 商品描述：views/mall/product/spu/form/descriptionform.vue\n * 其它设置：views/mall/product/spu/form/otherform.vue\n\n\n# 3. 移动端\n\n商品在 uni-app 的代码，主要在 yudao-ui-uniapp 项目的 @/pages/goods 目录。如下图所示：\n\n\n\n\n# 3.1 商品列表\n\n商品列表，对应 @/pages/goods/list.vue 文件。界面效果如下图所示：\n\n\n\n\n# 3.2 商品详情\n\n商品详情，对应 @/pages/goods/index.vue 文件。界面效果如下图所示：\n\n\n\n考虑到商品详情界面的复杂性，所以将其拆分成多个组件，如下图所示：\n\n\n\n另外，如果你想看商品 sku 选择的代码，可以看 /sheep/components/s-select-sku/s-select-sku.vue 文件。\n\n注意，拼团、秒杀商品的界面展示不同，所以单独分别对应了 @/pages/goods/groupon.vue、@/pages/goods/seckill.vue 文件。\n\n\n# 4. 社区贡献的商品相关\n\n * 新增基于 spu id 复制商品的功能：#517、#49",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【商品】商品评价",
            frontmatter: {
                title: "【商品】商品评价",
                date: "2024-01-15T07:49:00.000Z",
                permalink: "/mall/product-comment/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/14.%E5%95%86%E5%9F%8E%E6%89%8B%E5%86%8C/13.%E3%80%90%E5%95%86%E5%93%81%E3%80%91%E5%95%86%E5%93%81%E8%AF%84%E4%BB%B7.html",
            relativePath: "01.开发指南/14.商城手册/13.【商品】商品评价.md",
            key: "v-743e4ef6",
            path: "/mall/product-comment/",
            headers: [{
                level: 2,
                title: "1. 表结构",
                slug: "_1-表结构",
                normalizedTitle: "1. 表结构",
                charIndex: 2
            }, {
                level: 2,
                title: "2. 管理后台",
                slug: "_2-管理后台",
                normalizedTitle: "2. 管理后台",
                charIndex: 2634
            }, {
                level: 2,
                title: "3. 移动端",
                slug: "_3-移动端",
                normalizedTitle: "3. 移动端",
                charIndex: 2840
            }, {
                level: 3,
                title: "3.1 评价列表",
                slug: "_3-1-评价列表",
                normalizedTitle: "3.1 评价列表",
                charIndex: 2851
            }, {
                level: 3,
                title: "3.2 添加评价",
                slug: "_3-2-添加评价",
                normalizedTitle: "3.2 添加评价",
                charIndex: 3058
            }],
            headersStr: "1. 表结构 2. 管理后台 3. 移动端 3.1 评价列表 3.2 添加评价",
            content: "# 1. 表结构\n\n商品评价由 yudao-module-product-biz 后端模块的 comment 包实现，表结构如下：\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `product_comment` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '评价编号，主键自增',\n  \n  `user_id` bigint NOT NULL COMMENT '评价人的用户编号，关联 MemberUserDO 的 id 编号',\n  `user_nickname` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '评价人名称',\n  `user_avatar` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '评价人头像',\n  `anonymous` bit(1) NOT NULL COMMENT '是否匿名',\n  \n  `order_id` bigint DEFAULT '0' COMMENT '交易订单编号，关联 TradeOrderDO 的 id 编号',\n  `order_item_id` bigint DEFAULT '0' COMMENT '交易订单项编号，关联 TradeOrderItemDO 的 id 编号',\n  \n  `spu_id` bigint NOT NULL COMMENT '商品 SPU 编号，关联 ProductSpuDO 的 id',\n  `spu_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '商品 SPU 名称',\n  `sku_id` bigint NOT NULL COMMENT '商品 SKU 编号，关联 ProductSkuDO 的 id 编号',\n  `sku_pic_url` varchar(256) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '图片地址',\n  `sku_properties` varchar(512) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '属性数组，JSON 格式 [{propertId: , valueId: }, {propertId: , valueId: }]',\n  \n  `scores` tinyint NOT NULL COMMENT '评分星级1-5分',\n  `description_scores` tinyint NOT NULL COMMENT '描述星级 1-5 星',\n  `benefit_scores` tinyint NOT NULL COMMENT '服务星级 1-5 星',\n  `content` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '评价内容',\n  `pic_urls` varchar(4096) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '评价图片地址数组',\n  \n  `visible` bit(1) DEFAULT NULL COMMENT '是否可见，true:显示false:隐藏',\n  `reply_status` bit(1) DEFAULT b'0' COMMENT '商家是否回复',\n  `reply_user_id` bigint DEFAULT NULL COMMENT '回复管理员编号，关联 AdminUserDO 的 id 编号',\n  `reply_content` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '商家回复内容',\n  `reply_time` datetime DEFAULT NULL COMMENT '商家回复时间',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=14 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT='商品评价';\n\n\n① user_id、user_nickname、user_avatar、anonymous 字段，会员用户相关信息。\n\n② order_id、order_item_id 字段，交易订单相关信息。下单的每个订单项（商品），都可以评价一次，所以这里可以看到 order_item_id 字段。\n\n③ spu_id、spu_name、sku_id、sku_pic_url、sku_properties 字段，商品 SPU、SKU 相关信息。通过冗余这些商品字段，可以减少关联查询，提高查询效率。\n\n④ description_scores、benefit_scores、content、pic_urls 字段，会员用户的评价信息。而 score 字段是 description_scores、benefit_scores 两个字段的平均值。\n\n⑤ reply_status、reply_user_id、reply_content、reply_time 字段，商家回复相关信息。\n\nvisible 字段，控制评价在 uni-app 是否可见，默认为 true，可以通过管理后台修改。\n\n\n# 2. 管理后台\n\n对应 [商城系统 -> 商品中心 -> 商品评价] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/mall/product/comment 目录。\n\n\n\n① 点击「添加虚拟评价」按钮，可以给某个商品添加虚拟评价，用于商品详情页的评价展示。\n\n② 点击「回复」按钮，可以回复某个评价。\n\n③ 点击「是否展示」按钮，可以控制评价在 uni-app 是否可见。\n\n\n# 3. 移动端\n\n\n# 3.1 评价列表\n\n① 商品详情页，展示近 3 条评价，由 yudao-ui-uniapp 项目的 pages/goods/components/detail/detail-comment-card.vue 实现。如下图所示：\n\n\n\n② 点击「查看全部」按钮，进入商品评价列表页，由 yudao-ui-uniapp 项目的 pages/goods/comment/list.vue 实现。如下图所示：\n\n\n\n\n# 3.2 添加评价\n\n在订单确认售后后，可以对商品进行评价，由 yudao-ui-uniapp 项目的 pages/goods/comment/add.vue 实现。如下图所示：\n\n\n\n",
            normalizedContent: "# 1. 表结构\n\n商品评价由 yudao-module-product-biz 后端模块的 comment 包实现，表结构如下：\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `product_comment` (\n  `id` bigint not null auto_increment comment '评价编号，主键自增',\n  \n  `user_id` bigint not null comment '评价人的用户编号，关联 memberuserdo 的 id 编号',\n  `user_nickname` varchar(255) character set utf8mb4 collate utf8mb4_general_ci default null comment '评价人名称',\n  `user_avatar` varchar(1024) character set utf8mb4 collate utf8mb4_general_ci default null comment '评价人头像',\n  `anonymous` bit(1) not null comment '是否匿名',\n  \n  `order_id` bigint default '0' comment '交易订单编号，关联 tradeorderdo 的 id 编号',\n  `order_item_id` bigint default '0' comment '交易订单项编号，关联 tradeorderitemdo 的 id 编号',\n  \n  `spu_id` bigint not null comment '商品 spu 编号，关联 productspudo 的 id',\n  `spu_name` varchar(255) character set utf8mb4 collate utf8mb4_general_ci default null comment '商品 spu 名称',\n  `sku_id` bigint not null comment '商品 sku 编号，关联 productskudo 的 id 编号',\n  `sku_pic_url` varchar(256) character set utf8mb4 collate utf8mb4_general_ci not null comment '图片地址',\n  `sku_properties` varchar(512) character set utf8mb4 collate utf8mb4_general_ci default null comment '属性数组，json 格式 [{propertid: , valueid: }, {propertid: , valueid: }]',\n  \n  `scores` tinyint not null comment '评分星级1-5分',\n  `description_scores` tinyint not null comment '描述星级 1-5 星',\n  `benefit_scores` tinyint not null comment '服务星级 1-5 星',\n  `content` varchar(1024) character set utf8mb4 collate utf8mb4_general_ci not null comment '评价内容',\n  `pic_urls` varchar(4096) character set utf8mb4 collate utf8mb4_general_ci default null comment '评价图片地址数组',\n  \n  `visible` bit(1) default null comment '是否可见，true:显示false:隐藏',\n  `reply_status` bit(1) default b'0' comment '商家是否回复',\n  `reply_user_id` bigint default null comment '回复管理员编号，关联 adminuserdo 的 id 编号',\n  `reply_content` varchar(1024) character set utf8mb4 collate utf8mb4_general_ci default null comment '商家回复内容',\n  `reply_time` datetime default null comment '商家回复时间',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=14 default charset=utf8mb4 collate=utf8mb4_general_ci comment='商品评价';\n\n\n① user_id、user_nickname、user_avatar、anonymous 字段，会员用户相关信息。\n\n② order_id、order_item_id 字段，交易订单相关信息。下单的每个订单项（商品），都可以评价一次，所以这里可以看到 order_item_id 字段。\n\n③ spu_id、spu_name、sku_id、sku_pic_url、sku_properties 字段，商品 spu、sku 相关信息。通过冗余这些商品字段，可以减少关联查询，提高查询效率。\n\n④ description_scores、benefit_scores、content、pic_urls 字段，会员用户的评价信息。而 score 字段是 description_scores、benefit_scores 两个字段的平均值。\n\n⑤ reply_status、reply_user_id、reply_content、reply_time 字段，商家回复相关信息。\n\nvisible 字段，控制评价在 uni-app 是否可见，默认为 true，可以通过管理后台修改。\n\n\n# 2. 管理后台\n\n对应 [商城系统 -> 商品中心 -> 商品评价] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/mall/product/comment 目录。\n\n\n\n① 点击「添加虚拟评价」按钮，可以给某个商品添加虚拟评价，用于商品详情页的评价展示。\n\n② 点击「回复」按钮，可以回复某个评价。\n\n③ 点击「是否展示」按钮，可以控制评价在 uni-app 是否可见。\n\n\n# 3. 移动端\n\n\n# 3.1 评价列表\n\n① 商品详情页，展示近 3 条评价，由 yudao-ui-uniapp 项目的 pages/goods/components/detail/detail-comment-card.vue 实现。如下图所示：\n\n\n\n② 点击「查看全部」按钮，进入商品评价列表页，由 yudao-ui-uniapp 项目的 pages/goods/comment/list.vue 实现。如下图所示：\n\n\n\n\n# 3.2 添加评价\n\n在订单确认售后后，可以对商品进行评价，由 yudao-ui-uniapp 项目的 pages/goods/comment/add.vue 实现。如下图所示：\n\n\n\n",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【交易】购物车",
            frontmatter: {
                title: "【交易】购物车",
                date: "2024-01-15T17:18:00.000Z",
                permalink: "/mall/trade-cart/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/14.%E5%95%86%E5%9F%8E%E6%89%8B%E5%86%8C/21.%E3%80%90%E4%BA%A4%E6%98%93%E3%80%91%E8%B4%AD%E7%89%A9%E8%BD%A6.html",
            relativePath: "01.开发指南/14.商城手册/21.【交易】购物车.md",
            key: "v-d0f81f92",
            path: "/mall/trade-cart/",
            headers: [{
                level: 2,
                title: "1. 表结构",
                slug: "_1-表结构",
                normalizedTitle: "1. 表结构",
                charIndex: 2
            }, {
                level: 2,
                title: "2. 管理后台",
                slug: "_2-管理后台",
                normalizedTitle: "2. 管理后台",
                charIndex: 1069
            }, {
                level: 2,
                title: "3. 移动端",
                slug: "_3-移动端",
                normalizedTitle: "3. 移动端",
                charIndex: 1174
            }, {
                level: 3,
                title: "3.1 添加购物车",
                slug: "_3-1-添加购物车",
                normalizedTitle: "3.1 添加购物车",
                charIndex: 1185
            }, {
                level: 3,
                title: "3.2 购物车列表",
                slug: "_3-2-购物车列表",
                normalizedTitle: "3.2 购物车列表",
                charIndex: 1251
            }],
            headersStr: "1. 表结构 2. 管理后台 3. 移动端 3.1 添加购物车 3.2 购物车列表",
            content: "# 1. 表结构\n\n购物车表，由 yudao-module-trade-biz 后端模块的 cart 包实现。表结构如下：\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `trade_cart`  (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号，唯一自增。',\n    \n  `user_id` bigint NOT NULL COMMENT '用户编号',\n    \n  `spu_id` bigint NOT NULL COMMENT '商品 SPU 编号',\n  `sku_id` bigint NOT NULL COMMENT '商品 SKU 编号',\n  \n  `count` int NOT NULL COMMENT '商品购买数量',\n  `selected` bit(1) NOT NULL DEFAULT b'1' COMMENT '是否选中',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 70 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '购物车的商品信息';\n\n\n注意，它存储的是购物项，用户添加了多个商品 SKU 则会有多条记录。字段可以分成三类：\n\n * ① user_id 字段：对应的用户编号。\n * ② spu_id、sku_id 字段：商品 SPU、SKU 相关信息。\n * ③ count、selected 字段：购买数量和选中状态。相同商品 SKU 被多次添加到购物车时，只会记录一条，count 数量进行累加，直到被下单。\n\n疑问：为什么不使用 Redis 存储购物车？\n\nMySQL 实现简单易懂，性能足够满足绝大多数公司。目前，市面上主流的电商开源项目都使用 MySQL 存储购物车信息。它有如下三点好处：\n\n * 数据分析。例如，哪些商品被添加到购物车很多，但是很少被下单，实现转换率漏斗\n * 业务拓展。例如，卖家基于买家购物车的商品信息，进行回访，促发购买\n * 用户体验。缓存总会过期，可能买家目前仅仅是添加到购物车，N 天后会进行购买\n\n当然，如果你真的希望使用 Redis 实现购物车，推荐阅读 《购物车服务》 文档。\n\n\n# 2. 管理后台\n\n暂时没有对应菜单，可以查询 trade_cart 表实现。\n\n因为它采用 MySQL 实现存储，所以实现还是比较简单的。如果是 Redis 的话，可能条件 + 分页查询就比较复杂了。\n\n\n# 3. 移动端\n\n\n# 3.1 添加购物车\n\n在商品详情页，选择完商品 SKU 后，可点击「加入购物车」按钮，实现添加购物车功能。如下图所示：\n\n\n\n\n# 3.2 购物车列表\n\n对应 uni-app 底部的 [购物车] 导航，对应 yudao-mall-uniapp 项目的 pages/index/cart.vue 页面。如下图所示：\n\n\n\n后续，点击「去结算」按钮，即可进入下单流程。",
            normalizedContent: "# 1. 表结构\n\n购物车表，由 yudao-module-trade-biz 后端模块的 cart 包实现。表结构如下：\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `trade_cart`  (\n  `id` bigint not null auto_increment comment '编号，唯一自增。',\n    \n  `user_id` bigint not null comment '用户编号',\n    \n  `spu_id` bigint not null comment '商品 spu 编号',\n  `sku_id` bigint not null comment '商品 sku 编号',\n  \n  `count` int not null comment '商品购买数量',\n  `selected` bit(1) not null default b'1' comment '是否选中',\n  primary key (`id`) using btree\n) engine = innodb auto_increment = 70 character set = utf8mb4 collate = utf8mb4_general_ci comment = '购物车的商品信息';\n\n\n注意，它存储的是购物项，用户添加了多个商品 sku 则会有多条记录。字段可以分成三类：\n\n * ① user_id 字段：对应的用户编号。\n * ② spu_id、sku_id 字段：商品 spu、sku 相关信息。\n * ③ count、selected 字段：购买数量和选中状态。相同商品 sku 被多次添加到购物车时，只会记录一条，count 数量进行累加，直到被下单。\n\n疑问：为什么不使用 redis 存储购物车？\n\nmysql 实现简单易懂，性能足够满足绝大多数公司。目前，市面上主流的电商开源项目都使用 mysql 存储购物车信息。它有如下三点好处：\n\n * 数据分析。例如，哪些商品被添加到购物车很多，但是很少被下单，实现转换率漏斗\n * 业务拓展。例如，卖家基于买家购物车的商品信息，进行回访，促发购买\n * 用户体验。缓存总会过期，可能买家目前仅仅是添加到购物车，n 天后会进行购买\n\n当然，如果你真的希望使用 redis 实现购物车，推荐阅读 《购物车服务》 文档。\n\n\n# 2. 管理后台\n\n暂时没有对应菜单，可以查询 trade_cart 表实现。\n\n因为它采用 mysql 实现存储，所以实现还是比较简单的。如果是 redis 的话，可能条件 + 分页查询就比较复杂了。\n\n\n# 3. 移动端\n\n\n# 3.1 添加购物车\n\n在商品详情页，选择完商品 sku 后，可点击「加入购物车」按钮，实现添加购物车功能。如下图所示：\n\n\n\n\n# 3.2 购物车列表\n\n对应 uni-app 底部的 [购物车] 导航，对应 yudao-mall-uniapp 项目的 pages/index/cart.vue 页面。如下图所示：\n\n\n\n后续，点击「去结算」按钮，即可进入下单流程。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【交易】交易订单",
            frontmatter: {
                title: "【交易】交易订单",
                date: "2024-01-15T18:18:00.000Z",
                permalink: "/mall/trade-order/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/14.%E5%95%86%E5%9F%8E%E6%89%8B%E5%86%8C/22.%E3%80%90%E4%BA%A4%E6%98%93%E3%80%91%E4%BA%A4%E6%98%93%E8%AE%A2%E5%8D%95.html",
            relativePath: "01.开发指南/14.商城手册/22.【交易】交易订单.md",
            key: "v-5dfa0e50",
            path: "/mall/trade-order/",
            headers: [{
                level: 2,
                title: "1. 表结构",
                slug: "_1-表结构",
                normalizedTitle: "1. 表结构",
                charIndex: 2
            }, {
                level: 3,
                title: "1. 订单表",
                slug: "_1-订单表",
                normalizedTitle: "1. 订单表",
                charIndex: 141
            }, {
                level: 3,
                title: "1.2 订单项表",
                slug: "_1-2-订单项表",
                normalizedTitle: "1.2 订单项表",
                charIndex: 5391
            }, {
                level: 3,
                title: "1.3 订单日志表",
                slug: "_1-3-订单日志表",
                normalizedTitle: "1.3 订单日志表",
                charIndex: 7586
            }, {
                level: 2,
                title: "2. 订单流程",
                slug: "_2-订单流程",
                normalizedTitle: "2. 订单流程",
                charIndex: 8440
            }, {
                level: 3,
                title: "2.1 结算【买家】",
                slug: "_2-1-结算【买家】",
                normalizedTitle: "2.1 结算【买家】",
                charIndex: 8517
            }, {
                level: 3,
                title: "2.2 提交【买家】",
                slug: "_2-2-提交【买家】",
                normalizedTitle: "2.2 提交【买家】",
                charIndex: 9149
            }, {
                level: 3,
                title: "2.3 支付【买家】",
                slug: "_2-3-支付【买家】",
                normalizedTitle: "2.3 支付【买家】",
                charIndex: 9596
            }, {
                level: 3,
                title: "2.4 发货【卖家】",
                slug: "_2-4-发货【卖家】",
                normalizedTitle: "2.4 发货【卖家】",
                charIndex: 10065
            }, {
                level: 3,
                title: "2.5 收货【买家】",
                slug: "_2-5-收货【买家】",
                normalizedTitle: "2.5 收货【买家】",
                charIndex: 10539
            }, {
                level: 3,
                title: "2.6 评价【买家】",
                slug: "_2-6-评价【买家】",
                normalizedTitle: "2.6 评价【买家】",
                charIndex: 11128
            }],
            headersStr: "1. 表结构 1. 订单表 1.2 订单项表 1.3 订单日志表 2. 订单流程 2.1 结算【买家】 2.2 提交【买家】 2.3 支付【买家】 2.4 发货【卖家】 2.5 收货【买家】 2.6 评价【买家】",
            content: "# 1. 表结构\n\n交易订单，由 yudao-module-trade-biz 后端模块的 order 包实现，分成三个表：\n\n\n\n * trade_order 订单主表\n * trade_order_item 订单项子表\n * trade_order_log 订单日志表\n\n\n# 1. 订单表\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `trade_order`  (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '订单编号',\n  `no` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '订单流水号',\n    \n  `type` int NOT NULL DEFAULT 0 COMMENT '订单类型',\n  `seckill_activity_id` bigint NULL DEFAULT NULL COMMENT '秒杀活动编号',\n  `bargain_activity_id` bigint NULL DEFAULT NULL COMMENT '砍价活动编号',\n  `bargain_record_id` bigint NULL DEFAULT NULL COMMENT '砍价记录编号',\n  `combination_activity_id` bigint NULL DEFAULT NULL COMMENT '拼团活动编号',\n  `combination_head_id` bigint NULL DEFAULT NULL COMMENT '拼团团长编号',\n  `combination_record_id` bigint NULL DEFAULT NULL COMMENT '拼团记录编号',\n\n  `user_id` bigint UNSIGNED NOT NULL COMMENT '用户编号',    \n  `terminal` int NOT NULL COMMENT '订单来源终端',\n  `user_ip` varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL DEFAULT '' COMMENT '用户 IP',\n    \n  `status` int NOT NULL DEFAULT 0 COMMENT '订单状态',\n  `cancel_type` int NULL DEFAULT NULL COMMENT '取消类型',\n  `comment_status` bit(1) NOT NULL DEFAULT b'0' COMMENT '是否评价',\n  `cancel_time` datetime NULL DEFAULT NULL COMMENT '订单取消时间',\n  `finish_time` datetime NULL DEFAULT NULL COMMENT '订单完成时间',\n\n  `user_remark` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NULL DEFAULT NULL COMMENT '用户备注',\n  `product_count` int NOT NULL COMMENT '购买的商品数量',\n  `remark` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NULL DEFAULT NULL COMMENT '商家备注',\n  \n  `brokerage_user_id` bigint NULL DEFAULT NULL COMMENT '推广人编号',\n  \n  `pay_order_id` bigint NULL DEFAULT NULL COMMENT '支付订单编号',\n  `pay_status` bit(1) NOT NULL DEFAULT b'0' COMMENT '是否已支付：[0:未支付 1:已经支付过]',\n  `pay_time` datetime NULL DEFAULT NULL COMMENT '订单支付时间',\n  `pay_channel_code` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NULL DEFAULT NULL COMMENT '支付成功的支付渠道',\n    \n  `total_price` int NOT NULL DEFAULT 0 COMMENT '商品原价（总），单位：分',\n  `discount_price` int NOT NULL DEFAULT 0 COMMENT '订单优惠（总），单位：分',\n  `delivery_price` int NOT NULL DEFAULT 0 COMMENT '运费金额，单位：分',\n  `adjust_price` int NOT NULL DEFAULT 0 COMMENT '订单调价（总），单位：分',\n  `pay_price` int NOT NULL DEFAULT 0 COMMENT '应付金额（总），单位：分',\n  `coupon_price` int NOT NULL DEFAULT 0 COMMENT '优惠劵减免金额，单位：分',\n  `point_price` int NOT NULL DEFAULT 0 COMMENT '积分抵扣的金额',\n  `vip_price` int NOT NULL DEFAULT 0 COMMENT 'VIP 减免金额，单位：分',\n\n  `coupon_id` bigint UNSIGNED NULL DEFAULT NULL COMMENT '优惠劵编号',\n  `use_point` int NOT NULL DEFAULT 0 COMMENT '使用的积分',\n  `give_point` int NOT NULL DEFAULT 0 COMMENT '赠送的积分',\n\n  `refund_status` tinyint NOT NULL DEFAULT 0 COMMENT '售后状态',\n  `refund_point` int NOT NULL DEFAULT 0 COMMENT '退还的使用的积分',\n  `refund_price` int NOT NULL DEFAULT 0 COMMENT '退款金额，单位：分',\n\n  `delivery_type` tinyint NOT NULL COMMENT '配送类型',\n  `logistics_id` bigint NULL DEFAULT NULL COMMENT '发货物流公司编号',\n  `logistics_no` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NULL DEFAULT NULL COMMENT '物流公司单号',\n  `delivery_time` datetime NULL DEFAULT NULL COMMENT '发货时间',\n  `receive_time` datetime NULL DEFAULT NULL COMMENT '收货时间',\n  `receiver_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '收件人名称',\n  `receiver_mobile` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '收件人手机',\n  `receiver_area_id` int NULL DEFAULT NULL COMMENT '收件人地区编号',\n  `receiver_detail_address` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NULL DEFAULT NULL COMMENT '收件人详细地址',\n  `pick_up_store_id` bigint NULL DEFAULT NULL COMMENT '自提门店编号',\n  `pick_up_verify_code` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NULL DEFAULT NULL COMMENT '自提核销码',\n\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 128 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_bin COMMENT = '交易订单表';\n\n\n字段还是非常多的，我们来分块来看看。\n\n① no 字段：订单流水号，主要展示给用户看，由 TradeNoRedisDAO 的 #generate(...) 方法生成。\n\n而 id 字段是数据库自增的订单编号，系统内部使用，一般不展示给用户查看。\n\n② type 字段：订单类型，使用 TradeOrderTypeEnum 枚举，目前有 4 种类型的订单：\n\n * 普通：一般情况下的订单，未参与秒杀、砍价、拼团活动\n * 秒杀：参与秒杀活动，会关联 seckill_activity_id 字段\n * 砍价：参与砍价活动，会关联 bargain_activity_id、bargain_record_id 字段\n * 拼团：参与拼团活动，会关联 combination_activity_id、combination_head_id、combination_record_id 字段\n\n③ 【用户】user_id、terminal、user_ip 字段：下单的用户信息。\n\n④ 【状态】status 字段：订单状态，由 TradeOrderStatusEnum 枚举，流转状态如下图：\n\n\n\ncancel_type 字段：取消类型，标记 status 为“已取消”的原因，由 TradeOrderCancelTypeEnum 枚举，例如说：超时未支付、退款关闭、买家取消。\n\ncomment_status 字段：订单是否评价。目的是，uni-app 筛选未评价的订单列表，也有商城系统会该字段融合到 status 作为“待评价”状态。\n\n⑤ 【支付】pay_status 字段：是否已支付。由于订单可以全部退款变成“已关闭”状态，所以需要 pay_status 区分该订单实际是否发生过支付。\n\npay_order_id 字段：关联的支付中心的支付单号。对支付中心还不了解的同学，可以阅读下 《支付手册》 文档。\n\n⑥ 【价格】各种价格字段，最终使用 pay_price 字段进行支付，分类如下：\n\n * + 收钱：total_price、delivery_price\n * - 优惠：discount_price、coupon_price、point_price、vip_price\n * ? 改价：adjust_price\n\n价格字段拆的这些细，主要是 uni-app 或者管理后台需要展示，同时我们也需要搞清楚一个订单的具体价格明细。\n\n⑦ 【营销】coupon_id、use_point、give_point 字段：优惠劵、积分相关信息。\n\n⑧ 【退款】refund_status 字段：订单的整体售后（退款）状态，由 TradeOrderRefundStatusEnum 枚举，有 3 种状态：未退款、部分退款、全部退款。如果全部退款，则订单 status 变成“已关闭”。\n\nrefund_point、refund_price 字段：退款的积分、金额。\n\n⑨ 【配送】delivery_type 字段：配送类型，由 DeliveryTypeEnum 枚举，有 2 种类型：\n\n * 快递发货：使用 logistics_id、logistics_no、receiver_name、receiver_mobile、receiver_area_id、receiver_detail_address 字段\n * 用户自提：使用 pick_up_store_id、pick_up_verify_code 字段\n\n⑩ 各种 _time 结尾的字段，就是各种阶段、操作的时间，满足业务查询、统计需求。\n\n\n# 1.2 订单项表\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `trade_order_item`  (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '订单项编号',\n  \n  `user_id` bigint UNSIGNED NOT NULL COMMENT '用户编号',\n  `order_id` bigint UNSIGNED NOT NULL COMMENT '订单编号',\n  `cart_id` bigint UNSIGNED NULL DEFAULT NULL COMMENT '购物车项编号',\n  \n  `spu_id` bigint UNSIGNED NOT NULL COMMENT '商品 SPU 编号',\n  `spu_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '商品 SPU 名称',\n  `sku_id` bigint UNSIGNED NOT NULL COMMENT '商品 SKU 编号',\n  `properties` json NULL COMMENT '商品属性数组，JSON 格式',\n  `pic_url` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NULL DEFAULT NULL COMMENT '商品图片',\n  `count` int NOT NULL COMMENT '购买数量',\n  \n  `comment_status` bit(1) NOT NULL DEFAULT b'0' COMMENT '是否评价',\n  \n  `price` int NOT NULL DEFAULT 0 COMMENT '商品原价（单），单位：分',\n  `discount_price` int NOT NULL DEFAULT 0 COMMENT '商品级优惠（总），单位：分',\n  `delivery_price` int NOT NULL DEFAULT 0 COMMENT '运费金额，单位：分',\n  `adjust_price` int NOT NULL DEFAULT 0 COMMENT '订单调价（总），单位：分',\n  `pay_price` int NOT NULL DEFAULT 0 COMMENT '子订单实付金额（总），不算主订单分摊金额，单位：分',\n  `coupon_price` int NOT NULL DEFAULT 0 COMMENT '优惠劵减免金额，单位：分',\n  `point_price` int NOT NULL DEFAULT 0 COMMENT '积分抵扣的金额',\n  `vip_price` int NOT NULL DEFAULT 0 COMMENT 'VIP 减免金额，单位：分',\n  \n  `use_point` int NOT NULL DEFAULT 0 COMMENT '使用的积分',\n  `give_point` int NOT NULL DEFAULT 0 COMMENT '赠送的积分',\n\n  `after_sale_id` bigint UNSIGNED NULL DEFAULT NULL COMMENT '售后订单编号',\n  `after_sale_status` int NOT NULL DEFAULT 0 COMMENT '售后状态',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 124 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_bin COMMENT = '交易订单明细表';\n\n\n字段也是非常多，但是和订单表类似，我们也来分块来看看。\n\n① 【用户】user_id 字段：对应的用户编号。\n\n② 【订单】order_id 字段：关联的订单编号。\n\n③ 【商品】spu_id、spu_name、sku_id、properties、pic_url、count 字段：商品 SPU、SKU 相关信息。用户下单的每个 SKU 会对应一条 trade_order_item 记录。\n\n④ 【状态】comment_status 字段：订单项是否评价。\n\n⑤ 【价格】price、discount_price、delivery_price、adjust_price、pay_price、coupon_price、point_price、vip_price 字段：订单项的价格信息。\n\n⑥ 【营销】use_point、give_point 字段：订单项的积分信息。\n\n⑦ 【售后】after_sale_id、after_sale_status 字段：订单项的售后信息。每个订单项只能发起一次售后，所以这里只有一个 after_sale_id 字段。\n\n\n# 1.3 订单日志表\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `trade_order_log`  (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '日志主键',\n  `user_id` bigint NOT NULL COMMENT '用户编号',\n  `user_type` tinyint NOT NULL DEFAULT 0 COMMENT '用户类型',\n  `order_id` bigint NOT NULL COMMENT '订单号',\n  `before_status` tinyint NULL DEFAULT NULL COMMENT '操作前状态',\n  `after_status` tinyint NULL DEFAULT NULL COMMENT '操作后状态',\n  `operate_type` int NOT NULL DEFAULT 0 COMMENT '操作类型',\n  `content` varchar(2000) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '操作内容',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 8602 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci COMMENT = '交易订单日志';\n\n\n每次订单状态变更，都会记录一条日志，方便后续查询、统计。\n\n通过 @TradeOrderLog 注解，基于 Spring AOP 实现记录，具体可以看看 TradeOrderLogAspect 类。\n\n\n# 2. 订单流程\n\n本小节，我们按照订单的 结算 => 提交 => 支付 => 发货 => 收货 => 评价 流程，来看看订单的各个阶段。\n\n\n\n\n\n\n# 2.1 结算【买家】\n\n① 前端对应 yudao-mall-uniapp 项目的 pages/order/confirm.vue 页面，如下图所示：\n\n\n\n② 后端对应 AppTradeOrderController 的 #settlementOrder(...) 提供的“获得订单结算信息”接口，核心的价格计算通过 TradePriceCalculator 实现。如下图所示：\n\n\n\nTradePriceCalculator 只是一个接口，它有多个实现类，满足不同的价格计算组合：\n\n * 优惠劵：TradeCouponPriceCalculator\n * 运费：TradeDeliveryPriceCalculator\n * 积分：TradePointUsePriceCalculator、TradePointGiveCalculator\n * VIP：TradeMemberLevelPriceCalculator\n * 限时折扣：TradeDiscountActivityPriceCalculator\n * 满减送：TradeRewardActivityPriceCalculator\n * 拼团：TradeCombinationActivityPriceCalculator\n * 秒杀：TradeSeckillActivityPriceCalculator\n * 砍价：TradeBargainActivityPriceCalculator\n\n\n# 2.2 提交【买家】\n\n点击「提交订单」按钮后，会调用 AppTradeOrderController 的 #createOrder(...) 提供的“提交订单”接口，插入一条 trade_order、多条 trade_order_item 记录。\n\n订单状态：待支付\n\n由于这个过程中会涉及到很多业务，所以我们把它们抽象成一个又一个 TradeOrderHandler 实现，如下图所示：\n\n\n\n * 库存扣减：TradeProductSkuOrderHandler\n * 积分扣减：TradeMemberPointOrderHandler\n * 优惠劵使用：TradeCouponOrderHandler\n * 订单分销：TradeBrokerageOrderHandler\n * 拼团处理：TradeCombinationOrderHandler\n * 秒杀处理：TradeSeckillOrderHandler\n * 砍价处理：TradeBargainOrderHandler\n\n\n# 2.3 支付【买家】\n\n① 订单提交成功后，会进入支付页面，如下图所示：\n\n\n\n这块已经在 《微信公众号支付接入》、《微信小程序支付接入》 文档中介绍过了，这里就不再赘述。\n\n② 支付成功后，【支付中心】会回调 AppTradeOrderController 的 #updateOrderPaid(...) 提供的“支付成功回调”接口，更新 trade_order 为已支付（待发货）。\n\n订单状态：待发货（已支付）\n\n③ 支付成功后，【前端】会跳转到“支付结果”页面，对应 yudao-mall-uniapp 项目的 pages/pay/result.vue 页面。如下图所示：\n\n\n\n④ 点击「查看订单」按钮，进入我的订单列表，对应 yudao-mall-uniapp 项目的 pages/order/list.vue 页面。如下图所示：\n\n\n\n⑤ 点击某个订单，进入订单详情，对应 yudao-mall-uniapp 项目的 pages/order/detail.vue 页面。如下图所示：\n\n\n\n此时，需要等待卖家发货。\n\n\n# 2.4 发货【卖家】\n\n① 卖家可以在订单列表进行发货，对应 [商城系统 -> 订单中心 -> 订单列表] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/trade/order 目录。如下图所示：\n\n\n\n当然，也可以在订单详情页进行发货，点击「详情」按钮进入，对应 yudao-ui-admin-vue3 项目的 @/views/trade/order/detail.vue 文件。如下图所示：\n\n\n\n② 卖家点击「发货」按钮，进入发货页面，对应 yudao-ui-admin-vue3 项目的 @/views/trade/order/delivery.vue 文件。如下图所示：\n\n\n\n这里，我们选择物流公司为“申通快递”，并输入物流单号为“777168349863987”（因为它有真实物流数据），点击「确定」按钮，完成发货，更新 trade_order 为已发货（待收货）。\n\n订单状态：已发货（待收货）\n\nps：微信小程序的发货，可以使用订阅消息功能，具体可以后面看看 《微信小程序订阅消息》 文档。\n\n\n# 2.5 收货【买家】\n\n① 买家点击「查看物流」按钮，进入物流详情页，对应 yudao-mall-uniapp 项目的 pages/order/express/log.vue 页面。如下图所示：\n\n\n\n② 物流信息，由 AppTradeOrderController 的 #getOrderExpressTrackList(...) 提供的“获得交易订单的物流轨迹”接口。它的核心实现由 ExpressClient 实现，如下图所示：\n\n\n\n * KdNiaoExpressClient：对接快递鸟的客户端，官方文档 https://www.kdniao.com/api-follow\n * Kd100ExpressClient：对接快递 100 的客户端，官方文档 https://api.kuaidi100.com/document/\n\n具体使用哪个客户端，可修改 application.yaml 配置文件的 yudao.trade.express.client 配置项。如下图所示：\n\n\n\n另外，如果使用快递鸟的话，要注意 8001 是免费套餐，1002 是付费套餐，可见 https://t.zsxq.com/GcSDL 讨论。\n\n③ 回到订单详情页，点击「确认收货」按钮，完成收货，更新 trade_order 为已完成。\n\n订单状态：已完成（未评价）\n\n\n\n\n# 2.6 评价【买家】\n\n① 买家点击「评价」按钮，进入评价页，这块已经在 《【商品】商品评价》 文档中介绍过了，这里就不再赘述。\n\n评价接口由 AppTradeOrderController 的 #createOrderItemComment(...) 所提供的“创建交易订单项的评价”接口。\n\n② 评价成功后，更新 trade_order 为已评价。\n\n订单状态：已完成（已评价）\n\n至此，订单流程结束~可以试着多多 debug 调试整个流程，并不复杂噢。",
            normalizedContent: "# 1. 表结构\n\n交易订单，由 yudao-module-trade-biz 后端模块的 order 包实现，分成三个表：\n\n\n\n * trade_order 订单主表\n * trade_order_item 订单项子表\n * trade_order_log 订单日志表\n\n\n# 1. 订单表\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `trade_order`  (\n  `id` bigint not null auto_increment comment '订单编号',\n  `no` varchar(32) character set utf8mb4 collate utf8mb4_bin not null comment '订单流水号',\n    \n  `type` int not null default 0 comment '订单类型',\n  `seckill_activity_id` bigint null default null comment '秒杀活动编号',\n  `bargain_activity_id` bigint null default null comment '砍价活动编号',\n  `bargain_record_id` bigint null default null comment '砍价记录编号',\n  `combination_activity_id` bigint null default null comment '拼团活动编号',\n  `combination_head_id` bigint null default null comment '拼团团长编号',\n  `combination_record_id` bigint null default null comment '拼团记录编号',\n\n  `user_id` bigint unsigned not null comment '用户编号',    \n  `terminal` int not null comment '订单来源终端',\n  `user_ip` varchar(30) character set utf8mb4 collate utf8mb4_bin not null default '' comment '用户 ip',\n    \n  `status` int not null default 0 comment '订单状态',\n  `cancel_type` int null default null comment '取消类型',\n  `comment_status` bit(1) not null default b'0' comment '是否评价',\n  `cancel_time` datetime null default null comment '订单取消时间',\n  `finish_time` datetime null default null comment '订单完成时间',\n\n  `user_remark` varchar(200) character set utf8mb4 collate utf8mb4_bin null default null comment '用户备注',\n  `product_count` int not null comment '购买的商品数量',\n  `remark` varchar(200) character set utf8mb4 collate utf8mb4_bin null default null comment '商家备注',\n  \n  `brokerage_user_id` bigint null default null comment '推广人编号',\n  \n  `pay_order_id` bigint null default null comment '支付订单编号',\n  `pay_status` bit(1) not null default b'0' comment '是否已支付：[0:未支付 1:已经支付过]',\n  `pay_time` datetime null default null comment '订单支付时间',\n  `pay_channel_code` varchar(16) character set utf8mb4 collate utf8mb4_bin null default null comment '支付成功的支付渠道',\n    \n  `total_price` int not null default 0 comment '商品原价（总），单位：分',\n  `discount_price` int not null default 0 comment '订单优惠（总），单位：分',\n  `delivery_price` int not null default 0 comment '运费金额，单位：分',\n  `adjust_price` int not null default 0 comment '订单调价（总），单位：分',\n  `pay_price` int not null default 0 comment '应付金额（总），单位：分',\n  `coupon_price` int not null default 0 comment '优惠劵减免金额，单位：分',\n  `point_price` int not null default 0 comment '积分抵扣的金额',\n  `vip_price` int not null default 0 comment 'vip 减免金额，单位：分',\n\n  `coupon_id` bigint unsigned null default null comment '优惠劵编号',\n  `use_point` int not null default 0 comment '使用的积分',\n  `give_point` int not null default 0 comment '赠送的积分',\n\n  `refund_status` tinyint not null default 0 comment '售后状态',\n  `refund_point` int not null default 0 comment '退还的使用的积分',\n  `refund_price` int not null default 0 comment '退款金额，单位：分',\n\n  `delivery_type` tinyint not null comment '配送类型',\n  `logistics_id` bigint null default null comment '发货物流公司编号',\n  `logistics_no` varchar(64) character set utf8mb4 collate utf8mb4_bin null default null comment '物流公司单号',\n  `delivery_time` datetime null default null comment '发货时间',\n  `receive_time` datetime null default null comment '收货时间',\n  `receiver_name` varchar(20) character set utf8mb4 collate utf8mb4_bin not null comment '收件人名称',\n  `receiver_mobile` varchar(20) character set utf8mb4 collate utf8mb4_bin not null comment '收件人手机',\n  `receiver_area_id` int null default null comment '收件人地区编号',\n  `receiver_detail_address` varchar(255) character set utf8mb4 collate utf8mb4_bin null default null comment '收件人详细地址',\n  `pick_up_store_id` bigint null default null comment '自提门店编号',\n  `pick_up_verify_code` varchar(64) character set utf8mb4 collate utf8mb4_bin null default null comment '自提核销码',\n\n  primary key (`id`) using btree\n) engine = innodb auto_increment = 128 character set = utf8mb4 collate = utf8mb4_bin comment = '交易订单表';\n\n\n字段还是非常多的，我们来分块来看看。\n\n① no 字段：订单流水号，主要展示给用户看，由 tradenoredisdao 的 #generate(...) 方法生成。\n\n而 id 字段是数据库自增的订单编号，系统内部使用，一般不展示给用户查看。\n\n② type 字段：订单类型，使用 tradeordertypeenum 枚举，目前有 4 种类型的订单：\n\n * 普通：一般情况下的订单，未参与秒杀、砍价、拼团活动\n * 秒杀：参与秒杀活动，会关联 seckill_activity_id 字段\n * 砍价：参与砍价活动，会关联 bargain_activity_id、bargain_record_id 字段\n * 拼团：参与拼团活动，会关联 combination_activity_id、combination_head_id、combination_record_id 字段\n\n③ 【用户】user_id、terminal、user_ip 字段：下单的用户信息。\n\n④ 【状态】status 字段：订单状态，由 tradeorderstatusenum 枚举，流转状态如下图：\n\n\n\ncancel_type 字段：取消类型，标记 status 为“已取消”的原因，由 tradeordercanceltypeenum 枚举，例如说：超时未支付、退款关闭、买家取消。\n\ncomment_status 字段：订单是否评价。目的是，uni-app 筛选未评价的订单列表，也有商城系统会该字段融合到 status 作为“待评价”状态。\n\n⑤ 【支付】pay_status 字段：是否已支付。由于订单可以全部退款变成“已关闭”状态，所以需要 pay_status 区分该订单实际是否发生过支付。\n\npay_order_id 字段：关联的支付中心的支付单号。对支付中心还不了解的同学，可以阅读下 《支付手册》 文档。\n\n⑥ 【价格】各种价格字段，最终使用 pay_price 字段进行支付，分类如下：\n\n * + 收钱：total_price、delivery_price\n * - 优惠：discount_price、coupon_price、point_price、vip_price\n * ? 改价：adjust_price\n\n价格字段拆的这些细，主要是 uni-app 或者管理后台需要展示，同时我们也需要搞清楚一个订单的具体价格明细。\n\n⑦ 【营销】coupon_id、use_point、give_point 字段：优惠劵、积分相关信息。\n\n⑧ 【退款】refund_status 字段：订单的整体售后（退款）状态，由 tradeorderrefundstatusenum 枚举，有 3 种状态：未退款、部分退款、全部退款。如果全部退款，则订单 status 变成“已关闭”。\n\nrefund_point、refund_price 字段：退款的积分、金额。\n\n⑨ 【配送】delivery_type 字段：配送类型，由 deliverytypeenum 枚举，有 2 种类型：\n\n * 快递发货：使用 logistics_id、logistics_no、receiver_name、receiver_mobile、receiver_area_id、receiver_detail_address 字段\n * 用户自提：使用 pick_up_store_id、pick_up_verify_code 字段\n\n⑩ 各种 _time 结尾的字段，就是各种阶段、操作的时间，满足业务查询、统计需求。\n\n\n# 1.2 订单项表\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `trade_order_item`  (\n  `id` bigint not null auto_increment comment '订单项编号',\n  \n  `user_id` bigint unsigned not null comment '用户编号',\n  `order_id` bigint unsigned not null comment '订单编号',\n  `cart_id` bigint unsigned null default null comment '购物车项编号',\n  \n  `spu_id` bigint unsigned not null comment '商品 spu 编号',\n  `spu_name` varchar(255) character set utf8mb4 collate utf8mb4_bin not null comment '商品 spu 名称',\n  `sku_id` bigint unsigned not null comment '商品 sku 编号',\n  `properties` json null comment '商品属性数组，json 格式',\n  `pic_url` varchar(200) character set utf8mb4 collate utf8mb4_bin null default null comment '商品图片',\n  `count` int not null comment '购买数量',\n  \n  `comment_status` bit(1) not null default b'0' comment '是否评价',\n  \n  `price` int not null default 0 comment '商品原价（单），单位：分',\n  `discount_price` int not null default 0 comment '商品级优惠（总），单位：分',\n  `delivery_price` int not null default 0 comment '运费金额，单位：分',\n  `adjust_price` int not null default 0 comment '订单调价（总），单位：分',\n  `pay_price` int not null default 0 comment '子订单实付金额（总），不算主订单分摊金额，单位：分',\n  `coupon_price` int not null default 0 comment '优惠劵减免金额，单位：分',\n  `point_price` int not null default 0 comment '积分抵扣的金额',\n  `vip_price` int not null default 0 comment 'vip 减免金额，单位：分',\n  \n  `use_point` int not null default 0 comment '使用的积分',\n  `give_point` int not null default 0 comment '赠送的积分',\n\n  `after_sale_id` bigint unsigned null default null comment '售后订单编号',\n  `after_sale_status` int not null default 0 comment '售后状态',\n  primary key (`id`) using btree\n) engine = innodb auto_increment = 124 character set = utf8mb4 collate = utf8mb4_bin comment = '交易订单明细表';\n\n\n字段也是非常多，但是和订单表类似，我们也来分块来看看。\n\n① 【用户】user_id 字段：对应的用户编号。\n\n② 【订单】order_id 字段：关联的订单编号。\n\n③ 【商品】spu_id、spu_name、sku_id、properties、pic_url、count 字段：商品 spu、sku 相关信息。用户下单的每个 sku 会对应一条 trade_order_item 记录。\n\n④ 【状态】comment_status 字段：订单项是否评价。\n\n⑤ 【价格】price、discount_price、delivery_price、adjust_price、pay_price、coupon_price、point_price、vip_price 字段：订单项的价格信息。\n\n⑥ 【营销】use_point、give_point 字段：订单项的积分信息。\n\n⑦ 【售后】after_sale_id、after_sale_status 字段：订单项的售后信息。每个订单项只能发起一次售后，所以这里只有一个 after_sale_id 字段。\n\n\n# 1.3 订单日志表\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `trade_order_log`  (\n  `id` bigint not null auto_increment comment '日志主键',\n  `user_id` bigint not null comment '用户编号',\n  `user_type` tinyint not null default 0 comment '用户类型',\n  `order_id` bigint not null comment '订单号',\n  `before_status` tinyint null default null comment '操作前状态',\n  `after_status` tinyint null default null comment '操作后状态',\n  `operate_type` int not null default 0 comment '操作类型',\n  `content` varchar(2000) character set utf8mb4 collate utf8mb4_unicode_ci not null default '' comment '操作内容',\n  primary key (`id`) using btree\n) engine = innodb auto_increment = 8602 character set = utf8mb4 collate = utf8mb4_unicode_ci comment = '交易订单日志';\n\n\n每次订单状态变更，都会记录一条日志，方便后续查询、统计。\n\n通过 @tradeorderlog 注解，基于 spring aop 实现记录，具体可以看看 tradeorderlogaspect 类。\n\n\n# 2. 订单流程\n\n本小节，我们按照订单的 结算 => 提交 => 支付 => 发货 => 收货 => 评价 流程，来看看订单的各个阶段。\n\n\n\n\n\n\n# 2.1 结算【买家】\n\n① 前端对应 yudao-mall-uniapp 项目的 pages/order/confirm.vue 页面，如下图所示：\n\n\n\n② 后端对应 apptradeordercontroller 的 #settlementorder(...) 提供的“获得订单结算信息”接口，核心的价格计算通过 tradepricecalculator 实现。如下图所示：\n\n\n\ntradepricecalculator 只是一个接口，它有多个实现类，满足不同的价格计算组合：\n\n * 优惠劵：tradecouponpricecalculator\n * 运费：tradedeliverypricecalculator\n * 积分：tradepointusepricecalculator、tradepointgivecalculator\n * vip：tradememberlevelpricecalculator\n * 限时折扣：tradediscountactivitypricecalculator\n * 满减送：traderewardactivitypricecalculator\n * 拼团：tradecombinationactivitypricecalculator\n * 秒杀：tradeseckillactivitypricecalculator\n * 砍价：tradebargainactivitypricecalculator\n\n\n# 2.2 提交【买家】\n\n点击「提交订单」按钮后，会调用 apptradeordercontroller 的 #createorder(...) 提供的“提交订单”接口，插入一条 trade_order、多条 trade_order_item 记录。\n\n订单状态：待支付\n\n由于这个过程中会涉及到很多业务，所以我们把它们抽象成一个又一个 tradeorderhandler 实现，如下图所示：\n\n\n\n * 库存扣减：tradeproductskuorderhandler\n * 积分扣减：tradememberpointorderhandler\n * 优惠劵使用：tradecouponorderhandler\n * 订单分销：tradebrokerageorderhandler\n * 拼团处理：tradecombinationorderhandler\n * 秒杀处理：tradeseckillorderhandler\n * 砍价处理：tradebargainorderhandler\n\n\n# 2.3 支付【买家】\n\n① 订单提交成功后，会进入支付页面，如下图所示：\n\n\n\n这块已经在 《微信公众号支付接入》、《微信小程序支付接入》 文档中介绍过了，这里就不再赘述。\n\n② 支付成功后，【支付中心】会回调 apptradeordercontroller 的 #updateorderpaid(...) 提供的“支付成功回调”接口，更新 trade_order 为已支付（待发货）。\n\n订单状态：待发货（已支付）\n\n③ 支付成功后，【前端】会跳转到“支付结果”页面，对应 yudao-mall-uniapp 项目的 pages/pay/result.vue 页面。如下图所示：\n\n\n\n④ 点击「查看订单」按钮，进入我的订单列表，对应 yudao-mall-uniapp 项目的 pages/order/list.vue 页面。如下图所示：\n\n\n\n⑤ 点击某个订单，进入订单详情，对应 yudao-mall-uniapp 项目的 pages/order/detail.vue 页面。如下图所示：\n\n\n\n此时，需要等待卖家发货。\n\n\n# 2.4 发货【卖家】\n\n① 卖家可以在订单列表进行发货，对应 [商城系统 -> 订单中心 -> 订单列表] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/trade/order 目录。如下图所示：\n\n\n\n当然，也可以在订单详情页进行发货，点击「详情」按钮进入，对应 yudao-ui-admin-vue3 项目的 @/views/trade/order/detail.vue 文件。如下图所示：\n\n\n\n② 卖家点击「发货」按钮，进入发货页面，对应 yudao-ui-admin-vue3 项目的 @/views/trade/order/delivery.vue 文件。如下图所示：\n\n\n\n这里，我们选择物流公司为“申通快递”，并输入物流单号为“777168349863987”（因为它有真实物流数据），点击「确定」按钮，完成发货，更新 trade_order 为已发货（待收货）。\n\n订单状态：已发货（待收货）\n\nps：微信小程序的发货，可以使用订阅消息功能，具体可以后面看看 《微信小程序订阅消息》 文档。\n\n\n# 2.5 收货【买家】\n\n① 买家点击「查看物流」按钮，进入物流详情页，对应 yudao-mall-uniapp 项目的 pages/order/express/log.vue 页面。如下图所示：\n\n\n\n② 物流信息，由 apptradeordercontroller 的 #getorderexpresstracklist(...) 提供的“获得交易订单的物流轨迹”接口。它的核心实现由 expressclient 实现，如下图所示：\n\n\n\n * kdniaoexpressclient：对接快递鸟的客户端，官方文档 https://www.kdniao.com/api-follow\n * kd100expressclient：对接快递 100 的客户端，官方文档 https://api.kuaidi100.com/document/\n\n具体使用哪个客户端，可修改 application.yaml 配置文件的 yudao.trade.express.client 配置项。如下图所示：\n\n\n\n另外，如果使用快递鸟的话，要注意 8001 是免费套餐，1002 是付费套餐，可见 https://t.zsxq.com/gcsdl 讨论。\n\n③ 回到订单详情页，点击「确认收货」按钮，完成收货，更新 trade_order 为已完成。\n\n订单状态：已完成（未评价）\n\n\n\n\n# 2.6 评价【买家】\n\n① 买家点击「评价」按钮，进入评价页，这块已经在 《【商品】商品评价》 文档中介绍过了，这里就不再赘述。\n\n评价接口由 apptradeordercontroller 的 #createorderitemcomment(...) 所提供的“创建交易订单项的评价”接口。\n\n② 评价成功后，更新 trade_order 为已评价。\n\n订单状态：已完成（已评价）\n\n至此，订单流程结束~可以试着多多 debug 调试整个流程，并不复杂噢。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【交易】售后退款",
            frontmatter: {
                title: "【交易】售后退款",
                date: "2024-01-15T18:18:00.000Z",
                permalink: "/mall/trade-aftersale/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/14.%E5%95%86%E5%9F%8E%E6%89%8B%E5%86%8C/23.%E3%80%90%E4%BA%A4%E6%98%93%E3%80%91%E5%94%AE%E5%90%8E%E9%80%80%E6%AC%BE.html",
            relativePath: "01.开发指南/14.商城手册/23.【交易】售后退款.md",
            key: "v-c0d3292c",
            path: "/mall/trade-aftersale/",
            headers: [{
                level: 2,
                title: "1. 表结构",
                slug: "_1-表结构",
                normalizedTitle: "1. 表结构",
                charIndex: 2
            }, {
                level: 3,
                title: "1.1 售后订单表",
                slug: "_1-1-售后订单表",
                normalizedTitle: "1.1 售后订单表",
                charIndex: 133
            }, {
                level: 3,
                title: "1.2 售后订单日志表",
                slug: "_1-2-售后订单日志表",
                normalizedTitle: "1.2 售后订单日志表",
                charIndex: 3425
            }, {
                level: 2,
                title: "2. 售后流程",
                slug: "_2-售后流程",
                normalizedTitle: "2. 售后流程",
                charIndex: 4227
            }, {
                level: 3,
                title: "2.1 申请【买家】",
                slug: "_2-1-申请【买家】",
                normalizedTitle: "2.1 申请【买家】",
                charIndex: 4298
            }, {
                level: 3,
                title: "2.2 审批【卖家】",
                slug: "_2-2-审批【卖家】",
                normalizedTitle: "2.2 审批【卖家】",
                charIndex: 4836
            }, {
                level: 3,
                title: "2.3 退货【买家】",
                slug: "_2-3-退货【买家】",
                normalizedTitle: "2.3 退货【买家】",
                charIndex: 5220
            }, {
                level: 3,
                title: "2.4 收货【卖家】",
                slug: "_2-4-收货【卖家】",
                normalizedTitle: "2.4 收货【卖家】",
                charIndex: 5506
            }, {
                level: 3,
                title: "2.5 退款【卖家】",
                slug: "_2-5-退款【卖家】",
                normalizedTitle: "2.5 退款【卖家】",
                charIndex: 5682
            }, {
                level: 2,
                title: "3. 售后配置",
                slug: "_3-售后配置",
                normalizedTitle: "3. 售后配置",
                charIndex: 6048
            }],
            headersStr: "1. 表结构 1.1 售后订单表 1.2 售后订单日志表 2. 售后流程 2.1 申请【买家】 2.2 审批【卖家】 2.3 退货【买家】 2.4 收货【卖家】 2.5 退款【卖家】 3. 售后配置",
            content: "# 1. 表结构\n\n售后退款，由 yudao-module-trade-biz 后端模块的 aftersale 包实现，分成二个表：\n\n\n\n * trade_after_sale_：售后订单表\n * trade_after_sale_log：售后订单日志表\n\n\n# 1.1 售后订单表\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `trade_after_sale` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '售后编号',\n  `no` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '售后单号',\n  `user_id` bigint unsigned NOT NULL COMMENT '用户编号',\n  \n  `type` tinyint DEFAULT NULL COMMENT '售后类型',\n\n  `status` int NOT NULL DEFAULT '0' COMMENT '售后状态',\n  `way` tinyint NOT NULL COMMENT '售后方式',\n  \n  `refund_price` int NOT NULL DEFAULT '0' COMMENT '退款金额，单位：分',\n  `apply_reason` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '申请原因',\n  `apply_description` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '补充描述',\n  `apply_pic_urls` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '补充凭证图片',\n  \n  `order_id` bigint unsigned NOT NULL COMMENT '订单编号',\n  `order_no` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '订单流水号',\n  `order_item_Id` bigint unsigned NOT NULL COMMENT '订单项编号',\n  \n  `spu_id` bigint unsigned NOT NULL COMMENT '商品 SPU 编号',\n  `spu_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '商品 SPU 名称',\n  `sku_id` bigint unsigned NOT NULL COMMENT '商品 SKU 编号',\n  `properties` json DEFAULT NULL COMMENT '商品属性数组，JSON 格式',\n  `pic_url` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '商品图片',\n  `count` int NOT NULL COMMENT '购买数量',\n  \n  `audit_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '审批时间',\n  `audit_user_id` bigint unsigned DEFAULT NULL COMMENT '审批人',\n  `audit_reason` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '审批备注',\n  \n  `logistics_id` bigint DEFAULT NULL COMMENT '退货物流公司编号',\n  `logistics_no` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '退货物流单号',\n  `delivery_time` datetime DEFAULT NULL COMMENT '退货时间',\n  `receive_time` datetime DEFAULT NULL COMMENT '收货时间',\n  `receive_reason` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '收货备注',\n  \n  `pay_refund_id` bigint unsigned DEFAULT NULL COMMENT '支付退款编号',\n  `refund_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '退款时间',\n\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=23 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin COMMENT='售后订单';\n\n\n字段还是非常多的，我们来分块来看看。\n\n① no 字段：售后单号，主要展示给用户看，由 TradeNoRedisDAO 的 #generate(...) 方法生成。\n\n而 id 字段是数据库自增的订单编号，系统内部使用，一般不展示给用户查看。\n\n② 【类型】type 字段：售后类型，由 AfterSaleTypeEnum 枚举，分成两种类型：\n\n * 售中退款：交易完成【前】买家申请退款\n * 售后退款：交易完成【后】买家申请退款\n\n③ 【状态】status 字段：订单状态，由 AfterSaleStatusEnum 枚举，流转状态如下图：\n\n\n\nway 字段：售后方式，由 AfterSaleWayEnum 枚举，分成两种方式：仅退款、退货退款。如上图所示，退款会多 SELLER_AGREE、BUYER_DELIVERY 两个动作。\n\n④ 【申请】refund_price、apply_reason、apply_description、apply_pic_urls 字段：买家发起售后的基本信息。\n\n⑤ 【订单】order_id、order_no、order_item_Id 字段：关联的订单项信息，一个 trade_order_item 可以发起多次售后，同一时间只允许一个，并且最终只能有一个成功。\n\n如果你希望一个售后订单可以退多个订单项，需要自己加个 trade_after_sale_item 表，将部分【订单信息】【商品信息】挪过去。\n\n⑥ 【商品】spu_id、sku_id、count 字段：关联的商品信息。冗余的 spu_name、pic_url、properties 字段，是为了方便查询。\n\n⑦ 【审核】audit_time、audit_user_id、audit_reason 字段：卖家审核的信息。\n\n⑧ 【退货】logistics_id、logistics_no、delivery_time 字段：买家退货的信息。\n\nreceive_time、receive_reason 字段：卖家收货的信息。\n\n⑨ 【退款】pay_refund_id、refund_time 字段：退款的信息。 其中，pay_refund_id 关联的支付中心的退款单号。对支付中心还不了解的同学，可以阅读下 《支付手册》 文档。\n\n\n# 1.2 售后订单日志表\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `trade_after_sale_log` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  `user_id` bigint NOT NULL COMMENT '用户编号',\n  `user_type` tinyint NOT NULL COMMENT '用户类型',\n  `after_sale_id` bigint NOT NULL COMMENT '售后编号',\n  `before_status` tinyint DEFAULT NULL COMMENT '售后状态（之前）',\n  `after_status` tinyint NOT NULL COMMENT '售后状态（之后）',\n  `operate_type` tinyint NOT NULL COMMENT '操作类型',\n  `content` varchar(512) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '操作明细',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=32 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin COMMENT='售后订单日志';\n\n\n每次售后状态变更，都会记录一条日志，方便后续查询、统计。\n\n通过 @AfterSaleLog 注解，基于 Spring AOP 实现记录，具体可以看看 AfterSaleLogAspect 类。\n\n\n# 2. 售后流程\n\n本小节，我们按照售后的 申请 => 审批 => 退货 => 收货 => 退款 流程，来看看售后的各个阶段。\n\n\n\n\n\n\n# 2.1 申请【买家】\n\n① 点击「申请售后」按钮，进入售后页面，对应前端 yudao-mall-uniapp 项目的 pages/order/aftersale/apply.vue 页面，如下图所示：\n\n\n\n另外，可选的“申请原因”，可在 trade_config 表的 after_sale_refund_reasons、after_sale_return_reasons 字段配置。\n\n② 点击「提交」按钮，调用后端对应 AppAfterSaleController 的 #createAfterSale(...) 提供的“申请售后”接口，插入 trade_after_sale 表一条记录，状态为 APPLY 申请中。\n\n售后状态：APPLY 申请中\n\n③ 发起成功后，进入售后列表页面，对应前端 yudao-mall-uniapp 项目的 pages/order/aftersale/list.vue 页面，如下图所示：\n\n\n\n④ 点击第一条售后记录，进入售后详情页面，对应前端 yudao-mall-uniapp 项目的 pages/order/aftersale/detail.vue 页面，如下图所示：\n\n\n\n此时，买家只能等待卖家审核，或者取消售后。\n\n\n# 2.2 审批【卖家】\n\n① 卖家可以在售后列表进行审批，对应 [商城系统 -> 订单中心 -> 售后退款] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/trade/afterSale 目录。如下图所示：\n\n\n\n② 点击第一条售后记录的「处理退款」按钮，进入售后详情页面，对应 yudao-ui-admin-vue3 项目的 @/views/trade/afterSale/detail 目录，如下图所示：\n\n\n\n③ 点击「同意售后」按钮，调用后端对应 AfterSaleController 的 #agreeAfterSale(...) 提供的“同意售后”接口，更新 trade_after_sale 表的状态为 SELLER_AGREE 卖家通过（待买家退货）。\n\n售后状态：SELLER_AGREE 卖家通过（待买家退货）\n\n\n# 2.3 退货【买家】\n\n① 点击「填写退货」按钮，进入退货页面，对应前端 yudao-mall-uniapp 项目的 pages/order/aftersale/return-delivery.vue 页面，如下图所示：\n\n\n\n② 点击「提交」按钮，调用后端对应 AppAfterSaleController 的 #deliveryAfterSale(...) 提供的“退回货物”接口，更新 trade_after_sale 表的状态为 BUYER_DELIVERY 买家已退货（待卖家收货）。\n\n售后状态：BUYER_DELIVERY 买家已退货（待卖家收货）\n\n\n# 2.4 收货【卖家】\n\n点击「确认收货」按钮，调用后端对应 AfterSaleController 的 #receiveAfterSale(...) 提供的“确认收货”接口，更新 trade_after_sale 表的状态为 WAIT_REFUND 卖家已收货（待卖家退款）。\n\n售后状态：WAIT_REFUND 卖家已收货（待卖家退款）\n\n\n\n\n# 2.5 退款【卖家】\n\n① 点击「确认退款」按钮，调用后端对应 AfterSaleController 的 #refundAfterSale(...) 提供的“确认退款”接口，更新 trade_after_sale 表的状态为 COMPLETE 退款成功。\n\n售后状态：COMPLETE 退款成功\n\n\n\n该接口的内部实现，主要是调用支付中心的退款接口，具体可以看看 《21.支付宝、微信退款接入》 文档。\n\n② 在真正退款到卖家的支付宝、微信账户后（退款是个异步过程），支付中心会回调 AfterSaleController 的 #updateAfterRefund(...) 提供的“更新售后订单为已退款”接口，目前仅仅打印日志，可以按需拓展。\n\n至此，售后流程结束~可以试着多多 debug 调试整个流程，并不复杂噢。\n\n\n# 3. 售后配置\n\n\n\n * SQL 对应 trade_config 表的 after_sale_ 开头的字段。\n * 前端对应 yudao-ui-admin-vue3 项目的 views/mall/trade/config/index.vue 目录\n * 后端对应 yudao-module-trade-biz 项目的 TradeConfigController 类",
            normalizedContent: "# 1. 表结构\n\n售后退款，由 yudao-module-trade-biz 后端模块的 aftersale 包实现，分成二个表：\n\n\n\n * trade_after_sale_：售后订单表\n * trade_after_sale_log：售后订单日志表\n\n\n# 1.1 售后订单表\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `trade_after_sale` (\n  `id` bigint not null auto_increment comment '售后编号',\n  `no` varchar(32) character set utf8mb4 collate utf8mb4_bin not null comment '售后单号',\n  `user_id` bigint unsigned not null comment '用户编号',\n  \n  `type` tinyint default null comment '售后类型',\n\n  `status` int not null default '0' comment '售后状态',\n  `way` tinyint not null comment '售后方式',\n  \n  `refund_price` int not null default '0' comment '退款金额，单位：分',\n  `apply_reason` varchar(255) character set utf8mb4 collate utf8mb4_bin not null comment '申请原因',\n  `apply_description` varchar(255) character set utf8mb4 collate utf8mb4_bin default null comment '补充描述',\n  `apply_pic_urls` varchar(255) character set utf8mb4 collate utf8mb4_bin default null comment '补充凭证图片',\n  \n  `order_id` bigint unsigned not null comment '订单编号',\n  `order_no` varchar(32) character set utf8mb4 collate utf8mb4_bin not null comment '订单流水号',\n  `order_item_id` bigint unsigned not null comment '订单项编号',\n  \n  `spu_id` bigint unsigned not null comment '商品 spu 编号',\n  `spu_name` varchar(255) character set utf8mb4 collate utf8mb4_bin not null comment '商品 spu 名称',\n  `sku_id` bigint unsigned not null comment '商品 sku 编号',\n  `properties` json default null comment '商品属性数组，json 格式',\n  `pic_url` varchar(200) character set utf8mb4 collate utf8mb4_bin default null comment '商品图片',\n  `count` int not null comment '购买数量',\n  \n  `audit_time` datetime default current_timestamp comment '审批时间',\n  `audit_user_id` bigint unsigned default null comment '审批人',\n  `audit_reason` varchar(255) character set utf8mb4 collate utf8mb4_bin default null comment '审批备注',\n  \n  `logistics_id` bigint default null comment '退货物流公司编号',\n  `logistics_no` varchar(64) character set utf8mb4 collate utf8mb4_bin default null comment '退货物流单号',\n  `delivery_time` datetime default null comment '退货时间',\n  `receive_time` datetime default null comment '收货时间',\n  `receive_reason` varchar(255) character set utf8mb4 collate utf8mb4_bin default null comment '收货备注',\n  \n  `pay_refund_id` bigint unsigned default null comment '支付退款编号',\n  `refund_time` datetime default current_timestamp comment '退款时间',\n\n  primary key (`id`) using btree\n) engine=innodb auto_increment=23 default charset=utf8mb4 collate=utf8mb4_bin comment='售后订单';\n\n\n字段还是非常多的，我们来分块来看看。\n\n① no 字段：售后单号，主要展示给用户看，由 tradenoredisdao 的 #generate(...) 方法生成。\n\n而 id 字段是数据库自增的订单编号，系统内部使用，一般不展示给用户查看。\n\n② 【类型】type 字段：售后类型，由 aftersaletypeenum 枚举，分成两种类型：\n\n * 售中退款：交易完成【前】买家申请退款\n * 售后退款：交易完成【后】买家申请退款\n\n③ 【状态】status 字段：订单状态，由 aftersalestatusenum 枚举，流转状态如下图：\n\n\n\nway 字段：售后方式，由 aftersalewayenum 枚举，分成两种方式：仅退款、退货退款。如上图所示，退款会多 seller_agree、buyer_delivery 两个动作。\n\n④ 【申请】refund_price、apply_reason、apply_description、apply_pic_urls 字段：买家发起售后的基本信息。\n\n⑤ 【订单】order_id、order_no、order_item_id 字段：关联的订单项信息，一个 trade_order_item 可以发起多次售后，同一时间只允许一个，并且最终只能有一个成功。\n\n如果你希望一个售后订单可以退多个订单项，需要自己加个 trade_after_sale_item 表，将部分【订单信息】【商品信息】挪过去。\n\n⑥ 【商品】spu_id、sku_id、count 字段：关联的商品信息。冗余的 spu_name、pic_url、properties 字段，是为了方便查询。\n\n⑦ 【审核】audit_time、audit_user_id、audit_reason 字段：卖家审核的信息。\n\n⑧ 【退货】logistics_id、logistics_no、delivery_time 字段：买家退货的信息。\n\nreceive_time、receive_reason 字段：卖家收货的信息。\n\n⑨ 【退款】pay_refund_id、refund_time 字段：退款的信息。 其中，pay_refund_id 关联的支付中心的退款单号。对支付中心还不了解的同学，可以阅读下 《支付手册》 文档。\n\n\n# 1.2 售后订单日志表\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `trade_after_sale_log` (\n  `id` bigint not null auto_increment comment '编号',\n  `user_id` bigint not null comment '用户编号',\n  `user_type` tinyint not null comment '用户类型',\n  `after_sale_id` bigint not null comment '售后编号',\n  `before_status` tinyint default null comment '售后状态（之前）',\n  `after_status` tinyint not null comment '售后状态（之后）',\n  `operate_type` tinyint not null comment '操作类型',\n  `content` varchar(512) character set utf8mb4 collate utf8mb4_bin not null comment '操作明细',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=32 default charset=utf8mb4 collate=utf8mb4_bin comment='售后订单日志';\n\n\n每次售后状态变更，都会记录一条日志，方便后续查询、统计。\n\n通过 @aftersalelog 注解，基于 spring aop 实现记录，具体可以看看 aftersalelogaspect 类。\n\n\n# 2. 售后流程\n\n本小节，我们按照售后的 申请 => 审批 => 退货 => 收货 => 退款 流程，来看看售后的各个阶段。\n\n\n\n\n\n\n# 2.1 申请【买家】\n\n① 点击「申请售后」按钮，进入售后页面，对应前端 yudao-mall-uniapp 项目的 pages/order/aftersale/apply.vue 页面，如下图所示：\n\n\n\n另外，可选的“申请原因”，可在 trade_config 表的 after_sale_refund_reasons、after_sale_return_reasons 字段配置。\n\n② 点击「提交」按钮，调用后端对应 appaftersalecontroller 的 #createaftersale(...) 提供的“申请售后”接口，插入 trade_after_sale 表一条记录，状态为 apply 申请中。\n\n售后状态：apply 申请中\n\n③ 发起成功后，进入售后列表页面，对应前端 yudao-mall-uniapp 项目的 pages/order/aftersale/list.vue 页面，如下图所示：\n\n\n\n④ 点击第一条售后记录，进入售后详情页面，对应前端 yudao-mall-uniapp 项目的 pages/order/aftersale/detail.vue 页面，如下图所示：\n\n\n\n此时，买家只能等待卖家审核，或者取消售后。\n\n\n# 2.2 审批【卖家】\n\n① 卖家可以在售后列表进行审批，对应 [商城系统 -> 订单中心 -> 售后退款] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/trade/aftersale 目录。如下图所示：\n\n\n\n② 点击第一条售后记录的「处理退款」按钮，进入售后详情页面，对应 yudao-ui-admin-vue3 项目的 @/views/trade/aftersale/detail 目录，如下图所示：\n\n\n\n③ 点击「同意售后」按钮，调用后端对应 aftersalecontroller 的 #agreeaftersale(...) 提供的“同意售后”接口，更新 trade_after_sale 表的状态为 seller_agree 卖家通过（待买家退货）。\n\n售后状态：seller_agree 卖家通过（待买家退货）\n\n\n# 2.3 退货【买家】\n\n① 点击「填写退货」按钮，进入退货页面，对应前端 yudao-mall-uniapp 项目的 pages/order/aftersale/return-delivery.vue 页面，如下图所示：\n\n\n\n② 点击「提交」按钮，调用后端对应 appaftersalecontroller 的 #deliveryaftersale(...) 提供的“退回货物”接口，更新 trade_after_sale 表的状态为 buyer_delivery 买家已退货（待卖家收货）。\n\n售后状态：buyer_delivery 买家已退货（待卖家收货）\n\n\n# 2.4 收货【卖家】\n\n点击「确认收货」按钮，调用后端对应 aftersalecontroller 的 #receiveaftersale(...) 提供的“确认收货”接口，更新 trade_after_sale 表的状态为 wait_refund 卖家已收货（待卖家退款）。\n\n售后状态：wait_refund 卖家已收货（待卖家退款）\n\n\n\n\n# 2.5 退款【卖家】\n\n① 点击「确认退款」按钮，调用后端对应 aftersalecontroller 的 #refundaftersale(...) 提供的“确认退款”接口，更新 trade_after_sale 表的状态为 complete 退款成功。\n\n售后状态：complete 退款成功\n\n\n\n该接口的内部实现，主要是调用支付中心的退款接口，具体可以看看 《21.支付宝、微信退款接入》 文档。\n\n② 在真正退款到卖家的支付宝、微信账户后（退款是个异步过程），支付中心会回调 aftersalecontroller 的 #updateafterrefund(...) 提供的“更新售后订单为已退款”接口，目前仅仅打印日志，可以按需拓展。\n\n至此，售后流程结束~可以试着多多 debug 调试整个流程，并不复杂噢。\n\n\n# 3. 售后配置\n\n\n\n * sql 对应 trade_config 表的 after_sale_ 开头的字段。\n * 前端对应 yudao-ui-admin-vue3 项目的 views/mall/trade/config/index.vue 目录\n * 后端对应 yudao-module-trade-biz 项目的 tradeconfigcontroller 类",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【交易】快递发货",
            frontmatter: {
                title: "【交易】快递发货",
                date: "2024-01-16T21:28:03.000Z",
                permalink: "/mall/trade-delivery-express"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/14.%E5%95%86%E5%9F%8E%E6%89%8B%E5%86%8C/24.%E3%80%90%E4%BA%A4%E6%98%93%E3%80%91%E5%BF%AB%E9%80%92%E5%8F%91%E8%B4%A7.html",
            relativePath: "01.开发指南/14.商城手册/24.【交易】快递发货.md",
            key: "v-139162e2",
            path: "/mall/trade-delivery-express/",
            headers: [{
                level: 2,
                title: "1. 快递公司",
                slug: "_1-快递公司",
                normalizedTitle: "1. 快递公司",
                charIndex: 2
            }, {
                level: 3,
                title: "1.1 表结构",
                slug: "_1-1-表结构",
                normalizedTitle: "1.1 表结构",
                charIndex: 14
            }, {
                level: 3,
                title: "1.2 管理后台",
                slug: "_1-2-管理后台",
                normalizedTitle: "1.2 管理后台",
                charIndex: 828
            }, {
                level: 3,
                title: "1.3 物流信息",
                slug: "_1-3-物流信息",
                normalizedTitle: "1.3 物流信息",
                charIndex: 960
            }, {
                level: 2,
                title: "2. 快递运费模板",
                slug: "_2-快递运费模板",
                normalizedTitle: "2. 快递运费模板",
                charIndex: 1045
            }, {
                level: 3,
                title: "2.1 表结构",
                slug: "_2-1-表结构",
                normalizedTitle: "2.1 表结构",
                charIndex: 1059
            }, {
                level: 3,
                title: "2.2 管理后台",
                slug: "_2-2-管理后台",
                normalizedTitle: "2.2 管理后台",
                charIndex: 3411
            }, {
                level: 3,
                title: "2.3 运费计算",
                slug: "_2-3-运费计算",
                normalizedTitle: "2.3 运费计算",
                charIndex: 3551
            }, {
                level: 2,
                title: "3. 配送配置",
                slug: "_3-配送配置",
                normalizedTitle: "3. 配送配置",
                charIndex: 3636
            }],
            headersStr: "1. 快递公司 1.1 表结构 1.2 管理后台 1.3 物流信息 2. 快递运费模板 2.1 表结构 2.2 管理后台 2.3 运费计算 3. 配送配置",
            content: "# 1. 快递公司\n\n\n# 1.1 表结构\n\n快递公司，由 yudao-module-trade-biz 后端模块的 delivery 包的 DeliveryExpressService 实现，只有一个表：\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `trade_delivery_express` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  `code` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '快递公司编码',\n  `name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '快递公司名称',\n  `logo` varchar(256) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '快递公司 logo',\n  `sort` int NOT NULL DEFAULT '0' COMMENT '排序',\n  `status` tinyint NOT NULL DEFAULT '0' COMMENT '状态',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='快递公司';\n\n\n比较简单，就是存储下快递公司的基本信息。\n\n\n# 1.2 管理后台\n\n对应 [商城系统 -> 订单中心 -> 配送管理 -> 快递发货 -> 快递公司] 菜单，对应 yudao-ui-admin-vue3 项目的 views/mall/trade/delivery/express 目录。如下图所示：\n\n\n\n\n# 1.3 物流信息\n\n由 yudao-module-trade-biz 后端模块的 ExpressClient 实现，已对接快递鸟、快递 100 等快递查询接口。\n\n\n# 2. 快递运费模板\n\n\n# 2.1 表结构\n\n运费模版，由 yudao-module-trade-biz 后端模块的 delivery 包的 DeliveryExpressTemplateService 实现，包括一个主表 + 两个子表：\n\n\n\n# 2.1.1 运费模版表\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `trade_delivery_express_template` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  `name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '模板名称',\n  `charge_mode` tinyint NOT NULL COMMENT '配送计费方式',\n  `sort` int NOT NULL DEFAULT '0' COMMENT '排序',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='快递运费模板';\n\n\n比较简单，关键信息都在两个子表中。\n\n唯一需要注意的是，charge_mode 字段，表示配送计费方式，由 DeliveryExpressChargeModeEnum 枚举，有三种：按件、按重量、按体积。\n\n# 2.1.2 运费模板【计费】配置表\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `trade_delivery_express_template_charge` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号，自增',\n  \n  `template_id` bigint NOT NULL COMMENT '快递运费模板编号',\n  `charge_mode` tinyint NOT NULL COMMENT '配送计费方式',\n  \n  `area_ids` text CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '配送区域 id',\n  \n  `start_count` double NOT NULL COMMENT '首件数量',\n  `start_price` int NOT NULL COMMENT '起步价，单位：分',\n  `extra_count` double NOT NULL COMMENT '续件数量',\n  `extra_price` int NOT NULL COMMENT '额外价，单位：分',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=15 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='快递运费模板计费配置';\n\n\n① template_id 字段：关联 trade_delivery_express_template 表的 id 字段，表示该计费配置属于哪个运费模版。而 charge_mode 字段，只是进行冗余存储，减少查询次数。\n\n② area_ids 字段：配送区域 id 数组，存储的区级别。如下图所示：\n\n\n\n③ start_count、start_price、extra_count、extra_price 字段：配送计费的具体配置。\n\n# 2.1.3 运费模板【包邮】配置\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `trade_delivery_express_template_free` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  \n  `template_id` bigint NOT NULL COMMENT '快递运费模板编号',\n  \n  `area_ids` text CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '包邮区域 id',\n  \n  `free_price` int NOT NULL COMMENT '包邮金额，单位：分',\n  `free_count` int NOT NULL DEFAULT '0' COMMENT '包邮件数,',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=21 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='快递运费模板包邮配置';\n\n\n整体类似 trade_delivery_express_template_charge 表，就不重复赘述。\n\n\n# 2.2 管理后台\n\n对应 [商城系统 -> 交易系统 -> 快递发货 -> 快递发货 -> 运费模版] 菜单，对应 yudao-ui-admin-vue3 项目的 views/mall/trade/delivery/expressTemplate 目录。如下图所示：\n\n\n\n\n# 2.3 运费计算\n\n由 yudao-module-trade-biz 后端模块的 TradeDeliveryPriceCalculator 实现订单的运费计算。\n\n\n# 3. 配送配置\n\n\n\n * SQL 对应 trade_config 表的 delivery_ 开头的字段。\n * 前端对应 yudao-ui-admin-vue3 项目的 views/mall/trade/config/index.vue 目录\n * 后端对应 yudao-module-trade-biz 项目的 TradeConfigController 类",
            normalizedContent: "# 1. 快递公司\n\n\n# 1.1 表结构\n\n快递公司，由 yudao-module-trade-biz 后端模块的 delivery 包的 deliveryexpressservice 实现，只有一个表：\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `trade_delivery_express` (\n  `id` bigint not null auto_increment comment '编号',\n  `code` varchar(64) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '快递公司编码',\n  `name` varchar(64) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '快递公司名称',\n  `logo` varchar(256) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '快递公司 logo',\n  `sort` int not null default '0' comment '排序',\n  `status` tinyint not null default '0' comment '状态',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=5 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='快递公司';\n\n\n比较简单，就是存储下快递公司的基本信息。\n\n\n# 1.2 管理后台\n\n对应 [商城系统 -> 订单中心 -> 配送管理 -> 快递发货 -> 快递公司] 菜单，对应 yudao-ui-admin-vue3 项目的 views/mall/trade/delivery/express 目录。如下图所示：\n\n\n\n\n# 1.3 物流信息\n\n由 yudao-module-trade-biz 后端模块的 expressclient 实现，已对接快递鸟、快递 100 等快递查询接口。\n\n\n# 2. 快递运费模板\n\n\n# 2.1 表结构\n\n运费模版，由 yudao-module-trade-biz 后端模块的 delivery 包的 deliveryexpresstemplateservice 实现，包括一个主表 + 两个子表：\n\n\n\n# 2.1.1 运费模版表\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `trade_delivery_express_template` (\n  `id` bigint not null auto_increment comment '编号',\n  `name` varchar(64) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '模板名称',\n  `charge_mode` tinyint not null comment '配送计费方式',\n  `sort` int not null default '0' comment '排序',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=5 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='快递运费模板';\n\n\n比较简单，关键信息都在两个子表中。\n\n唯一需要注意的是，charge_mode 字段，表示配送计费方式，由 deliveryexpresschargemodeenum 枚举，有三种：按件、按重量、按体积。\n\n# 2.1.2 运费模板【计费】配置表\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `trade_delivery_express_template_charge` (\n  `id` bigint not null auto_increment comment '编号，自增',\n  \n  `template_id` bigint not null comment '快递运费模板编号',\n  `charge_mode` tinyint not null comment '配送计费方式',\n  \n  `area_ids` text character set utf8mb4 collate utf8mb4_unicode_ci not null comment '配送区域 id',\n  \n  `start_count` double not null comment '首件数量',\n  `start_price` int not null comment '起步价，单位：分',\n  `extra_count` double not null comment '续件数量',\n  `extra_price` int not null comment '额外价，单位：分',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=15 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='快递运费模板计费配置';\n\n\n① template_id 字段：关联 trade_delivery_express_template 表的 id 字段，表示该计费配置属于哪个运费模版。而 charge_mode 字段，只是进行冗余存储，减少查询次数。\n\n② area_ids 字段：配送区域 id 数组，存储的区级别。如下图所示：\n\n\n\n③ start_count、start_price、extra_count、extra_price 字段：配送计费的具体配置。\n\n# 2.1.3 运费模板【包邮】配置\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `trade_delivery_express_template_free` (\n  `id` bigint not null auto_increment comment '编号',\n  \n  `template_id` bigint not null comment '快递运费模板编号',\n  \n  `area_ids` text character set utf8mb4 collate utf8mb4_unicode_ci not null comment '包邮区域 id',\n  \n  `free_price` int not null comment '包邮金额，单位：分',\n  `free_count` int not null default '0' comment '包邮件数,',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=21 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='快递运费模板包邮配置';\n\n\n整体类似 trade_delivery_express_template_charge 表，就不重复赘述。\n\n\n# 2.2 管理后台\n\n对应 [商城系统 -> 交易系统 -> 快递发货 -> 快递发货 -> 运费模版] 菜单，对应 yudao-ui-admin-vue3 项目的 views/mall/trade/delivery/expresstemplate 目录。如下图所示：\n\n\n\n\n# 2.3 运费计算\n\n由 yudao-module-trade-biz 后端模块的 tradedeliverypricecalculator 实现订单的运费计算。\n\n\n# 3. 配送配置\n\n\n\n * sql 对应 trade_config 表的 delivery_ 开头的字段。\n * 前端对应 yudao-ui-admin-vue3 项目的 views/mall/trade/config/index.vue 目录\n * 后端对应 yudao-module-trade-biz 项目的 tradeconfigcontroller 类",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【交易】分销返佣",
            frontmatter: {
                title: "【交易】分销返佣",
                date: "2024-01-17T07:06:37.000Z",
                permalink: "/mall/trade-brokerage"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/14.%E5%95%86%E5%9F%8E%E6%89%8B%E5%86%8C/26.%E3%80%90%E4%BA%A4%E6%98%93%E3%80%91%E5%88%86%E9%94%80%E8%BF%94%E4%BD%A3.html",
            relativePath: "01.开发指南/14.商城手册/26.【交易】分销返佣.md",
            key: "v-6077cf88",
            path: "/mall/trade-brokerage/",
            headers: [{
                level: 2,
                title: "1. 分销用户",
                slug: "_1-分销用户",
                normalizedTitle: "1. 分销用户",
                charIndex: 119
            }, {
                level: 3,
                title: "1.1 表结构",
                slug: "_1-1-表结构",
                normalizedTitle: "1.1 表结构",
                charIndex: 201
            }, {
                level: 3,
                title: "1.2 管理后台",
                slug: "_1-2-管理后台",
                normalizedTitle: "1.2 管理后台",
                charIndex: 1116
            }, {
                level: 3,
                title: "1.3 移动端",
                slug: "_1-3-移动端",
                normalizedTitle: "1.3 移动端",
                charIndex: 1271
            }, {
                level: 3,
                title: "1.4 怎么成为分销用户？",
                slug: "_1-4-怎么成为分销用户",
                normalizedTitle: "1.4 怎么成为分销用户？",
                charIndex: 1463
            }, {
                level: 2,
                title: "2. 分销记录",
                slug: "_2-分销记录",
                normalizedTitle: "2. 分销记录",
                charIndex: 1860
            }, {
                level: 3,
                title: "2.1 表结构",
                slug: "_2-1-表结构",
                normalizedTitle: "2.1 表结构",
                charIndex: 1944
            }, {
                level: 3,
                title: "2.2 管理后台",
                slug: "_2-2-管理后台",
                normalizedTitle: "2.2 管理后台",
                charIndex: 4154
            }, {
                level: 3,
                title: "2.3 移动端",
                slug: "_2-3-移动端",
                normalizedTitle: "2.3 移动端",
                charIndex: 4278
            }, {
                level: 2,
                title: "3. 分销提现",
                slug: "_3-分销提现",
                normalizedTitle: "3. 分销提现",
                charIndex: 4356
            }, {
                level: 3,
                title: "3.1 表结构",
                slug: "_3-1-表结构",
                normalizedTitle: "3.1 表结构",
                charIndex: 4442
            }, {
                level: 3,
                title: "3.2 管理后台",
                slug: "_3-2-管理后台",
                normalizedTitle: "3.2 管理后台",
                charIndex: 6215
            }, {
                level: 3,
                title: "3.2 移动端",
                slug: "_3-2-移动端",
                normalizedTitle: "3.2 移动端",
                charIndex: 6341
            }, {
                level: 2,
                title: "4. 分佣配置",
                slug: "_4-分佣配置",
                normalizedTitle: "4. 分佣配置",
                charIndex: 6486
            }],
            headersStr: "1. 分销用户 1.1 表结构 1.2 管理后台 1.3 移动端 1.4 怎么成为分销用户？ 2. 分销记录 2.1 表结构 2.2 管理后台 2.3 移动端 3. 分销提现 3.1 表结构 3.2 管理后台 3.2 移动端 4. 分佣配置",
            content: "分销返佣，是指商城中，用户通过分享商品链接，或者通过分享二维码，帮助商家推广商品，当有用户通过分享的链接或者二维码购买商品时，分享者可以获得一定的佣金。\n\n它可以分成三部分：分销用户、分销记录、分销提现。最终存储表结构如下：\n\n\n\n\n# 1. 分销用户\n\n由 yudao-module-trade-biz 后端模块的 brokerage 包的 BrokerageUserService 实现。\n\n\n# 1.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `trade_brokerage_user` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '用户编号',\n  `brokerage_enabled` bit(1) NOT NULL DEFAULT b'1' COMMENT '是否成为推广员',\n  `brokerage_time` datetime DEFAULT NULL COMMENT '成为分销员时间',\n  \n  `bind_user_id` bigint DEFAULT NULL COMMENT '推广员编号',\n  `bind_user_time` datetime DEFAULT NULL COMMENT '推广员绑定时间',\n  \n  `brokerage_price` int NOT NULL DEFAULT '0' COMMENT '可用佣金',\n  `frozen_price` int NOT NULL DEFAULT '0' COMMENT '冻结佣金',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=249 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='分销用户';\n\n\n① 【自身】id 字段：用户编号，对应会员用户（买家）表的 id 字段。因为要存储分佣的绑定关系，所以每个用户都会在这个表有个记录。\n\nbrokerage_enabled 字段：是否成为分销用户。只有为 true 的用户才能进行分销。\n\n② 【上级】bind_user_id 字段：推广员编号，自己对应的上级，或者说是由哪个用户分销用户推广来的，后续订单佣金算他的。\n\n③ 【佣金】brokerage_price、frozen_price 字段：可用佣金、冻结佣金。\n\n\n# 1.2 管理后台\n\n对应 [商城系统 -> 订单中心 -> 分销管理 -> 分销用户] 菜单，对应 yudao-ui-admin-vue3 项目的 views/mall/trade/brokerage/user 目录。如下图所示：\n\n\n\n可以查看分销用户的推广人、推广订单，也可以修改它的上级推广人。\n\n\n# 1.3 移动端\n\n对应 uni-app [我的 -> 分销中心] 菜单，对应 yudao-mall-unipp 项目的 yudao-mall-uniapp/pages/commission 目录。如下图所示：\n\n\n\n在 [我的团队] 中，可以查看自己的下级分销用户，以及下级分销用户的推广订单，对应 pages/commission/team.vue 文件。如下图所示：\n\n\n\n\n# 1.4 怎么成为分销用户？\n\n① 方式一：在“分销模式”为“人人分销”时，新用户通过邀请链接注册，则注册完成后会往 trade_brokerage_user 表插入数据，从而成为分销员。\n\n1、老用户，在【分销中心】界面，点击【邀请海报】，复制邀请链接，分享给新用户。如下图所示：\n\n\n\n友情提示：\n\n在微信小程序里，可以使用小程序码，具体可以后面看看 《微信小程序码》 文档。\n\n2、新用户，点击该链接，注册新用户。\n\n3、老用户，在【分销中心】界面，点击【我的团队】，可以查看到该新用户。如下图所示：\n\n\n\n----------------------------------------\n\n② 方式二：在“分销模式”为“指定分销”时，并且用户不是通过邀请，而是通过管理员在后台进行新增，会往 trade_brokerage_user 表插入数据，从而成为分销员。如下图所示：\n\n\n\n\n# 2. 分销记录\n\n由 yudao-module-trade-biz 后端模块的 brokerage 包的 BrokerageRecordService 实现。\n\n\n# 2.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `trade_brokerage_record` (\n  `id` int NOT NULL AUTO_INCREMENT COMMENT '编号',\n  \n  `user_id` bigint NOT NULL COMMENT '用户编号',\n  `source_user_id` bigint NOT NULL DEFAULT '0' COMMENT '来源用户编号',\n  `source_user_level` int NOT NULL DEFAULT '0' COMMENT '来源用户等级',\n  \n  `biz_id` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '业务编号',\n  `biz_type` tinyint NOT NULL DEFAULT '0' COMMENT '业务类型：1-订单，2-提现',\n  `title` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '标题',\n  `description` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '说明',\n  \n  `price` int NOT NULL DEFAULT '0' COMMENT '金额',\n  `total_price` int NOT NULL DEFAULT '0' COMMENT '当前总佣金',\n  `status` tinyint NOT NULL DEFAULT '0' COMMENT '状态：0-待结算，1-已结算，2-已取消',\n  `frozen_days` int NOT NULL DEFAULT '0' COMMENT '冻结时间（天）',\n  `unfreeze_time` datetime DEFAULT NULL COMMENT '解冻时间',\n\n  PRIMARY KEY (`id`) USING BTREE,\n  KEY `idx_user_id` (`user_id`) USING BTREE COMMENT '用户编号',\n  KEY `idx_biz` (`biz_type`,`biz_id`) USING BTREE COMMENT '业务',\n  KEY `idx_status` (`status`) USING BTREE COMMENT '状态'\n) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='佣金记录';\n\n\n① id 字段：编号，自增主键。目前佣金每次发生变化时，都会生成一条记录，例如说订单分佣、佣金提现等等。\n\n② 【分销关系】user_id 字段：用户编号，对应分销用户表的 id 字段。\n\nsource_user_id 字段：来源用户编号，例如说，订单分佣时，就是订单的买家编号。source_user_level 字段：来源用户等级，例如说，一级分佣、二级分佣。如下图所示：\n\n\n\n * 上下级关系：A 推广 B，B 推广了 C\n * A 购买商品：自己没有返佣\n * B 购买商品：A 获得一级返佣\n * C 购买商品：B 获得一级返佣，A 获得二级返佣\n\n③ 【业务】biz_id、biz_type 字段：业务编号、业务类型（由 BrokerageRecordBizTypeEnum 枚举）。title、description 字段：标题、说明，主要用于展示。\n\n例如说，订单分佣时，biz_type 为 1，biz_id 为订单编号。具体 TradeBrokerageOrderHandler 处理器，订单被支付时，会生成分佣记录。\n\n疑问：B 已经是 A 的下级了，为什么下单支付后，没有分销记录？\n\n有一种可能性，计算的分佣金额为 0，所以没有生成分销记录。例如说：https://t.zsxq.com/e4aSR\n\n④ 【佣金】price、total_price 字段：分佣金额、当前总佣金。每个商品的佣金，可以全局设置，也可以自定设置，如下图所示：\n\n\n\n友情提示：分销商品，后续会从商品管理中解耦出来，单独管理，单独表存储。\n\n⑤ 【状态】status 字段：状态，由 BrokerageRecordStatusEnum 枚举，目前就待结算（冻结）、已结算（生效）、已取消（失效）三种状态。\n\nfrozen_days 字段：冻结时间（天），例如说，订单分佣时，可以设置冻结时间，冻结时间内，佣金不可提现。解冻通过 BrokerageRecordUnfreezeJob 定时任务实现。\n\n\n# 2.2 管理后台\n\n对应 [商城系统 -> 订单中心 -> 分销管理 -> 佣金记录] 菜单，对应 yudao-ui-admin-vue3 项目的 views/mall/trade/brokerage/recrod 目录。如下图所示：\n\n\n\n\n# 2.3 移动端\n\n在 [分销订单] 中，可以查看自己的分销订单，对应 pages/commission/order.vue 文件。如下图所示：\n\n\n\n\n# 3. 分销提现\n\n由 yudao-module-trade-biz 后端模块的 brokerage 包的 BrokerageWithdrawService 实现。\n\n\n# 3.1 表结构\n\nCREATE TABLE `trade_brokerage_withdraw` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  \n  `user_id` bigint NOT NULL COMMENT '用户编号',\n  \n  `price` int NOT NULL DEFAULT '0' COMMENT '提现金额',\n  `fee_price` int NOT NULL DEFAULT '0' COMMENT '提现手续费',\n  `total_price` int NOT NULL DEFAULT '0' COMMENT '当前总佣金',\n \n  `type` tinyint NOT NULL DEFAULT '0' COMMENT '提现类型：1-钱包；2-银行卡；3-微信；4-支付宝',\n  `name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '真实姓名',\n  `account_no` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '账号',\n  `bank_name` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '银行名称',\n  `bank_address` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '开户地址',\n  `account_qr_code_url` varchar(512) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '收款码',\n  \n  `status` tinyint NOT NULL DEFAULT '0' COMMENT '状态：0-审核中，10-审核通过 20-审核不通过；预留：11 - 提现成功；21-提现失败',\n  `audit_reason` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '审核驳回原因',\n  `audit_time` datetime DEFAULT NULL COMMENT '审核时间',\n  \n  PRIMARY KEY (`id`) USING BTREE,\n  KEY `idx_user_id` (`user_id`) USING BTREE COMMENT '用户编号',\n  KEY `idx_audit_status` (`status`) USING BTREE COMMENT '状态'\n) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='佣金提现';\n\n\n字段虽然比较多，但是都比较简单，就不一一介绍了，只挑选部分重点的。\n\n① type 字段，提现类型，由 BrokerageWithdrawTypeEnum 枚举，目前支持钱包、银行卡、微信、支付宝。具体需要填写哪些字段，可见 AppBrokerageWithdrawCreateReqVO 类的注释。\n\n② status 字段，提现状态，由 BrokerageWithdrawStatusEnum 枚举，可以分成三个阶段：分佣用户申请、管理员审核（通过、不通过）、管理员打款（成功、失败）。\n\n疑问：为什么提现成功、失败是“预留”？\n\n由于【支付中心】的“转账”功能还没开发完成，所以暂时不支持线上的该操作，仅仅预留，你可以先自己实现~\n\n\n# 3.2 管理后台\n\n对应 [商城系统 -> 订单中心 -> 分销管理 -> 佣金提现] 菜单，对应 yudao-ui-admin-vue3 项目的 views/mall/trade/brokerage/withdraw 目录。如下图所示：\n\n\n\n\n# 3.2 移动端\n\n① 在 [佣金明细] 中，可以查看自己的提现记录，对应 pages/commission/wallet.vue 文件。如下图所示：\n\n\n\n② 点击「提现」按钮，可以申请提现，对应 pages/commission/withdraw.vue 文件。如下图所示：\n\n\n\n\n# 4. 分佣配置\n\n\n\n * SQL 对应 trade_config 表的 brokerage_ 开头的字段。\n * 前端对应 yudao-ui-admin-vue3 项目的 views/mall/trade/config/index.vue 目录\n * 后端对应 yudao-module-trade-biz 项目的 TradeConfigController 类",
            normalizedContent: "分销返佣，是指商城中，用户通过分享商品链接，或者通过分享二维码，帮助商家推广商品，当有用户通过分享的链接或者二维码购买商品时，分享者可以获得一定的佣金。\n\n它可以分成三部分：分销用户、分销记录、分销提现。最终存储表结构如下：\n\n\n\n\n# 1. 分销用户\n\n由 yudao-module-trade-biz 后端模块的 brokerage 包的 brokerageuserservice 实现。\n\n\n# 1.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `trade_brokerage_user` (\n  `id` bigint not null auto_increment comment '用户编号',\n  `brokerage_enabled` bit(1) not null default b'1' comment '是否成为推广员',\n  `brokerage_time` datetime default null comment '成为分销员时间',\n  \n  `bind_user_id` bigint default null comment '推广员编号',\n  `bind_user_time` datetime default null comment '推广员绑定时间',\n  \n  `brokerage_price` int not null default '0' comment '可用佣金',\n  `frozen_price` int not null default '0' comment '冻结佣金',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=249 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='分销用户';\n\n\n① 【自身】id 字段：用户编号，对应会员用户（买家）表的 id 字段。因为要存储分佣的绑定关系，所以每个用户都会在这个表有个记录。\n\nbrokerage_enabled 字段：是否成为分销用户。只有为 true 的用户才能进行分销。\n\n② 【上级】bind_user_id 字段：推广员编号，自己对应的上级，或者说是由哪个用户分销用户推广来的，后续订单佣金算他的。\n\n③ 【佣金】brokerage_price、frozen_price 字段：可用佣金、冻结佣金。\n\n\n# 1.2 管理后台\n\n对应 [商城系统 -> 订单中心 -> 分销管理 -> 分销用户] 菜单，对应 yudao-ui-admin-vue3 项目的 views/mall/trade/brokerage/user 目录。如下图所示：\n\n\n\n可以查看分销用户的推广人、推广订单，也可以修改它的上级推广人。\n\n\n# 1.3 移动端\n\n对应 uni-app [我的 -> 分销中心] 菜单，对应 yudao-mall-unipp 项目的 yudao-mall-uniapp/pages/commission 目录。如下图所示：\n\n\n\n在 [我的团队] 中，可以查看自己的下级分销用户，以及下级分销用户的推广订单，对应 pages/commission/team.vue 文件。如下图所示：\n\n\n\n\n# 1.4 怎么成为分销用户？\n\n① 方式一：在“分销模式”为“人人分销”时，新用户通过邀请链接注册，则注册完成后会往 trade_brokerage_user 表插入数据，从而成为分销员。\n\n1、老用户，在【分销中心】界面，点击【邀请海报】，复制邀请链接，分享给新用户。如下图所示：\n\n\n\n友情提示：\n\n在微信小程序里，可以使用小程序码，具体可以后面看看 《微信小程序码》 文档。\n\n2、新用户，点击该链接，注册新用户。\n\n3、老用户，在【分销中心】界面，点击【我的团队】，可以查看到该新用户。如下图所示：\n\n\n\n----------------------------------------\n\n② 方式二：在“分销模式”为“指定分销”时，并且用户不是通过邀请，而是通过管理员在后台进行新增，会往 trade_brokerage_user 表插入数据，从而成为分销员。如下图所示：\n\n\n\n\n# 2. 分销记录\n\n由 yudao-module-trade-biz 后端模块的 brokerage 包的 brokeragerecordservice 实现。\n\n\n# 2.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `trade_brokerage_record` (\n  `id` int not null auto_increment comment '编号',\n  \n  `user_id` bigint not null comment '用户编号',\n  `source_user_id` bigint not null default '0' comment '来源用户编号',\n  `source_user_level` int not null default '0' comment '来源用户等级',\n  \n  `biz_id` varchar(64) character set utf8mb4 collate utf8mb4_unicode_ci not null default '' comment '业务编号',\n  `biz_type` tinyint not null default '0' comment '业务类型：1-订单，2-提现',\n  `title` varchar(64) character set utf8mb4 collate utf8mb4_unicode_ci not null default '' comment '标题',\n  `description` varchar(500) character set utf8mb4 collate utf8mb4_unicode_ci not null default '' comment '说明',\n  \n  `price` int not null default '0' comment '金额',\n  `total_price` int not null default '0' comment '当前总佣金',\n  `status` tinyint not null default '0' comment '状态：0-待结算，1-已结算，2-已取消',\n  `frozen_days` int not null default '0' comment '冻结时间（天）',\n  `unfreeze_time` datetime default null comment '解冻时间',\n\n  primary key (`id`) using btree,\n  key `idx_user_id` (`user_id`) using btree comment '用户编号',\n  key `idx_biz` (`biz_type`,`biz_id`) using btree comment '业务',\n  key `idx_status` (`status`) using btree comment '状态'\n) engine=innodb auto_increment=8 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='佣金记录';\n\n\n① id 字段：编号，自增主键。目前佣金每次发生变化时，都会生成一条记录，例如说订单分佣、佣金提现等等。\n\n② 【分销关系】user_id 字段：用户编号，对应分销用户表的 id 字段。\n\nsource_user_id 字段：来源用户编号，例如说，订单分佣时，就是订单的买家编号。source_user_level 字段：来源用户等级，例如说，一级分佣、二级分佣。如下图所示：\n\n\n\n * 上下级关系：a 推广 b，b 推广了 c\n * a 购买商品：自己没有返佣\n * b 购买商品：a 获得一级返佣\n * c 购买商品：b 获得一级返佣，a 获得二级返佣\n\n③ 【业务】biz_id、biz_type 字段：业务编号、业务类型（由 brokeragerecordbiztypeenum 枚举）。title、description 字段：标题、说明，主要用于展示。\n\n例如说，订单分佣时，biz_type 为 1，biz_id 为订单编号。具体 tradebrokerageorderhandler 处理器，订单被支付时，会生成分佣记录。\n\n疑问：b 已经是 a 的下级了，为什么下单支付后，没有分销记录？\n\n有一种可能性，计算的分佣金额为 0，所以没有生成分销记录。例如说：https://t.zsxq.com/e4asr\n\n④ 【佣金】price、total_price 字段：分佣金额、当前总佣金。每个商品的佣金，可以全局设置，也可以自定设置，如下图所示：\n\n\n\n友情提示：分销商品，后续会从商品管理中解耦出来，单独管理，单独表存储。\n\n⑤ 【状态】status 字段：状态，由 brokeragerecordstatusenum 枚举，目前就待结算（冻结）、已结算（生效）、已取消（失效）三种状态。\n\nfrozen_days 字段：冻结时间（天），例如说，订单分佣时，可以设置冻结时间，冻结时间内，佣金不可提现。解冻通过 brokeragerecordunfreezejob 定时任务实现。\n\n\n# 2.2 管理后台\n\n对应 [商城系统 -> 订单中心 -> 分销管理 -> 佣金记录] 菜单，对应 yudao-ui-admin-vue3 项目的 views/mall/trade/brokerage/recrod 目录。如下图所示：\n\n\n\n\n# 2.3 移动端\n\n在 [分销订单] 中，可以查看自己的分销订单，对应 pages/commission/order.vue 文件。如下图所示：\n\n\n\n\n# 3. 分销提现\n\n由 yudao-module-trade-biz 后端模块的 brokerage 包的 brokeragewithdrawservice 实现。\n\n\n# 3.1 表结构\n\ncreate table `trade_brokerage_withdraw` (\n  `id` bigint not null auto_increment comment '编号',\n  \n  `user_id` bigint not null comment '用户编号',\n  \n  `price` int not null default '0' comment '提现金额',\n  `fee_price` int not null default '0' comment '提现手续费',\n  `total_price` int not null default '0' comment '当前总佣金',\n \n  `type` tinyint not null default '0' comment '提现类型：1-钱包；2-银行卡；3-微信；4-支付宝',\n  `name` varchar(64) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '真实姓名',\n  `account_no` varchar(64) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '账号',\n  `bank_name` varchar(100) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '银行名称',\n  `bank_address` varchar(200) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '开户地址',\n  `account_qr_code_url` varchar(512) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '收款码',\n  \n  `status` tinyint not null default '0' comment '状态：0-审核中，10-审核通过 20-审核不通过；预留：11 - 提现成功；21-提现失败',\n  `audit_reason` varchar(128) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '审核驳回原因',\n  `audit_time` datetime default null comment '审核时间',\n  \n  primary key (`id`) using btree,\n  key `idx_user_id` (`user_id`) using btree comment '用户编号',\n  key `idx_audit_status` (`status`) using btree comment '状态'\n) engine=innodb auto_increment=11 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='佣金提现';\n\n\n字段虽然比较多，但是都比较简单，就不一一介绍了，只挑选部分重点的。\n\n① type 字段，提现类型，由 brokeragewithdrawtypeenum 枚举，目前支持钱包、银行卡、微信、支付宝。具体需要填写哪些字段，可见 appbrokeragewithdrawcreatereqvo 类的注释。\n\n② status 字段，提现状态，由 brokeragewithdrawstatusenum 枚举，可以分成三个阶段：分佣用户申请、管理员审核（通过、不通过）、管理员打款（成功、失败）。\n\n疑问：为什么提现成功、失败是“预留”？\n\n由于【支付中心】的“转账”功能还没开发完成，所以暂时不支持线上的该操作，仅仅预留，你可以先自己实现~\n\n\n# 3.2 管理后台\n\n对应 [商城系统 -> 订单中心 -> 分销管理 -> 佣金提现] 菜单，对应 yudao-ui-admin-vue3 项目的 views/mall/trade/brokerage/withdraw 目录。如下图所示：\n\n\n\n\n# 3.2 移动端\n\n① 在 [佣金明细] 中，可以查看自己的提现记录，对应 pages/commission/wallet.vue 文件。如下图所示：\n\n\n\n② 点击「提现」按钮，可以申请提现，对应 pages/commission/withdraw.vue 文件。如下图所示：\n\n\n\n\n# 4. 分佣配置\n\n\n\n * sql 对应 trade_config 表的 brokerage_ 开头的字段。\n * 前端对应 yudao-ui-admin-vue3 项目的 views/mall/trade/config/index.vue 目录\n * 后端对应 yudao-module-trade-biz 项目的 tradeconfigcontroller 类",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【营销】优惠劵",
            frontmatter: {
                title: "【营销】优惠劵",
                date: "2024-01-17T10:29:45.000Z",
                permalink: "/mall/promotion-coupon"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/14.%E5%95%86%E5%9F%8E%E6%89%8B%E5%86%8C/30.%E3%80%90%E8%90%A5%E9%94%80%E3%80%91%E4%BC%98%E6%83%A0%E5%8A%B5.html",
            relativePath: "01.开发指南/14.商城手册/30.【营销】优惠劵.md",
            key: "v-030ec89a",
            path: "/mall/promotion-coupon/",
            headers: [{
                level: 2,
                title: "1. 优惠劵模版",
                slug: "_1-优惠劵模版",
                normalizedTitle: "1. 优惠劵模版",
                charIndex: 82
            }, {
                level: 3,
                title: "1.1 表结构",
                slug: "_1-1-表结构",
                normalizedTitle: "1.1 表结构",
                charIndex: 154
            }, {
                level: 3,
                title: "1.2 管理后台",
                slug: "_1-2-管理后台",
                normalizedTitle: "1.2 管理后台",
                charIndex: 2550
            }, {
                level: 3,
                title: "1.3 移动端",
                slug: "_1-3-移动端",
                normalizedTitle: "1.3 移动端",
                charIndex: 2679
            }, {
                level: 2,
                title: "2. 优惠劵",
                slug: "_2-优惠劵",
                normalizedTitle: "2. 优惠劵",
                charIndex: 2874
            }, {
                level: 3,
                title: "2.1 表结构",
                slug: "_2-1-表结构",
                normalizedTitle: "2.1 表结构",
                charIndex: 2926
            }, {
                level: 3,
                title: "2.2 管理后台",
                slug: "_2-2-管理后台",
                normalizedTitle: "2.2 管理后台",
                charIndex: 4644
            }, {
                level: 3,
                title: "2.3 移动端",
                slug: "_2-3-移动端",
                normalizedTitle: "2.3 移动端",
                charIndex: 4765
            }],
            headersStr: "1. 优惠劵模版 1.1 表结构 1.2 管理后台 1.3 移动端 2. 优惠劵 2.1 表结构 2.2 管理后台 2.3 移动端",
            content: "优惠劵功能，主要由 yudao-module-promotion-biz 后端模块的 coupon 实现，包括两部分：优惠劵模版、优惠劵。如下图所示：\n\n\n\n\n# 1. 优惠劵模版\n\n优惠劵模版，由卖家在管理后台配置，提供给买家领取成优惠劵，由 CouponTemplateService 类实现。\n\n\n# 1.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `promotion_coupon_template` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '模板编号，自增唯一。',\n  `name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '优惠劵名',\n  \n  `status` tinyint NOT NULL COMMENT '状态',\n\n  `take_type` tinyint NOT NULL COMMENT '领取方式',  \n  `total_count` int NOT NULL COMMENT '发放数量, -1 - 则表示不限制',\n  `take_limit_count` tinyint NOT NULL COMMENT '每人限领个数, -1 - 则表示不限制',\n  `take_count` int NOT NULL DEFAULT '0' COMMENT '领取优惠券的数量',\n  `use_count` int NOT NULL DEFAULT '0' COMMENT '使用优惠券的次数',\n  \n  `use_price` int NOT NULL COMMENT '是否设置满多少金额可用，单位：分',\n  `product_scope` tinyint NOT NULL COMMENT '商品范围',\n  `product_scope_values` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '商品范围编号的数组',\n  \n  `validity_type` tinyint NOT NULL COMMENT '生效日期类型',\n  `valid_start_time` datetime DEFAULT NULL COMMENT '固定日期-生效开始时间',\n  `valid_end_time` datetime DEFAULT NULL COMMENT '固定日期-生效结束时间',\n  `fixed_start_term` int DEFAULT NULL COMMENT '领取日期-开始天数',\n  `fixed_end_term` int DEFAULT NULL COMMENT '领取日期-结束天数',\n  \n  `discount_type` int NOT NULL COMMENT '优惠类型：1-代金劵；2-折扣劵\\n',\n  `discount_percent` tinyint DEFAULT NULL COMMENT '折扣百分比',\n  `discount_price` int DEFAULT NULL COMMENT '优惠金额，单位：分',\n  `discount_limit_price` int DEFAULT NULL COMMENT '折扣上限，仅在 discount_type 等于 2 时生效',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=17 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT='优惠劵模板';\n\n\n① status 字段：优惠劵模版状态，由 CommonStatusEnum 枚举，只有开启、禁用两个状态。禁用时，无法领取。\n\n② 【领取限制】take_type 字段：领取方式，由 CouponTemplateTakeTypeEnum 枚举，分成 3 种情况：\n\n * 1、直接领取：展示在 uni-app 的 [首页]、[领劵中心]、[商品详情]，由用户主动领取。如下图所示：\n\n * 2、指定发放：管理员在管理后台，指定用户发放。如下图所示：\n\n * 3、新人券：买家在注册时，自动发放，由 CouponTakeByRegisterConsumer 消息消费者实现\n\n③ 【使用条件】product_scope 字段：商品范围，由 PromotionProductScopeEnum 枚举，分成 3 种情况：\n\n * 1、通用券：全部商品\n * 2、商品券：指定商品，由 product_scope_values 字段指定商品编号的数组\n * 3、品类券：指定品类，由 product_scope_values 字段指定品类编号的数组\n\n④ 【有效期】validity_type 字段：生效日期类型，由 CouponTemplateValidityTypeEnum 枚举，分成 2 种情况：\n\n * 1、固定日期：由 valid_start_time、valid_end_time 字段指定生效时间范围\n * 2、领取日期：由 fixed_start_term、fixed_end_term 字段指定领取后多少天生效\n\n⑤ 【优惠金额】discount_type 字段：优惠类型，由 PromotionDiscountTypeEnum 枚举，分成 2 种情况：\n\n * 1、代金劵：由 discount_price 字段指定优惠金额\n * 2、折扣劵：由 discount_percent 字段指定折扣百分比，由 discount_limit_price 字段指定折扣上限\n\n\n# 1.2 管理后台\n\n对应 [商城系统 -> 营销中心 -> 优惠劵 -> 优惠劵] 菜单，对应 yudao-ui-admin-vue3 项目的 src/views/mall/promotion/coupon/template 目录。如下图所示：\n\n\n\n\n# 1.3 移动端\n\n① 在 uni-app 的 [我的] 有 [领劵中心]，可以领取优惠劵，对应 yudao-ui-uniapp 项目的 pages/coupon/list.vue 文件。如下图所示：\n\n\n\n② 点击 [领劵中心] 的优惠劵，可以查看该优惠劵的详情，对应 yudao-ui-uniapp 项目的 pages/coupon/detail.vue 文件。如下图所示：\n\n\n\n\n# 2. 优惠劵\n\n优惠劵，会员领取优惠劵模版来“生成”，由 CouponService 类实现。\n\n\n# 2.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `promotion_coupon` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '优惠劵编号',\n  \n  `template_id` bigint NOT NULL COMMENT '优惠劵模板编号',\n  `name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '优惠劵名',\n  `use_price` int NOT NULL COMMENT '是否设置满多少金额可用，单位：分',\n  `take_type` tinyint NOT NULL COMMENT '领取方式',\n  `valid_start_time` datetime NOT NULL COMMENT '生效开始时间',\n  `valid_end_time` datetime NOT NULL COMMENT '生效结束时间',\n  `product_scope` tinyint NOT NULL COMMENT '商品范围',\n  `product_scope_values` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '商品范围编号的数组',\n  `discount_type` tinyint NOT NULL COMMENT '折扣类型',\n  `discount_percent` tinyint DEFAULT NULL COMMENT '折扣百分比',\n  `discount_price` int DEFAULT NULL COMMENT '优惠金额，单位：分',\n  `discount_limit_price` int DEFAULT NULL COMMENT '折扣上限',\n  \n  `user_id` bigint NOT NULL COMMENT '用户编号',\n\n  `status` tinyint NOT NULL COMMENT '优惠码状态；1-未使用；2-已使用；3-已失效',\n  `use_order_id` bigint DEFAULT NULL COMMENT '使用订单号',\n  `use_time` datetime DEFAULT NULL COMMENT '使用时间',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=18 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT='优惠劵';\n\n\n字段虽然也蛮多，但是都是从 promotion_coupon_template 中复制过来的，所以更多讲讲差异的地方。\n\n① 【优惠劵模版】从 template_id 开始到 discount_limit_price 结束，都是从 promotion_coupon_template 中复制过来的，用于记录优惠劵模版的信息。\n\n要注意，如果 promotion_coupon_template 中的信息发生变化，promotion_coupon 中的信息不会变化，因为买家已经领取了，不能随意变更。\n\n② 【用户】user_id 字段：用户编号，就是领取的买家。\n\n③ 【状态】status 字段：优惠码状态，由 CouponStatusEnum 枚举，分成 3 种情况：未使用、已使用、已失效。\n\n如果已使用，会记录 use_order_id、use_time 字段，表示使用的订单编号、使用时间。\n\n优惠劵的过期，由 CouponExpireJob 定时任务实现。\n\n\n# 2.2 管理后台\n\n对应 [商城系统 -> 营销中心 -> 优惠劵 -> 领取记录] 菜单，对应 yudao-ui-admin-vue3 项目的 src/views/mall/promotion/coupon 目录。如下图所示：\n\n\n\n\n# 2.3 移动端\n\n① 在 uni-app 的 [我的] 有 [已领取]、[已使用]、[已失效]，可以查看优惠劵，对应 yudao-ui-uniapp 项目的 pages/coupon/list.vue 文件。如下图所示：\n\n\n\n② 点击某个优惠劵，可以查看该优惠劵的详情，对应 yudao-ui-uniapp 项目的 pages/coupon/detail.vue 文件。如下图所示：\n\n\n\n③ 在 uni-app 下单时，可以选择优惠劵，对应 yudao-ui-uniapp 项目的 sheep/components/s-coupon-select/s-coupon-select.vue 文件。如下图所示：\n\n",
            normalizedContent: "优惠劵功能，主要由 yudao-module-promotion-biz 后端模块的 coupon 实现，包括两部分：优惠劵模版、优惠劵。如下图所示：\n\n\n\n\n# 1. 优惠劵模版\n\n优惠劵模版，由卖家在管理后台配置，提供给买家领取成优惠劵，由 coupontemplateservice 类实现。\n\n\n# 1.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `promotion_coupon_template` (\n  `id` bigint not null auto_increment comment '模板编号，自增唯一。',\n  `name` varchar(50) character set utf8mb4 collate utf8mb4_general_ci not null comment '优惠劵名',\n  \n  `status` tinyint not null comment '状态',\n\n  `take_type` tinyint not null comment '领取方式',  \n  `total_count` int not null comment '发放数量, -1 - 则表示不限制',\n  `take_limit_count` tinyint not null comment '每人限领个数, -1 - 则表示不限制',\n  `take_count` int not null default '0' comment '领取优惠券的数量',\n  `use_count` int not null default '0' comment '使用优惠券的次数',\n  \n  `use_price` int not null comment '是否设置满多少金额可用，单位：分',\n  `product_scope` tinyint not null comment '商品范围',\n  `product_scope_values` varchar(500) character set utf8mb4 collate utf8mb4_general_ci default null comment '商品范围编号的数组',\n  \n  `validity_type` tinyint not null comment '生效日期类型',\n  `valid_start_time` datetime default null comment '固定日期-生效开始时间',\n  `valid_end_time` datetime default null comment '固定日期-生效结束时间',\n  `fixed_start_term` int default null comment '领取日期-开始天数',\n  `fixed_end_term` int default null comment '领取日期-结束天数',\n  \n  `discount_type` int not null comment '优惠类型：1-代金劵；2-折扣劵\\n',\n  `discount_percent` tinyint default null comment '折扣百分比',\n  `discount_price` int default null comment '优惠金额，单位：分',\n  `discount_limit_price` int default null comment '折扣上限，仅在 discount_type 等于 2 时生效',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=17 default charset=utf8mb4 collate=utf8mb4_general_ci comment='优惠劵模板';\n\n\n① status 字段：优惠劵模版状态，由 commonstatusenum 枚举，只有开启、禁用两个状态。禁用时，无法领取。\n\n② 【领取限制】take_type 字段：领取方式，由 coupontemplatetaketypeenum 枚举，分成 3 种情况：\n\n * 1、直接领取：展示在 uni-app 的 [首页]、[领劵中心]、[商品详情]，由用户主动领取。如下图所示：\n\n * 2、指定发放：管理员在管理后台，指定用户发放。如下图所示：\n\n * 3、新人券：买家在注册时，自动发放，由 coupontakebyregisterconsumer 消息消费者实现\n\n③ 【使用条件】product_scope 字段：商品范围，由 promotionproductscopeenum 枚举，分成 3 种情况：\n\n * 1、通用券：全部商品\n * 2、商品券：指定商品，由 product_scope_values 字段指定商品编号的数组\n * 3、品类券：指定品类，由 product_scope_values 字段指定品类编号的数组\n\n④ 【有效期】validity_type 字段：生效日期类型，由 coupontemplatevaliditytypeenum 枚举，分成 2 种情况：\n\n * 1、固定日期：由 valid_start_time、valid_end_time 字段指定生效时间范围\n * 2、领取日期：由 fixed_start_term、fixed_end_term 字段指定领取后多少天生效\n\n⑤ 【优惠金额】discount_type 字段：优惠类型，由 promotiondiscounttypeenum 枚举，分成 2 种情况：\n\n * 1、代金劵：由 discount_price 字段指定优惠金额\n * 2、折扣劵：由 discount_percent 字段指定折扣百分比，由 discount_limit_price 字段指定折扣上限\n\n\n# 1.2 管理后台\n\n对应 [商城系统 -> 营销中心 -> 优惠劵 -> 优惠劵] 菜单，对应 yudao-ui-admin-vue3 项目的 src/views/mall/promotion/coupon/template 目录。如下图所示：\n\n\n\n\n# 1.3 移动端\n\n① 在 uni-app 的 [我的] 有 [领劵中心]，可以领取优惠劵，对应 yudao-ui-uniapp 项目的 pages/coupon/list.vue 文件。如下图所示：\n\n\n\n② 点击 [领劵中心] 的优惠劵，可以查看该优惠劵的详情，对应 yudao-ui-uniapp 项目的 pages/coupon/detail.vue 文件。如下图所示：\n\n\n\n\n# 2. 优惠劵\n\n优惠劵，会员领取优惠劵模版来“生成”，由 couponservice 类实现。\n\n\n# 2.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `promotion_coupon` (\n  `id` bigint not null auto_increment comment '优惠劵编号',\n  \n  `template_id` bigint not null comment '优惠劵模板编号',\n  `name` varchar(50) character set utf8mb4 collate utf8mb4_general_ci not null comment '优惠劵名',\n  `use_price` int not null comment '是否设置满多少金额可用，单位：分',\n  `take_type` tinyint not null comment '领取方式',\n  `valid_start_time` datetime not null comment '生效开始时间',\n  `valid_end_time` datetime not null comment '生效结束时间',\n  `product_scope` tinyint not null comment '商品范围',\n  `product_scope_values` varchar(500) character set utf8mb4 collate utf8mb4_general_ci default null comment '商品范围编号的数组',\n  `discount_type` tinyint not null comment '折扣类型',\n  `discount_percent` tinyint default null comment '折扣百分比',\n  `discount_price` int default null comment '优惠金额，单位：分',\n  `discount_limit_price` int default null comment '折扣上限',\n  \n  `user_id` bigint not null comment '用户编号',\n\n  `status` tinyint not null comment '优惠码状态；1-未使用；2-已使用；3-已失效',\n  `use_order_id` bigint default null comment '使用订单号',\n  `use_time` datetime default null comment '使用时间',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=18 default charset=utf8mb4 collate=utf8mb4_general_ci comment='优惠劵';\n\n\n字段虽然也蛮多，但是都是从 promotion_coupon_template 中复制过来的，所以更多讲讲差异的地方。\n\n① 【优惠劵模版】从 template_id 开始到 discount_limit_price 结束，都是从 promotion_coupon_template 中复制过来的，用于记录优惠劵模版的信息。\n\n要注意，如果 promotion_coupon_template 中的信息发生变化，promotion_coupon 中的信息不会变化，因为买家已经领取了，不能随意变更。\n\n② 【用户】user_id 字段：用户编号，就是领取的买家。\n\n③ 【状态】status 字段：优惠码状态，由 couponstatusenum 枚举，分成 3 种情况：未使用、已使用、已失效。\n\n如果已使用，会记录 use_order_id、use_time 字段，表示使用的订单编号、使用时间。\n\n优惠劵的过期，由 couponexpirejob 定时任务实现。\n\n\n# 2.2 管理后台\n\n对应 [商城系统 -> 营销中心 -> 优惠劵 -> 领取记录] 菜单，对应 yudao-ui-admin-vue3 项目的 src/views/mall/promotion/coupon 目录。如下图所示：\n\n\n\n\n# 2.3 移动端\n\n① 在 uni-app 的 [我的] 有 [已领取]、[已使用]、[已失效]，可以查看优惠劵，对应 yudao-ui-uniapp 项目的 pages/coupon/list.vue 文件。如下图所示：\n\n\n\n② 点击某个优惠劵，可以查看该优惠劵的详情，对应 yudao-ui-uniapp 项目的 pages/coupon/detail.vue 文件。如下图所示：\n\n\n\n③ 在 uni-app 下单时，可以选择优惠劵，对应 yudao-ui-uniapp 项目的 sheep/components/s-coupon-select/s-coupon-select.vue 文件。如下图所示：\n\n",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【营销】积分商城",
            frontmatter: {
                title: "【营销】积分商城",
                date: "2024-10-04T18:45:41.000Z",
                permalink: "/mall/point-activity"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/14.%E5%95%86%E5%9F%8E%E6%89%8B%E5%86%8C/31.%E3%80%90%E8%90%A5%E9%94%80%E3%80%91%E7%A7%AF%E5%88%86%E5%95%86%E5%9F%8E.html",
            relativePath: "01.开发指南/14.商城手册/31.【营销】积分商城.md",
            key: "v-533a65b7",
            path: "/mall/point-activity/",
            headers: [{
                level: 2,
                title: "1. 表结构",
                slug: "_1-表结构",
                normalizedTitle: "1. 表结构",
                charIndex: 82
            }, {
                level: 2,
                title: "2. 管理后台",
                slug: "_2-管理后台",
                normalizedTitle: "2. 管理后台",
                charIndex: 2044
            }, {
                level: 2,
                title: "3. 移动端",
                slug: "_3-移动端",
                normalizedTitle: "3. 移动端",
                charIndex: 2174
            }],
            headersStr: "1. 表结构 2. 管理后台 3. 移动端",
            content: "积分商城，主要由 yudao-module-promotion-biz 后端模块的 point 实现，支持纯积分兑换商品、或者积分 + 金额兑换商品。\n\n\n\n\n# 1. 表结构\n\n一个积分活动，对应一条 promotion_point_activity 表记录，对应一个商品 SPU。而每个商品 SKU 在该活动下可以单独配置兑换价格，所以会有多条 promotion_point_product 子表记录。\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `promotion_point_activity` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '积分商城活动编号',\n  `remark` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '备注',\n  `sort` int NOT NULL COMMENT '排序',\n  \n  `spu_id` bigint NOT NULL COMMENT '商品 SPU ID',\n  \n  `status` int NOT NULL COMMENT '活动状态',\n  \n  `stock` int NOT NULL COMMENT '积分商城活动库存(剩余库存积分兑换时扣减)',\n  `total_stock` int NOT NULL COMMENT '积分商城活动总库存',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC COMMENT='积分商城活动';\n\n\n① spu_id 字段：商品 SPU ID，对应商品 SPU 表的 id 字段。\n\n注意：一个积分活动，只能对应一个商品 SPU，不能对应多个商品 SPU！！！\n\n② status 字段：活动状态，由 CommonStatusEnum 枚举，只有开启、禁用两个状态。禁用时，无法参与积分兑换。\n\n③ stock、total_stock 字段：积分商城活动库存，自定义参与积分兑换的数量。目前它是 promotion_point_product 表的 stock 字段的总和。\n\n----------------------------------------\n\nCREATE TABLE `promotion_point_product` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '积分商城商品编号',\n\n  `activity_id` bigint NOT NULL COMMENT '积分商城活动 id',  \n  `activity_status` int NOT NULL COMMENT '积分商城商品状态',\n  \n  `spu_id` bigint NOT NULL COMMENT '商品 SPU 编号',\n  `sku_id` bigint NOT NULL COMMENT '商品 SKU 编号',\n  \n  `count` int NOT NULL COMMENT '可兑换次数',\n  `stock` int NOT NULL COMMENT '积分商城商品库存',\n\n  `point` int NOT NULL COMMENT '所需兑换积分',\n  `price` int NOT NULL COMMENT '所需兑换金额，单位：分',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC COMMENT='积分商城商品';\n\n\n① 【活动信息】activity_id 字段：积分商城活动 id，对应 promotion_point_activity 表的 id 字段。\n\n② 【SKU 信息】spu_id、sku_id 字段：商品 SPU 编号、商品 SKU 编号。\n\n * count 字段：可兑换次数，例如说，每个用户最多兑换 1 次。stock 字段：积分商城商品库存。\n * point 字段：所需兑换积分。price 字段：所需兑换金额，单位：分。\n\n如果想要支持纯积分兑换商品，那么 price 字段可以设置为 0。\n\n\n# 2. 管理后台\n\n对应 [商城系统 -> 营销中心 -> 优惠活动 -> 积分商城] 菜单，对应 yudao-ui-admin-vue3 项目的 src/views/mall/promotion/pointActivity 目录。如下图所示：\n\n\n\n\n\n\n# 3. 移动端\n\n① 在 uni-app 的个人中心，点击 [积分商城] 菜单，进入积分商品列表页，对应 yudao-mall-uniapp 的 pages/activity/point/list.vue 文件。如下图所示：\n\n\n\n② 点击商品，进入商品详情页，对应 pages/goods/point.vue 文件。如下图所示：\n\n\n\n③ 点击 [立即兑换] 按钮，选择商品后，进入确认订单页，如下图所示：\n\n\n\n点击「提交订单」按钮后，会创建一条 trade_order 订单记录：\n\n * trade_order 的 type 字段为积分商城类型，point_activity_id 字段为积分活动编号\n * 积分优惠金额的计算，由 TradePointOrderHandler 类实现\n * 积分在订单的自定义处理逻辑，由 TradePointActivityPriceCalculator 类实现\n\n后续的逻辑，就是普通订单的流程，就不重复赘述了~",
            normalizedContent: "积分商城，主要由 yudao-module-promotion-biz 后端模块的 point 实现，支持纯积分兑换商品、或者积分 + 金额兑换商品。\n\n\n\n\n# 1. 表结构\n\n一个积分活动，对应一条 promotion_point_activity 表记录，对应一个商品 spu。而每个商品 sku 在该活动下可以单独配置兑换价格，所以会有多条 promotion_point_product 子表记录。\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `promotion_point_activity` (\n  `id` bigint not null auto_increment comment '积分商城活动编号',\n  `remark` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '备注',\n  `sort` int not null comment '排序',\n  \n  `spu_id` bigint not null comment '商品 spu id',\n  \n  `status` int not null comment '活动状态',\n  \n  `stock` int not null comment '积分商城活动库存(剩余库存积分兑换时扣减)',\n  `total_stock` int not null comment '积分商城活动总库存',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=2 default charset=utf8mb4 collate=utf8mb4_unicode_ci row_format=dynamic comment='积分商城活动';\n\n\n① spu_id 字段：商品 spu id，对应商品 spu 表的 id 字段。\n\n注意：一个积分活动，只能对应一个商品 spu，不能对应多个商品 spu！！！\n\n② status 字段：活动状态，由 commonstatusenum 枚举，只有开启、禁用两个状态。禁用时，无法参与积分兑换。\n\n③ stock、total_stock 字段：积分商城活动库存，自定义参与积分兑换的数量。目前它是 promotion_point_product 表的 stock 字段的总和。\n\n----------------------------------------\n\ncreate table `promotion_point_product` (\n  `id` bigint not null auto_increment comment '积分商城商品编号',\n\n  `activity_id` bigint not null comment '积分商城活动 id',  \n  `activity_status` int not null comment '积分商城商品状态',\n  \n  `spu_id` bigint not null comment '商品 spu 编号',\n  `sku_id` bigint not null comment '商品 sku 编号',\n  \n  `count` int not null comment '可兑换次数',\n  `stock` int not null comment '积分商城商品库存',\n\n  `point` int not null comment '所需兑换积分',\n  `price` int not null comment '所需兑换金额，单位：分',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=4 default charset=utf8mb4 collate=utf8mb4_unicode_ci row_format=dynamic comment='积分商城商品';\n\n\n① 【活动信息】activity_id 字段：积分商城活动 id，对应 promotion_point_activity 表的 id 字段。\n\n② 【sku 信息】spu_id、sku_id 字段：商品 spu 编号、商品 sku 编号。\n\n * count 字段：可兑换次数，例如说，每个用户最多兑换 1 次。stock 字段：积分商城商品库存。\n * point 字段：所需兑换积分。price 字段：所需兑换金额，单位：分。\n\n如果想要支持纯积分兑换商品，那么 price 字段可以设置为 0。\n\n\n# 2. 管理后台\n\n对应 [商城系统 -> 营销中心 -> 优惠活动 -> 积分商城] 菜单，对应 yudao-ui-admin-vue3 项目的 src/views/mall/promotion/pointactivity 目录。如下图所示：\n\n\n\n\n\n\n# 3. 移动端\n\n① 在 uni-app 的个人中心，点击 [积分商城] 菜单，进入积分商品列表页，对应 yudao-mall-uniapp 的 pages/activity/point/list.vue 文件。如下图所示：\n\n\n\n② 点击商品，进入商品详情页，对应 pages/goods/point.vue 文件。如下图所示：\n\n\n\n③ 点击 [立即兑换] 按钮，选择商品后，进入确认订单页，如下图所示：\n\n\n\n点击「提交订单」按钮后，会创建一条 trade_order 订单记录：\n\n * trade_order 的 type 字段为积分商城类型，point_activity_id 字段为积分活动编号\n * 积分优惠金额的计算，由 tradepointorderhandler 类实现\n * 积分在订单的自定义处理逻辑，由 tradepointactivitypricecalculator 类实现\n\n后续的逻辑，就是普通订单的流程，就不重复赘述了~",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【交易】门店自提",
            frontmatter: {
                title: "【交易】门店自提",
                date: "2024-01-16T23:18:13.000Z",
                permalink: "/mall/trade-delivery-pickup"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/14.%E5%95%86%E5%9F%8E%E6%89%8B%E5%86%8C/25.%E3%80%90%E4%BA%A4%E6%98%93%E3%80%91%E9%97%A8%E5%BA%97%E8%87%AA%E6%8F%90.html",
            relativePath: "01.开发指南/14.商城手册/25.【交易】门店自提.md",
            key: "v-daa527f8",
            path: "/mall/trade-delivery-pickup/",
            headers: [{
                level: 2,
                title: "1. 门店信息",
                slug: "_1-门店信息",
                normalizedTitle: "1. 门店信息",
                charIndex: 41
            }, {
                level: 3,
                title: "1.1 表结构",
                slug: "_1-1-表结构",
                normalizedTitle: "1.1 表结构",
                charIndex: 143
            }, {
                level: 3,
                title: "1.2 管理后台",
                slug: "_1-2-管理后台",
                normalizedTitle: "1.2 管理后台",
                charIndex: 1491
            }, {
                level: 2,
                title: "2. 自提流程",
                slug: "_2-自提流程",
                normalizedTitle: "2. 自提流程",
                charIndex: 1623
            }, {
                level: 3,
                title: "2.1 下单【买家】",
                slug: "_2-1-下单【买家】",
                normalizedTitle: "2.1 下单【买家】",
                charIndex: 1635
            }, {
                level: 3,
                title: "2.2 核销【卖家】",
                slug: "_2-2-核销【卖家】",
                normalizedTitle: "2.2 核销【卖家】",
                charIndex: 1815
            }, {
                level: 2,
                title: "3. 配送配置",
                slug: "_3-配送配置",
                normalizedTitle: "3. 配送配置",
                charIndex: 2269
            }],
            headersStr: "1. 门店信息 1.1 表结构 1.2 管理后台 2. 自提流程 2.1 下单【买家】 2.2 核销【卖家】 3. 配送配置",
            content: "门店自提，是指用户在下单时，选择自提，然后到指定的门店进行自提（核销）。\n\n\n# 1. 门店信息\n\n门店自提时，需要使用门店信息，由 yudao-module-trade-biz 后端模块的 delivery 包的 DeliveryPickUpStoreService 实现。\n\n\n# 1.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `trade_delivery_pick_up_store` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  `name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '门店名称',\n  `introduction` varchar(256) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '门店简介',\n  `phone` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '门店手机',\n  `area_id` int NOT NULL COMMENT '区域编号',\n  `detail_address` varchar(256) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '门店详细地址',\n  `logo` varchar(256) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '门店 logo',\n  `opening_time` time NOT NULL COMMENT '营业开始时间',\n  `closing_time` time NOT NULL COMMENT '营业结束时间',\n  `latitude` double NOT NULL COMMENT '纬度',\n  `longitude` double NOT NULL COMMENT '经度',\n  `status` tinyint NOT NULL DEFAULT '0' COMMENT '门店状态',\n  \n  `verify_user_ids` varchar(256) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '核销用户编号数组',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='自提门店';\n\n\n主要是，存储下门店的基本信息。\n\n比较重要特殊的字段，是 verify_user_ids 字段，存储该门店可核销的管理员用户编号数组，关联的是 system_admin_users 的 id 字段。就是说，下单在该门店的订单，只有这些管理员才能核销。\n\n\n# 1.2 管理后台\n\n对应 [商城系统 -> 订单中心 -> 配送管理 -> 门店自提 -> 门店管理] 菜单，对应 yudao-ui-admin-vue3 项目的 views/mall/trade/delivery/express 目录。如下图所示：\n\n\n\n\n# 2. 自提流程\n\n\n# 2.1 下单【买家】\n\n① 买家在 uni-app 订单结算页时，选择自提，然后选择自提门店。如下图所示：\n\n\n\n注意：商品的配送方式需要支持自提，才会显示自提的选项！！！如果没设置，去“商品管理”里，编辑下相关的商品。\n\n② 下单并支付完成后，买家在 uni-app 订单详情页时，可以看到自提门店的信息，也包括核销码、核销二维码。如下图所示：\n\n\n\n\n# 2.2 核销【卖家】\n\n① 核销订单列表，对应 [商城系统 -> 订单中心 -> 配送管理 -> 门店自提 -> 核销订单] 菜单，对应 yudao-ui-admin-vue3 项目的 views/mall/trade/delivery/pickUpOrder 目录。如下图所示：\n\n\n\n注意！只展示当前登录的管理员用户可核销的订单。关注下“自提门店”这个筛选项！！！\n\n② 点击「核销」按钮，输入核销码，查询核销订单的信息。如下图所示：\n\n\n\n后端对应 AppTradeOrderController 的 #getByPickUpVerifyCode(...) 提供的“查询核销码对应的订单”接口，基于 trade_order 表的 pick_up_verify_code 字段查询。\n\n③ 点击「确认核销」按钮后，即可核销成功。如下图所示：\n\n\n\n后端对应 AppTradeOrderController 的 #pickUpOrderByVerifyCode(...) 提供的“订单核销”接口。\n\n\n# 3. 配送配置\n\n\n\n * SQL 对应 trade_config 表的 delivery_ 开头的字段。\n * 前端对应 yudao-ui-admin-vue3 项目的 views/mall/trade/config/index.vue 目录\n * 后端对应 yudao-module-trade-biz 项目的 TradeConfigController 类",
            normalizedContent: "门店自提，是指用户在下单时，选择自提，然后到指定的门店进行自提（核销）。\n\n\n# 1. 门店信息\n\n门店自提时，需要使用门店信息，由 yudao-module-trade-biz 后端模块的 delivery 包的 deliverypickupstoreservice 实现。\n\n\n# 1.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `trade_delivery_pick_up_store` (\n  `id` bigint not null auto_increment comment '编号',\n  `name` varchar(64) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '门店名称',\n  `introduction` varchar(256) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '门店简介',\n  `phone` varchar(16) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '门店手机',\n  `area_id` int not null comment '区域编号',\n  `detail_address` varchar(256) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '门店详细地址',\n  `logo` varchar(256) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '门店 logo',\n  `opening_time` time not null comment '营业开始时间',\n  `closing_time` time not null comment '营业结束时间',\n  `latitude` double not null comment '纬度',\n  `longitude` double not null comment '经度',\n  `status` tinyint not null default '0' comment '门店状态',\n  \n  `verify_user_ids` varchar(256) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '核销用户编号数组',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=2 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='自提门店';\n\n\n主要是，存储下门店的基本信息。\n\n比较重要特殊的字段，是 verify_user_ids 字段，存储该门店可核销的管理员用户编号数组，关联的是 system_admin_users 的 id 字段。就是说，下单在该门店的订单，只有这些管理员才能核销。\n\n\n# 1.2 管理后台\n\n对应 [商城系统 -> 订单中心 -> 配送管理 -> 门店自提 -> 门店管理] 菜单，对应 yudao-ui-admin-vue3 项目的 views/mall/trade/delivery/express 目录。如下图所示：\n\n\n\n\n# 2. 自提流程\n\n\n# 2.1 下单【买家】\n\n① 买家在 uni-app 订单结算页时，选择自提，然后选择自提门店。如下图所示：\n\n\n\n注意：商品的配送方式需要支持自提，才会显示自提的选项！！！如果没设置，去“商品管理”里，编辑下相关的商品。\n\n② 下单并支付完成后，买家在 uni-app 订单详情页时，可以看到自提门店的信息，也包括核销码、核销二维码。如下图所示：\n\n\n\n\n# 2.2 核销【卖家】\n\n① 核销订单列表，对应 [商城系统 -> 订单中心 -> 配送管理 -> 门店自提 -> 核销订单] 菜单，对应 yudao-ui-admin-vue3 项目的 views/mall/trade/delivery/pickuporder 目录。如下图所示：\n\n\n\n注意！只展示当前登录的管理员用户可核销的订单。关注下“自提门店”这个筛选项！！！\n\n② 点击「核销」按钮，输入核销码，查询核销订单的信息。如下图所示：\n\n\n\n后端对应 apptradeordercontroller 的 #getbypickupverifycode(...) 提供的“查询核销码对应的订单”接口，基于 trade_order 表的 pick_up_verify_code 字段查询。\n\n③ 点击「确认核销」按钮后，即可核销成功。如下图所示：\n\n\n\n后端对应 apptradeordercontroller 的 #pickuporderbyverifycode(...) 提供的“订单核销”接口。\n\n\n# 3. 配送配置\n\n\n\n * sql 对应 trade_config 表的 delivery_ 开头的字段。\n * 前端对应 yudao-ui-admin-vue3 项目的 views/mall/trade/config/index.vue 目录\n * 后端对应 yudao-module-trade-biz 项目的 tradeconfigcontroller 类",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【营销】拼团活动",
            frontmatter: {
                title: "【营销】拼团活动",
                date: "2024-01-17T13:44:15.000Z",
                permalink: "/mall/promotion-combination"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/14.%E5%95%86%E5%9F%8E%E6%89%8B%E5%86%8C/32.%E3%80%90%E8%90%A5%E9%94%80%E3%80%91%E6%8B%BC%E5%9B%A2%E6%B4%BB%E5%8A%A8.html",
            relativePath: "01.开发指南/14.商城手册/32.【营销】拼团活动.md",
            key: "v-2c1efaa7",
            path: "/mall/promotion-combination/",
            headers: [{
                level: 2,
                title: "1. 拼团活动",
                slug: "_1-拼团活动",
                normalizedTitle: "1. 拼团活动",
                charIndex: 82
            }, {
                level: 3,
                title: "1.1 表结构",
                slug: "_1-1-表结构",
                normalizedTitle: "1.1 表结构",
                charIndex: 155
            }, {
                level: 3,
                title: "1.2 管理后台",
                slug: "_1-2-管理后台",
                normalizedTitle: "1.2 管理后台",
                charIndex: 2415
            }, {
                level: 3,
                title: "1.3 移动端",
                slug: "_1-3-移动端",
                normalizedTitle: "1.3 移动端",
                charIndex: 2547
            }, {
                level: 2,
                title: "2. 拼团记录",
                slug: "_2-拼团记录",
                normalizedTitle: "2. 拼团记录",
                charIndex: 2697
            }, {
                level: 3,
                title: "2.1 表结构",
                slug: "_2-1-表结构",
                normalizedTitle: "2.1 表结构",
                charIndex: 2766
            }, {
                level: 3,
                title: "2.2 管理后台",
                slug: "_2-2-管理后台",
                normalizedTitle: "2.2 管理后台",
                charIndex: 4828
            }, {
                level: 3,
                title: "2.3 移动端【团长】",
                slug: "_2-3-移动端【团长】",
                normalizedTitle: "2.3 移动端【团长】",
                charIndex: 4958
            }, {
                level: 3,
                title: "2.4 移动端【团员】",
                slug: "_2-4-移动端【团员】",
                normalizedTitle: "2.4 移动端【团员】",
                charIndex: 5767
            }],
            headersStr: "1. 拼团活动 1.1 表结构 1.2 管理后台 1.3 移动端 2. 拼团记录 2.1 表结构 2.2 管理后台 2.3 移动端【团长】 2.4 移动端【团员】",
            content: "拼团，主要由 yudao-module-promotion-biz 后端模块的 promotion 实现，包括两部分：拼团活动、拼团记录。如下图所示：\n\n\n\n\n# 1. 拼团活动\n\n拼团活动，由卖家在管理后台配置，提供给买家参与拼团，由 CombinationActivityService 类实现。\n\n\n# 1.1 表结构\n\n一个拼团活动，对应一条 promotion_combination_activity 表记录，对应一个商品 SPU。而每个商品 SKU 在该拼团下可以单独配置拼团价格，所以会有多条 promotion_combination_activity_sku 子表记录。\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `promotion_combination_activity` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '活动编号',\n  `name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '拼团名称',\n  \n  `spu_id` bigint NOT NULL COMMENT '商品 SPU ID',\n  \n  `status` tinyint NOT NULL DEFAULT '0' COMMENT '活动状态：0开启 1关闭',\n\n  `total_limit_count` int NOT NULL COMMENT '总限购数量',\n  `single_limit_count` int NOT NULL COMMENT '单次限购数量',\n  `start_time` datetime NOT NULL COMMENT '开始时间',\n  `end_time` datetime NOT NULL COMMENT '结束时间',\n  \n  `user_size` int DEFAULT NULL COMMENT '购买人数',\n  `virtual_group` int NOT NULL COMMENT '虚拟成团',\n  `limit_duration` int NOT NULL COMMENT '限制时长（小时）',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT='拼团活动';\n\n\n① spu_id 字段：商品 SPU ID，对应商品 SPU 表的 id 字段。\n\n注意：一个拼团活动，只能对应一个商品 SPU，不能对应多个商品 SPU！！！\n\n② status 字段：活动状态，由 CommonStatusEnum 枚举，只有开启、禁用两个状态。禁用时，无法参与拼团。\n\n③ user_size 字段：每个拼团需要的人数，例如说，3 人团、5 人团。\n\n如果超过 limit_duration 时长，还没凑齐人数，就会自动拼团失败。当然，如果希望虚拟成团，则可以设置 virtual_group 字段，此时只要 user_size - virtual_group 人即可拼团成功。这块逻辑，由 CombinationRecordExpireJob 定时任务实现。\n\n----------------------------------------\n\nCREATE TABLE `promotion_combination_product` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  \n  `activity_id` bigint DEFAULT NULL COMMENT '拼团活动编号',\n  `activity_status` tinyint NOT NULL DEFAULT '0' COMMENT '拼团商品状态',\n  `activity_start_time` datetime NOT NULL COMMENT '活动开始时间点',\n  `activity_end_time` datetime NOT NULL COMMENT '活动结束时间点',\n  \n  `spu_id` bigint DEFAULT NULL COMMENT '商品 SPU 编号',\n  `sku_id` bigint DEFAULT NULL COMMENT '商品 SKU 编号',\n\n  `combination_price` int NOT NULL DEFAULT '0' COMMENT '拼团价格，单位分',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=32 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT='拼团商品';\n\n\n① 【活动信息】activity_id 字段：拼团活动编号，对应 promotion_combination_activity 表的 id 字段。其它 activity_* + spu_id 字段，都是冗余字段，方便查询。\n\n② 【SKU 信息】sku_id 字段：商品 SKU 编号，对应商品 SKU 表的 id 字段。combination_price 字段：拼团价格，单位分。\n\n\n# 1.2 管理后台\n\n对应 [商城系统 -> 营销中心 -> 拼团活动 -> 拼团商品] 菜单，对应 yudao-ui-admin-vue3 项目的 views/mall/promotion/combination/activity 目录。如下图所示：\n\n\n\n\n# 1.3 移动端\n\n① 点击 uni-app 首页的 [拼团] 菜单，进入拼团列表页，对应 pages/activity/groupon/list.vue 目录。如下图所示：\n\n\n\n② 点击某个拼团，进入拼团详情页，对应 pages/goods/groupon.vue 目录。如下图所示：\n\n\n\n\n# 2. 拼团记录\n\n拼团记录，由买家参与拼团时生成，分成团长和团员，由 CombinationRecordService 类实现。\n\n\n# 2.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `promotion_combination_record` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  \n  `activity_id` bigint DEFAULT NULL COMMENT '拼团活动编号',\n  `spu_id` bigint DEFAULT NULL COMMENT '商品 SPU 编号',\n  `pic_url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '商品图片',\n  `spu_name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '商品名称',\n  `sku_id` bigint DEFAULT NULL COMMENT '商品 SKU 编号',\n  `count` int DEFAULT NULL COMMENT '购买的商品数量',\n  `combination_price` int NOT NULL COMMENT '拼团商品单价，单位分',\n  `user_size` int NOT NULL COMMENT '可参团人数',\n  \n  `user_id` bigint DEFAULT NULL COMMENT '用户编号',\n  `nickname` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT '' COMMENT '用户昵称',\n  `avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT '' COMMENT '用户头像',\n\n  `status` tinyint NOT NULL DEFAULT '0' COMMENT '参与状态：1进行中 2已完成 3未完成',  \n  `head_id` bigint DEFAULT NULL COMMENT '团长编号',\n  `user_count` int NOT NULL COMMENT '已参团人数',\n  `virtual_group` bit(1) DEFAULT NULL COMMENT '是否虚拟拼团',\n  `expire_time` datetime NOT NULL COMMENT '过期时间',\n  `start_time` datetime DEFAULT NULL COMMENT '开始时间 (订单付款后开始的时间)',\n  `end_time` datetime DEFAULT NULL COMMENT '结束时间（成团时间/失败时间）',\n  \n  `order_id` bigint DEFAULT NULL COMMENT '订单编号',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT='拼团记录';\n\n\n① 【活动信息】activity_id 字段：拼团活动编号，对应 promotion_combination_activity 表的 id 字段。\n\n其它 spu_id、pic_url、spu_name、sku_id、count、combination_price、user_size 字段，都是冗余字段，方便查询。\n\n② 【用户信息】user_id 字段：用户编号，就是拼团的买家。\n\n其它 nickname、avatar 字段，都是冗余字段，方便查询。\n\n③ 【拼团信息】status 字段：参与状态，由 CombinationRecordStatusEnum 枚举，分成 3 种情况：进行中、拼团成功、拼团失败。\n\nhead_id 字段：团长“编号”。分成两种情况：\n\n * 团长：则该字段为 0，表示它是团长的拼团记录。\n * 团员：则该字段为团队拼团记录的 id，表示它是团长的拼团记录的团员。\n\n其它 user_count、virtual_group、expire_time、start_time、end_time 字段，就是拼团的一些信息。\n\n④ 【订单信息】order_id 字段：订单编号，对应订单表的 id 字段。每个拼团记录，都会生成一个订单。\n\n\n# 2.2 管理后台\n\n对应 [商城系统 -> 营销中心 -> 拼团活动 -> 拼团记录] 菜单，对应 yudao-ui-admin-vue3 项目的 views/mall/promotion/combination/record 目录。如下图所示：\n\n\n\n\n# 2.3 移动端【团长】\n\n友情提示：本小节，我们会“发起”一次拼团，扮演【团长】的角色\n\n① 在 uni-app 拼团详情页，点击「立即购买」按钮，选择商品后，进入确认订单页，如下图所示：\n\n\n\n点击「提交订单」按钮后，会创建一条 trade_order 订单记录。此时，并未创建 promotion_combination_record 拼团记录：\n\n * trade_order 的 type 字段为拼团类型，combination_activity_id 字段为拼团活动编号，head_id 字段为 0 表示它是团长，combination_head_id 字段为 0 因为此时还没拼团记录\n * 拼团优惠金额的计算，由 TradeCombinationActivityPriceCalculator 类实现\n * 拼团在订单的自定义处理逻辑，由 TradeCombinationOrderHandler 类实现\n\n② 之后，会跳转到支付页。完成支付后，在 trade_order 订单记录为“已支付”的同时，会创建一条 promotion_combination_record 拼团记录，此时，拼团记录的状态为“进行中”，如下图所示：\n\n\n\n * 相关的逻辑处理，也是由 TradeCombinationOrderHandler 类实现\n * trade_order 的 combination_head_id 字段为拼团记录的 id\n\n③ 点击「我的拼团」按钮，进入拼团列表页，对应 yudao-mall-unipp 项目的 pages/activity/groupon/order.vue 目录。如下图所示：\n\n\n\n④ 点击「邀请拼团」按钮，进入拼团详情页，对应 yudao-mall-unipp 项目的 pages/activity/groupon/detail.vue 目录。如下图所示：\n\n\n\n\n# 2.4 移动端【团员】\n\n友情提示：本小节，我们会“参与”一次拼团，扮演【团员】的角色\n\n① 注册一个新的买家账号，然后在 uni-app 拼团详情页。如下图所示：\n\n\n\n② 点击拼团记录后面的「去参团」按钮，选择商品后，进入确认订单页，如下图所示：\n\n\n\n整体流程和【团长】的流程一致，只是在 trade_order 订单记录的 combination_head_id 字段为拼团记录的 id。\n\n③ 之后，会跳转到支付页。完成支付后，在 trade_order 订单记录为“已支付”的同时，会创建一条 promotion_combination_record 拼团记录，此时，拼团记录的状态为“拼团成功”。\n\n\n\n为什么是“拼团成功”呢？因为该拼团是 2 人团，此时显然已经满足，所以拼团成功。具体逻辑，可见 CombinationRecordService 类的 #createCombinationRecord(...) 方法，它会更新拼团进展（状态）。\n\n----------------------------------------\n\n至此，我们已经完成了拼团流程，可以 debug 调试调试哈~~~",
            normalizedContent: "拼团，主要由 yudao-module-promotion-biz 后端模块的 promotion 实现，包括两部分：拼团活动、拼团记录。如下图所示：\n\n\n\n\n# 1. 拼团活动\n\n拼团活动，由卖家在管理后台配置，提供给买家参与拼团，由 combinationactivityservice 类实现。\n\n\n# 1.1 表结构\n\n一个拼团活动，对应一条 promotion_combination_activity 表记录，对应一个商品 spu。而每个商品 sku 在该拼团下可以单独配置拼团价格，所以会有多条 promotion_combination_activity_sku 子表记录。\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `promotion_combination_activity` (\n  `id` bigint not null auto_increment comment '活动编号',\n  `name` varchar(50) character set utf8mb4 collate utf8mb4_general_ci not null default '' comment '拼团名称',\n  \n  `spu_id` bigint not null comment '商品 spu id',\n  \n  `status` tinyint not null default '0' comment '活动状态：0开启 1关闭',\n\n  `total_limit_count` int not null comment '总限购数量',\n  `single_limit_count` int not null comment '单次限购数量',\n  `start_time` datetime not null comment '开始时间',\n  `end_time` datetime not null comment '结束时间',\n  \n  `user_size` int default null comment '购买人数',\n  `virtual_group` int not null comment '虚拟成团',\n  `limit_duration` int not null comment '限制时长（小时）',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=9 default charset=utf8mb4 collate=utf8mb4_general_ci comment='拼团活动';\n\n\n① spu_id 字段：商品 spu id，对应商品 spu 表的 id 字段。\n\n注意：一个拼团活动，只能对应一个商品 spu，不能对应多个商品 spu！！！\n\n② status 字段：活动状态，由 commonstatusenum 枚举，只有开启、禁用两个状态。禁用时，无法参与拼团。\n\n③ user_size 字段：每个拼团需要的人数，例如说，3 人团、5 人团。\n\n如果超过 limit_duration 时长，还没凑齐人数，就会自动拼团失败。当然，如果希望虚拟成团，则可以设置 virtual_group 字段，此时只要 user_size - virtual_group 人即可拼团成功。这块逻辑，由 combinationrecordexpirejob 定时任务实现。\n\n----------------------------------------\n\ncreate table `promotion_combination_product` (\n  `id` bigint not null auto_increment comment '编号',\n  \n  `activity_id` bigint default null comment '拼团活动编号',\n  `activity_status` tinyint not null default '0' comment '拼团商品状态',\n  `activity_start_time` datetime not null comment '活动开始时间点',\n  `activity_end_time` datetime not null comment '活动结束时间点',\n  \n  `spu_id` bigint default null comment '商品 spu 编号',\n  `sku_id` bigint default null comment '商品 sku 编号',\n\n  `combination_price` int not null default '0' comment '拼团价格，单位分',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=32 default charset=utf8mb4 collate=utf8mb4_general_ci comment='拼团商品';\n\n\n① 【活动信息】activity_id 字段：拼团活动编号，对应 promotion_combination_activity 表的 id 字段。其它 activity_* + spu_id 字段，都是冗余字段，方便查询。\n\n② 【sku 信息】sku_id 字段：商品 sku 编号，对应商品 sku 表的 id 字段。combination_price 字段：拼团价格，单位分。\n\n\n# 1.2 管理后台\n\n对应 [商城系统 -> 营销中心 -> 拼团活动 -> 拼团商品] 菜单，对应 yudao-ui-admin-vue3 项目的 views/mall/promotion/combination/activity 目录。如下图所示：\n\n\n\n\n# 1.3 移动端\n\n① 点击 uni-app 首页的 [拼团] 菜单，进入拼团列表页，对应 pages/activity/groupon/list.vue 目录。如下图所示：\n\n\n\n② 点击某个拼团，进入拼团详情页，对应 pages/goods/groupon.vue 目录。如下图所示：\n\n\n\n\n# 2. 拼团记录\n\n拼团记录，由买家参与拼团时生成，分成团长和团员，由 combinationrecordservice 类实现。\n\n\n# 2.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `promotion_combination_record` (\n  `id` bigint not null auto_increment comment '编号',\n  \n  `activity_id` bigint default null comment '拼团活动编号',\n  `spu_id` bigint default null comment '商品 spu 编号',\n  `pic_url` varchar(255) character set utf8mb4 collate utf8mb4_general_ci not null comment '商品图片',\n  `spu_name` varchar(64) character set utf8mb4 collate utf8mb4_general_ci not null comment '商品名称',\n  `sku_id` bigint default null comment '商品 sku 编号',\n  `count` int default null comment '购买的商品数量',\n  `combination_price` int not null comment '拼团商品单价，单位分',\n  `user_size` int not null comment '可参团人数',\n  \n  `user_id` bigint default null comment '用户编号',\n  `nickname` varchar(64) character set utf8mb4 collate utf8mb4_general_ci default '' comment '用户昵称',\n  `avatar` varchar(255) character set utf8mb4 collate utf8mb4_general_ci default '' comment '用户头像',\n\n  `status` tinyint not null default '0' comment '参与状态：1进行中 2已完成 3未完成',  \n  `head_id` bigint default null comment '团长编号',\n  `user_count` int not null comment '已参团人数',\n  `virtual_group` bit(1) default null comment '是否虚拟拼团',\n  `expire_time` datetime not null comment '过期时间',\n  `start_time` datetime default null comment '开始时间 (订单付款后开始的时间)',\n  `end_time` datetime default null comment '结束时间（成团时间/失败时间）',\n  \n  `order_id` bigint default null comment '订单编号',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=13 default charset=utf8mb4 collate=utf8mb4_general_ci comment='拼团记录';\n\n\n① 【活动信息】activity_id 字段：拼团活动编号，对应 promotion_combination_activity 表的 id 字段。\n\n其它 spu_id、pic_url、spu_name、sku_id、count、combination_price、user_size 字段，都是冗余字段，方便查询。\n\n② 【用户信息】user_id 字段：用户编号，就是拼团的买家。\n\n其它 nickname、avatar 字段，都是冗余字段，方便查询。\n\n③ 【拼团信息】status 字段：参与状态，由 combinationrecordstatusenum 枚举，分成 3 种情况：进行中、拼团成功、拼团失败。\n\nhead_id 字段：团长“编号”。分成两种情况：\n\n * 团长：则该字段为 0，表示它是团长的拼团记录。\n * 团员：则该字段为团队拼团记录的 id，表示它是团长的拼团记录的团员。\n\n其它 user_count、virtual_group、expire_time、start_time、end_time 字段，就是拼团的一些信息。\n\n④ 【订单信息】order_id 字段：订单编号，对应订单表的 id 字段。每个拼团记录，都会生成一个订单。\n\n\n# 2.2 管理后台\n\n对应 [商城系统 -> 营销中心 -> 拼团活动 -> 拼团记录] 菜单，对应 yudao-ui-admin-vue3 项目的 views/mall/promotion/combination/record 目录。如下图所示：\n\n\n\n\n# 2.3 移动端【团长】\n\n友情提示：本小节，我们会“发起”一次拼团，扮演【团长】的角色\n\n① 在 uni-app 拼团详情页，点击「立即购买」按钮，选择商品后，进入确认订单页，如下图所示：\n\n\n\n点击「提交订单」按钮后，会创建一条 trade_order 订单记录。此时，并未创建 promotion_combination_record 拼团记录：\n\n * trade_order 的 type 字段为拼团类型，combination_activity_id 字段为拼团活动编号，head_id 字段为 0 表示它是团长，combination_head_id 字段为 0 因为此时还没拼团记录\n * 拼团优惠金额的计算，由 tradecombinationactivitypricecalculator 类实现\n * 拼团在订单的自定义处理逻辑，由 tradecombinationorderhandler 类实现\n\n② 之后，会跳转到支付页。完成支付后，在 trade_order 订单记录为“已支付”的同时，会创建一条 promotion_combination_record 拼团记录，此时，拼团记录的状态为“进行中”，如下图所示：\n\n\n\n * 相关的逻辑处理，也是由 tradecombinationorderhandler 类实现\n * trade_order 的 combination_head_id 字段为拼团记录的 id\n\n③ 点击「我的拼团」按钮，进入拼团列表页，对应 yudao-mall-unipp 项目的 pages/activity/groupon/order.vue 目录。如下图所示：\n\n\n\n④ 点击「邀请拼团」按钮，进入拼团详情页，对应 yudao-mall-unipp 项目的 pages/activity/groupon/detail.vue 目录。如下图所示：\n\n\n\n\n# 2.4 移动端【团员】\n\n友情提示：本小节，我们会“参与”一次拼团，扮演【团员】的角色\n\n① 注册一个新的买家账号，然后在 uni-app 拼团详情页。如下图所示：\n\n\n\n② 点击拼团记录后面的「去参团」按钮，选择商品后，进入确认订单页，如下图所示：\n\n\n\n整体流程和【团长】的流程一致，只是在 trade_order 订单记录的 combination_head_id 字段为拼团记录的 id。\n\n③ 之后，会跳转到支付页。完成支付后，在 trade_order 订单记录为“已支付”的同时，会创建一条 promotion_combination_record 拼团记录，此时，拼团记录的状态为“拼团成功”。\n\n\n\n为什么是“拼团成功”呢？因为该拼团是 2 人团，此时显然已经满足，所以拼团成功。具体逻辑，可见 combinationrecordservice 类的 #createcombinationrecord(...) 方法，它会更新拼团进展（状态）。\n\n----------------------------------------\n\n至此，我们已经完成了拼团流程，可以 debug 调试调试哈~~~",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【营销】秒杀活动",
            frontmatter: {
                title: "【营销】秒杀活动",
                date: "2024-01-17T16:06:36.000Z",
                permalink: "/mall/promotion-seckill/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/14.%E5%95%86%E5%9F%8E%E6%89%8B%E5%86%8C/33.%E3%80%90%E8%90%A5%E9%94%80%E3%80%91%E7%A7%92%E6%9D%80%E6%B4%BB%E5%8A%A8.html",
            relativePath: "01.开发指南/14.商城手册/33.【营销】秒杀活动.md",
            key: "v-718a2694",
            path: "/mall/promotion-seckill/",
            headers: [{
                level: 2,
                title: "1. 秒杀配置",
                slug: "_1-秒杀配置",
                normalizedTitle: "1. 秒杀配置",
                charIndex: 86
            }, {
                level: 3,
                title: "1.1 表结构",
                slug: "_1-1-表结构",
                normalizedTitle: "1.1 表结构",
                charIndex: 159
            }, {
                level: 3,
                title: "1.2 管理后台",
                slug: "_1-2-管理后台",
                normalizedTitle: "1.2 管理后台",
                charIndex: 935
            }, {
                level: 2,
                title: "2. 秒杀活动",
                slug: "_2-秒杀活动",
                normalizedTitle: "2. 秒杀活动",
                charIndex: 1061
            }, {
                level: 3,
                title: "2.1 表结构",
                slug: "_2-1-表结构",
                normalizedTitle: "2.1 表结构",
                charIndex: 1130
            }, {
                level: 3,
                title: "2.2 管理后台",
                slug: "_2-2-管理后台",
                normalizedTitle: "2.2 管理后台",
                charIndex: 3809
            }, {
                level: 3,
                title: "2.3 移动端",
                slug: "_2-3-移动端",
                normalizedTitle: "2.3 移动端",
                charIndex: 3937
            }],
            headersStr: "1. 秒杀配置 1.1 表结构 1.2 管理后台 2. 秒杀活动 2.1 表结构 2.2 管理后台 2.3 移动端",
            content: "秒杀功能，主要由 yudao-module-promotion-biz 后端模块的 seckill 实现，包括两部分：秒杀配置（场次）、秒杀活动。如下图所示：\n\n\n\n\n# 1. 秒杀配置\n\n秒杀配置，由卖家在管理后台配置，设置可参与秒杀的时间段（场次），由 SeckillConfigService 类实现。\n\n\n# 1.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `promotion_seckill_config` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '秒杀时段名称',\n  `start_time` varchar(25) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '开始时间点',\n  `end_time` varchar(25) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '结束时间点',\n  `slider_pic_urls` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '秒杀主图',\n  `status` tinyint NOT NULL DEFAULT '0' COMMENT '活动状态',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=38 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT='秒杀时段';\n\n\n\n# 1.2 管理后台\n\n对应 [商城系统 -> 营销中心 -> 秒杀活动 -> 秒杀时段] 菜单，对应 yudao-ui-admin-vue3 项目的 views/mall/promotion/seckill/config 目录。如下图所示：\n\n\n\n\n# 2. 秒杀活动\n\n秒杀活动，由卖家在管理后台配置，提供给买家参与秒杀，由 SeckillActivityService 类实现。\n\n\n# 2.1 表结构\n\n一个秒杀活动，对应一条 promotion_seckill_activity 表记录，对应一个商品 SPU。而每个商品 SKU 在该秒杀下可以单独配置秒杀价格、库存，所以会有多条 promotion_seckill_product 子表记录。\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `promotion_seckill_activity` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '秒杀活动编号',\n  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '秒杀活动名称',\n  `sort` int NOT NULL DEFAULT '0' COMMENT '排序',\n  `remark` varchar(1000) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT '' COMMENT '备注',\n\n  `config_ids` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '0' COMMENT '秒杀时段 id 数组',\n  \n  `spu_id` bigint NOT NULL DEFAULT '0' COMMENT '秒杀活动商品',\n  \n  `status` tinyint NOT NULL DEFAULT '0' COMMENT '活动状态',\n  \n  `total_limit_count` int DEFAULT '0' COMMENT '总限购数量',  \n  `single_limit_count` int DEFAULT '0' COMMENT '单次限够数量',\n  `start_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '活动开始时间',\n  `end_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '活动结束时间',\n  \n  `stock` int DEFAULT '0' COMMENT '秒杀库存',\n  `total_stock` int DEFAULT '0' COMMENT '秒杀总库存',  \n  \n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=42 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT='秒杀活动';\n\n\n① config_ids 字段：秒杀时段 id 数组，由 promotion_seckill_config 表的 id 字段组成的数组。\n\n② spu_id 字段：商品 SPU ID，对应商品 SPU 表的 id 字段。\n\n注意：一个秒杀活动，只能对应一个商品 SPU，不能对应多个商品 SPU！！！\n\n③ status 字段：活动状态，由 CommonStatusEnum 枚举，只有开启、禁用两个状态。禁用时，无法参与秒杀。\n\n④ stock、total_stock 字段：秒杀库存、秒杀总库存。业务上考虑秒杀价格可能较低，一般少量库存参与秒杀。\n\n----------------------------------------\n\nCREATE TABLE `promotion_seckill_product` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '秒杀参与商品编号',\n  \n  `activity_id` bigint NOT NULL DEFAULT '0' COMMENT '秒杀活动 id',\n  `config_ids` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '0' COMMENT '秒杀时段 id 数组',\n  `activity_status` tinyint NOT NULL DEFAULT '0' COMMENT '秒杀商品状态',\n  `activity_start_time` datetime NOT NULL COMMENT '活动开始时间点',\n  `activity_end_time` datetime NOT NULL COMMENT '活动结束时间点',\n  `spu_id` bigint NOT NULL DEFAULT '0' COMMENT '商品 spu_id',\n  \n  `sku_id` bigint NOT NULL DEFAULT '0' COMMENT '商品 sku_id',\n  \n  `seckill_price` int NOT NULL DEFAULT '0' COMMENT '秒杀金额，单位：分',\n  `stock` int NOT NULL DEFAULT '0' COMMENT '秒杀库存',\n  \n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=81 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT='秒杀参与商品';\n\n\n① 【活动信息】activity_id 字段：秒杀活动编号，对应 promotion_seckill_activity 表的 id 字段。其它 activity_* + spu_id 字段，都是冗余字段，方便查询。\n\n② 【SKU 信息】sku_id 字段：商品 SKU 编号，对应商品 SKU 表的 id 字段。seckill_price 字段：秒杀价格，单位分。stock 字段：秒杀库存。\n\n\n# 2.2 管理后台\n\n对应 [商城系统 -> 营销中心 -> 秒杀活动 -> 秒杀商品] 菜单，对应 yudao-ui-admin-vue3 项目的 views/mall/promotion/seckill/activity 目录。如下图所示：\n\n\n\n\n# 2.3 移动端\n\n① 点击 uni-app 首页的 [秒杀] 菜单，进入秒杀列表页，对应 pages/activity/seckill/list.vue 目录。如下图所示：\n\n\n\n② 点击某个秒杀，进入秒杀详情页，对应 pages/goods/seckill.vue 目录。如下图所示：\n\n\n\n③ 点击「立即购买」按钮，选择商品后，进入确认订单页，如下图所示：\n\n\n\n点击「提交订单」按钮后，会创建一条 trade_order 订单记录：\n\n * trade_order 的 type 字段为秒杀类型，seckill_activity_id 字段为秒杀活动编号\n * 秒杀优惠金额的计算，由 TradeSeckillActivityPriceCalculator 类实现\n * 秒杀在订单的自定义处理逻辑，由 TradeSeckillOrderHandler 类实现\n\n后续的逻辑，就是普通订单的流程，就不重复赘述了~",
            normalizedContent: "秒杀功能，主要由 yudao-module-promotion-biz 后端模块的 seckill 实现，包括两部分：秒杀配置（场次）、秒杀活动。如下图所示：\n\n\n\n\n# 1. 秒杀配置\n\n秒杀配置，由卖家在管理后台配置，设置可参与秒杀的时间段（场次），由 seckillconfigservice 类实现。\n\n\n# 1.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `promotion_seckill_config` (\n  `id` bigint not null auto_increment comment '编号',\n  `name` varchar(255) character set utf8mb4 collate utf8mb4_general_ci not null comment '秒杀时段名称',\n  `start_time` varchar(25) character set utf8mb4 collate utf8mb4_general_ci not null comment '开始时间点',\n  `end_time` varchar(25) character set utf8mb4 collate utf8mb4_general_ci not null comment '结束时间点',\n  `slider_pic_urls` varchar(1024) character set utf8mb4 collate utf8mb4_general_ci not null comment '秒杀主图',\n  `status` tinyint not null default '0' comment '活动状态',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=38 default charset=utf8mb4 collate=utf8mb4_general_ci comment='秒杀时段';\n\n\n\n# 1.2 管理后台\n\n对应 [商城系统 -> 营销中心 -> 秒杀活动 -> 秒杀时段] 菜单，对应 yudao-ui-admin-vue3 项目的 views/mall/promotion/seckill/config 目录。如下图所示：\n\n\n\n\n# 2. 秒杀活动\n\n秒杀活动，由卖家在管理后台配置，提供给买家参与秒杀，由 seckillactivityservice 类实现。\n\n\n# 2.1 表结构\n\n一个秒杀活动，对应一条 promotion_seckill_activity 表记录，对应一个商品 spu。而每个商品 sku 在该秒杀下可以单独配置秒杀价格、库存，所以会有多条 promotion_seckill_product 子表记录。\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `promotion_seckill_activity` (\n  `id` bigint not null auto_increment comment '秒杀活动编号',\n  `name` varchar(255) character set utf8mb4 collate utf8mb4_general_ci not null default '' comment '秒杀活动名称',\n  `sort` int not null default '0' comment '排序',\n  `remark` varchar(1000) character set utf8mb4 collate utf8mb4_general_ci default '' comment '备注',\n\n  `config_ids` varchar(255) character set utf8mb4 collate utf8mb4_general_ci not null default '0' comment '秒杀时段 id 数组',\n  \n  `spu_id` bigint not null default '0' comment '秒杀活动商品',\n  \n  `status` tinyint not null default '0' comment '活动状态',\n  \n  `total_limit_count` int default '0' comment '总限购数量',  \n  `single_limit_count` int default '0' comment '单次限够数量',\n  `start_time` datetime not null default current_timestamp comment '活动开始时间',\n  `end_time` datetime not null default current_timestamp comment '活动结束时间',\n  \n  `stock` int default '0' comment '秒杀库存',\n  `total_stock` int default '0' comment '秒杀总库存',  \n  \n  primary key (`id`) using btree\n) engine=innodb auto_increment=42 default charset=utf8mb4 collate=utf8mb4_general_ci comment='秒杀活动';\n\n\n① config_ids 字段：秒杀时段 id 数组，由 promotion_seckill_config 表的 id 字段组成的数组。\n\n② spu_id 字段：商品 spu id，对应商品 spu 表的 id 字段。\n\n注意：一个秒杀活动，只能对应一个商品 spu，不能对应多个商品 spu！！！\n\n③ status 字段：活动状态，由 commonstatusenum 枚举，只有开启、禁用两个状态。禁用时，无法参与秒杀。\n\n④ stock、total_stock 字段：秒杀库存、秒杀总库存。业务上考虑秒杀价格可能较低，一般少量库存参与秒杀。\n\n----------------------------------------\n\ncreate table `promotion_seckill_product` (\n  `id` bigint not null auto_increment comment '秒杀参与商品编号',\n  \n  `activity_id` bigint not null default '0' comment '秒杀活动 id',\n  `config_ids` varchar(100) character set utf8mb4 collate utf8mb4_general_ci not null default '0' comment '秒杀时段 id 数组',\n  `activity_status` tinyint not null default '0' comment '秒杀商品状态',\n  `activity_start_time` datetime not null comment '活动开始时间点',\n  `activity_end_time` datetime not null comment '活动结束时间点',\n  `spu_id` bigint not null default '0' comment '商品 spu_id',\n  \n  `sku_id` bigint not null default '0' comment '商品 sku_id',\n  \n  `seckill_price` int not null default '0' comment '秒杀金额，单位：分',\n  `stock` int not null default '0' comment '秒杀库存',\n  \n  primary key (`id`) using btree\n) engine=innodb auto_increment=81 default charset=utf8mb4 collate=utf8mb4_general_ci comment='秒杀参与商品';\n\n\n① 【活动信息】activity_id 字段：秒杀活动编号，对应 promotion_seckill_activity 表的 id 字段。其它 activity_* + spu_id 字段，都是冗余字段，方便查询。\n\n② 【sku 信息】sku_id 字段：商品 sku 编号，对应商品 sku 表的 id 字段。seckill_price 字段：秒杀价格，单位分。stock 字段：秒杀库存。\n\n\n# 2.2 管理后台\n\n对应 [商城系统 -> 营销中心 -> 秒杀活动 -> 秒杀商品] 菜单，对应 yudao-ui-admin-vue3 项目的 views/mall/promotion/seckill/activity 目录。如下图所示：\n\n\n\n\n# 2.3 移动端\n\n① 点击 uni-app 首页的 [秒杀] 菜单，进入秒杀列表页，对应 pages/activity/seckill/list.vue 目录。如下图所示：\n\n\n\n② 点击某个秒杀，进入秒杀详情页，对应 pages/goods/seckill.vue 目录。如下图所示：\n\n\n\n③ 点击「立即购买」按钮，选择商品后，进入确认订单页，如下图所示：\n\n\n\n点击「提交订单」按钮后，会创建一条 trade_order 订单记录：\n\n * trade_order 的 type 字段为秒杀类型，seckill_activity_id 字段为秒杀活动编号\n * 秒杀优惠金额的计算，由 tradeseckillactivitypricecalculator 类实现\n * 秒杀在订单的自定义处理逻辑，由 tradeseckillorderhandler 类实现\n\n后续的逻辑，就是普通订单的流程，就不重复赘述了~",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【营销】砍价活动",
            frontmatter: {
                title: "【营销】砍价活动",
                date: "2024-01-17T19:41:12.000Z",
                permalink: "/mall/promotion-bargain/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/14.%E5%95%86%E5%9F%8E%E6%89%8B%E5%86%8C/34.%E3%80%90%E8%90%A5%E9%94%80%E3%80%91%E7%A0%8D%E4%BB%B7%E6%B4%BB%E5%8A%A8.html",
            relativePath: "01.开发指南/14.商城手册/34.【营销】砍价活动.md",
            key: "v-6f357586",
            path: "/mall/promotion-bargain/",
            headers: [{
                level: 2,
                title: "1. 砍价活动",
                slug: "_1-砍价活动",
                normalizedTitle: "1. 砍价活动",
                charIndex: 216
            }, {
                level: 3,
                title: "1.1 表结构",
                slug: "_1-1-表结构",
                normalizedTitle: "1.1 表结构",
                charIndex: 285
            }, {
                level: 3,
                title: "1.2 管理后台",
                slug: "_1-2-管理后台",
                normalizedTitle: "1.2 管理后台",
                charIndex: 2199
            }, {
                level: 3,
                title: "1.3 移动端",
                slug: "_1-3-移动端",
                normalizedTitle: "1.3 移动端",
                charIndex: 2331
            }, {
                level: 2,
                title: "2. 砍价记录",
                slug: "_2-砍价记录",
                normalizedTitle: "2. 砍价记录",
                charIndex: 2358
            }, {
                level: 3,
                title: "2.1 表结构",
                slug: "_2-1-表结构",
                normalizedTitle: "2.1 表结构",
                charIndex: 2429
            }, {
                level: 3,
                title: "2.2 管理后台",
                slug: "_2-2-管理后台",
                normalizedTitle: "2.2 管理后台",
                charIndex: 3604
            }, {
                level: 3,
                title: "2.3 移动端",
                slug: "_2-3-移动端",
                normalizedTitle: "2.3 移动端",
                charIndex: 3730
            }, {
                level: 2,
                title: "3. 砍价助力",
                slug: "_3-砍价助力",
                normalizedTitle: "3. 砍价助力",
                charIndex: 3757
            }, {
                level: 3,
                title: "3.1 表结构",
                slug: "_3-1-表结构",
                normalizedTitle: "3.1 表结构",
                charIndex: 3819
            }, {
                level: 3,
                title: "3.2 管理后台",
                slug: "_3-2-管理后台",
                normalizedTitle: "3.2 管理后台",
                charIndex: 4388
            }, {
                level: 3,
                title: "3.3 移动端",
                slug: "_3-3-移动端",
                normalizedTitle: "3.3 移动端",
                charIndex: 4440
            }],
            headersStr: "1. 砍价活动 1.1 表结构 1.2 管理后台 1.3 移动端 2. 砍价记录 2.1 表结构 2.2 管理后台 2.3 移动端 3. 砍价助力 3.1 表结构 3.2 管理后台 3.3 移动端",
            content: "友情提示：\n\nuni-app Vue3 版本，砍价暂未迁移完成，目前只缺：砍价商品详情页。\n\n如果你着急的话，可以参考 uni-app Vue2 版本 迁移过来，相关的后端接口都已经完成。\n\n不过有一点要注意！微信现在基本不允许砍价业务，所以不太建议使用砍价功能。\n\n砍价功能，主要由 yudao-module-promotion-biz 后端模块的 bargain 实现，包括三部分：砍价活动、砍价助力。如下图所示：\n\n\n\n\n# 1. 砍价活动\n\n砍价活动，由卖家在管理后台配置，提供给买家参与砍价，由 BargainActivityService 类实现。\n\n\n# 1.1 表结构\n\n不同于砍价、砍价活动，一个砍价活动，只对应一个商品 SKU。\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `promotion_bargain_activity` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '砍价活动编号',\n  `name` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '砍价活动名称',\n  \n  `spu_id` bigint NOT NULL DEFAULT '0' COMMENT '商品 SPU 编号',\n  `sku_id` bigint NOT NULL COMMENT '商品 SKU 编号',\n  \n  `status` int NOT NULL DEFAULT '0' COMMENT '活动状态',\n  \n  `total_limit_count` int NOT NULL DEFAULT '0' COMMENT '总限购数量',\n  `start_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '活动开始时间',\n  `end_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '活动结束时间',\n\n  `bargain_first_price` int NOT NULL DEFAULT '0' COMMENT '砍价起始价格，单位分',\n  `bargain_min_price` int NOT NULL DEFAULT '0' COMMENT '砍价底价，单位：分',\n  `help_max_count` int NOT NULL DEFAULT '0' COMMENT '砍价人数',\n  `bargain_count` int NOT NULL DEFAULT '0' COMMENT '最大帮砍次数',\n  `random_min_price` int NOT NULL DEFAULT '0' COMMENT '用户每次砍价的最小金额，单位：分',\n  `random_max_price` int NOT NULL DEFAULT '0' COMMENT '用户每次砍价的最大金额，单位：分',\n\n  `stock` int NOT NULL DEFAULT '0' COMMENT '砍价库存',\n  `total_stock` int NOT NULL DEFAULT '0' COMMENT '砍价总库存',\n\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=26 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT='砍价活动';\n\n\n① spu_id、sku_id 字段：对应的商品 SPU 编号、商品 SKU 编号。\n\n注意：一个砍价活动，只能对应一个商品 SKU，不能对应多个商品 SPU 或者 SKU！！！\n\n② status 字段：活动状态，由 CommonStatusEnum 枚举，只有开启、禁用两个状态。禁用时，无法参与砍价。\n\n③ stock、total_stock 字段：砍价库存，自定义参与砍价的数量。\n\n④ bargain_first_price、bargain_min_price 字段：砍价起始价格、砍价最低价格。比如商品原价 100 元，砍价起始价格 80 元，砍价底价 50 元，那么用户发起砍价时的价格为 80 元，最多邀请好友砍价到 50 元。\n\nhelp_max_count 字段：砍价人数，需要多少人，砍价才能成功。如果不砍价成功，则该砍价记录不允许下单支付。\n\nhelp_max_count 字段：单个活动，用户可以帮砍的次数。例如说：帮砍次数为 1 时，A 和 B 同时将该活动链接发给 C，C 只能帮其中一个人砍价。\n\nrandom_min_price、random_max_price 字段：用户每次砍价的最小金额、最大金额。比如用户每次砍价的金额为 1 元到 10 元之间的随机数。\n\n\n# 1.2 管理后台\n\n对应 [商城系统 -> 营销中心 -> 砍价活动 -> 砍价商品] 菜单，对应 yudao-ui-admin-vue3 项目的 views/mall/promotion/combination/activity 目录。如下图所示：\n\n\n\n\n# 1.3 移动端\n\nTODO 界面迁移后，补充\n\n\n# 2. 砍价记录\n\n砍价记录，由买家发起砍价时生成，后续可邀请好友助力（砍价），由 BargainRecordService 类实现。\n\n\n# 2.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `promotion_bargain_record` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '砍价记录编号',\n\n  `activity_id` bigint NOT NULL COMMENT '砍价活动名称',  \n  `spu_id` bigint NOT NULL DEFAULT '0' COMMENT '商品 SPU 编号',\n  `sku_id` bigint NOT NULL COMMENT '商品 SKU 编号',\n  \n  `user_id` bigint NOT NULL COMMENT '用户编号',\n\n  `status` int NOT NULL DEFAULT '0' COMMENT '砍价状态',\n  `bargain_first_price` int NOT NULL DEFAULT '0' COMMENT '砍价起始价格，单位：分',\n  `bargain_price` int NOT NULL DEFAULT '0' COMMENT '当前砍价，单位：分',\n  `end_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '结束时间',\n\n  `order_id` bigint DEFAULT NULL COMMENT '订单编号',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=33 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT='砍价记录表';\n\n\n① 【活动信息】activity_id 字段：砍价活动编号，对应 promotion_bargain_activity 表的 id 字段。其它 spu_id、sku_id 字段，都是冗余字段，方便查询。\n\n② 【用户信息】user_id 字段：用户编号，就是砍价发起的买家。\n\n③ 【砍价信息】status 字段：砍价状态，由 BargainRecordStatusEnum 枚举，分成 3 种情况：砍价中、砍价成功、砍价失败。\n\nbargain_first_price、bargain_price 字段：砍价起始价格、当前砍价。\n\n④ 【订单信息】order_id 字段：订单编号，对应订单表的 id 字段。砍价记录的 status 为砍价成功时，才可以创建并支付订单。\n\n\n# 2.2 管理后台\n\n对应 [商城系统 -> 营销中心 -> 砍价活动 -> 砍价记录] 菜单，对应 yudao-ui-admin-vue3 项目的 views/mall/promotion/bargain/record 目录。如下图所示：\n\n\n\n\n# 2.3 移动端\n\nTODO 界面迁移后，补充\n\n\n# 3. 砍价助力\n\n砍价助力，给好友的砍价记录助力（砍价）时生成，由 BargainHelpService 类实现。\n\n\n# 3.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `promotion_bargain_help` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '砍价助力编号',\n  \n  `user_id` bigint NOT NULL COMMENT '用户编号',\n  \n  `activity_id` bigint NOT NULL COMMENT '砍价活动名称',\n  \n  `record_id` bigint NOT NULL DEFAULT '0' COMMENT '砍价记录编号',\n  \n  `reduce_price` int NOT NULL DEFAULT '0' COMMENT '减少砍价，单位：分',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=37 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT='砍价助力表';\n\n\n比较简单，主要是一些关联的字段，自己瞅瞅就好。\n\n\n# 3.2 管理后台\n\n点击某个砍价记录后面的「助力」按钮，可以查看它的助力列表。如下图所示：\n\n\n\n\n# 3.3 移动端\n\nTODO 界面迁移后，补充",
            normalizedContent: "友情提示：\n\nuni-app vue3 版本，砍价暂未迁移完成，目前只缺：砍价商品详情页。\n\n如果你着急的话，可以参考 uni-app vue2 版本 迁移过来，相关的后端接口都已经完成。\n\n不过有一点要注意！微信现在基本不允许砍价业务，所以不太建议使用砍价功能。\n\n砍价功能，主要由 yudao-module-promotion-biz 后端模块的 bargain 实现，包括三部分：砍价活动、砍价助力。如下图所示：\n\n\n\n\n# 1. 砍价活动\n\n砍价活动，由卖家在管理后台配置，提供给买家参与砍价，由 bargainactivityservice 类实现。\n\n\n# 1.1 表结构\n\n不同于砍价、砍价活动，一个砍价活动，只对应一个商品 sku。\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `promotion_bargain_activity` (\n  `id` bigint not null auto_increment comment '砍价活动编号',\n  `name` varchar(200) character set utf8mb4 collate utf8mb4_general_ci not null default '' comment '砍价活动名称',\n  \n  `spu_id` bigint not null default '0' comment '商品 spu 编号',\n  `sku_id` bigint not null comment '商品 sku 编号',\n  \n  `status` int not null default '0' comment '活动状态',\n  \n  `total_limit_count` int not null default '0' comment '总限购数量',\n  `start_time` datetime not null default current_timestamp comment '活动开始时间',\n  `end_time` datetime not null default current_timestamp comment '活动结束时间',\n\n  `bargain_first_price` int not null default '0' comment '砍价起始价格，单位分',\n  `bargain_min_price` int not null default '0' comment '砍价底价，单位：分',\n  `help_max_count` int not null default '0' comment '砍价人数',\n  `bargain_count` int not null default '0' comment '最大帮砍次数',\n  `random_min_price` int not null default '0' comment '用户每次砍价的最小金额，单位：分',\n  `random_max_price` int not null default '0' comment '用户每次砍价的最大金额，单位：分',\n\n  `stock` int not null default '0' comment '砍价库存',\n  `total_stock` int not null default '0' comment '砍价总库存',\n\n  primary key (`id`) using btree\n) engine=innodb auto_increment=26 default charset=utf8mb4 collate=utf8mb4_general_ci comment='砍价活动';\n\n\n① spu_id、sku_id 字段：对应的商品 spu 编号、商品 sku 编号。\n\n注意：一个砍价活动，只能对应一个商品 sku，不能对应多个商品 spu 或者 sku！！！\n\n② status 字段：活动状态，由 commonstatusenum 枚举，只有开启、禁用两个状态。禁用时，无法参与砍价。\n\n③ stock、total_stock 字段：砍价库存，自定义参与砍价的数量。\n\n④ bargain_first_price、bargain_min_price 字段：砍价起始价格、砍价最低价格。比如商品原价 100 元，砍价起始价格 80 元，砍价底价 50 元，那么用户发起砍价时的价格为 80 元，最多邀请好友砍价到 50 元。\n\nhelp_max_count 字段：砍价人数，需要多少人，砍价才能成功。如果不砍价成功，则该砍价记录不允许下单支付。\n\nhelp_max_count 字段：单个活动，用户可以帮砍的次数。例如说：帮砍次数为 1 时，a 和 b 同时将该活动链接发给 c，c 只能帮其中一个人砍价。\n\nrandom_min_price、random_max_price 字段：用户每次砍价的最小金额、最大金额。比如用户每次砍价的金额为 1 元到 10 元之间的随机数。\n\n\n# 1.2 管理后台\n\n对应 [商城系统 -> 营销中心 -> 砍价活动 -> 砍价商品] 菜单，对应 yudao-ui-admin-vue3 项目的 views/mall/promotion/combination/activity 目录。如下图所示：\n\n\n\n\n# 1.3 移动端\n\ntodo 界面迁移后，补充\n\n\n# 2. 砍价记录\n\n砍价记录，由买家发起砍价时生成，后续可邀请好友助力（砍价），由 bargainrecordservice 类实现。\n\n\n# 2.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `promotion_bargain_record` (\n  `id` bigint not null auto_increment comment '砍价记录编号',\n\n  `activity_id` bigint not null comment '砍价活动名称',  \n  `spu_id` bigint not null default '0' comment '商品 spu 编号',\n  `sku_id` bigint not null comment '商品 sku 编号',\n  \n  `user_id` bigint not null comment '用户编号',\n\n  `status` int not null default '0' comment '砍价状态',\n  `bargain_first_price` int not null default '0' comment '砍价起始价格，单位：分',\n  `bargain_price` int not null default '0' comment '当前砍价，单位：分',\n  `end_time` datetime not null default current_timestamp comment '结束时间',\n\n  `order_id` bigint default null comment '订单编号',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=33 default charset=utf8mb4 collate=utf8mb4_general_ci comment='砍价记录表';\n\n\n① 【活动信息】activity_id 字段：砍价活动编号，对应 promotion_bargain_activity 表的 id 字段。其它 spu_id、sku_id 字段，都是冗余字段，方便查询。\n\n② 【用户信息】user_id 字段：用户编号，就是砍价发起的买家。\n\n③ 【砍价信息】status 字段：砍价状态，由 bargainrecordstatusenum 枚举，分成 3 种情况：砍价中、砍价成功、砍价失败。\n\nbargain_first_price、bargain_price 字段：砍价起始价格、当前砍价。\n\n④ 【订单信息】order_id 字段：订单编号，对应订单表的 id 字段。砍价记录的 status 为砍价成功时，才可以创建并支付订单。\n\n\n# 2.2 管理后台\n\n对应 [商城系统 -> 营销中心 -> 砍价活动 -> 砍价记录] 菜单，对应 yudao-ui-admin-vue3 项目的 views/mall/promotion/bargain/record 目录。如下图所示：\n\n\n\n\n# 2.3 移动端\n\ntodo 界面迁移后，补充\n\n\n# 3. 砍价助力\n\n砍价助力，给好友的砍价记录助力（砍价）时生成，由 bargainhelpservice 类实现。\n\n\n# 3.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `promotion_bargain_help` (\n  `id` bigint not null auto_increment comment '砍价助力编号',\n  \n  `user_id` bigint not null comment '用户编号',\n  \n  `activity_id` bigint not null comment '砍价活动名称',\n  \n  `record_id` bigint not null default '0' comment '砍价记录编号',\n  \n  `reduce_price` int not null default '0' comment '减少砍价，单位：分',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=37 default charset=utf8mb4 collate=utf8mb4_general_ci comment='砍价助力表';\n\n\n比较简单，主要是一些关联的字段，自己瞅瞅就好。\n\n\n# 3.2 管理后台\n\n点击某个砍价记录后面的「助力」按钮，可以查看它的助力列表。如下图所示：\n\n\n\n\n# 3.3 移动端\n\ntodo 界面迁移后，补充",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【营销】内容管理",
            frontmatter: {
                title: "【营销】内容管理",
                date: "2024-01-17T22:25:34.000Z",
                permalink: "/mall/promotion-content/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/14.%E5%95%86%E5%9F%8E%E6%89%8B%E5%86%8C/37.%E3%80%90%E8%90%A5%E9%94%80%E3%80%91%E5%86%85%E5%AE%B9%E7%AE%A1%E7%90%86.html",
            relativePath: "01.开发指南/14.商城手册/37.【营销】内容管理.md",
            key: "v-7b64b9ed",
            path: "/mall/promotion-content/",
            headers: [{
                level: 2,
                title: "1. 文章管理",
                slug: "_1-文章管理",
                normalizedTitle: "1. 文章管理",
                charIndex: 46
            }, {
                level: 3,
                title: "1.1 表结构",
                slug: "_1-1-表结构",
                normalizedTitle: "1.1 表结构",
                charIndex: 125
            }, {
                level: 3,
                title: "1.2 管理后台",
                slug: "_1-2-管理后台",
                normalizedTitle: "1.2 管理后台",
                charIndex: 2052
            }, {
                level: 3,
                title: "1.3 移动端",
                slug: "_1-3-移动端",
                normalizedTitle: "1.3 移动端",
                charIndex: 2375
            }, {
                level: 2,
                title: "2. 轮播位",
                slug: "_2-轮播位",
                normalizedTitle: "2. 轮播位",
                charIndex: 2600
            }, {
                level: 3,
                title: "2.1 表结构",
                slug: "_2-1-表结构",
                normalizedTitle: "2.1 表结构",
                charIndex: 2670
            }, {
                level: 3,
                title: "2.2 管理后台",
                slug: "_2-2-管理后台",
                normalizedTitle: "2.2 管理后台",
                charIndex: 3590
            }, {
                level: 3,
                title: "2.3 移动端",
                slug: "_2-3-移动端",
                normalizedTitle: "2.3 移动端",
                charIndex: 3714
            }],
            headersStr: "1. 文章管理 1.1 表结构 1.2 管理后台 1.3 移动端 2. 轮播位 2.1 表结构 2.2 管理后台 2.3 移动端",
            content: "本小节，我们来讲 [商城系统 -> 营销中心 -> 内容管理] 菜单下的相关内容。\n\n\n# 1. 文章管理\n\n文章管理，主要由 yudao-module-promotion-biz 后端模块的 article 实现，包括文章分类、文章内容。\n\n\n# 1.1 表结构\n\n# 1.1.1 文章分类\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `promotion_article_category` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '文章分类编号',\n  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '分类名称',\n  `pic_url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT '' COMMENT '图标地址',\n  `status` tinyint NOT NULL DEFAULT '1' COMMENT '状态',\n  `sort` int NOT NULL DEFAULT '99999' COMMENT '排序',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='文章分类表';\n\n\n# 1.1.2 文章内容\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `promotion_article` (\n  `id` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT '文章管理编号',\n  `category_id` bigint NOT NULL COMMENT '分类编号',\n  `title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '文章标题',\n  `author` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT '' COMMENT '文章作者',\n  `content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '文章内容',\n  `pic_url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '文章封面图片地址',\n  `introduction` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT '' COMMENT '文章简介',\n  `sort` int unsigned NOT NULL DEFAULT '0' COMMENT '排序',\n  `status` tinyint unsigned NOT NULL DEFAULT '0' COMMENT '状态',\n  `recommend_hot` bit(1) NOT NULL DEFAULT b'0' COMMENT '是否热门(小程序)',\n  `recommend_banner` bit(1) NOT NULL DEFAULT b'0' COMMENT '是否轮播图(小程序)',\n  `browse_count` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT '' COMMENT '浏览次数',\n  \n  `spu_id` bigint NOT NULL DEFAULT '0' COMMENT '关联商品编号',\n\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='文章管理表';\n\n\n\n# 1.2 管理后台\n\n# 1.2.1 文章分类\n\n对应 [商城系统 -> 营销中心 -> 内容管理 -> 文章分类] 菜单，对应 yudao-ui-admin-vue3 项目的 src/views/mall/promotion/article/category 目录。如下图所示：\n\n\n\n# 1.2.2 文章内容\n\n① 对应 [商城系统 -> 营销中心 -> 内容管理 -> 文章列表] 菜单，对应 yudao-ui-admin-vue3 项目的 src/views/mall/promotion/article 目录。如下图所示：\n\n\n\n② 在 [店铺装修] 里，有“营销文章”组件，可以关联一个文章内容，展示在首页上。如下图所示：\n\n\n\n\n# 1.3 移动端\n\n# 1.3.1 文章分类\n\n暂未使用到，可以忽略\n\n# 1.3.2 文章内容\n\n① 文章内容，使用 yudao-mall-uniapp 项目的 pages/public/richtext.vue 页面。如下图所示：\n\n\n\n② 目前 [常见问题]、[关于我们]、[隐私协议]、[用户协议] 等，直接使用的文章内容。\n\n考虑到暂时不想做的太复杂，直接用 title 字段来区分！！！如上图 URL 中的 title=常见问题。\n\n\n# 2. 轮播位\n\n轮播位，主要由 yudao-module-promotion-biz 后端模块的 banner 实现，包括轮播位。\n\n\n# 2.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `promotion_banner` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT 'Banner 编号',\n  `title` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT 'Banner 标题',\n  `pic_url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '图片 URL',\n  `url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '跳转地址',\n  `status` tinyint NOT NULL DEFAULT '-1' COMMENT '活动状态',\n  `sort` int DEFAULT NULL COMMENT '排序',\n  `position` tinyint NOT NULL COMMENT '位置',\n  `memo` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '描述',\n  `browse_count` int DEFAULT NULL COMMENT 'Banner 点击次数',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='Banner 广告位';\n\n\n\n# 2.2 管理后台\n\n对应 [商城系统 -> 营销中心 -> 内容管理 -> Banner] 菜单，对应 yudao-ui-admin-vue3 项目的 src/views/mall/promotion/banner 目录。如下图所示：\n\n\n\n\n# 2.3 移动端\n\n目前 uni-app 暂时未使用到，可以忽略。。。",
            normalizedContent: "本小节，我们来讲 [商城系统 -> 营销中心 -> 内容管理] 菜单下的相关内容。\n\n\n# 1. 文章管理\n\n文章管理，主要由 yudao-module-promotion-biz 后端模块的 article 实现，包括文章分类、文章内容。\n\n\n# 1.1 表结构\n\n# 1.1.1 文章分类\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `promotion_article_category` (\n  `id` bigint not null auto_increment comment '文章分类编号',\n  `name` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '分类名称',\n  `pic_url` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci default '' comment '图标地址',\n  `status` tinyint not null default '1' comment '状态',\n  `sort` int not null default '99999' comment '排序',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=4 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='文章分类表';\n\n\n# 1.1.2 文章内容\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `promotion_article` (\n  `id` bigint unsigned not null auto_increment comment '文章管理编号',\n  `category_id` bigint not null comment '分类编号',\n  `title` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '文章标题',\n  `author` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci default '' comment '文章作者',\n  `content` text character set utf8mb4 collate utf8mb4_unicode_ci not null comment '文章内容',\n  `pic_url` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '文章封面图片地址',\n  `introduction` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci default '' comment '文章简介',\n  `sort` int unsigned not null default '0' comment '排序',\n  `status` tinyint unsigned not null default '0' comment '状态',\n  `recommend_hot` bit(1) not null default b'0' comment '是否热门(小程序)',\n  `recommend_banner` bit(1) not null default b'0' comment '是否轮播图(小程序)',\n  `browse_count` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci default '' comment '浏览次数',\n  \n  `spu_id` bigint not null default '0' comment '关联商品编号',\n\n  primary key (`id`) using btree\n) engine=innodb auto_increment=6 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='文章管理表';\n\n\n\n# 1.2 管理后台\n\n# 1.2.1 文章分类\n\n对应 [商城系统 -> 营销中心 -> 内容管理 -> 文章分类] 菜单，对应 yudao-ui-admin-vue3 项目的 src/views/mall/promotion/article/category 目录。如下图所示：\n\n\n\n# 1.2.2 文章内容\n\n① 对应 [商城系统 -> 营销中心 -> 内容管理 -> 文章列表] 菜单，对应 yudao-ui-admin-vue3 项目的 src/views/mall/promotion/article 目录。如下图所示：\n\n\n\n② 在 [店铺装修] 里，有“营销文章”组件，可以关联一个文章内容，展示在首页上。如下图所示：\n\n\n\n\n# 1.3 移动端\n\n# 1.3.1 文章分类\n\n暂未使用到，可以忽略\n\n# 1.3.2 文章内容\n\n① 文章内容，使用 yudao-mall-uniapp 项目的 pages/public/richtext.vue 页面。如下图所示：\n\n\n\n② 目前 [常见问题]、[关于我们]、[隐私协议]、[用户协议] 等，直接使用的文章内容。\n\n考虑到暂时不想做的太复杂，直接用 title 字段来区分！！！如上图 url 中的 title=常见问题。\n\n\n# 2. 轮播位\n\n轮播位，主要由 yudao-module-promotion-biz 后端模块的 banner 实现，包括轮播位。\n\n\n# 2.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `promotion_banner` (\n  `id` bigint not null auto_increment comment 'banner 编号',\n  `title` varchar(64) character set utf8mb4 collate utf8mb4_unicode_ci not null default '' comment 'banner 标题',\n  `pic_url` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '图片 url',\n  `url` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '跳转地址',\n  `status` tinyint not null default '-1' comment '活动状态',\n  `sort` int default null comment '排序',\n  `position` tinyint not null comment '位置',\n  `memo` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '描述',\n  `browse_count` int default null comment 'banner 点击次数',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=5 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='banner 广告位';\n\n\n\n# 2.2 管理后台\n\n对应 [商城系统 -> 营销中心 -> 内容管理 -> banner] 菜单，对应 yudao-ui-admin-vue3 项目的 src/views/mall/promotion/banner 目录。如下图所示：\n\n\n\n\n# 2.3 移动端\n\n目前 uni-app 暂时未使用到，可以忽略。。。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【统计】会员、商品、交易统计",
            frontmatter: {
                title: "【统计】会员、商品、交易统计",
                date: "2024-01-17T23:43:59.000Z",
                permalink: "/mall/statistics/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/14.%E5%95%86%E5%9F%8E%E6%89%8B%E5%86%8C/40.%E3%80%90%E7%BB%9F%E8%AE%A1%E3%80%91%E4%BC%9A%E5%91%98%E3%80%81%E5%95%86%E5%93%81%E3%80%81%E4%BA%A4%E6%98%93%E7%BB%9F%E8%AE%A1.html",
            relativePath: "01.开发指南/14.商城手册/40.【统计】会员、商品、交易统计.md",
            key: "v-31a9a83c",
            path: "/mall/statistics/",
            headers: [{
                level: 2,
                title: "1. 会员统计",
                slug: "_1-会员统计",
                normalizedTitle: "1. 会员统计",
                charIndex: 372
            }, {
                level: 3,
                title: "1.1 表结构",
                slug: "_1-1-表结构",
                normalizedTitle: "1.1 表结构",
                charIndex: 422
            }, {
                level: 3,
                title: "1.2 管理后台",
                slug: "_1-2-管理后台",
                normalizedTitle: "1.2 管理后台",
                charIndex: 458
            }, {
                level: 2,
                title: "2. 商品统计",
                slug: "_2-商品统计",
                normalizedTitle: "2. 商品统计",
                charIndex: 573
            }, {
                level: 3,
                title: "2.1 表结构",
                slug: "_2-1-表结构",
                normalizedTitle: "2.1 表结构",
                charIndex: 624
            }, {
                level: 3,
                title: "2.2 管理后台",
                slug: "_2-2-管理后台",
                normalizedTitle: "2.2 管理后台",
                charIndex: 2173
            }, {
                level: 2,
                title: "3. 交易统计",
                slug: "_3-交易统计",
                normalizedTitle: "3. 交易统计",
                charIndex: 2370
            }, {
                level: 3,
                title: "3.1 表结构",
                slug: "_3-1-表结构",
                normalizedTitle: "3.1 表结构",
                charIndex: 2419
            }, {
                level: 3,
                title: "3.2 管理后台",
                slug: "_3-2-管理后台",
                normalizedTitle: "3.2 管理后台",
                charIndex: 4128
            }],
            headersStr: "1. 会员统计 1.1 表结构 1.2 管理后台 2. 商品统计 2.1 表结构 2.2 管理后台 3. 交易统计 3.1 表结构 3.2 管理后台",
            content: "本小节，我们来讲 [商城系统 -> 统计中心] 菜单下的会员、商品、交易统计相关内容，它们是由 yudao-module-statistics-biz 后端模块实现。\n\n友情提示：为什么所有数据库操作都使用 StatisticsMapper 结尾呢？\n\n一方面，和现有业务使用的 Mapper 独立开，避免业务 Mapper 混乱，统计 SQL 往往较为复杂（个性化）。\n\n另一方面，随着数据规模的增大，统计 SQL 不适合放在 MySQL 关系数据库中执行，往往会引入 ClickHouse、Doris 作为数据仓库，这个时候只要把 StatisticsMapper 改造下即可。\n\n另外，考虑统计 SQL 往往非常消耗 MySQL 资源，可以把 StatisticsMapper 切到单独的 MySQL 读库上，避免影响线上业务。\n\n\n# 1. 会员统计\n\n由 MemberStatisticsController 提供统计接口。\n\n\n# 1.1 表结构\n\n暂时没有统计表，都是通过 SQL 查询实现。\n\n\n# 1.2 管理后台\n\n对应 [商城系统 -> 统计中心 -> 会员统计] 菜单，对应 yudao-ui-admin-vue3 项目的 src/views/mall/statistics/member 目录。如下图所示：\n\n\n\n\n# 2. 商品统计\n\n由 ProductStatisticsController 提供统计接口。\n\n\n# 2.1 表结构\n\n统计每个商品 SPU 的浏览量、访客量、收藏数量、加购数量、下单件数、支付件数、支付金额、退款件数、退款金额、访客支付转化率等，通过 ProductStatisticsJob 每天定时统计。\n\nCREATE TABLE `product_statistics` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号，主键自增',\n  `time` date NOT NULL COMMENT '统计日期',\n  `spu_id` bigint NOT NULL COMMENT '商品 SPU 编号',\n  \n  `browse_count` int NOT NULL DEFAULT '0' COMMENT '浏览量',\n  `browse_user_count` int NOT NULL DEFAULT '0' COMMENT '访客量',\n  `favorite_count` int NOT NULL DEFAULT '0' COMMENT '收藏数量',\n  `cart_count` int NOT NULL DEFAULT '0' COMMENT '加购数量',\n  \n  `order_count` int NOT NULL DEFAULT '0' COMMENT '下单件数',\n  `order_pay_count` int NOT NULL DEFAULT '0' COMMENT '支付件数',\n  `order_pay_price` int NOT NULL DEFAULT '0' COMMENT '支付金额，单位：分',\n  \n  `after_sale_count` int NOT NULL DEFAULT '0' COMMENT '退款件数',\n  `after_sale_refund_price` int NOT NULL DEFAULT '0' COMMENT '退款金额，单位：分',\n  \n  `browse_convert_percent` int NOT NULL DEFAULT '0' COMMENT '访客支付转化率（百分比）',\n  \n  `creator` varchar(64) COLLATE utf8mb4_unicode_ci DEFAULT '' COMMENT '创建者',\n  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\n  `updater` varchar(64) COLLATE utf8mb4_unicode_ci DEFAULT '' COMMENT '更新者',\n  `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',\n  `deleted` bit(1) NOT NULL DEFAULT b'0' COMMENT '是否删除',\n  `tenant_id` bigint NOT NULL DEFAULT '0' COMMENT '租户编号',\n  PRIMARY KEY (`id`),\n  KEY `idx_time` (`time`),\n  KEY `idx_spu_id` (`spu_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='商品统计表';\n\n\n\n# 2.2 管理后台\n\n对应 [商城系统 -> 统计中心 -> 商品统计] 菜单，对应 yudao-ui-admin-vue3 项目的 src/views/mall/statistics/product 目录。如下图所示：\n\n\n\n友情提示：\n\nProductStatisticsJob 需要参考 《定时任务》 文档，配置每天 00:00:00 执行。否则上面的界面上，可能没有统计的数据。\n\n\n# 3. 交易统计\n\n由 TradeStatisticsController 提供统计接口。\n\n\n# 3.1 表结构\n\n统计每天的订单创建数、支付数、支付金额、退款数、退款金额、佣金金额、余额支付金额、充值数、充值金额、充值退款数、充值退款金额等，通过 TradeStatisticsJob 每天定时统计。\n\nCREATE TABLE `trade_statistics` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号，主键自增',\n  `time` datetime NOT NULL COMMENT '统计日期',\n  \n  `order_create_count` int NOT NULL DEFAULT '0' COMMENT '创建订单数',\n  `order_pay_count` int NOT NULL DEFAULT '0' COMMENT '支付订单商品数',\n  `order_pay_price` int NOT NULL DEFAULT '0' COMMENT '总支付金额，单位：分',\n  \n  `after_sale_count` int NOT NULL DEFAULT '0' COMMENT '退款订单数',\n  `after_sale_refund_price` int NOT NULL DEFAULT '0' COMMENT '总退款金额，单位：分',\n  \n  `brokerage_settlement_price` int NOT NULL DEFAULT '0' COMMENT '佣金金额（已结算），单位：分',\n  \n  `wallet_pay_price` int NOT NULL DEFAULT '0' COMMENT '总支付金额（余额），单位：分',\n  `recharge_pay_count` int NOT NULL DEFAULT '0' COMMENT '充值订单数',\n  `recharge_pay_price` int NOT NULL DEFAULT '0' COMMENT '充值金额，单位：分',\n  `recharge_refund_count` int NOT NULL DEFAULT '0' COMMENT '充值退款订单数',\n  `recharge_refund_price` int NOT NULL DEFAULT '0' COMMENT '充值退款金额，单位：分',\n\n  `creator` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT '' COMMENT '创建者',\n  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\n  `updater` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT '' COMMENT '更新者',\n  `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',\n  `deleted` bit(1) NOT NULL DEFAULT b'0' COMMENT '是否删除',\n  `tenant_id` bigint NOT NULL DEFAULT '0' COMMENT '租户编号',\n  PRIMARY KEY (`id`) USING BTREE,\n  KEY `trade_statistics_time_index` (`time`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=153 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='交易统计表';\n\n\n\n# 3.2 管理后台\n\n对应 [商城系统 -> 统计中心 -> 交易统计] 菜单，对应 yudao-ui-admin-vue3 项目的 src/views/mall/statistics/trade 目录。如下图所示：\n\n\n\n友情提示：\n\nTradeStatisticsJob 需要参考 《定时任务》 文档，配置每天 00:00:00 执行。否则上面的界面上，可能没有统计的数据。",
            normalizedContent: "本小节，我们来讲 [商城系统 -> 统计中心] 菜单下的会员、商品、交易统计相关内容，它们是由 yudao-module-statistics-biz 后端模块实现。\n\n友情提示：为什么所有数据库操作都使用 statisticsmapper 结尾呢？\n\n一方面，和现有业务使用的 mapper 独立开，避免业务 mapper 混乱，统计 sql 往往较为复杂（个性化）。\n\n另一方面，随着数据规模的增大，统计 sql 不适合放在 mysql 关系数据库中执行，往往会引入 clickhouse、doris 作为数据仓库，这个时候只要把 statisticsmapper 改造下即可。\n\n另外，考虑统计 sql 往往非常消耗 mysql 资源，可以把 statisticsmapper 切到单独的 mysql 读库上，避免影响线上业务。\n\n\n# 1. 会员统计\n\n由 memberstatisticscontroller 提供统计接口。\n\n\n# 1.1 表结构\n\n暂时没有统计表，都是通过 sql 查询实现。\n\n\n# 1.2 管理后台\n\n对应 [商城系统 -> 统计中心 -> 会员统计] 菜单，对应 yudao-ui-admin-vue3 项目的 src/views/mall/statistics/member 目录。如下图所示：\n\n\n\n\n# 2. 商品统计\n\n由 productstatisticscontroller 提供统计接口。\n\n\n# 2.1 表结构\n\n统计每个商品 spu 的浏览量、访客量、收藏数量、加购数量、下单件数、支付件数、支付金额、退款件数、退款金额、访客支付转化率等，通过 productstatisticsjob 每天定时统计。\n\ncreate table `product_statistics` (\n  `id` bigint not null auto_increment comment '编号，主键自增',\n  `time` date not null comment '统计日期',\n  `spu_id` bigint not null comment '商品 spu 编号',\n  \n  `browse_count` int not null default '0' comment '浏览量',\n  `browse_user_count` int not null default '0' comment '访客量',\n  `favorite_count` int not null default '0' comment '收藏数量',\n  `cart_count` int not null default '0' comment '加购数量',\n  \n  `order_count` int not null default '0' comment '下单件数',\n  `order_pay_count` int not null default '0' comment '支付件数',\n  `order_pay_price` int not null default '0' comment '支付金额，单位：分',\n  \n  `after_sale_count` int not null default '0' comment '退款件数',\n  `after_sale_refund_price` int not null default '0' comment '退款金额，单位：分',\n  \n  `browse_convert_percent` int not null default '0' comment '访客支付转化率（百分比）',\n  \n  `creator` varchar(64) collate utf8mb4_unicode_ci default '' comment '创建者',\n  `create_time` datetime not null default current_timestamp comment '创建时间',\n  `updater` varchar(64) collate utf8mb4_unicode_ci default '' comment '更新者',\n  `update_time` datetime not null default current_timestamp on update current_timestamp comment '更新时间',\n  `deleted` bit(1) not null default b'0' comment '是否删除',\n  `tenant_id` bigint not null default '0' comment '租户编号',\n  primary key (`id`),\n  key `idx_time` (`time`),\n  key `idx_spu_id` (`spu_id`)\n) engine=innodb default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='商品统计表';\n\n\n\n# 2.2 管理后台\n\n对应 [商城系统 -> 统计中心 -> 商品统计] 菜单，对应 yudao-ui-admin-vue3 项目的 src/views/mall/statistics/product 目录。如下图所示：\n\n\n\n友情提示：\n\nproductstatisticsjob 需要参考 《定时任务》 文档，配置每天 00:00:00 执行。否则上面的界面上，可能没有统计的数据。\n\n\n# 3. 交易统计\n\n由 tradestatisticscontroller 提供统计接口。\n\n\n# 3.1 表结构\n\n统计每天的订单创建数、支付数、支付金额、退款数、退款金额、佣金金额、余额支付金额、充值数、充值金额、充值退款数、充值退款金额等，通过 tradestatisticsjob 每天定时统计。\n\ncreate table `trade_statistics` (\n  `id` bigint not null auto_increment comment '编号，主键自增',\n  `time` datetime not null comment '统计日期',\n  \n  `order_create_count` int not null default '0' comment '创建订单数',\n  `order_pay_count` int not null default '0' comment '支付订单商品数',\n  `order_pay_price` int not null default '0' comment '总支付金额，单位：分',\n  \n  `after_sale_count` int not null default '0' comment '退款订单数',\n  `after_sale_refund_price` int not null default '0' comment '总退款金额，单位：分',\n  \n  `brokerage_settlement_price` int not null default '0' comment '佣金金额（已结算），单位：分',\n  \n  `wallet_pay_price` int not null default '0' comment '总支付金额（余额），单位：分',\n  `recharge_pay_count` int not null default '0' comment '充值订单数',\n  `recharge_pay_price` int not null default '0' comment '充值金额，单位：分',\n  `recharge_refund_count` int not null default '0' comment '充值退款订单数',\n  `recharge_refund_price` int not null default '0' comment '充值退款金额，单位：分',\n\n  `creator` varchar(64) character set utf8mb4 collate utf8mb4_unicode_ci default '' comment '创建者',\n  `create_time` datetime not null default current_timestamp comment '创建时间',\n  `updater` varchar(64) character set utf8mb4 collate utf8mb4_unicode_ci default '' comment '更新者',\n  `update_time` datetime not null default current_timestamp on update current_timestamp comment '更新时间',\n  `deleted` bit(1) not null default b'0' comment '是否删除',\n  `tenant_id` bigint not null default '0' comment '租户编号',\n  primary key (`id`) using btree,\n  key `trade_statistics_time_index` (`time`) using btree\n) engine=innodb auto_increment=153 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='交易统计表';\n\n\n\n# 3.2 管理后台\n\n对应 [商城系统 -> 统计中心 -> 交易统计] 菜单，对应 yudao-ui-admin-vue3 项目的 src/views/mall/statistics/trade 目录。如下图所示：\n\n\n\n友情提示：\n\ntradestatisticsjob 需要参考 《定时任务》 文档，配置每天 00:00:00 执行。否则上面的界面上，可能没有统计的数据。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "ERP 演示",
            frontmatter: {
                title: "ERP 演示",
                date: "2024-02-16T08:25:56.000Z",
                permalink: "/erp-preview"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/15.ERP%E6%89%8B%E5%86%8C/01.ERP%20%E6%BC%94%E7%A4%BA.html",
            relativePath: "01.开发指南/15.ERP手册/01.ERP 演示.md",
            key: "v-c7b93916",
            path: "/erp-preview/",
            headers: [{
                level: 2,
                title: "1. 演示地址",
                slug: "_1-演示地址",
                normalizedTitle: "1. 演示地址",
                charIndex: 2
            }, {
                level: 3,
                title: "1.1 ERP 管理后台",
                slug: "_1-1-erp-管理后台",
                normalizedTitle: "1.1 erp 管理后台",
                charIndex: 14
            }, {
                level: 3,
                title: "1.2 ERP 后端",
                slug: "_1-2-erp-后端",
                normalizedTitle: "1.2 erp 后端",
                charIndex: 219
            }, {
                level: 2,
                title: "2. ERP 启动",
                slug: "_2-erp-启动",
                normalizedTitle: "2. erp 启动",
                charIndex: 414
            }, {
                level: 2,
                title: "3. ERP 交流",
                slug: "_3-erp-交流",
                normalizedTitle: "3. erp 交流",
                charIndex: 468
            }, {
                level: 2,
                title: "4. 功能描述",
                slug: "_4-功能描述",
                normalizedTitle: "4. 功能描述",
                charIndex: 500
            }, {
                level: 2,
                title: "5. 表结构",
                slug: "_5-表结构",
                normalizedTitle: "5. 表结构",
                charIndex: 544
            }, {
                level: 3,
                title: "5.1 采购管理",
                slug: "_5-1-采购管理",
                normalizedTitle: "5.1 采购管理",
                charIndex: 611
            }, {
                level: 3,
                title: "5.2 销售管理",
                slug: "_5-2-销售管理",
                normalizedTitle: "5.2 销售管理",
                charIndex: 678
            }, {
                level: 3,
                title: "5.3 库存管理",
                slug: "_5-3-库存管理",
                normalizedTitle: "5.3 库存管理",
                charIndex: 741
            }, {
                level: 3,
                title: "5.4 产品管理",
                slug: "_5-4-产品管理",
                normalizedTitle: "5.4 产品管理",
                charIndex: 842
            }, {
                level: 3,
                title: "5.5 财务管理",
                slug: "_5-5-财务管理",
                normalizedTitle: "5.5 财务管理",
                charIndex: 908
            }],
            headersStr: "1. 演示地址 1.1 ERP 管理后台 1.2 ERP 后端 2. ERP 启动 3. ERP 交流 4. 功能描述 5. 表结构 5.1 采购管理 5.2 销售管理 5.3 库存管理 5.4 产品管理 5.5 财务管理",
            content: "# 1. 演示地址\n\n\n# 1.1 ERP 管理后台\n\n * 演示地址：http://dashboard-vue3.yudao.iocoder.cn/\n * 菜单：“ERP 系统”下的「采购管理」「销售管理」「库存管理」「产品管理」「财务管理」\n * 仓库：https://github.com/yudaocode/yudao-ui-admin-vue3 的 erp 目录，基于 Vue3 + Element Plus 实现\n\n\n\n\n# 1.2 ERP 后端\n\n支持 Spring Boot 单体、Spring Cloud 微服务架构\n\n * 单体仓库： https://github.com/YunaiV/ruoyi-vue-pro 的 yudao-module-erp 模块\n * 微服务仓库： https://github.com/YunaiV/yudao-cloud 的 yudao-module-erp 服务\n\n\n# 2. ERP 启动\n\n参见 《ERP 手册 —— 功能开启》 文档，一般 3 分钟就可以启动完成。\n\n\n# 3. ERP 交流\n\n专属交流社区，欢迎扫码加入。\n\n\n\n\n# 4. 功能描述\n\n主要分为 5 个核心模块：采购、销售、库存、产品、财务。\n\n\n\n\n# 5. 表结构\n\nERP 一共有 30+ 张表，具备一定的业务复杂度，对提升技术能力会有不错的帮助，平时做项目也可以参考参考。\n\n\n# 5.1 采购管理\n\n以 erp_purchase_ 作为前缀的表，表结构如下：\n\n\n\n * 《【采购】采购订单、入库、退货》\n\n\n# 5.2 销售管理\n\n以 erp_sale_ 作为前缀的表，表结构如下：\n\n\n\n * 《【销售】销售订单、出库、退货》\n\n\n# 5.3 库存管理\n\n以 erp_stock_ 作为前缀的表，表结构如下：\n\n\n\n * 《【库存】产品库存、库存明细》\n * 《【库存】其它入库、其它出库》\n * 《【库存】库存调拨、库存盘点》\n\n\n# 5.4 产品管理\n\n以 erp_product_ 作为前缀的表，表结构如下：\n\n\n\n * 《【产品】产品信息、分类、单位》\n\n\n# 5.5 财务管理\n\n以 erp_finance_ 作为前缀的表，表结构如下：\n\n\n\n * 《【财务】采购付款、销售收款》",
            normalizedContent: "# 1. 演示地址\n\n\n# 1.1 erp 管理后台\n\n * 演示地址：http://dashboard-vue3.yudao.iocoder.cn/\n * 菜单：“erp 系统”下的「采购管理」「销售管理」「库存管理」「产品管理」「财务管理」\n * 仓库：https://github.com/yudaocode/yudao-ui-admin-vue3 的 erp 目录，基于 vue3 + element plus 实现\n\n\n\n\n# 1.2 erp 后端\n\n支持 spring boot 单体、spring cloud 微服务架构\n\n * 单体仓库： https://github.com/yunaiv/ruoyi-vue-pro 的 yudao-module-erp 模块\n * 微服务仓库： https://github.com/yunaiv/yudao-cloud 的 yudao-module-erp 服务\n\n\n# 2. erp 启动\n\n参见 《erp 手册 —— 功能开启》 文档，一般 3 分钟就可以启动完成。\n\n\n# 3. erp 交流\n\n专属交流社区，欢迎扫码加入。\n\n\n\n\n# 4. 功能描述\n\n主要分为 5 个核心模块：采购、销售、库存、产品、财务。\n\n\n\n\n# 5. 表结构\n\nerp 一共有 30+ 张表，具备一定的业务复杂度，对提升技术能力会有不错的帮助，平时做项目也可以参考参考。\n\n\n# 5.1 采购管理\n\n以 erp_purchase_ 作为前缀的表，表结构如下：\n\n\n\n * 《【采购】采购订单、入库、退货》\n\n\n# 5.2 销售管理\n\n以 erp_sale_ 作为前缀的表，表结构如下：\n\n\n\n * 《【销售】销售订单、出库、退货》\n\n\n# 5.3 库存管理\n\n以 erp_stock_ 作为前缀的表，表结构如下：\n\n\n\n * 《【库存】产品库存、库存明细》\n * 《【库存】其它入库、其它出库》\n * 《【库存】库存调拨、库存盘点》\n\n\n# 5.4 产品管理\n\n以 erp_product_ 作为前缀的表，表结构如下：\n\n\n\n * 《【产品】产品信息、分类、单位》\n\n\n# 5.5 财务管理\n\n以 erp_finance_ 作为前缀的表，表结构如下：\n\n\n\n * 《【财务】采购付款、销售收款》",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【产品】产品信息、分类、单位",
            frontmatter: {
                title: "【产品】产品信息、分类、单位",
                date: "2024-02-16T11:00:20.000Z",
                permalink: "/erp/product/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/15.ERP%E6%89%8B%E5%86%8C/10.%E3%80%90%E4%BA%A7%E5%93%81%E3%80%91%E4%BA%A7%E5%93%81%E4%BF%A1%E6%81%AF%E3%80%81%E5%88%86%E7%B1%BB%E3%80%81%E5%8D%95%E4%BD%8D.html",
            relativePath: "01.开发指南/15.ERP手册/10.【产品】产品信息、分类、单位.md",
            key: "v-3b32bf6e",
            path: "/erp/product/",
            headers: [{
                level: 2,
                title: "1. 产品分类",
                slug: "_1-产品分类",
                normalizedTitle: "1. 产品分类",
                charIndex: 125
            }, {
                level: 3,
                title: "1.1 表结构",
                slug: "_1-1-表结构",
                normalizedTitle: "1.1 表结构",
                charIndex: 180
            }, {
                level: 3,
                title: "1.2 管理后台",
                slug: "_1-2-管理后台",
                normalizedTitle: "1.2 管理后台",
                charIndex: 855
            }, {
                level: 2,
                title: "2. 产品单位",
                slug: "_2-产品单位",
                normalizedTitle: "2. 产品单位",
                charIndex: 962
            }, {
                level: 3,
                title: "2.1 表结构",
                slug: "_2-1-表结构",
                normalizedTitle: "2.1 表结构",
                charIndex: 1013
            }, {
                level: 3,
                title: "2.2 管理后台",
                slug: "_2-2-管理后台",
                normalizedTitle: "2.2 管理后台",
                charIndex: 1428
            }, {
                level: 2,
                title: "3. 产品（物料）",
                slug: "_3-产品-物料",
                normalizedTitle: "3. 产品（物料）",
                charIndex: 1531
            }, {
                level: 3,
                title: "3.1 表结构",
                slug: "_3-1-表结构",
                normalizedTitle: "3.1 表结构",
                charIndex: 1588
            }, {
                level: 3,
                title: "3.2 管理后台",
                slug: "_3-2-管理后台",
                normalizedTitle: "3.2 管理后台",
                charIndex: 2998
            }],
            headersStr: "1. 产品分类 1.1 表结构 1.2 管理后台 2. 产品单位 2.1 表结构 2.2 管理后台 3. 产品（物料） 3.1 表结构 3.2 管理后台",
            content: "友情提示：\n\n不同 ERP 系统，产品可能也会叫做物料、商品等，我们项目统一都叫产品。\n\n产品模块，由 yudao-module-erp-biz 后端模块的 product 包实现，主要有产品信息、产品分类、产品单位等功能。如下图所示：\n\n\n\n\n# 1. 产品分类\n\n产品分类，由 ErpProductCategoryController 提供接口。\n\n\n# 1.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `erp_product_category` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '分类编号',\n  `parent_id` bigint NOT NULL COMMENT '父分类编号',\n  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '分类名称',\n  `code` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '分类编码',\n  `sort` int DEFAULT '0' COMMENT '分类排序',\n  `status` tinyint NOT NULL COMMENT '开启状态',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=87 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='ERP 产品分类';\n\n\n分类目前支持无限层级，其中 parent_id 为 0 的是一级分类。\n\n\n# 1.2 管理后台\n\n对应 [ERP 系统 -> 产品管理 -> 产品分类] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/erp/product/category 目录。\n\n\n\n\n# 2. 产品单位\n\n产品单位，由 ErpProductUnitController 提供接口。\n\n\n# 2.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `erp_product_unit` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '单位编号',\n  `name` varchar(50) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '单位名字',\n  `status` tinyint NOT NULL COMMENT '单位状态',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='ERP 产品单位表';\n\n\n\n# 2.2 管理后台\n\n对应 [ERP 系统 -> 产品管理 -> 产品单位] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/erp/product/unit 目录。\n\n\n\n\n# 3. 产品（物料）\n\n产品信息，由 ErpProductCategoryController 提供接口。\n\n\n# 3.1 表结构\n\nCREATE TABLE `erp_product` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '产品编号',\n  `name` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '产品名称',\n  `bar_code` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '产品条码',\n  `category_id` bigint NOT NULL COMMENT '产品分类编号',\n  `unit_id` int NOT NULL COMMENT '单位编号',\n  `status` tinyint NOT NULL COMMENT '产品状态',\n  `standard` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '产品规格',\n  `remark` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '产品备注',\n  `expiry_day` int DEFAULT NULL COMMENT '保质期天数',\n  `weight` decimal(24,6) DEFAULT NULL COMMENT '基础重量（kg）',\n  `purchase_price` decimal(24,6) DEFAULT NULL COMMENT '采购价格，单位：元',\n  `sale_price` decimal(24,6) DEFAULT NULL COMMENT '销售价格，单位：元',\n  `min_price` decimal(24,6) DEFAULT NULL COMMENT '最低价格，单位：元',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='ERP 产品表';\n\n\n① bar_code 为产品条码，可用于 MALL 商城系统 的商品 SKU 的打通。\n\n② category_id 为产品分类编号，关联 erp_product_category 表的 id 字段。\n\n③ unit_id 为单位编号，关联 erp_product_unit 表的 id 字段。\n\n④ status 为产品状态，0 开启、1 禁用。\n\n⑤ purchase_price 为采购价格，单位：元，默认只有 2 位小数。目前它可用于采购订单的价格计算，稍后可以看到。\n\nsale_price 为销售价格，单位：元，默认只有 2 位小数。目前它可用于销售订单的价格计算，稍后可以看到。\n\n⑥ standard、expiry_day、weight 只是一些信息字段，仅仅用于展示，没有什么特殊逻辑。\n\n\n# 3.2 管理后台\n\n对应 [ERP 系统 -> 产品管理 -> 产品信息] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/erp/product/product 目录。\n\n",
            normalizedContent: "友情提示：\n\n不同 erp 系统，产品可能也会叫做物料、商品等，我们项目统一都叫产品。\n\n产品模块，由 yudao-module-erp-biz 后端模块的 product 包实现，主要有产品信息、产品分类、产品单位等功能。如下图所示：\n\n\n\n\n# 1. 产品分类\n\n产品分类，由 erpproductcategorycontroller 提供接口。\n\n\n# 1.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `erp_product_category` (\n  `id` bigint not null auto_increment comment '分类编号',\n  `parent_id` bigint not null comment '父分类编号',\n  `name` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '分类名称',\n  `code` varchar(100) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '分类编码',\n  `sort` int default '0' comment '分类排序',\n  `status` tinyint not null comment '开启状态',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=87 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='erp 产品分类';\n\n\n分类目前支持无限层级，其中 parent_id 为 0 的是一级分类。\n\n\n# 1.2 管理后台\n\n对应 [erp 系统 -> 产品管理 -> 产品分类] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/erp/product/category 目录。\n\n\n\n\n# 2. 产品单位\n\n产品单位，由 erpproductunitcontroller 提供接口。\n\n\n# 2.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `erp_product_unit` (\n  `id` bigint not null auto_increment comment '单位编号',\n  `name` varchar(50) collate utf8mb4_unicode_ci not null comment '单位名字',\n  `status` tinyint not null comment '单位状态',\n  primary key (`id`)\n) engine=innodb auto_increment=3 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='erp 产品单位表';\n\n\n\n# 2.2 管理后台\n\n对应 [erp 系统 -> 产品管理 -> 产品单位] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/erp/product/unit 目录。\n\n\n\n\n# 3. 产品（物料）\n\n产品信息，由 erpproductcategorycontroller 提供接口。\n\n\n# 3.1 表结构\n\ncreate table `erp_product` (\n  `id` bigint not null auto_increment comment '产品编号',\n  `name` varchar(100) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '产品名称',\n  `bar_code` varchar(50) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '产品条码',\n  `category_id` bigint not null comment '产品分类编号',\n  `unit_id` int not null comment '单位编号',\n  `status` tinyint not null comment '产品状态',\n  `standard` varchar(100) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '产品规格',\n  `remark` varchar(500) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '产品备注',\n  `expiry_day` int default null comment '保质期天数',\n  `weight` decimal(24,6) default null comment '基础重量（kg）',\n  `purchase_price` decimal(24,6) default null comment '采购价格，单位：元',\n  `sale_price` decimal(24,6) default null comment '销售价格，单位：元',\n  `min_price` decimal(24,6) default null comment '最低价格，单位：元',\n  primary key (`id`)\n) engine=innodb auto_increment=3 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='erp 产品表';\n\n\n① bar_code 为产品条码，可用于 mall 商城系统 的商品 sku 的打通。\n\n② category_id 为产品分类编号，关联 erp_product_category 表的 id 字段。\n\n③ unit_id 为单位编号，关联 erp_product_unit 表的 id 字段。\n\n④ status 为产品状态，0 开启、1 禁用。\n\n⑤ purchase_price 为采购价格，单位：元，默认只有 2 位小数。目前它可用于采购订单的价格计算，稍后可以看到。\n\nsale_price 为销售价格，单位：元，默认只有 2 位小数。目前它可用于销售订单的价格计算，稍后可以看到。\n\n⑥ standard、expiry_day、weight 只是一些信息字段，仅仅用于展示，没有什么特殊逻辑。\n\n\n# 3.2 管理后台\n\n对应 [erp 系统 -> 产品管理 -> 产品信息] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/erp/product/product 目录。\n\n",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【营销】限时折扣",
            frontmatter: {
                title: "【营销】限时折扣",
                date: "2024-01-17T21:40:11.000Z",
                permalink: "/mall/promotion-discount/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/14.%E5%95%86%E5%9F%8E%E6%89%8B%E5%86%8C/36.%E3%80%90%E8%90%A5%E9%94%80%E3%80%91%E9%99%90%E6%97%B6%E6%8A%98%E6%89%A3.html",
            relativePath: "01.开发指南/14.商城手册/36.【营销】限时折扣.md",
            key: "v-35ca4e46",
            path: "/mall/promotion-discount/",
            headers: [{
                level: 2,
                title: "1. 表结构",
                slug: "_1-表结构",
                normalizedTitle: "1. 表结构",
                charIndex: 80
            }, {
                level: 2,
                title: "2. 管理后台",
                slug: "_2-管理后台",
                normalizedTitle: "2. 管理后台",
                charIndex: 2024
            }, {
                level: 2,
                title: "3. 移动端",
                slug: "_3-移动端",
                normalizedTitle: "3. 移动端",
                charIndex: 2155
            }, {
                level: 3,
                title: "3.1 商品详情",
                slug: "_3-1-商品详情",
                normalizedTitle: "3.1 商品详情",
                charIndex: 2166
            }, {
                level: 3,
                title: "3.2 价格计算",
                slug: "_3-2-价格计算",
                normalizedTitle: "3.2 价格计算",
                charIndex: 2444
            }],
            headersStr: "1. 表结构 2. 管理后台 3. 移动端 3.1 商品详情 3.2 价格计算",
            content: "限时折扣，指的是在指定时间段内，对指定商品进行折扣。主要由 yudao-module-promotion-biz 后端模块的 discount 实现。\n\n\n# 1. 表结构\n\n一个限时折扣活动，可以有多个商品参与，所以它有一个 promotion_discount_activity 活动主表，和 promotion_discount_activity_product 活动商品子表。如下图所示：\n\n\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `promotion_discount_activity` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '活动编号',\n  `name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '活动标题',\n  \n  `status` tinyint NOT NULL DEFAULT '-1' COMMENT '活动状态',\n  \n  `start_time` datetime NOT NULL COMMENT '开始时间',\n  `end_time` datetime NOT NULL COMMENT '结束时间',\n  `remark` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT '' COMMENT '备注',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT='限时折扣活动';\n\n\n① status 字段：活动状态，由 CommonStatusEnum 枚举，只有开启、禁用两个状态。禁用时，无法参与限时折扣活动。\n\n----------------------------------------\n\nCREATE TABLE `promotion_discount_product` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号，主键自增',\n  \n  `activity_id` bigint NOT NULL COMMENT '活动编号',\n  `activity_status` tinyint NOT NULL DEFAULT '0' COMMENT '秒杀商品状态',\n  `activity_start_time` datetime NOT NULL COMMENT '活动开始时间点',\n  `activity_end_time` datetime NOT NULL COMMENT '活动结束时间点',\n  \n  `spu_id` bigint NOT NULL DEFAULT '-1' COMMENT '商品 SPU 编号',\n  `sku_id` bigint NOT NULL COMMENT '商品 SKU 编号',\n  \n  `discount_type` int NOT NULL COMMENT '优惠类型；1-代金劵；2-折扣劵',\n  `discount_percent` tinyint DEFAULT NULL COMMENT '折扣百分比',\n  `discount_price` int DEFAULT NULL COMMENT '优惠金额，单位：分',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=22 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT='限时折扣商品\\n';\n\n\n① activity_id 字段：活动编号，对应 promotion_discount_activity 表的 id 字段。而 activity_ 开头字段，是为了方便查询，冗余存储的。\n\n② spu_id、sku_id 字段：对应的商品 SPU 编号、商品 SKU 编号。\n\n③ discount_type 字段：优惠类型，由 DiscountTypeEnum 枚举，分成 2 种情况：\n\n * 满减：配合 discount_price 字段，表示优惠多少金额\n * 折扣：配合 discount_percent 字段，表示折扣百分比\n\n\n# 2. 管理后台\n\n对应 [商城系统 -> 营销中心 -> 优惠活动 -> 限时折扣] 菜单，对应 yudao-ui-admin-vue3 项目的 src/views/mall/promotion/discountActivity 目录。如下图所示：\n\n\n\n\n# 3. 移动端\n\n\n# 3.1 商品详情\n\n① 在 uni-app 商品列表页，会展示该商品参与的限时折扣的优惠信息。如下图所示：\n\n\n\n具体的前端逻辑，可见 yudao-mall-uniapp 的 sheep/components/s-goods-column/s-goods-column.vue 文件，搜 discountText 关键字。\n\n友情提示：\n\n限时折扣、和 会员折扣 ，两者都是折扣，是相互冲突的。所以，两者都存在的情况下，谁的折扣力度大，就以谁的为准。\n\n② 在 uni-app 商品详情页，也会展示该商品参与的限时折扣的优惠信息。如下图所示：\n\n\n\n\n# 3.2 价格计算\n\n下单时，限时折扣的价格计算，后端由 TradeDiscountActivityPriceCalculator 类实现。效果如下图所示：\n\n\n\n弹窗由 yudao-mall-uniapp 的 /sheep/components/s-discount-list/s-discount-list.vue 组件实现。",
            normalizedContent: "限时折扣，指的是在指定时间段内，对指定商品进行折扣。主要由 yudao-module-promotion-biz 后端模块的 discount 实现。\n\n\n# 1. 表结构\n\n一个限时折扣活动，可以有多个商品参与，所以它有一个 promotion_discount_activity 活动主表，和 promotion_discount_activity_product 活动商品子表。如下图所示：\n\n\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `promotion_discount_activity` (\n  `id` bigint not null auto_increment comment '活动编号',\n  `name` varchar(50) character set utf8mb4 collate utf8mb4_general_ci not null default '' comment '活动标题',\n  \n  `status` tinyint not null default '-1' comment '活动状态',\n  \n  `start_time` datetime not null comment '开始时间',\n  `end_time` datetime not null comment '结束时间',\n  `remark` varchar(255) character set utf8mb4 collate utf8mb4_general_ci default '' comment '备注',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=13 default charset=utf8mb4 collate=utf8mb4_general_ci comment='限时折扣活动';\n\n\n① status 字段：活动状态，由 commonstatusenum 枚举，只有开启、禁用两个状态。禁用时，无法参与限时折扣活动。\n\n----------------------------------------\n\ncreate table `promotion_discount_product` (\n  `id` bigint not null auto_increment comment '编号，主键自增',\n  \n  `activity_id` bigint not null comment '活动编号',\n  `activity_status` tinyint not null default '0' comment '秒杀商品状态',\n  `activity_start_time` datetime not null comment '活动开始时间点',\n  `activity_end_time` datetime not null comment '活动结束时间点',\n  \n  `spu_id` bigint not null default '-1' comment '商品 spu 编号',\n  `sku_id` bigint not null comment '商品 sku 编号',\n  \n  `discount_type` int not null comment '优惠类型；1-代金劵；2-折扣劵',\n  `discount_percent` tinyint default null comment '折扣百分比',\n  `discount_price` int default null comment '优惠金额，单位：分',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=22 default charset=utf8mb4 collate=utf8mb4_general_ci comment='限时折扣商品\\n';\n\n\n① activity_id 字段：活动编号，对应 promotion_discount_activity 表的 id 字段。而 activity_ 开头字段，是为了方便查询，冗余存储的。\n\n② spu_id、sku_id 字段：对应的商品 spu 编号、商品 sku 编号。\n\n③ discount_type 字段：优惠类型，由 discounttypeenum 枚举，分成 2 种情况：\n\n * 满减：配合 discount_price 字段，表示优惠多少金额\n * 折扣：配合 discount_percent 字段，表示折扣百分比\n\n\n# 2. 管理后台\n\n对应 [商城系统 -> 营销中心 -> 优惠活动 -> 限时折扣] 菜单，对应 yudao-ui-admin-vue3 项目的 src/views/mall/promotion/discountactivity 目录。如下图所示：\n\n\n\n\n# 3. 移动端\n\n\n# 3.1 商品详情\n\n① 在 uni-app 商品列表页，会展示该商品参与的限时折扣的优惠信息。如下图所示：\n\n\n\n具体的前端逻辑，可见 yudao-mall-uniapp 的 sheep/components/s-goods-column/s-goods-column.vue 文件，搜 discounttext 关键字。\n\n友情提示：\n\n限时折扣、和 会员折扣 ，两者都是折扣，是相互冲突的。所以，两者都存在的情况下，谁的折扣力度大，就以谁的为准。\n\n② 在 uni-app 商品详情页，也会展示该商品参与的限时折扣的优惠信息。如下图所示：\n\n\n\n\n# 3.2 价格计算\n\n下单时，限时折扣的价格计算，后端由 tradediscountactivitypricecalculator 类实现。效果如下图所示：\n\n\n\n弹窗由 yudao-mall-uniapp 的 /sheep/components/s-discount-list/s-discount-list.vue 组件实现。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【营销】满减送活动",
            frontmatter: {
                title: "【营销】满减送活动",
                date: "2024-01-17T20:52:15.000Z",
                permalink: "/mall/promotion-record/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/14.%E5%95%86%E5%9F%8E%E6%89%8B%E5%86%8C/35.%E3%80%90%E8%90%A5%E9%94%80%E3%80%91%E6%BB%A1%E5%87%8F%E9%80%81%E6%B4%BB%E5%8A%A8.html",
            relativePath: "01.开发指南/14.商城手册/35.【营销】满减送活动.md",
            key: "v-3dd7997c",
            path: "/mall/promotion-record/",
            headers: [{
                level: 2,
                title: "1. 表结构",
                slug: "_1-表结构",
                normalizedTitle: "1. 表结构",
                charIndex: 79
            }, {
                level: 2,
                title: "2. 管理后台",
                slug: "_2-管理后台",
                normalizedTitle: "2. 管理后台",
                charIndex: 1478
            }, {
                level: 2,
                title: "3. 移动端",
                slug: "_3-移动端",
                normalizedTitle: "3. 移动端",
                charIndex: 1606
            }, {
                level: 3,
                title: "3.1 商品详情",
                slug: "_3-1-商品详情",
                normalizedTitle: "3.1 商品详情",
                charIndex: 1617
            }, {
                level: 3,
                title: "3.2 活动详情",
                slug: "_3-2-活动详情",
                normalizedTitle: "3.2 活动详情",
                charIndex: 1944
            }, {
                level: 3,
                title: "3.3 价格计算",
                slug: "_3-3-价格计算",
                normalizedTitle: "3.3 价格计算",
                charIndex: 2072
            }],
            headersStr: "1. 表结构 2. 管理后台 3. 移动端 3.1 商品详情 3.2 活动详情 3.3 价格计算",
            content: "满减送活动，主要由 yudao-module-promotion-biz 后端模块的 reward 实现，支持减金额、减运费、送积分、送优惠券等等。\n\n\n# 1. 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `promotion_reward_activity` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '活动编号',\n  `name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '活动标题',\n  `start_time` datetime NOT NULL COMMENT '开始时间',\n  `end_time` datetime NOT NULL COMMENT '结束时间',\n  `remark` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT '' COMMENT '备注',\n  \n  `status` tinyint NOT NULL DEFAULT '-1' COMMENT '活动状态',\n  \n  `product_scope` tinyint NOT NULL COMMENT '商品范围',\n  `product_scope_values` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '商品范围编号的数组',\n  \n  `condition_type` tinyint NOT NULL DEFAULT '-1' COMMENT '条件类型',\n  `rules` varchar(2000) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '优惠规则的数组',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT='满减送活动';\n\n\n① status 字段：活动状态，由 CommonStatusEnum 枚举，只有开启、禁用两个状态。禁用时，无法参与满减送活动。\n\n② product_scope 字段：商品范围，商品范围，由 PromotionProductScopeEnum 枚举，分成 3 种情况：\n\n * 1、通用券：全部商品\n * 2、商品券：指定商品，由 product_scope_values 字段指定商品编号的数组\n * 3、品类券：指定品类，由 product_scope_values 字段指定品类编号的数组\n\n③ condition_type 字段：条件类型，由 PromotionConditionTypeEnum 枚举，分成 2 种情况：满 N 元、满 N 件。\n\nrules 字段：优惠规则的数组，支持多层级，可配置优惠金额、包邮、赠送积分、优惠劵。\n\n\n# 2. 管理后台\n\n对应 [商城系统 -> 营销中心 -> 优惠活动 -> 满减送] 菜单，对应 yudao-ui-admin-vue3 项目的 src/views/mall/promotion/rewardActivity 目录。如下图所示：\n\n\n\n\n# 3. 移动端\n\n\n# 3.1 商品详情\n\n① 在 uni-app 商品列表页，会展示该商品参与的满减送活动的 1 条优惠信息。如下图所示：\n\n\n\n具体的前端逻辑，可见 yudao-mall-uniapp 的 sheep/components/s-goods-column/s-goods-column.vue 文件，搜 rewardActivity 关键字。\n\n② 在 uni-app 商品详情页，会展示该商品参与的满减送活动的至多 3 条优惠信息。点击后，会弹出满减送的所有优惠明细，如下图所示：\n\n\n\n弹窗由 yudao-mall-uniapp 的 sheep/components/s-activity-pop/s-activity-pop.vue 组件实现。\n\n\n# 3.2 活动详情\n\n继续点击上图的满减送活动，会进入活动详情页，并展示参与该活动的商品列表，对应 yudao-mall-uniapp 的 yudao-mall-uniapp/pages/activity/index.vue 文件。如下图所示：\n\n\n\n\n# 3.3 价格计算\n\n下单时，满减送的价格计算，后端由 TradeRewardActivityPriceCalculator 类实现。效果如下图所示：\n\n\n\n弹窗由 yudao-mall-uniapp 的 /sheep/components/s-discount-list/s-discount-list.vue 组件实现。",
            normalizedContent: "满减送活动，主要由 yudao-module-promotion-biz 后端模块的 reward 实现，支持减金额、减运费、送积分、送优惠券等等。\n\n\n# 1. 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `promotion_reward_activity` (\n  `id` bigint not null auto_increment comment '活动编号',\n  `name` varchar(50) character set utf8mb4 collate utf8mb4_general_ci not null default '' comment '活动标题',\n  `start_time` datetime not null comment '开始时间',\n  `end_time` datetime not null comment '结束时间',\n  `remark` varchar(255) character set utf8mb4 collate utf8mb4_general_ci default '' comment '备注',\n  \n  `status` tinyint not null default '-1' comment '活动状态',\n  \n  `product_scope` tinyint not null comment '商品范围',\n  `product_scope_values` varchar(1024) character set utf8mb4 collate utf8mb4_general_ci default null comment '商品范围编号的数组',\n  \n  `condition_type` tinyint not null default '-1' comment '条件类型',\n  `rules` varchar(2000) character set utf8mb4 collate utf8mb4_general_ci default null comment '优惠规则的数组',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=5 default charset=utf8mb4 collate=utf8mb4_general_ci comment='满减送活动';\n\n\n① status 字段：活动状态，由 commonstatusenum 枚举，只有开启、禁用两个状态。禁用时，无法参与满减送活动。\n\n② product_scope 字段：商品范围，商品范围，由 promotionproductscopeenum 枚举，分成 3 种情况：\n\n * 1、通用券：全部商品\n * 2、商品券：指定商品，由 product_scope_values 字段指定商品编号的数组\n * 3、品类券：指定品类，由 product_scope_values 字段指定品类编号的数组\n\n③ condition_type 字段：条件类型，由 promotionconditiontypeenum 枚举，分成 2 种情况：满 n 元、满 n 件。\n\nrules 字段：优惠规则的数组，支持多层级，可配置优惠金额、包邮、赠送积分、优惠劵。\n\n\n# 2. 管理后台\n\n对应 [商城系统 -> 营销中心 -> 优惠活动 -> 满减送] 菜单，对应 yudao-ui-admin-vue3 项目的 src/views/mall/promotion/rewardactivity 目录。如下图所示：\n\n\n\n\n# 3. 移动端\n\n\n# 3.1 商品详情\n\n① 在 uni-app 商品列表页，会展示该商品参与的满减送活动的 1 条优惠信息。如下图所示：\n\n\n\n具体的前端逻辑，可见 yudao-mall-uniapp 的 sheep/components/s-goods-column/s-goods-column.vue 文件，搜 rewardactivity 关键字。\n\n② 在 uni-app 商品详情页，会展示该商品参与的满减送活动的至多 3 条优惠信息。点击后，会弹出满减送的所有优惠明细，如下图所示：\n\n\n\n弹窗由 yudao-mall-uniapp 的 sheep/components/s-activity-pop/s-activity-pop.vue 组件实现。\n\n\n# 3.2 活动详情\n\n继续点击上图的满减送活动，会进入活动详情页，并展示参与该活动的商品列表，对应 yudao-mall-uniapp 的 yudao-mall-uniapp/pages/activity/index.vue 文件。如下图所示：\n\n\n\n\n# 3.3 价格计算\n\n下单时，满减送的价格计算，后端由 traderewardactivitypricecalculator 类实现。效果如下图所示：\n\n\n\n弹窗由 yudao-mall-uniapp 的 /sheep/components/s-discount-list/s-discount-list.vue 组件实现。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "功能开启",
            frontmatter: {
                title: "功能开启",
                date: "2024-02-16T10:10:38.000Z",
                permalink: "/erp/build"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/15.ERP%E6%89%8B%E5%86%8C/02.%E5%8A%9F%E8%83%BD%E5%BC%80%E5%90%AF.html",
            relativePath: "01.开发指南/15.ERP手册/02.功能开启.md",
            key: "v-2a7a8dba",
            path: "/erp/build/",
            headers: [{
                level: 2,
                title: "1. 第一步，开启模块",
                slug: "_1-第一步-开启模块",
                normalizedTitle: "1. 第一步，开启模块",
                charIndex: 390
            }, {
                level: 2,
                title: "2. 第二步，导入 SQL",
                slug: "_2-第二步-导入-sql",
                normalizedTitle: "2. 第二步，导入 sql",
                charIndex: 592
            }, {
                level: 2,
                title: "3. 第三步，重启项目",
                slug: "_3-第三步-重启项目",
                normalizedTitle: "3. 第三步，重启项目",
                charIndex: 733
            }],
            headersStr: "1. 第一步，开启模块 2. 第二步，导入 SQL 3. 第三步，重启项目",
            content: "进度说明：\n\n * 管理后台，请使用 https://gitee.com/yudaocode/yudao-ui-admin-vue3 仓库的 master 分支\n * 后端项目，请使用 https://gitee.com/zhijiantianya/ruoyi-vue-pro 仓库的 master（JDK8） 或 master-jdk17（JDK17//21） 分支\n\nERP 系统，后端由 yudao-module-erp 模块实现，前端由 yudao-ui-admin-vue3 的 erp 目录实现。\n\n考虑到编译速度，默认 yudao-module-erp 模块是关闭的，需要手动开启。步骤如下：\n\n * 第一步，开启 yudao-module-erp 模块\n * 第二步，导入 ERP 系统的 SQL 数据库脚本\n * 第三步，重启后端项目，确认功能是否生效\n\n\n# 1. 第一步，开启模块\n\n① 修改根目录的 pom.xml 文件，取消 yudao-module-erp 模块的注释。如下图所示：\n\n\n\n② 修改 yudao-server 目录的 pom.xml 文件，引入 yudao-module-erp 模块。如下图所示：\n\n\n\n③ 点击 IDEA 右上角的【Reload All Maven Projects】，刷新 Maven 依赖。如下图所示：\n\n\n\n\n# 2. 第二步，导入 SQL\n\n点击 erp-2024-02-16.sql.zip 下载附件，解压出 SQL 文件，然后导入到数据库中。 如下图所示：\n\n友情提示：↑↑↑ erp.sql 是可以点击下载的！ ↑↑↑\n\n\n\n以 erp_ 作为前缀的表，就是 ERP 模块的表。\n\n\n# 3. 第三步，重启项目\n\n重启后端项目，然后访问前端的 ERP 菜单，确认功能是否生效。如下图所示：\n\n\n\n至此，我们就成功开启了 ERP 的功能 🙂",
            normalizedContent: "进度说明：\n\n * 管理后台，请使用 https://gitee.com/yudaocode/yudao-ui-admin-vue3 仓库的 master 分支\n * 后端项目，请使用 https://gitee.com/zhijiantianya/ruoyi-vue-pro 仓库的 master（jdk8） 或 master-jdk17（jdk17//21） 分支\n\nerp 系统，后端由 yudao-module-erp 模块实现，前端由 yudao-ui-admin-vue3 的 erp 目录实现。\n\n考虑到编译速度，默认 yudao-module-erp 模块是关闭的，需要手动开启。步骤如下：\n\n * 第一步，开启 yudao-module-erp 模块\n * 第二步，导入 erp 系统的 sql 数据库脚本\n * 第三步，重启后端项目，确认功能是否生效\n\n\n# 1. 第一步，开启模块\n\n① 修改根目录的 pom.xml 文件，取消 yudao-module-erp 模块的注释。如下图所示：\n\n\n\n② 修改 yudao-server 目录的 pom.xml 文件，引入 yudao-module-erp 模块。如下图所示：\n\n\n\n③ 点击 idea 右上角的【reload all maven projects】，刷新 maven 依赖。如下图所示：\n\n\n\n\n# 2. 第二步，导入 sql\n\n点击 erp-2024-02-16.sql.zip 下载附件，解压出 sql 文件，然后导入到数据库中。 如下图所示：\n\n友情提示：↑↑↑ erp.sql 是可以点击下载的！ ↑↑↑\n\n\n\n以 erp_ 作为前缀的表，就是 erp 模块的表。\n\n\n# 3. 第三步，重启项目\n\n重启后端项目，然后访问前端的 erp 菜单，确认功能是否生效。如下图所示：\n\n\n\n至此，我们就成功开启了 erp 的功能 🙂",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【库存】其它入库、其它出库",
            frontmatter: {
                title: "【库存】其它入库、其它出库",
                date: "2024-02-16T16:12:39.000Z",
                permalink: "/erp/stock-in-out"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/15.ERP%E6%89%8B%E5%86%8C/21.%E3%80%90%E5%BA%93%E5%AD%98%E3%80%91%E5%85%B6%E5%AE%83%E5%85%A5%E5%BA%93%E3%80%81%E5%85%B6%E5%AE%83%E5%87%BA%E5%BA%93.html",
            relativePath: "01.开发指南/15.ERP手册/21.【库存】其它入库、其它出库.md",
            key: "v-72c968c8",
            path: "/erp/stock-in-out/",
            headers: [{
                level: 2,
                title: "1. 其它入库",
                slug: "_1-其它入库",
                normalizedTitle: "1. 其它入库",
                charIndex: 61
            }, {
                level: 3,
                title: "1. 表结构",
                slug: "_1-表结构",
                normalizedTitle: "1. 表结构",
                charIndex: 185
            }, {
                level: 3,
                title: "1.2 管理后台",
                slug: "_1-2-管理后台",
                normalizedTitle: "1.2 管理后台",
                charIndex: 2241
            }, {
                level: 2,
                title: "2. 其它出库",
                slug: "_2-其它出库",
                normalizedTitle: "2. 其它出库",
                charIndex: 2515
            }, {
                level: 3,
                title: "2. 表结构",
                slug: "_2-表结构",
                normalizedTitle: "2. 表结构",
                charIndex: 2640
            }, {
                level: 3,
                title: "2.2 管理后台",
                slug: "_2-2-管理后台",
                normalizedTitle: "2.2 管理后台",
                charIndex: 4727
            }],
            headersStr: "1. 其它入库 1. 表结构 1.2 管理后台 2. 其它出库 2. 表结构 2.2 管理后台",
            content: "本文接 《【库存】仓库、产品库存、库存明细》，主要讲解库存管理的其它入库、其它出库。它们的表关系如下图所示：\n\n\n\n\n# 1. 其它入库\n\n其它入库，由 ErpStockInController 提供接口，一些 ERP 系统也会称为“仓库入库”，将产品从仓库放进去，增加 产品的库存。\n\n为什么要叫“其它”入库呢？是指除了采购入库、生产入库之外的其它入库操作。\n\n\n# 1. 表结构\n\nerp_stock_in 表和 erp_stock_in_item 表，分别对应入库单和入库项。\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `erp_stock_in` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '入库编号',\n  `no` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '入库单号',\n  \n  `supplier_id` bigint DEFAULT NULL COMMENT '供应商编号',\n  `in_time` datetime NOT NULL COMMENT '入库时间',\n  \n  `total_count` decimal(24,6) NOT NULL COMMENT '合计数量',\n  `total_price` decimal(24,6) NOT NULL COMMENT '合计金额，单位：元',\n  \n  `status` tinyint NOT NULL COMMENT '状态',\n  \n  `remark` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '备注',\n  `file_url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '附件 URL',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='ERP 其它入库单表';\n\n\n① no：入库单号，一般是系统自动生成的，目前格式是 {prefix}{yyyyMMdd}{6 位自增}。具体可见 ErpNoRedisDAO 类，如下图所示：\n\n\n\n② supplier_id：供应商编号。\n\n③ total_count 和 total_price：合计数量和金额，目前只是记录，并无特殊逻辑。\n\n④ status：状态，统一使用 ErpAuditStatus 枚举类，只有“未审批”、“已审批”两个状态，后续会接入到 BPM 工作流 中。\n\n\n\n----------------------------------------\n\nCREATE TABLE `erp_stock_in_item` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '入库项编号',\n  \n  `in_id` bigint NOT NULL COMMENT '入库编号',\n  \n  `warehouse_id` bigint NOT NULL COMMENT '仓库编号',\n  `product_id` bigint NOT NULL COMMENT '产品编号',\n  \n  `product_unit_id` bigint NOT NULL COMMENT '产品单位编号',\n  `product_price` decimal(24,6) DEFAULT NULL COMMENT '产品单价',\n  `count` decimal(24,6) NOT NULL COMMENT '产品数量',\n  `total_price` decimal(24,6) DEFAULT NULL COMMENT '合计金额，单位：元',\n  \n  `remark` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '备注',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='ERP 其它入库单项表';\n\n\n① in_id：入库编号，关联到上面的 erp_stock_in 表。\n\n② warehouse_id 和 product_id：分别关联到仓库和产品。\n\n③ product_unit_id、product_price、count 和 total_price：产品单位编号、产品单价、数量和金额。\n\n其中 total_price 等于 product_price * count。\n\n\n# 1.2 管理后台\n\n对应 [ERP 系统 -> 库存管理 -> 其它入库] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/erp/stock/in 目录。\n\n\n\n① 点击「新增」按钮，随便填写一些信息，点击「确认」按钮，即可新增一条其它入库单。\n\n\n\n② 点击该入库单的「审批」按钮，审批通过该入库单，此时状态会变成“已审批”，同时增加对应的库存、新增库存明细。如下图所示：\n\n\n\n③ 点击该入库单的「反审批」按钮，反审批该入库单，此时状态会变成“未审批”，同时减少对应的库存、新增库存明细。如下图所示：\n\n\n\n\n# 2. 其它出库\n\n其它出库，由 ErpStockOutController 提供接口，一些 ERP 系统也会称为“仓库出库”，将产品从仓库拿出来，减少 产品的库存。\n\n为什么要叫“其它”出库呢？是指除了销售出库、生产出库之外的其它出库操作。\n\n\n# 2. 表结构\n\n友情提示：其它出库相关的表，和其它入库相关的表结构基本一致。\n\nerp_stock_out 表和 erp_stock_out_item 表，分别对应出库单和出库项。\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `erp_stock_out` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '出库编号',\n  `no` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '出库单号',\n  \n  `customer_id` bigint DEFAULT NULL COMMENT '客户编号',\n  `out_time` datetime NOT NULL COMMENT '出库时间',\n  \n  `total_count` decimal(24,6) NOT NULL COMMENT '合计数量',\n  `total_price` decimal(24,6) NOT NULL COMMENT '合计金额，单位：元',\n  \n  `status` tinyint NOT NULL COMMENT '状态',\n  \n  `remark` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '备注',\n  `file_url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '附件 URL',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='ERP 其它入库单表';\n\n\n① no：出库单号，一般是系统自动生成的，目前格式是 {prefix}{yyyyMMdd}{6 位自增}。具体可见 ErpNoRedisDAO 类。\n\n② customer_id：客户编号。\n\n③ total_count 和 total_price：合计数量和金额，目前只是记录，并无特殊逻辑。\n\n④ status：状态，统一使用 ErpAuditStatus 枚举类，只有“未审批”、“已审批”两个状态。\n\n----------------------------------------\n\nCREATE TABLE `erp_stock_out_item` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '出库项编号',\n  `out_id` bigint NOT NULL COMMENT '出库编号',\n  \n  `warehouse_id` bigint NOT NULL COMMENT '仓库编号',\n  `product_id` bigint NOT NULL COMMENT '产品编号',\n  \n  `product_unit_id` bigint NOT NULL COMMENT '产品单位编号',\n  `product_price` decimal(24,6) DEFAULT NULL COMMENT '产品单价',\n  `count` decimal(24,6) NOT NULL COMMENT '产品数量',\n  `total_price` decimal(24,6) DEFAULT NULL COMMENT '合计金额，单位：元',\n  \n  `remark` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '备注',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='ERP 其它出库单项表';\n\n\n① out_id：出库编号，关联到上面的 erp_stock_out 表。\n\n② warehouse_id 和 product_id：分别关联到仓库和产品。\n\n③ product_unit_id、product_price、count 和 total_price：产品单位编号、产品单价、数量和金额。\n\n其中 total_price 等于 product_price * count。\n\n\n# 2.2 管理后台\n\n对应 [ERP 系统 -> 库存管理 -> 其它出库] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/erp/stock/out 目录。\n\n\n\n① 点击「新增」按钮，随便填写一些信息，点击「确认」按钮，即可新增一条其它出库单。\n\n\n\n② 点击该出库单的「审批」按钮，审批通过该出库单，此时状态会变成“已审批”，同时减少对应的库存、新增库存明细。如下图所示：\n\n\n\n③ 点击该出库单的「反审批」按钮，反审批该出库单，此时状态会变成“未审批”，同时增加对应的库存、新增库存明细。如下图所示：\n\n",
            normalizedContent: "本文接 《【库存】仓库、产品库存、库存明细》，主要讲解库存管理的其它入库、其它出库。它们的表关系如下图所示：\n\n\n\n\n# 1. 其它入库\n\n其它入库，由 erpstockincontroller 提供接口，一些 erp 系统也会称为“仓库入库”，将产品从仓库放进去，增加 产品的库存。\n\n为什么要叫“其它”入库呢？是指除了采购入库、生产入库之外的其它入库操作。\n\n\n# 1. 表结构\n\nerp_stock_in 表和 erp_stock_in_item 表，分别对应入库单和入库项。\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `erp_stock_in` (\n  `id` bigint not null auto_increment comment '入库编号',\n  `no` varchar(255) collate utf8mb4_unicode_ci not null comment '入库单号',\n  \n  `supplier_id` bigint default null comment '供应商编号',\n  `in_time` datetime not null comment '入库时间',\n  \n  `total_count` decimal(24,6) not null comment '合计数量',\n  `total_price` decimal(24,6) not null comment '合计金额，单位：元',\n  \n  `status` tinyint not null comment '状态',\n  \n  `remark` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '备注',\n  `file_url` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '附件 url',\n  primary key (`id`)\n) engine=innodb auto_increment=9 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='erp 其它入库单表';\n\n\n① no：入库单号，一般是系统自动生成的，目前格式是 {prefix}{yyyymmdd}{6 位自增}。具体可见 erpnoredisdao 类，如下图所示：\n\n\n\n② supplier_id：供应商编号。\n\n③ total_count 和 total_price：合计数量和金额，目前只是记录，并无特殊逻辑。\n\n④ status：状态，统一使用 erpauditstatus 枚举类，只有“未审批”、“已审批”两个状态，后续会接入到 bpm 工作流 中。\n\n\n\n----------------------------------------\n\ncreate table `erp_stock_in_item` (\n  `id` bigint not null auto_increment comment '入库项编号',\n  \n  `in_id` bigint not null comment '入库编号',\n  \n  `warehouse_id` bigint not null comment '仓库编号',\n  `product_id` bigint not null comment '产品编号',\n  \n  `product_unit_id` bigint not null comment '产品单位编号',\n  `product_price` decimal(24,6) default null comment '产品单价',\n  `count` decimal(24,6) not null comment '产品数量',\n  `total_price` decimal(24,6) default null comment '合计金额，单位：元',\n  \n  `remark` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '备注',\n  primary key (`id`)\n) engine=innodb auto_increment=10 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='erp 其它入库单项表';\n\n\n① in_id：入库编号，关联到上面的 erp_stock_in 表。\n\n② warehouse_id 和 product_id：分别关联到仓库和产品。\n\n③ product_unit_id、product_price、count 和 total_price：产品单位编号、产品单价、数量和金额。\n\n其中 total_price 等于 product_price * count。\n\n\n# 1.2 管理后台\n\n对应 [erp 系统 -> 库存管理 -> 其它入库] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/erp/stock/in 目录。\n\n\n\n① 点击「新增」按钮，随便填写一些信息，点击「确认」按钮，即可新增一条其它入库单。\n\n\n\n② 点击该入库单的「审批」按钮，审批通过该入库单，此时状态会变成“已审批”，同时增加对应的库存、新增库存明细。如下图所示：\n\n\n\n③ 点击该入库单的「反审批」按钮，反审批该入库单，此时状态会变成“未审批”，同时减少对应的库存、新增库存明细。如下图所示：\n\n\n\n\n# 2. 其它出库\n\n其它出库，由 erpstockoutcontroller 提供接口，一些 erp 系统也会称为“仓库出库”，将产品从仓库拿出来，减少 产品的库存。\n\n为什么要叫“其它”出库呢？是指除了销售出库、生产出库之外的其它出库操作。\n\n\n# 2. 表结构\n\n友情提示：其它出库相关的表，和其它入库相关的表结构基本一致。\n\nerp_stock_out 表和 erp_stock_out_item 表，分别对应出库单和出库项。\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `erp_stock_out` (\n  `id` bigint not null auto_increment comment '出库编号',\n  `no` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '出库单号',\n  \n  `customer_id` bigint default null comment '客户编号',\n  `out_time` datetime not null comment '出库时间',\n  \n  `total_count` decimal(24,6) not null comment '合计数量',\n  `total_price` decimal(24,6) not null comment '合计金额，单位：元',\n  \n  `status` tinyint not null comment '状态',\n  \n  `remark` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '备注',\n  `file_url` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '附件 url',\n  primary key (`id`)\n) engine=innodb auto_increment=11 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='erp 其它入库单表';\n\n\n① no：出库单号，一般是系统自动生成的，目前格式是 {prefix}{yyyymmdd}{6 位自增}。具体可见 erpnoredisdao 类。\n\n② customer_id：客户编号。\n\n③ total_count 和 total_price：合计数量和金额，目前只是记录，并无特殊逻辑。\n\n④ status：状态，统一使用 erpauditstatus 枚举类，只有“未审批”、“已审批”两个状态。\n\n----------------------------------------\n\ncreate table `erp_stock_out_item` (\n  `id` bigint not null auto_increment comment '出库项编号',\n  `out_id` bigint not null comment '出库编号',\n  \n  `warehouse_id` bigint not null comment '仓库编号',\n  `product_id` bigint not null comment '产品编号',\n  \n  `product_unit_id` bigint not null comment '产品单位编号',\n  `product_price` decimal(24,6) default null comment '产品单价',\n  `count` decimal(24,6) not null comment '产品数量',\n  `total_price` decimal(24,6) default null comment '合计金额，单位：元',\n  \n  `remark` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '备注',\n  primary key (`id`)\n) engine=innodb auto_increment=12 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='erp 其它出库单项表';\n\n\n① out_id：出库编号，关联到上面的 erp_stock_out 表。\n\n② warehouse_id 和 product_id：分别关联到仓库和产品。\n\n③ product_unit_id、product_price、count 和 total_price：产品单位编号、产品单价、数量和金额。\n\n其中 total_price 等于 product_price * count。\n\n\n# 2.2 管理后台\n\n对应 [erp 系统 -> 库存管理 -> 其它出库] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/erp/stock/out 目录。\n\n\n\n① 点击「新增」按钮，随便填写一些信息，点击「确认」按钮，即可新增一条其它出库单。\n\n\n\n② 点击该出库单的「审批」按钮，审批通过该出库单，此时状态会变成“已审批”，同时减少对应的库存、新增库存明细。如下图所示：\n\n\n\n③ 点击该出库单的「反审批」按钮，反审批该出库单，此时状态会变成“未审批”，同时增加对应的库存、新增库存明细。如下图所示：\n\n",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【库存】库存调拨、库存盘点",
            frontmatter: {
                title: "【库存】库存调拨、库存盘点",
                date: "2024-02-16T18:34:27.000Z",
                permalink: "/erp/stock-move-check"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/15.ERP%E6%89%8B%E5%86%8C/22.%E3%80%90%E5%BA%93%E5%AD%98%E3%80%91%E5%BA%93%E5%AD%98%E8%B0%83%E6%8B%A8%E3%80%81%E5%BA%93%E5%AD%98%E7%9B%98%E7%82%B9.html",
            relativePath: "01.开发指南/15.ERP手册/22.【库存】库存调拨、库存盘点.md",
            key: "v-281927db",
            path: "/erp/stock-move-check/",
            headers: [{
                level: 2,
                title: "1. 库存调拨",
                slug: "_1-库存调拨",
                normalizedTitle: "1. 库存调拨",
                charIndex: 58
            }, {
                level: 3,
                title: "1. 表结构",
                slug: "_1-表结构",
                normalizedTitle: "1. 表结构",
                charIndex: 146
            }, {
                level: 3,
                title: "2. 管理后台",
                slug: "_2-管理后台",
                normalizedTitle: "2. 管理后台",
                charIndex: 2230
            }, {
                level: 2,
                title: "2. 库存盘点",
                slug: "_2-库存盘点",
                normalizedTitle: "2. 库存盘点",
                charIndex: 2543
            }, {
                level: 3,
                title: "2.1 表结构",
                slug: "_2-1-表结构",
                normalizedTitle: "2.1 表结构",
                charIndex: 2618
            }, {
                level: 3,
                title: "2.2 管理后台",
                slug: "_2-2-管理后台",
                normalizedTitle: "2.2 管理后台",
                charIndex: 4917
            }],
            headersStr: "1. 库存调拨 1. 表结构 2. 管理后台 2. 库存盘点 2.1 表结构 2.2 管理后台",
            content: "本文接 《【库存】其它入库、其它出库》，主要讲解库存管理的库存调拨、库存盘点。它们的表关系如下图所示：\n\n\n\n\n# 1. 库存调拨\n\n库存调拨，由 ErpStockMoveController 提供接口，将产品从一个仓库调拨到另一个仓库，减少 来源仓库的库存，增加 目标仓库的库存。\n\n\n# 1. 表结构\n\nerp_stock_move 表和 erp_stock_move_item 表，分别对应调拨单和调拨项。\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `erp_stock_move` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '调拨编号',\n  `no` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '调拨单号',\n  `move_time` datetime NOT NULL COMMENT '调拨时间',\n  \n  `total_count` decimal(24,6) NOT NULL COMMENT '合计数量',\n  `total_price` decimal(24,6) NOT NULL COMMENT '合计金额，单位：元',\n  `status` tinyint NOT NULL COMMENT '状态',\n  \n  `remark` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '备注',\n  `file_url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '附件 URL',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='ERP 库存调拨单表';\n\n\n① no：调拨单号，一般是系统自动生成的，目前格式是 {prefix}{yyyyMMdd}{6 位自增}。具体可见 ErpNoRedisDAO 类。\n\n② total_count 和 total_price：合计数量和金额，目前只是记录，并无特殊逻辑。\n\n③ status：状态，统一使用 ErpAuditStatus 枚举类，只有“未审批”、“已审批”两个状态。\n\n----------------------------------------\n\nCREATE TABLE `erp_stock_move_item` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '调拨项编号',\n  \n  `move_id` bigint NOT NULL COMMENT '调拨编号',\n \n  `from_warehouse_id` bigint NOT NULL COMMENT '调出仓库编号',\n  `to_warehouse_id` bigint NOT NULL COMMENT '调入仓库编号',\n   \n  `product_id` bigint NOT NULL COMMENT '产品编号',\n  `product_unit_id` bigint NOT NULL COMMENT '产品单位编号',\n  `product_price` decimal(24,6) DEFAULT NULL COMMENT '产品单价',\n  `count` decimal(24,6) NOT NULL COMMENT '产品数量',\n  `total_price` decimal(24,6) DEFAULT NULL COMMENT '合计金额，单位：元',\n  \n  `remark` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '备注',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='ERP 库存调拨项表';\n\n\n① move_id：调拨编号，关联到上面的 erp_stock_move 表。\n\n② from_warehouse_id 和 to_warehouse_id：调出（来源）仓库编号和调入（目标）仓库编号。\n\n③ product_id、product_unit_id、product_price、count 和 total_price：产品编号、产品单位编号、产品单价、数量和金额。\n\n其中 total_price 等于 product_price * count。\n\n\n# 2. 管理后台\n\n对应 [ERP 系统 -> 库存管理 -> 库存调拨] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/erp/stock/move 目录。\n\n\n\n① 点击「新增」按钮，随便填写一些信息，点击「确认」按钮，即可新增一条调拨单。\n\n\n\n② 点击该调拨单的「审批」按钮，审批通过该出库单，此时状态会变成“已审批”，同时会减少来源仓库的库存、增加目标仓库的库存、新增 2n 条库存变动记录。如下图所示：\n\n\n\n③ 点击该调拨单的「反审批」按钮，反审批该调拨单，此时状态会变成“未审批”，同时会增加来源仓库的库存、减少目标仓库的库存、新增 2n 条库存变动记录。如下图所示：\n\n\n\n\n# 2. 库存盘点\n\n库存盘点，由 ErpStockCheckController 提供接口，盘点产品在仓库的具体库存，修改 它在该仓库的库存。\n\n\n# 2.1 表结构\n\nerp_stock_check 表和 erp_stock_check_item 表，分别对应盘点单和盘点项。\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `erp_stock_check` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '盘点编号',\n  \n  `no` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '盘点单号',\n  `check_time` datetime NOT NULL COMMENT '盘点时间',\n  \n  `total_count` decimal(24,6) NOT NULL COMMENT '合计数量',\n  `total_price` decimal(24,6) NOT NULL COMMENT '合计金额，单位：元',\n  \n  `status` tinyint NOT NULL COMMENT '状态',\n  \n  `remark` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '备注',\n  `file_url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '附件 URL',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='ERP 库存盘点单表';\n\n\n① no：盘点单号，一般是系统自动生成的，目前格式是 {prefix}{yyyyMMdd}{6 位自增}。具体可见 ErpNoRedisDAO 类。\n\n② total_count 和 total_price：合计数量和金额，目前只是记录，并无特殊逻辑。\n\n③ status：状态，统一使用 ErpAuditStatus 枚举类，只有“未审批”、“已审批”两个状态。\n\n----------------------------------------\n\nCREATE TABLE `erp_stock_check_item` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '调拨项编号',\n  \n  `check_id` bigint NOT NULL COMMENT '调拨编号',\n  \n  `warehouse_id` bigint NOT NULL COMMENT '仓库编号',\n  `product_id` bigint NOT NULL COMMENT '产品编号',\n  \n  `product_unit_id` bigint NOT NULL COMMENT '产品单位编号',\n  `product_price` decimal(24,6) DEFAULT NULL COMMENT '产品单价',\n  `count` decimal(24,6) NOT NULL COMMENT '盈亏数量',\n  `total_price` decimal(24,6) DEFAULT NULL COMMENT '合计金额，单位：元',\n  \n  `stock_count` decimal(24,6) NOT NULL COMMENT '账面数量（当前库存）',\n  `actual_count` decimal(24,6) NOT NULL COMMENT '实际数量（实际库存）',\n  \n  `remark` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '备注',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=14 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='ERP 库存盘点项表';\n\n\n① check_id：盘点编号，关联到上面的 erp_stock_check 表。\n\n② warehouse_id 和 product_id：仓库编号和产品编号，表示被盘点的产品在该仓库的库存。\n\n③ product_unit_id、product_price、count 和 total_price：产品单位编号、产品单价、盈亏数量和金额。\n\n其中 total_price 等于 product_price * count。\n\n④ stock_count 和 actual_count：账面数量（当前库存）和实际数量（实际库存），这 2 个字段的差值就是盈亏数量 count。\n\n不过也要注意，这 2 个字段更多是冗余，核心还是 count 表示盈亏。如果 count 是正数则库存增加（入库），count 是负数则库存减少（出库）。\n\n\n# 2.2 管理后台\n\n对应 [ERP 系统 -> 库存管理 -> 库存盘点] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/erp/stock/check 目录。\n\n① 点击「新增」按钮，随便填写一些信息，点击「确认」按钮，即可新增一条盘点单。\n\n\n\n② 点击该盘点单的「审批」按钮，审批通过该盘点单，此时状态会变成“已审批”，同时会修改对应的库存、新增库存明细。如下图所示：\n\n\n\n③ 点击该盘点单的「反审批」按钮，反审批该盘点单，此时状态会变成“未审批”，同时会修改对应的库存、新增库存明细。如下图所示：\n\n",
            normalizedContent: "本文接 《【库存】其它入库、其它出库》，主要讲解库存管理的库存调拨、库存盘点。它们的表关系如下图所示：\n\n\n\n\n# 1. 库存调拨\n\n库存调拨，由 erpstockmovecontroller 提供接口，将产品从一个仓库调拨到另一个仓库，减少 来源仓库的库存，增加 目标仓库的库存。\n\n\n# 1. 表结构\n\nerp_stock_move 表和 erp_stock_move_item 表，分别对应调拨单和调拨项。\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `erp_stock_move` (\n  `id` bigint not null auto_increment comment '调拨编号',\n  `no` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '调拨单号',\n  `move_time` datetime not null comment '调拨时间',\n  \n  `total_count` decimal(24,6) not null comment '合计数量',\n  `total_price` decimal(24,6) not null comment '合计金额，单位：元',\n  `status` tinyint not null comment '状态',\n  \n  `remark` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '备注',\n  `file_url` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '附件 url',\n  primary key (`id`)\n) engine=innodb auto_increment=11 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='erp 库存调拨单表';\n\n\n① no：调拨单号，一般是系统自动生成的，目前格式是 {prefix}{yyyymmdd}{6 位自增}。具体可见 erpnoredisdao 类。\n\n② total_count 和 total_price：合计数量和金额，目前只是记录，并无特殊逻辑。\n\n③ status：状态，统一使用 erpauditstatus 枚举类，只有“未审批”、“已审批”两个状态。\n\n----------------------------------------\n\ncreate table `erp_stock_move_item` (\n  `id` bigint not null auto_increment comment '调拨项编号',\n  \n  `move_id` bigint not null comment '调拨编号',\n \n  `from_warehouse_id` bigint not null comment '调出仓库编号',\n  `to_warehouse_id` bigint not null comment '调入仓库编号',\n   \n  `product_id` bigint not null comment '产品编号',\n  `product_unit_id` bigint not null comment '产品单位编号',\n  `product_price` decimal(24,6) default null comment '产品单价',\n  `count` decimal(24,6) not null comment '产品数量',\n  `total_price` decimal(24,6) default null comment '合计金额，单位：元',\n  \n  `remark` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '备注',\n  primary key (`id`)\n) engine=innodb auto_increment=11 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='erp 库存调拨项表';\n\n\n① move_id：调拨编号，关联到上面的 erp_stock_move 表。\n\n② from_warehouse_id 和 to_warehouse_id：调出（来源）仓库编号和调入（目标）仓库编号。\n\n③ product_id、product_unit_id、product_price、count 和 total_price：产品编号、产品单位编号、产品单价、数量和金额。\n\n其中 total_price 等于 product_price * count。\n\n\n# 2. 管理后台\n\n对应 [erp 系统 -> 库存管理 -> 库存调拨] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/erp/stock/move 目录。\n\n\n\n① 点击「新增」按钮，随便填写一些信息，点击「确认」按钮，即可新增一条调拨单。\n\n\n\n② 点击该调拨单的「审批」按钮，审批通过该出库单，此时状态会变成“已审批”，同时会减少来源仓库的库存、增加目标仓库的库存、新增 2n 条库存变动记录。如下图所示：\n\n\n\n③ 点击该调拨单的「反审批」按钮，反审批该调拨单，此时状态会变成“未审批”，同时会增加来源仓库的库存、减少目标仓库的库存、新增 2n 条库存变动记录。如下图所示：\n\n\n\n\n# 2. 库存盘点\n\n库存盘点，由 erpstockcheckcontroller 提供接口，盘点产品在仓库的具体库存，修改 它在该仓库的库存。\n\n\n# 2.1 表结构\n\nerp_stock_check 表和 erp_stock_check_item 表，分别对应盘点单和盘点项。\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `erp_stock_check` (\n  `id` bigint not null auto_increment comment '盘点编号',\n  \n  `no` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '盘点单号',\n  `check_time` datetime not null comment '盘点时间',\n  \n  `total_count` decimal(24,6) not null comment '合计数量',\n  `total_price` decimal(24,6) not null comment '合计金额，单位：元',\n  \n  `status` tinyint not null comment '状态',\n  \n  `remark` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '备注',\n  `file_url` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '附件 url',\n  primary key (`id`)\n) engine=innodb auto_increment=13 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='erp 库存盘点单表';\n\n\n① no：盘点单号，一般是系统自动生成的，目前格式是 {prefix}{yyyymmdd}{6 位自增}。具体可见 erpnoredisdao 类。\n\n② total_count 和 total_price：合计数量和金额，目前只是记录，并无特殊逻辑。\n\n③ status：状态，统一使用 erpauditstatus 枚举类，只有“未审批”、“已审批”两个状态。\n\n----------------------------------------\n\ncreate table `erp_stock_check_item` (\n  `id` bigint not null auto_increment comment '调拨项编号',\n  \n  `check_id` bigint not null comment '调拨编号',\n  \n  `warehouse_id` bigint not null comment '仓库编号',\n  `product_id` bigint not null comment '产品编号',\n  \n  `product_unit_id` bigint not null comment '产品单位编号',\n  `product_price` decimal(24,6) default null comment '产品单价',\n  `count` decimal(24,6) not null comment '盈亏数量',\n  `total_price` decimal(24,6) default null comment '合计金额，单位：元',\n  \n  `stock_count` decimal(24,6) not null comment '账面数量（当前库存）',\n  `actual_count` decimal(24,6) not null comment '实际数量（实际库存）',\n  \n  `remark` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '备注',\n  primary key (`id`)\n) engine=innodb auto_increment=14 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='erp 库存盘点项表';\n\n\n① check_id：盘点编号，关联到上面的 erp_stock_check 表。\n\n② warehouse_id 和 product_id：仓库编号和产品编号，表示被盘点的产品在该仓库的库存。\n\n③ product_unit_id、product_price、count 和 total_price：产品单位编号、产品单价、盈亏数量和金额。\n\n其中 total_price 等于 product_price * count。\n\n④ stock_count 和 actual_count：账面数量（当前库存）和实际数量（实际库存），这 2 个字段的差值就是盈亏数量 count。\n\n不过也要注意，这 2 个字段更多是冗余，核心还是 count 表示盈亏。如果 count 是正数则库存增加（入库），count 是负数则库存减少（出库）。\n\n\n# 2.2 管理后台\n\n对应 [erp 系统 -> 库存管理 -> 库存盘点] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/erp/stock/check 目录。\n\n① 点击「新增」按钮，随便填写一些信息，点击「确认」按钮，即可新增一条盘点单。\n\n\n\n② 点击该盘点单的「审批」按钮，审批通过该盘点单，此时状态会变成“已审批”，同时会修改对应的库存、新增库存明细。如下图所示：\n\n\n\n③ 点击该盘点单的「反审批」按钮，反审批该盘点单，此时状态会变成“未审批”，同时会修改对应的库存、新增库存明细。如下图所示：\n\n",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【库存】产品库存、库存明细",
            frontmatter: {
                title: "【库存】产品库存、库存明细",
                date: "2024-02-16T12:44:36.000Z",
                permalink: "/erp/stock/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/15.ERP%E6%89%8B%E5%86%8C/20.%E3%80%90%E5%BA%93%E5%AD%98%E3%80%91%E4%BA%A7%E5%93%81%E5%BA%93%E5%AD%98%E3%80%81%E5%BA%93%E5%AD%98%E6%98%8E%E7%BB%86.html",
            relativePath: "01.开发指南/15.ERP手册/20.【库存】产品库存、库存明细.md",
            key: "v-481dc19e",
            path: "/erp/stock/",
            headers: [{
                level: 2,
                title: "1. 仓库",
                slug: "_1-仓库",
                normalizedTitle: "1. 仓库",
                charIndex: 102
            }, {
                level: 3,
                title: "1. 表结构",
                slug: "_1-表结构",
                normalizedTitle: "1. 表结构",
                charIndex: 147
            }, {
                level: 3,
                title: "2. 管理后台",
                slug: "_2-管理后台",
                normalizedTitle: "2. 管理后台",
                charIndex: 1137
            }, {
                level: 2,
                title: "2. 产品库存",
                slug: "_2-产品库存",
                normalizedTitle: "2. 产品库存",
                charIndex: 1242
            }, {
                level: 3,
                title: "2.1 表结构",
                slug: "_2-1-表结构",
                normalizedTitle: "2.1 表结构",
                charIndex: 1294
            }, {
                level: 3,
                title: "2.2 管理后台",
                slug: "_2-2-管理后台",
                normalizedTitle: "2.2 管理后台",
                charIndex: 1849
            }, {
                level: 2,
                title: "3. 库存明细",
                slug: "_3-库存明细",
                normalizedTitle: "3. 库存明细",
                charIndex: 1959
            }, {
                level: 3,
                title: "3.1 表结构",
                slug: "_3-1-表结构",
                normalizedTitle: "3.1 表结构",
                charIndex: 2010
            }, {
                level: 3,
                title: "3.2 管理后台",
                slug: "_3-2-管理后台",
                normalizedTitle: "3.2 管理后台",
                charIndex: 3254
            }],
            headersStr: "1. 仓库 1. 表结构 2. 管理后台 2. 产品库存 2.1 表结构 2.2 管理后台 3. 库存明细 3.1 表结构 3.2 管理后台",
            content: "库存模块，由 yudao-module-erp-biz 后端模块的 stock 包实现，主要包括如下菜单：\n\n\n\n本文，我们主要讲解仓库、产品库存、库存明细三个功能。它们的表关系如下图所示：\n\n\n\n\n# 1. 仓库\n\n仓库，由 ErpWarehouseController 提供接口。\n\n\n# 1. 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `erp_warehouse` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '仓库编号',\n  `name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '仓库名称',\n  `address` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '仓库地址',\n  `sort` bigint NOT NULL COMMENT '排序',\n  `remark` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '备注',\n  `principal` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '负责人',\n  `warehouse_price` decimal(24,6) DEFAULT NULL COMMENT '仓储费，单位：元',\n  `truckage_price` decimal(24,6) DEFAULT NULL COMMENT '搬运费，单位：元',\n  `status` tinyint NOT NULL COMMENT '开启状态',\n  `default_status` bit(1) DEFAULT b'0' COMMENT '是否默认',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='ERP 仓库表';\n\n\n都是一些信息字段，仅仅用于展示，没有什么特殊逻辑。\n\n\n# 2. 管理后台\n\n对应 [ERP 系统 -> 库存管理 -> 仓库信息] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/erp/stock/warehouse 目录。\n\n\n\n\n# 2. 产品库存\n\n产品库存，由 ErpProductStockController 提供接口。\n\n\n# 2.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `erp_stock` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  `product_id` bigint NOT NULL COMMENT '产品编号',\n  `warehouse_id` bigint NOT NULL COMMENT '仓库编号',\n  `count` decimal(24,6) NOT NULL COMMENT '库存数量',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='ERP 产品库存表';\n\n\n① product_id 和 warehouse_id 分别关联对应的产品和仓库。本质上，它就是记录一个产品在某个仓库的库存数量。\n\n② count 是库存数量，注意它使用的是 decimal 类型，默认保留 3 位小数，并不是一个整数。\n\n\n# 2.2 管理后台\n\n对应 [ERP 系统 -> 库存管理 -> 产品库存] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/erp/stock/product-stock 目录。\n\n\n\n\n# 3. 库存明细\n\n库存明细，由 ErpStockRecordController 提供接口。\n\n\n# 3.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `erp_stock_record` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  `product_id` bigint NOT NULL COMMENT '产品编号',\n  `warehouse_id` bigint NOT NULL COMMENT '仓库编号',\n  \n  `count` decimal(24,6) NOT NULL COMMENT '出入库数量',\n  `total_count` decimal(24,6) NOT NULL COMMENT '总库存量',\n  \n  `biz_type` tinyint NOT NULL COMMENT '业务类型',\n  `biz_id` bigint NOT NULL COMMENT '业务编号',\n  `biz_item_id` bigint NOT NULL COMMENT '业务项编号',\n  `biz_no` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '业务单号',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=41 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='ERP 产品库存明细表';\n\n\n① product_id 和 warehouse_id 分别关联对应的产品和仓库。count 是出入库数量，total_count 是总库存量。\n\n本质上，它是记录一个产品在某个仓库的库存变化（出入库）数量。其中 count 为正数表示入库，为负数表示出库。\n\n② biz_type 是业务类型，比如采购入库、销售出库等。由 ErpStockRecordBizTypeEnum 枚举，如下图所示：\n\n\n\nbiz_id 和 biz_item_id、biz_no 用于关联对应的业务单据信息。\n\n有一点要注意，每个出入库操作是可以取消的，所以在 biz_type 都有一个 _CANCEL 的对应类型。例如说采购入库 PURCHASE_IN 对应的取消类型是 PURCHASE_IN_CANCEL。此时，会有两条记录：\n\n * 一条是 PURCHASE_IN 的 count 正数入库\n * 一条是 PURCHASE_IN_CANCEL 的 count 负数出库\n\n它的具体实现，可见 ErpStockRecordService 的 #createStockRecord(...) 方法，如下图所示：\n\n\n\n\n# 3.2 管理后台\n\n对应 [ERP 系统 -> 库存管理 -> 库存明细] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/erp/stock/record 目录。\n\n",
            normalizedContent: "库存模块，由 yudao-module-erp-biz 后端模块的 stock 包实现，主要包括如下菜单：\n\n\n\n本文，我们主要讲解仓库、产品库存、库存明细三个功能。它们的表关系如下图所示：\n\n\n\n\n# 1. 仓库\n\n仓库，由 erpwarehousecontroller 提供接口。\n\n\n# 1. 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `erp_warehouse` (\n  `id` bigint not null auto_increment comment '仓库编号',\n  `name` varchar(20) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '仓库名称',\n  `address` varchar(50) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '仓库地址',\n  `sort` bigint not null comment '排序',\n  `remark` varchar(100) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '备注',\n  `principal` varchar(20) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '负责人',\n  `warehouse_price` decimal(24,6) default null comment '仓储费，单位：元',\n  `truckage_price` decimal(24,6) default null comment '搬运费，单位：元',\n  `status` tinyint not null comment '开启状态',\n  `default_status` bit(1) default b'0' comment '是否默认',\n  primary key (`id`)\n) engine=innodb auto_increment=3 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='erp 仓库表';\n\n\n都是一些信息字段，仅仅用于展示，没有什么特殊逻辑。\n\n\n# 2. 管理后台\n\n对应 [erp 系统 -> 库存管理 -> 仓库信息] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/erp/stock/warehouse 目录。\n\n\n\n\n# 2. 产品库存\n\n产品库存，由 erpproductstockcontroller 提供接口。\n\n\n# 2.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `erp_stock` (\n  `id` bigint not null auto_increment comment '编号',\n  `product_id` bigint not null comment '产品编号',\n  `warehouse_id` bigint not null comment '仓库编号',\n  `count` decimal(24,6) not null comment '库存数量',\n  primary key (`id`)\n) engine=innodb auto_increment=5 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='erp 产品库存表';\n\n\n① product_id 和 warehouse_id 分别关联对应的产品和仓库。本质上，它就是记录一个产品在某个仓库的库存数量。\n\n② count 是库存数量，注意它使用的是 decimal 类型，默认保留 3 位小数，并不是一个整数。\n\n\n# 2.2 管理后台\n\n对应 [erp 系统 -> 库存管理 -> 产品库存] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/erp/stock/product-stock 目录。\n\n\n\n\n# 3. 库存明细\n\n库存明细，由 erpstockrecordcontroller 提供接口。\n\n\n# 3.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `erp_stock_record` (\n  `id` bigint not null auto_increment comment '编号',\n  `product_id` bigint not null comment '产品编号',\n  `warehouse_id` bigint not null comment '仓库编号',\n  \n  `count` decimal(24,6) not null comment '出入库数量',\n  `total_count` decimal(24,6) not null comment '总库存量',\n  \n  `biz_type` tinyint not null comment '业务类型',\n  `biz_id` bigint not null comment '业务编号',\n  `biz_item_id` bigint not null comment '业务项编号',\n  `biz_no` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '业务单号',\n  primary key (`id`)\n) engine=innodb auto_increment=41 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='erp 产品库存明细表';\n\n\n① product_id 和 warehouse_id 分别关联对应的产品和仓库。count 是出入库数量，total_count 是总库存量。\n\n本质上，它是记录一个产品在某个仓库的库存变化（出入库）数量。其中 count 为正数表示入库，为负数表示出库。\n\n② biz_type 是业务类型，比如采购入库、销售出库等。由 erpstockrecordbiztypeenum 枚举，如下图所示：\n\n\n\nbiz_id 和 biz_item_id、biz_no 用于关联对应的业务单据信息。\n\n有一点要注意，每个出入库操作是可以取消的，所以在 biz_type 都有一个 _cancel 的对应类型。例如说采购入库 purchase_in 对应的取消类型是 purchase_in_cancel。此时，会有两条记录：\n\n * 一条是 purchase_in 的 count 正数入库\n * 一条是 purchase_in_cancel 的 count 负数出库\n\n它的具体实现，可见 erpstockrecordservice 的 #createstockrecord(...) 方法，如下图所示：\n\n\n\n\n# 3.2 管理后台\n\n对应 [erp 系统 -> 库存管理 -> 库存明细] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/erp/stock/record 目录。\n\n",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【财务】采购付款、销售收款",
            frontmatter: {
                title: "【财务】采购付款、销售收款",
                date: "2024-02-16T22:17:35.000Z",
                permalink: "/sale/finance-payment-receipt"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/15.ERP%E6%89%8B%E5%86%8C/50.%E3%80%90%E8%B4%A2%E5%8A%A1%E3%80%91%E9%87%87%E8%B4%AD%E4%BB%98%E6%AC%BE%E3%80%81%E9%94%80%E5%94%AE%E6%94%B6%E6%AC%BE.html",
            relativePath: "01.开发指南/15.ERP手册/50.【财务】采购付款、销售收款.md",
            key: "v-7b9175cc",
            path: "/sale/finance-payment-receipt/",
            headers: [{
                level: 2,
                title: "1. 结算账户",
                slug: "_1-结算账户",
                normalizedTitle: "1. 结算账户",
                charIndex: 140
            }, {
                level: 3,
                title: "1.1 表结构",
                slug: "_1-1-表结构",
                normalizedTitle: "1.1 表结构",
                charIndex: 206
            }, {
                level: 3,
                title: "1.2 管理后台",
                slug: "_1-2-管理后台",
                normalizedTitle: "1.2 管理后台",
                charIndex: 938
            }, {
                level: 2,
                title: "2. 采购付款",
                slug: "_2-采购付款",
                normalizedTitle: "2. 采购付款",
                charIndex: 1044
            }, {
                level: 3,
                title: "2.1 表结构",
                slug: "_2-1-表结构",
                normalizedTitle: "2.1 表结构",
                charIndex: 1122
            }, {
                level: 3,
                title: "2.2 管理后台",
                slug: "_2-2-管理后台",
                normalizedTitle: "2.2 管理后台",
                charIndex: 3521
            }, {
                level: 2,
                title: "3. 销售收款",
                slug: "_3-销售收款",
                normalizedTitle: "3. 销售收款",
                charIndex: 3700
            }, {
                level: 3,
                title: "3.1 表结构",
                slug: "_3-1-表结构",
                normalizedTitle: "3.1 表结构",
                charIndex: 3832
            }, {
                level: 3,
                title: "3.2 管理后台",
                slug: "_3-2-管理后台",
                normalizedTitle: "3.2 管理后台",
                charIndex: 6293
            }],
            headersStr: "1. 结算账户 1.1 表结构 1.2 管理后台 2. 采购付款 2.1 表结构 2.2 管理后台 3. 销售收款 3.1 表结构 3.2 管理后台",
            content: "财务管理，由 yudao-module-erp-biz 后端模块的 finance 包实现，主要包括如下菜单：\n\n\n\n友情提示：目前财务相关的功能还做的相对简单，后续会继续增强！！！\n\n本文，我们主要讲解结算账户、采购付款、销售收款三个功能。它们的表关系如下图所示：\n\n\n\n\n# 1. 结算账户\n\n结算账户，由 ErpAccountController 提供接口，是指公司与供应商、客户之间的结算账户。\n\n\n# 1.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `erp_account` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '结算账户编号',\n  `name` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '账户名称',\n  `no` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '账户编码',\n  `remark` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '备注',\n  `status` tinyint NOT NULL COMMENT '开启状态',\n  `sort` int NOT NULL COMMENT '排序',\n  `default_status` bit(1) DEFAULT b'0' COMMENT '是否默认',\n  PRIMARY KEY (`id` DESC)\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='ERP 结算账户';\n\n\n都是一些信息字段，仅仅用于展示，没有什么特殊逻辑。\n\n\n# 1.2 管理后台\n\n对应 [ERP 系统 -> 财务管理 -> 结算账户] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/erp/finance/account 目录。\n\n\n\n\n# 2. 采购付款\n\n采购付款，由 ErpFinancePaymentController 提供接口，用于对采购入库进行付款，以及对采购退货进行退款。\n\n\n# 2.1 表结构\n\nerp_finance_payment 表和 erp_finance_payment_item 表，分别对应录付款单和付款单明细。\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `erp_finance_payment` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  \n  `no` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '付款单号',\n  \n  `status` tinyint NOT NULL COMMENT '状态',\n  `payment_time` datetime NOT NULL COMMENT '付款时间',\n  \n  `supplier_id` bigint NOT NULL COMMENT '供应商编号',\n  `finance_user_id` bigint DEFAULT NULL COMMENT '财务人员编号',\n  `account_id` bigint NOT NULL COMMENT '付款账户编号',\n  \n  `total_price` decimal(24,6) NOT NULL COMMENT '合计价格，单位：元',\n  `discount_price` decimal(24,6) NOT NULL COMMENT '优惠金额，单位：元',\n  `payment_price` decimal(24,6) NOT NULL COMMENT '实付金额，单位：分',\n  \n  `remark` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT '备注',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='ERP 付款单表';\n\n\n① no：付款单号，一般是系统自动生成的，目前格式是 {prefix}{yyyyMMdd}{6 位自增}。具体可见 ErpNoRedisDAO 类。\n\n② status：审核状态，统一使用 ErpAuditStatus 枚举类，只有“未审批”、“已审批”两个状态。\n\n③ supplier_id：供应商编号，关联 erp_supplier 表。\n\naccount_id：结算账户编号，关联上面的 erp_account 表。\n\n④ total_price、discount_price、payment_price：合计价格、优惠金额、实付金额。\n\n其中，payment_price 等于 total_price - discount_price。\n\n----------------------------------------\n\nCREATE TABLE `erp_finance_payment_item` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  \n  `payment_id` bigint NOT NULL COMMENT '付款单编号',\n  \n  `biz_type` tinyint NOT NULL COMMENT '业务类型',\n  `biz_id` bigint NOT NULL COMMENT '业务编号',\n  `biz_no` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '业务单号',\n  \n  `total_price` decimal(24,6) NOT NULL COMMENT '应付欠款，单位：分',\n  `paid_price` decimal(24,6) NOT NULL COMMENT '已付欠款，单位：分',\n  `payment_price` decimal(24,6) NOT NULL COMMENT '本次付款，单位：分',\n  \n  `remark` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '备注',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=20 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='ERP 付款项表';\n\n\n① payment_id：付款单编号，关联 erp_finance_payment 表。\n\n② biz_type、biz_id、biz_no：业务类型、业务编号、业务单号。\n\n其中 biz_type 由 ErpBizTypeEnum 枚举，目前使用“采购入库”、“采购退货”两种类型。\n\n③ total_price、paid_price、payment_price：应付欠款、已付欠款、本次付款。\n\n其中，payment_price 等于 total_price - paid_price。\n\n不过也要注意，这 total_price、paid_price 字段更多是冗余，核心还是 payment_price 表示本次付款。\n\n\n# 2.2 管理后台\n\n对应 [ERP 系统 -> 财务管理 -> 采购单] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/erp/finance/payment 目录。\n\n\n\n点击「新增」按钮，随便填写一些信息，点击「确认」按钮，即可新增一条付款单。\n\n\n\n友情提示：只有审批通过的采购入库、采购退货单才能进行选择添加。\n\n\n# 3. 销售收款\n\n友情提示：“销售”和“采购”目前是基本一致的，只是“销售”是从“客户”收款，“采购”是向“供应商”付款。\n\n销售收款，由 ErpFinanceReceiptController 提供接口，用于对销售出库进行收款，以及对销售退货进行退款。\n\n\n# 3.1 表结构\n\nerp_finance_receipt 表和 erp_finance_receipt_item 表，分别对应录收款单和收款单明细。\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `erp_finance_receipt` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  \n  `no` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '收款单号',\n  \n  `status` tinyint NOT NULL COMMENT '状态',\n  `receipt_time` datetime NOT NULL COMMENT '收款时间',\n  \n  `customer_id` bigint NOT NULL COMMENT '客户编号',\n  `account_id` bigint NOT NULL COMMENT '收款账户编号',\n  `finance_user_id` bigint DEFAULT NULL COMMENT '财务人员编号',\n  \n  `total_price` decimal(24,6) NOT NULL COMMENT '合计价格，单位：元',\n  `discount_price` decimal(24,6) NOT NULL COMMENT '优惠金额，单位：元',\n  `receipt_price` decimal(24,6) NOT NULL COMMENT '实收金额，单位：分',\n  \n  `remark` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT '备注',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=14 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='ERP 收款单表';\n\n\n① no：收款单号，一般是系统自动生成的，目前格式是 {prefix}{yyyyMMdd}{6 位自增}。具体可见 ErpNoRedisDAO 类。\n\n② status：审核状态，统一使用 ErpAuditStatus 枚举类，只有“未审批”、“已审批”两个状态。\n\n③ customer_id：客户编号，关联 erp_customer 表。\n\naccount_id：结算账户编号，关联上面的 erp_account 表。\n\n④ total_price、discount_price、receipt_price：合计价格、优惠金额、实收金额。\n\n其中，receipt_price 等于 total_price - discount_price。\n\n----------------------------------------\n\nCREATE TABLE `erp_finance_receipt_item` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  \n  `receipt_id` bigint NOT NULL COMMENT '收款单编号',\n  \n  `biz_type` tinyint NOT NULL COMMENT '业务类型',\n  `biz_id` bigint NOT NULL COMMENT '业务编号',\n  `biz_no` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '业务单号',\n  \n  `total_price` decimal(24,6) NOT NULL COMMENT '应收金额，单位：分',\n  `receipted_price` decimal(24,6) NOT NULL COMMENT '已收金额，单位：分',\n  `receipt_price` decimal(24,6) NOT NULL COMMENT '本次收款，单位：分',\n  \n  `remark` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '备注',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=24 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='ERP 收款项表';\n\n\n① receipt_id：收款单编号，关联 erp_finance_receipt 表。\n\n② biz_type、biz_id、biz_no：业务类型、业务编号、业务单号。\n\n其中 biz_type 由 ErpBizTypeEnum 枚举，目前使用“销售出库”、“销售退货”两种类型。\n\n③ total_price、receipted_price、receipt_price：应收金额、已收金额、本次收款。\n\n其中，receipt_price 等于 total_price - receipted_price。\n\n不过也要注意，这 total_price、receipted_price 字段更多是冗余，核心还是 receipt_price 表示本次收款。\n\n\n# 3.2 管理后台\n\n对应 [ERP 系统 -> 财务管理 -> 收款单] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/erp/finance/receipt 目录。\n\n\n\n点击「新增」按钮，随便填写一些信息，点击「确认」按钮，即可新增一条收款单。\n\n\n\n友情提示：只有审批通过的销售出库、销售退货单才能进行选择添加。",
            normalizedContent: "财务管理，由 yudao-module-erp-biz 后端模块的 finance 包实现，主要包括如下菜单：\n\n\n\n友情提示：目前财务相关的功能还做的相对简单，后续会继续增强！！！\n\n本文，我们主要讲解结算账户、采购付款、销售收款三个功能。它们的表关系如下图所示：\n\n\n\n\n# 1. 结算账户\n\n结算账户，由 erpaccountcontroller 提供接口，是指公司与供应商、客户之间的结算账户。\n\n\n# 1.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `erp_account` (\n  `id` bigint not null auto_increment comment '结算账户编号',\n  `name` varchar(255) collate utf8mb4_unicode_ci not null comment '账户名称',\n  `no` varchar(50) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '账户编码',\n  `remark` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '备注',\n  `status` tinyint not null comment '开启状态',\n  `sort` int not null comment '排序',\n  `default_status` bit(1) default b'0' comment '是否默认',\n  primary key (`id` desc)\n) engine=innodb auto_increment=2 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='erp 结算账户';\n\n\n都是一些信息字段，仅仅用于展示，没有什么特殊逻辑。\n\n\n# 1.2 管理后台\n\n对应 [erp 系统 -> 财务管理 -> 结算账户] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/erp/finance/account 目录。\n\n\n\n\n# 2. 采购付款\n\n采购付款，由 erpfinancepaymentcontroller 提供接口，用于对采购入库进行付款，以及对采购退货进行退款。\n\n\n# 2.1 表结构\n\nerp_finance_payment 表和 erp_finance_payment_item 表，分别对应录付款单和付款单明细。\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `erp_finance_payment` (\n  `id` bigint not null auto_increment comment '编号',\n  \n  `no` varchar(255) collate utf8mb4_unicode_ci not null comment '付款单号',\n  \n  `status` tinyint not null comment '状态',\n  `payment_time` datetime not null comment '付款时间',\n  \n  `supplier_id` bigint not null comment '供应商编号',\n  `finance_user_id` bigint default null comment '财务人员编号',\n  `account_id` bigint not null comment '付款账户编号',\n  \n  `total_price` decimal(24,6) not null comment '合计价格，单位：元',\n  `discount_price` decimal(24,6) not null comment '优惠金额，单位：元',\n  `payment_price` decimal(24,6) not null comment '实付金额，单位：分',\n  \n  `remark` varchar(1024) character set utf8mb4 collate utf8mb4_0900_ai_ci default null comment '备注',\n  primary key (`id`)\n) engine=innodb auto_increment=11 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='erp 付款单表';\n\n\n① no：付款单号，一般是系统自动生成的，目前格式是 {prefix}{yyyymmdd}{6 位自增}。具体可见 erpnoredisdao 类。\n\n② status：审核状态，统一使用 erpauditstatus 枚举类，只有“未审批”、“已审批”两个状态。\n\n③ supplier_id：供应商编号，关联 erp_supplier 表。\n\naccount_id：结算账户编号，关联上面的 erp_account 表。\n\n④ total_price、discount_price、payment_price：合计价格、优惠金额、实付金额。\n\n其中，payment_price 等于 total_price - discount_price。\n\n----------------------------------------\n\ncreate table `erp_finance_payment_item` (\n  `id` bigint not null auto_increment comment '编号',\n  \n  `payment_id` bigint not null comment '付款单编号',\n  \n  `biz_type` tinyint not null comment '业务类型',\n  `biz_id` bigint not null comment '业务编号',\n  `biz_no` varchar(255) collate utf8mb4_unicode_ci not null comment '业务单号',\n  \n  `total_price` decimal(24,6) not null comment '应付欠款，单位：分',\n  `paid_price` decimal(24,6) not null comment '已付欠款，单位：分',\n  `payment_price` decimal(24,6) not null comment '本次付款，单位：分',\n  \n  `remark` varchar(1024) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '备注',\n  primary key (`id`)\n) engine=innodb auto_increment=20 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='erp 付款项表';\n\n\n① payment_id：付款单编号，关联 erp_finance_payment 表。\n\n② biz_type、biz_id、biz_no：业务类型、业务编号、业务单号。\n\n其中 biz_type 由 erpbiztypeenum 枚举，目前使用“采购入库”、“采购退货”两种类型。\n\n③ total_price、paid_price、payment_price：应付欠款、已付欠款、本次付款。\n\n其中，payment_price 等于 total_price - paid_price。\n\n不过也要注意，这 total_price、paid_price 字段更多是冗余，核心还是 payment_price 表示本次付款。\n\n\n# 2.2 管理后台\n\n对应 [erp 系统 -> 财务管理 -> 采购单] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/erp/finance/payment 目录。\n\n\n\n点击「新增」按钮，随便填写一些信息，点击「确认」按钮，即可新增一条付款单。\n\n\n\n友情提示：只有审批通过的采购入库、采购退货单才能进行选择添加。\n\n\n# 3. 销售收款\n\n友情提示：“销售”和“采购”目前是基本一致的，只是“销售”是从“客户”收款，“采购”是向“供应商”付款。\n\n销售收款，由 erpfinancereceiptcontroller 提供接口，用于对销售出库进行收款，以及对销售退货进行退款。\n\n\n# 3.1 表结构\n\nerp_finance_receipt 表和 erp_finance_receipt_item 表，分别对应录收款单和收款单明细。\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `erp_finance_receipt` (\n  `id` bigint not null auto_increment comment '编号',\n  \n  `no` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '收款单号',\n  \n  `status` tinyint not null comment '状态',\n  `receipt_time` datetime not null comment '收款时间',\n  \n  `customer_id` bigint not null comment '客户编号',\n  `account_id` bigint not null comment '收款账户编号',\n  `finance_user_id` bigint default null comment '财务人员编号',\n  \n  `total_price` decimal(24,6) not null comment '合计价格，单位：元',\n  `discount_price` decimal(24,6) not null comment '优惠金额，单位：元',\n  `receipt_price` decimal(24,6) not null comment '实收金额，单位：分',\n  \n  `remark` varchar(1024) character set utf8mb4 collate utf8mb4_0900_ai_ci default null comment '备注',\n  primary key (`id`)\n) engine=innodb auto_increment=14 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='erp 收款单表';\n\n\n① no：收款单号，一般是系统自动生成的，目前格式是 {prefix}{yyyymmdd}{6 位自增}。具体可见 erpnoredisdao 类。\n\n② status：审核状态，统一使用 erpauditstatus 枚举类，只有“未审批”、“已审批”两个状态。\n\n③ customer_id：客户编号，关联 erp_customer 表。\n\naccount_id：结算账户编号，关联上面的 erp_account 表。\n\n④ total_price、discount_price、receipt_price：合计价格、优惠金额、实收金额。\n\n其中，receipt_price 等于 total_price - discount_price。\n\n----------------------------------------\n\ncreate table `erp_finance_receipt_item` (\n  `id` bigint not null auto_increment comment '编号',\n  \n  `receipt_id` bigint not null comment '收款单编号',\n  \n  `biz_type` tinyint not null comment '业务类型',\n  `biz_id` bigint not null comment '业务编号',\n  `biz_no` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '业务单号',\n  \n  `total_price` decimal(24,6) not null comment '应收金额，单位：分',\n  `receipted_price` decimal(24,6) not null comment '已收金额，单位：分',\n  `receipt_price` decimal(24,6) not null comment '本次收款，单位：分',\n  \n  `remark` varchar(1024) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '备注',\n  primary key (`id`)\n) engine=innodb auto_increment=24 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='erp 收款项表';\n\n\n① receipt_id：收款单编号，关联 erp_finance_receipt 表。\n\n② biz_type、biz_id、biz_no：业务类型、业务编号、业务单号。\n\n其中 biz_type 由 erpbiztypeenum 枚举，目前使用“销售出库”、“销售退货”两种类型。\n\n③ total_price、receipted_price、receipt_price：应收金额、已收金额、本次收款。\n\n其中，receipt_price 等于 total_price - receipted_price。\n\n不过也要注意，这 total_price、receipted_price 字段更多是冗余，核心还是 receipt_price 表示本次收款。\n\n\n# 3.2 管理后台\n\n对应 [erp 系统 -> 财务管理 -> 收款单] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/erp/finance/receipt 目录。\n\n\n\n点击「新增」按钮，随便填写一些信息，点击「确认」按钮，即可新增一条收款单。\n\n\n\n友情提示：只有审批通过的销售出库、销售退货单才能进行选择添加。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【采购】采购订单、入库、退货",
            frontmatter: {
                title: "【采购】采购订单、入库、退货",
                date: "2024-02-16T19:47:07.000Z",
                permalink: "/erp/purchase/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/15.ERP%E6%89%8B%E5%86%8C/30.%E3%80%90%E9%87%87%E8%B4%AD%E3%80%91%E9%87%87%E8%B4%AD%E8%AE%A2%E5%8D%95%E3%80%81%E5%85%A5%E5%BA%93%E3%80%81%E9%80%80%E8%B4%A7.html",
            relativePath: "01.开发指南/15.ERP手册/30.【采购】采购订单、入库、退货.md",
            key: "v-6a4d8916",
            path: "/erp/purchase/",
            headers: [{
                level: 2,
                title: "1. 供应商",
                slug: "_1-供应商",
                normalizedTitle: "1. 供应商",
                charIndex: 98
            }, {
                level: 3,
                title: "1.1 表结构",
                slug: "_1-1-表结构",
                normalizedTitle: "1.1 表结构",
                charIndex: 161
            }, {
                level: 3,
                title: "1.2 管理后台",
                slug: "_1-2-管理后台",
                normalizedTitle: "1.2 管理后台",
                charIndex: 1722
            }, {
                level: 2,
                title: "2. 采购订单",
                slug: "_2-采购订单",
                normalizedTitle: "2. 采购订单",
                charIndex: 1831
            }, {
                level: 3,
                title: "2.1 表结构",
                slug: "_2-1-表结构",
                normalizedTitle: "2.1 表结构",
                charIndex: 1912
            }, {
                level: 3,
                title: "2.2 管理后台",
                slug: "_2-2-管理后台",
                normalizedTitle: "2.2 管理后台",
                charIndex: 5296
            }, {
                level: 2,
                title: "3. 采购入库",
                slug: "_3-采购入库",
                normalizedTitle: "3. 采购入库",
                charIndex: 5497
            }, {
                level: 3,
                title: "3.1 表结构",
                slug: "_3-1-表结构",
                normalizedTitle: "3.1 表结构",
                charIndex: 5591
            }, {
                level: 3,
                title: "3.2 管理后台",
                slug: "_3-2-管理后台",
                normalizedTitle: "3.2 管理后台",
                charIndex: 8982
            }, {
                level: 2,
                title: "4. 采购退货",
                slug: "_4-采购退货",
                normalizedTitle: "4. 采购退货",
                charIndex: 9264
            }, {
                level: 3,
                title: "4.1 表结构",
                slug: "_4-1-表结构",
                normalizedTitle: "4.1 表结构",
                charIndex: 9362
            }, {
                level: 3,
                title: "4.2 管理后台",
                slug: "_4-2-管理后台",
                normalizedTitle: "4.2 管理后台",
                charIndex: 12928
            }, {
                level: 2,
                title: "5. 采购付款",
                slug: "_5-采购付款",
                normalizedTitle: "5. 采购付款",
                charIndex: 13214
            }],
            headersStr: "1. 供应商 1.1 表结构 1.2 管理后台 2. 采购订单 2.1 表结构 2.2 管理后台 3. 采购入库 3.1 表结构 3.2 管理后台 4. 采购退货 4.1 表结构 4.2 管理后台 5. 采购付款",
            content: "采购模块，由 yudao-module-erp-biz 后端模块的 purchase 包实现，主要有采购订单、采购入库、采购退货等功能。如下图所示：\n\n\n\n它的整体流程，如下图所示：\n\n\n\n\n# 1. 供应商\n\n供应商，由 ErpSupplierController 提供接口，所有采购都是针对供应商进行操作的。\n\n\n# 1.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `erp_supplier` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '供应商编号',\n  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '供应商名称',\n  `contact` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '联系人',\n  `mobile` varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '手机号码',\n  `telephone` varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '联系电话',\n  `email` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '电子邮箱',\n  `fax` varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '传真',\n  `remark` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '备注',\n  `status` tinyint NOT NULL COMMENT '开启状态',\n  `sort` int NOT NULL COMMENT '排序',\n  `tax_no` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '纳税人识别号',\n  `tax_percent` decimal(24,6) DEFAULT NULL COMMENT '税率',\n  `bank_name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '开户行',\n  `bank_account` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '开户账号',\n  `bank_address` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '开户地址',\n  PRIMARY KEY (`id` DESC)\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='ERP 供应商表';\n\n\n都是一些信息字段，仅仅用于展示，没有什么特殊逻辑。\n\n\n# 1.2 管理后台\n\n对应 [ERP 系统 -> 采购管理 -> 供应商信息] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/erp/purchase/supplier 目录。\n\n\n\n\n# 2. 采购订单\n\n采购订单，由 ErpPurchaseOrderController 提供接口，它不会直接影响库存，只有在入库、退货等操作才会影响库存。\n\n\n# 2.1 表结构\n\nerp_purchase_order 表和 erp_purchase_order_items 表，分别对应采购订单和采购订单项。\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `erp_purchase_order` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  `no` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '采购单编号',\n  \n  `status` tinyint NOT NULL COMMENT '采购状态',\n  `order_time` datetime NOT NULL COMMENT '采购时间',\n  \n  `supplier_id` bigint NOT NULL COMMENT '供应商编号',\n  `account_id` bigint DEFAULT NULL COMMENT '结算账户编号',\n\n  `total_count` decimal(24,6) NOT NULL COMMENT '合计数量',\n  `total_price` decimal(24,6) NOT NULL COMMENT '合计价格，单位：元',\n  `total_product_price` decimal(24,6) NOT NULL COMMENT '合计产品价格，单位：元',\n  `total_tax_price` decimal(24,6) NOT NULL COMMENT '合计税额，单位：元',\n  `discount_percent` decimal(24,6) NOT NULL COMMENT '优惠率，百分比',\n  `discount_price` decimal(24,6) NOT NULL COMMENT '优惠金额，单位：元',\n  `deposit_price` decimal(24,6) NOT NULL DEFAULT '0.000000' COMMENT '定金金额，单位：元',\n  \n  `file_url` varchar(512) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '附件地址',\n  `remark` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT '备注',\n\n  `in_count` decimal(24,6) NOT NULL DEFAULT '0.000000' COMMENT '采购入库数量',\n  `return_count` decimal(24,6) NOT NULL DEFAULT '0.000000' COMMENT '采购退货数量',\n\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `no` (`no`)\n) ENGINE=InnoDB AUTO_INCREMENT=16 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='ERP 采购订单表';\n\n\n① no：采购单号，一般是系统自动生成的，目前格式是 {prefix}{yyyyMMdd}{6 位自增}。具体可见 ErpNoRedisDAO 类。\n\n② status：采购状态，统一使用 ErpAuditStatus 枚举类，只有“未审批”、“已审批”两个状态。\n\n③ supplier_id：供应商编号，关联到上面的 erp_supplier 表。\n\naccount_id：结算账户编号，关联后续的 erp_account 表。暂时不用关注，它用于采购的付款。\n\n④ total_count、total_price、total_product_price、total_tax_price、discount_percent、discount_price 和 deposit_price：合计数量、合计价格、合计产品价格、合计税额、优惠率、优惠金额和定金金额。\n\n⑤ in_count：该采购订单已经入库的数量。一个订单可以被多次采购入库，但是不能超过最大的 total_count，所以需要记录已经入库的数量。\n\n⑥ return_count：该采购订单已经退货的数量。一个订单可以被多次采购退货，但是不能超过最大的 total_count，所以需要记录已经退货的数量。\n\n----------------------------------------\n\nCREATE TABLE `erp_purchase_order_items` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  \n  `order_id` bigint NOT NULL COMMENT '采购订单编号',\n  \n  `product_id` bigint NOT NULL COMMENT '产品编号',\n  \n  `product_unit_id` bigint NOT NULL COMMENT '产品单位单位',\n  `product_price` decimal(24,6) NOT NULL COMMENT '产品单价',\n  `count` decimal(24,6) NOT NULL COMMENT '数量',\n  `total_price` decimal(24,6) NOT NULL COMMENT '总价',\n  `tax_percent` decimal(24,6) DEFAULT NULL COMMENT '税率，百分比',\n  `tax_price` decimal(24,6) DEFAULT NULL COMMENT '税额，单位：元',\n  \n  `remark` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT '备注',\n  \n  `in_count` decimal(24,6) NOT NULL DEFAULT '0.000000' COMMENT '采购入库数量',\n  `return_count` decimal(24,6) NOT NULL DEFAULT '0.000000' COMMENT '采购退货数量',\n  \n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=15 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='ERP 采购订单项表';\n\n\n① order_id：采购订单编号，关联到上面的 erp_purchase_order 表。\n\n② product_id：产品编号。\n\n注意，因为采购订单不直接涉及库存，所以它并没有 warehouse_id 字段，也就是说它不关心库存的具体仓库。\n\n③ product_unit_id、product_price、count、total_price、tax_percent 和 tax_price：产品单位编号、产品单价、数量、总价、税率和税额。\n\n其中 total_price 等于 product_price * count + tax_price。（额外多了税额）\n\n④ in_count 和 return_count：同 erp_purchase_order 表，只是它表示的是该订单“项”的入库数量和退货数量，当然它也不能超过最大的 count。\n\n\n# 2.2 管理后台\n\n对应 [ERP 系统 -> 采购管理 -> 采购订单] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/erp/purchase/order 目录。\n\n\n\n① 点击「新增」按钮，随便填写一些信息，点击「确认」按钮，即可新增一条采购订单。\n\n\n\n② 点击该采购订单的「审批」按钮，审批通过该采购订单，此时状态会变成“已审批”，但是并不会影响库存。\n\n\n# 3. 采购入库\n\n采购入库，由 ErpPurchaseInController 提供接口，它会影响（增加）库存。总的来说，它的逻辑和 其它入库 基本一致，只是它是针对采购的入库。\n\n\n# 3.1 表结构\n\nerp_purchase_in 表和 erp_purchase_in_items 表，分别对应采购入库和采购入库项。\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `erp_purchase_in` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  `no` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '采购入库编号',\n  \n  `status` tinyint NOT NULL COMMENT '采购状态',\n  `in_time` datetime NOT NULL COMMENT '入库时间',\n  \n  `supplier_id` bigint NOT NULL COMMENT '供应商编号',\n  `account_id` bigint NOT NULL COMMENT '结算账户编号',\n\n  `order_id` bigint NOT NULL COMMENT '采购订单编号',\n  `order_no` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '采购订单号',\n  \n  `total_count` decimal(24,6) NOT NULL COMMENT '合计数量',\n  `total_price` decimal(24,6) NOT NULL COMMENT '合计价格，单位：元',\n  `total_product_price` decimal(24,6) NOT NULL COMMENT '合计产品价格，单位：元',\n  `total_tax_price` decimal(24,6) NOT NULL COMMENT '合计税额，单位：元',\n  `discount_percent` decimal(24,6) NOT NULL COMMENT '优惠率，百分比',\n  `discount_price` decimal(24,6) NOT NULL COMMENT '优惠金额，单位：元',\n  `other_price` decimal(24,6) NOT NULL DEFAULT '0.000000' COMMENT '其它金额，单位：元',\n  \n  `payment_price` decimal(24,6) NOT NULL DEFAULT '0.000000' COMMENT '已付款金额，单位：元',\n  \n  `file_url` varchar(512) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '附件地址',\n  `remark` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT '备注',\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `no` (`no`)\n) ENGINE=InnoDB AUTO_INCREMENT=17 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='ERP 采购入库表';\n\n\n① no：采购入库编号，一般是系统自动生成的，目前格式是 {prefix}{yyyyMMdd}{6 位自增}。具体可见 ErpNoRedisDAO 类。\n\n② status：入库状态，统一使用 ErpAuditStatus 枚举类，只有“未审批”、“已审批”两个状态。\n\n③ supplier_id：供应商编号，关联到上面的 erp_supplier 表。\n\naccount_id：结算账户编号，关联后续的 erp_account 表。暂时不用关注，它用于采购的付款。\n\n④ order_id 和 order_no：采购订单编号和采购订单号，关联到上面的 erp_purchase_order 表。\n\n⑤ total_count、total_price、total_product_price、total_tax_price、discount_percent、discount_price 和 other_price：合计数量、合计价格、合计产品价格、合计税额、优惠率、优惠金额和其它金额。\n\n其中，total_price 等于 total_product_price + total_tax_price + other_price - discount_price。\n\n⑥ payment_price：已付款金额，单位：元。暂时不用关注，它用于采购的付款。\n\n----------------------------------------\n\nCREATE TABLE `erp_purchase_in_items` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  \n  `in_id` bigint NOT NULL COMMENT '采购入库编号',\n  \n  `order_item_id` bigint NOT NULL COMMENT '采购订单项编号',\n  \n  `warehouse_id` bigint NOT NULL COMMENT '仓库编号',\n  `product_id` bigint NOT NULL COMMENT '产品编号',\n  \n  `product_unit_id` bigint NOT NULL COMMENT '产品单位单位',\n  `product_price` decimal(24,6) NOT NULL COMMENT '产品单价',\n  `count` decimal(24,6) NOT NULL COMMENT '数量',\n  `total_price` decimal(24,6) NOT NULL COMMENT '总价',\n  `tax_percent` decimal(24,6) DEFAULT NULL COMMENT '税率，百分比',\n  `tax_price` decimal(24,6) DEFAULT NULL COMMENT '税额，单位：元',\n\n  `remark` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT '备注',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=30 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='ERP 销售入库项表';\n\n\n① in_id：采购入库编号，关联到上面的 erp_purchase_in 表。\n\n② order_item_id：采购订单项编号，关联到上面的 erp_purchase_order_items 表，因为它需要对应的 in_count 字段。\n\n③ warehouse_id 和 product_id：分别关联到仓库和产品，因为它涉及到库存变更。\n\n④ product_unit_id、product_price、count、total_price、tax_percent 和 tax_price：产品单位编号、产品单价、数量、总价、税率和税额。\n\n其中 total_price 等于 product_price * count + tax_price。（额外多了税额）\n\n\n# 3.2 管理后台\n\n对应 [ERP 系统 -> 采购管理 -> 采购入库] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/erp/purchase/in 目录。\n\n\n\n① 点击「新增」按钮，随便填写一些信息，点击「确认」按钮，即可新增一条采购入库。\n\n\n\n② 点击该采购入库的「审批」按钮，审批通过该采购入库，此时状态会变成“已审批”，同时会增加对应的库存、新增库存明细。如下图所示：\n\n\n\n③ 点击该采购入库的「反审批」按钮，反审批该采购入库，此时状态会变成“未审批”，同时会减少对应的库存、新增库存明细。如下图所示：\n\n\n\n\n# 4. 采购退货\n\n采购退货，由 ErpPurchaseReturnController 提供接口，它会影响（减少）库存。总的来说，它的逻辑和 其它出库 基本一致，只是它是针对采购的出库。\n\n\n# 4.1 表结构\n\n友情提示：采购退货相关的表，和采购入库相关的表结构基本一致。\n\nerp_purchase_return 表和 erp_purchase_return_items 表，分别对应采购退货和采购退货项。\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `erp_purchase_return` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  `no` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '采购退货编号',\n  \n  `status` tinyint NOT NULL COMMENT '退货状态',\n  `return_time` datetime NOT NULL COMMENT '退货时间',\n  \n  `supplier_id` bigint NOT NULL COMMENT '供应商编号',\n  `account_id` bigint NOT NULL COMMENT '结算账户编号',\n  \n  `order_id` bigint NOT NULL COMMENT '采购订单编号',\n  `order_no` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '采购订单号',\n  \n  `total_count` decimal(24,6) NOT NULL COMMENT '合计数量',\n  `total_price` decimal(24,6) NOT NULL COMMENT '合计价格，单位：元',\n  `total_product_price` decimal(24,6) NOT NULL COMMENT '合计产品价格，单位：元',\n  `total_tax_price` decimal(24,6) NOT NULL COMMENT '合计税额，单位：元',\n  `discount_percent` decimal(24,6) NOT NULL COMMENT '优惠率，百分比',\n  `discount_price` decimal(24,6) NOT NULL COMMENT '优惠金额，单位：元',\n  `other_price` decimal(24,6) NOT NULL DEFAULT '0.000000' COMMENT '其它金额，单位：元',\n\n  `refund_price` decimal(24,6) NOT NULL DEFAULT '0.000000' COMMENT '已退款金额，单位：元',\n  \n  `file_url` varchar(512) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '附件地址',\n  `remark` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT '备注',\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `no` (`no`)\n) ENGINE=InnoDB AUTO_INCREMENT=25 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='ERP 采购退货表';\n\n\n① no：采购退货编号，一般是系统自动生成的，目前格式是 {prefix}{yyyyMMdd}{6 位自增}。具体可见 ErpNoRedisDAO 类。\n\n② status：退货状态，统一使用 ErpAuditStatus 枚举类，只有“未审批”、“已审批”两个状态。\n\n③ supplier_id：供应商编号，关联到上面的 erp_supplier 表。\n\naccount_id：结算账户编号，关联后续的 erp_account 表。暂时不用关注，它用于采购的付款。\n\n④ order_id 和 order_no：采购订单编号和采购订单号，关联到上面的 erp_purchase_order 表。\n\n疑问：采购退货，为什么不是针对采购入库进行退货，而是针对采购订单进行退货呢？\n\n确实是有 ERP 是针对采购入库进行退货的，不过相对比较少。和一些做 ERP 的朋友交流过，他们的倾向于基于采购订单进行退货。\n\n⑤ total_count、total_price、total_product_price、total_tax_price、discount_percent、discount_price 和 other_price：合计数量、合计价格、合计产品价格、合计税额、优惠率、优惠金额和其它金额。\n\n其中，total_price 等于 total_product_price + total_tax_price + other_price - discount_price。\n\n【差异】⑥ refund_price：已退款金额，单位：元。暂时不用关注，它用于采购的付款。\n\n----------------------------------------\n\nCREATE TABLE `erp_purchase_return_items` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  \n  `return_id` bigint NOT NULL COMMENT '采购退货编号',\n  \n  `order_item_id` bigint NOT NULL COMMENT '采购订单项编号',\n  \n  `warehouse_id` bigint NOT NULL COMMENT '仓库编号',\n  `product_id` bigint NOT NULL COMMENT '产品编号',\n  \n  `product_unit_id` bigint NOT NULL COMMENT '产品单位单位',\n  `product_price` decimal(24,6) NOT NULL COMMENT '产品单价',\n  `count` decimal(24,6) NOT NULL COMMENT '数量',\n  `total_price` decimal(24,6) NOT NULL COMMENT '总价',\n  `tax_percent` decimal(24,6) DEFAULT NULL COMMENT '税率，百分比',\n  `tax_price` decimal(24,6) DEFAULT NULL COMMENT '税额，单位：元',\n\n  `remark` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT '备注',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=45 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='ERP 采购退货项表';\n\n\n① return_id：采购退货编号，关联到上面的 erp_purchase_return 表。\n\n② order_item_id：采购订单项编号，关联到上面的 erp_purchase_order_items 表，因为它需要对应的 return_count 字段。\n\n③ warehouse_id 和 product_id：分别关联到仓库和产品，因为它涉及到库存变更。\n\n④ product_unit_id、product_price、count、total_price、tax_percent 和 tax_price：产品单位编号、产品单价、数量、总价、税率和税额。\n\n其中 total_price 等于 product_price * count + tax_price。（额外多了税额）\n\n\n# 4.2 管理后台\n\n对应 [ERP 系统 -> 采购管理 -> 采购退货] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/erp/purchase/return 目录。\n\n\n\n① 点击「新增」按钮，随便填写一些信息，点击「确认」按钮，即可新增一条采购退货。\n\n\n\n② 点击该采购退货的「审批」按钮，审批通过该采购退货，此时状态会变成“已审批”，同时会减少对应的库存、新增库存明细。如下图所示：\n\n\n\n③ 点击该采购退货的「反审批」按钮，反审批该采购退货，此时状态会变成“未审批”，同时会增加对应的库存、新增库存明细。如下图所示：\n\n\n\n\n# 5. 采购付款\n\n参见 《【财务】采购付款、销售收款》 文档。",
            normalizedContent: "采购模块，由 yudao-module-erp-biz 后端模块的 purchase 包实现，主要有采购订单、采购入库、采购退货等功能。如下图所示：\n\n\n\n它的整体流程，如下图所示：\n\n\n\n\n# 1. 供应商\n\n供应商，由 erpsuppliercontroller 提供接口，所有采购都是针对供应商进行操作的。\n\n\n# 1.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `erp_supplier` (\n  `id` bigint not null auto_increment comment '供应商编号',\n  `name` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '供应商名称',\n  `contact` varchar(100) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '联系人',\n  `mobile` varchar(30) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '手机号码',\n  `telephone` varchar(30) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '联系电话',\n  `email` varchar(50) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '电子邮箱',\n  `fax` varchar(30) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '传真',\n  `remark` varchar(255) collate utf8mb4_unicode_ci default null comment '备注',\n  `status` tinyint not null comment '开启状态',\n  `sort` int not null comment '排序',\n  `tax_no` varchar(50) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '纳税人识别号',\n  `tax_percent` decimal(24,6) default null comment '税率',\n  `bank_name` varchar(50) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '开户行',\n  `bank_account` varchar(50) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '开户账号',\n  `bank_address` varchar(50) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '开户地址',\n  primary key (`id` desc)\n) engine=innodb auto_increment=2 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='erp 供应商表';\n\n\n都是一些信息字段，仅仅用于展示，没有什么特殊逻辑。\n\n\n# 1.2 管理后台\n\n对应 [erp 系统 -> 采购管理 -> 供应商信息] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/erp/purchase/supplier 目录。\n\n\n\n\n# 2. 采购订单\n\n采购订单，由 erppurchaseordercontroller 提供接口，它不会直接影响库存，只有在入库、退货等操作才会影响库存。\n\n\n# 2.1 表结构\n\nerp_purchase_order 表和 erp_purchase_order_items 表，分别对应采购订单和采购订单项。\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `erp_purchase_order` (\n  `id` bigint not null auto_increment comment '编号',\n  `no` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '采购单编号',\n  \n  `status` tinyint not null comment '采购状态',\n  `order_time` datetime not null comment '采购时间',\n  \n  `supplier_id` bigint not null comment '供应商编号',\n  `account_id` bigint default null comment '结算账户编号',\n\n  `total_count` decimal(24,6) not null comment '合计数量',\n  `total_price` decimal(24,6) not null comment '合计价格，单位：元',\n  `total_product_price` decimal(24,6) not null comment '合计产品价格，单位：元',\n  `total_tax_price` decimal(24,6) not null comment '合计税额，单位：元',\n  `discount_percent` decimal(24,6) not null comment '优惠率，百分比',\n  `discount_price` decimal(24,6) not null comment '优惠金额，单位：元',\n  `deposit_price` decimal(24,6) not null default '0.000000' comment '定金金额，单位：元',\n  \n  `file_url` varchar(512) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '附件地址',\n  `remark` varchar(1024) character set utf8mb4 collate utf8mb4_0900_ai_ci default null comment '备注',\n\n  `in_count` decimal(24,6) not null default '0.000000' comment '采购入库数量',\n  `return_count` decimal(24,6) not null default '0.000000' comment '采购退货数量',\n\n  primary key (`id`),\n  unique key `no` (`no`)\n) engine=innodb auto_increment=16 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='erp 采购订单表';\n\n\n① no：采购单号，一般是系统自动生成的，目前格式是 {prefix}{yyyymmdd}{6 位自增}。具体可见 erpnoredisdao 类。\n\n② status：采购状态，统一使用 erpauditstatus 枚举类，只有“未审批”、“已审批”两个状态。\n\n③ supplier_id：供应商编号，关联到上面的 erp_supplier 表。\n\naccount_id：结算账户编号，关联后续的 erp_account 表。暂时不用关注，它用于采购的付款。\n\n④ total_count、total_price、total_product_price、total_tax_price、discount_percent、discount_price 和 deposit_price：合计数量、合计价格、合计产品价格、合计税额、优惠率、优惠金额和定金金额。\n\n⑤ in_count：该采购订单已经入库的数量。一个订单可以被多次采购入库，但是不能超过最大的 total_count，所以需要记录已经入库的数量。\n\n⑥ return_count：该采购订单已经退货的数量。一个订单可以被多次采购退货，但是不能超过最大的 total_count，所以需要记录已经退货的数量。\n\n----------------------------------------\n\ncreate table `erp_purchase_order_items` (\n  `id` bigint not null auto_increment comment '编号',\n  \n  `order_id` bigint not null comment '采购订单编号',\n  \n  `product_id` bigint not null comment '产品编号',\n  \n  `product_unit_id` bigint not null comment '产品单位单位',\n  `product_price` decimal(24,6) not null comment '产品单价',\n  `count` decimal(24,6) not null comment '数量',\n  `total_price` decimal(24,6) not null comment '总价',\n  `tax_percent` decimal(24,6) default null comment '税率，百分比',\n  `tax_price` decimal(24,6) default null comment '税额，单位：元',\n  \n  `remark` varchar(1024) character set utf8mb4 collate utf8mb4_0900_ai_ci default null comment '备注',\n  \n  `in_count` decimal(24,6) not null default '0.000000' comment '采购入库数量',\n  `return_count` decimal(24,6) not null default '0.000000' comment '采购退货数量',\n  \n  primary key (`id`)\n) engine=innodb auto_increment=15 default charset=utf8mb4 collate=utf8mb4_0900_ai_ci comment='erp 采购订单项表';\n\n\n① order_id：采购订单编号，关联到上面的 erp_purchase_order 表。\n\n② product_id：产品编号。\n\n注意，因为采购订单不直接涉及库存，所以它并没有 warehouse_id 字段，也就是说它不关心库存的具体仓库。\n\n③ product_unit_id、product_price、count、total_price、tax_percent 和 tax_price：产品单位编号、产品单价、数量、总价、税率和税额。\n\n其中 total_price 等于 product_price * count + tax_price。（额外多了税额）\n\n④ in_count 和 return_count：同 erp_purchase_order 表，只是它表示的是该订单“项”的入库数量和退货数量，当然它也不能超过最大的 count。\n\n\n# 2.2 管理后台\n\n对应 [erp 系统 -> 采购管理 -> 采购订单] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/erp/purchase/order 目录。\n\n\n\n① 点击「新增」按钮，随便填写一些信息，点击「确认」按钮，即可新增一条采购订单。\n\n\n\n② 点击该采购订单的「审批」按钮，审批通过该采购订单，此时状态会变成“已审批”，但是并不会影响库存。\n\n\n# 3. 采购入库\n\n采购入库，由 erppurchaseincontroller 提供接口，它会影响（增加）库存。总的来说，它的逻辑和 其它入库 基本一致，只是它是针对采购的入库。\n\n\n# 3.1 表结构\n\nerp_purchase_in 表和 erp_purchase_in_items 表，分别对应采购入库和采购入库项。\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `erp_purchase_in` (\n  `id` bigint not null auto_increment comment '编号',\n  `no` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '采购入库编号',\n  \n  `status` tinyint not null comment '采购状态',\n  `in_time` datetime not null comment '入库时间',\n  \n  `supplier_id` bigint not null comment '供应商编号',\n  `account_id` bigint not null comment '结算账户编号',\n\n  `order_id` bigint not null comment '采购订单编号',\n  `order_no` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '采购订单号',\n  \n  `total_count` decimal(24,6) not null comment '合计数量',\n  `total_price` decimal(24,6) not null comment '合计价格，单位：元',\n  `total_product_price` decimal(24,6) not null comment '合计产品价格，单位：元',\n  `total_tax_price` decimal(24,6) not null comment '合计税额，单位：元',\n  `discount_percent` decimal(24,6) not null comment '优惠率，百分比',\n  `discount_price` decimal(24,6) not null comment '优惠金额，单位：元',\n  `other_price` decimal(24,6) not null default '0.000000' comment '其它金额，单位：元',\n  \n  `payment_price` decimal(24,6) not null default '0.000000' comment '已付款金额，单位：元',\n  \n  `file_url` varchar(512) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '附件地址',\n  `remark` varchar(1024) character set utf8mb4 collate utf8mb4_0900_ai_ci default null comment '备注',\n  primary key (`id`),\n  unique key `no` (`no`)\n) engine=innodb auto_increment=17 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='erp 采购入库表';\n\n\n① no：采购入库编号，一般是系统自动生成的，目前格式是 {prefix}{yyyymmdd}{6 位自增}。具体可见 erpnoredisdao 类。\n\n② status：入库状态，统一使用 erpauditstatus 枚举类，只有“未审批”、“已审批”两个状态。\n\n③ supplier_id：供应商编号，关联到上面的 erp_supplier 表。\n\naccount_id：结算账户编号，关联后续的 erp_account 表。暂时不用关注，它用于采购的付款。\n\n④ order_id 和 order_no：采购订单编号和采购订单号，关联到上面的 erp_purchase_order 表。\n\n⑤ total_count、total_price、total_product_price、total_tax_price、discount_percent、discount_price 和 other_price：合计数量、合计价格、合计产品价格、合计税额、优惠率、优惠金额和其它金额。\n\n其中，total_price 等于 total_product_price + total_tax_price + other_price - discount_price。\n\n⑥ payment_price：已付款金额，单位：元。暂时不用关注，它用于采购的付款。\n\n----------------------------------------\n\ncreate table `erp_purchase_in_items` (\n  `id` bigint not null auto_increment comment '编号',\n  \n  `in_id` bigint not null comment '采购入库编号',\n  \n  `order_item_id` bigint not null comment '采购订单项编号',\n  \n  `warehouse_id` bigint not null comment '仓库编号',\n  `product_id` bigint not null comment '产品编号',\n  \n  `product_unit_id` bigint not null comment '产品单位单位',\n  `product_price` decimal(24,6) not null comment '产品单价',\n  `count` decimal(24,6) not null comment '数量',\n  `total_price` decimal(24,6) not null comment '总价',\n  `tax_percent` decimal(24,6) default null comment '税率，百分比',\n  `tax_price` decimal(24,6) default null comment '税额，单位：元',\n\n  `remark` varchar(1024) character set utf8mb4 collate utf8mb4_0900_ai_ci default null comment '备注',\n  primary key (`id`)\n) engine=innodb auto_increment=30 default charset=utf8mb4 collate=utf8mb4_0900_ai_ci comment='erp 销售入库项表';\n\n\n① in_id：采购入库编号，关联到上面的 erp_purchase_in 表。\n\n② order_item_id：采购订单项编号，关联到上面的 erp_purchase_order_items 表，因为它需要对应的 in_count 字段。\n\n③ warehouse_id 和 product_id：分别关联到仓库和产品，因为它涉及到库存变更。\n\n④ product_unit_id、product_price、count、total_price、tax_percent 和 tax_price：产品单位编号、产品单价、数量、总价、税率和税额。\n\n其中 total_price 等于 product_price * count + tax_price。（额外多了税额）\n\n\n# 3.2 管理后台\n\n对应 [erp 系统 -> 采购管理 -> 采购入库] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/erp/purchase/in 目录。\n\n\n\n① 点击「新增」按钮，随便填写一些信息，点击「确认」按钮，即可新增一条采购入库。\n\n\n\n② 点击该采购入库的「审批」按钮，审批通过该采购入库，此时状态会变成“已审批”，同时会增加对应的库存、新增库存明细。如下图所示：\n\n\n\n③ 点击该采购入库的「反审批」按钮，反审批该采购入库，此时状态会变成“未审批”，同时会减少对应的库存、新增库存明细。如下图所示：\n\n\n\n\n# 4. 采购退货\n\n采购退货，由 erppurchasereturncontroller 提供接口，它会影响（减少）库存。总的来说，它的逻辑和 其它出库 基本一致，只是它是针对采购的出库。\n\n\n# 4.1 表结构\n\n友情提示：采购退货相关的表，和采购入库相关的表结构基本一致。\n\nerp_purchase_return 表和 erp_purchase_return_items 表，分别对应采购退货和采购退货项。\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `erp_purchase_return` (\n  `id` bigint not null auto_increment comment '编号',\n  `no` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '采购退货编号',\n  \n  `status` tinyint not null comment '退货状态',\n  `return_time` datetime not null comment '退货时间',\n  \n  `supplier_id` bigint not null comment '供应商编号',\n  `account_id` bigint not null comment '结算账户编号',\n  \n  `order_id` bigint not null comment '采购订单编号',\n  `order_no` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '采购订单号',\n  \n  `total_count` decimal(24,6) not null comment '合计数量',\n  `total_price` decimal(24,6) not null comment '合计价格，单位：元',\n  `total_product_price` decimal(24,6) not null comment '合计产品价格，单位：元',\n  `total_tax_price` decimal(24,6) not null comment '合计税额，单位：元',\n  `discount_percent` decimal(24,6) not null comment '优惠率，百分比',\n  `discount_price` decimal(24,6) not null comment '优惠金额，单位：元',\n  `other_price` decimal(24,6) not null default '0.000000' comment '其它金额，单位：元',\n\n  `refund_price` decimal(24,6) not null default '0.000000' comment '已退款金额，单位：元',\n  \n  `file_url` varchar(512) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '附件地址',\n  `remark` varchar(1024) character set utf8mb4 collate utf8mb4_0900_ai_ci default null comment '备注',\n  primary key (`id`),\n  unique key `no` (`no`)\n) engine=innodb auto_increment=25 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='erp 采购退货表';\n\n\n① no：采购退货编号，一般是系统自动生成的，目前格式是 {prefix}{yyyymmdd}{6 位自增}。具体可见 erpnoredisdao 类。\n\n② status：退货状态，统一使用 erpauditstatus 枚举类，只有“未审批”、“已审批”两个状态。\n\n③ supplier_id：供应商编号，关联到上面的 erp_supplier 表。\n\naccount_id：结算账户编号，关联后续的 erp_account 表。暂时不用关注，它用于采购的付款。\n\n④ order_id 和 order_no：采购订单编号和采购订单号，关联到上面的 erp_purchase_order 表。\n\n疑问：采购退货，为什么不是针对采购入库进行退货，而是针对采购订单进行退货呢？\n\n确实是有 erp 是针对采购入库进行退货的，不过相对比较少。和一些做 erp 的朋友交流过，他们的倾向于基于采购订单进行退货。\n\n⑤ total_count、total_price、total_product_price、total_tax_price、discount_percent、discount_price 和 other_price：合计数量、合计价格、合计产品价格、合计税额、优惠率、优惠金额和其它金额。\n\n其中，total_price 等于 total_product_price + total_tax_price + other_price - discount_price。\n\n【差异】⑥ refund_price：已退款金额，单位：元。暂时不用关注，它用于采购的付款。\n\n----------------------------------------\n\ncreate table `erp_purchase_return_items` (\n  `id` bigint not null auto_increment comment '编号',\n  \n  `return_id` bigint not null comment '采购退货编号',\n  \n  `order_item_id` bigint not null comment '采购订单项编号',\n  \n  `warehouse_id` bigint not null comment '仓库编号',\n  `product_id` bigint not null comment '产品编号',\n  \n  `product_unit_id` bigint not null comment '产品单位单位',\n  `product_price` decimal(24,6) not null comment '产品单价',\n  `count` decimal(24,6) not null comment '数量',\n  `total_price` decimal(24,6) not null comment '总价',\n  `tax_percent` decimal(24,6) default null comment '税率，百分比',\n  `tax_price` decimal(24,6) default null comment '税额，单位：元',\n\n  `remark` varchar(1024) character set utf8mb4 collate utf8mb4_0900_ai_ci default null comment '备注',\n  primary key (`id`)\n) engine=innodb auto_increment=45 default charset=utf8mb4 collate=utf8mb4_0900_ai_ci comment='erp 采购退货项表';\n\n\n① return_id：采购退货编号，关联到上面的 erp_purchase_return 表。\n\n② order_item_id：采购订单项编号，关联到上面的 erp_purchase_order_items 表，因为它需要对应的 return_count 字段。\n\n③ warehouse_id 和 product_id：分别关联到仓库和产品，因为它涉及到库存变更。\n\n④ product_unit_id、product_price、count、total_price、tax_percent 和 tax_price：产品单位编号、产品单价、数量、总价、税率和税额。\n\n其中 total_price 等于 product_price * count + tax_price。（额外多了税额）\n\n\n# 4.2 管理后台\n\n对应 [erp 系统 -> 采购管理 -> 采购退货] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/erp/purchase/return 目录。\n\n\n\n① 点击「新增」按钮，随便填写一些信息，点击「确认」按钮，即可新增一条采购退货。\n\n\n\n② 点击该采购退货的「审批」按钮，审批通过该采购退货，此时状态会变成“已审批”，同时会减少对应的库存、新增库存明细。如下图所示：\n\n\n\n③ 点击该采购退货的「反审批」按钮，反审批该采购退货，此时状态会变成“未审批”，同时会增加对应的库存、新增库存明细。如下图所示：\n\n\n\n\n# 5. 采购付款\n\n参见 《【财务】采购付款、销售收款》 文档。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【销售】销售订单、出库、退货",
            frontmatter: {
                title: "【销售】销售订单、出库、退货",
                date: "2024-02-16T21:11:11.000Z",
                permalink: "/erp/sale/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/15.ERP%E6%89%8B%E5%86%8C/40.%E3%80%90%E9%94%80%E5%94%AE%E3%80%91%E9%94%80%E5%94%AE%E8%AE%A2%E5%8D%95%E3%80%81%E5%87%BA%E5%BA%93%E3%80%81%E9%80%80%E8%B4%A7.html",
            relativePath: "01.开发指南/15.ERP手册/40.【销售】销售订单、出库、退货.md",
            key: "v-5a202116",
            path: "/erp/sale/",
            headers: [{
                level: 2,
                title: "1. 客户",
                slug: "_1-客户",
                normalizedTitle: "1. 客户",
                charIndex: 146
            }, {
                level: 3,
                title: "1.1 表结构",
                slug: "_1-1-表结构",
                normalizedTitle: "1.1 表结构",
                charIndex: 206
            }, {
                level: 3,
                title: "1.2 管理后台",
                slug: "_1-2-管理后台",
                normalizedTitle: "1.2 管理后台",
                charIndex: 1786
            }, {
                level: 2,
                title: "2. 销售订单",
                slug: "_2-销售订单",
                normalizedTitle: "2. 销售订单",
                charIndex: 1890
            }, {
                level: 3,
                title: "2.1 表结构",
                slug: "_2-1-表结构",
                normalizedTitle: "2.1 表结构",
                charIndex: 1967
            }, {
                level: 3,
                title: "2.2 管理后台",
                slug: "_2-2-管理后台",
                normalizedTitle: "2.2 管理后台",
                charIndex: 5342
            }, {
                level: 2,
                title: "3. 销售出库",
                slug: "_3-销售出库",
                normalizedTitle: "3. 销售出库",
                charIndex: 5539
            }, {
                level: 3,
                title: "3.1 表结构",
                slug: "_3-1-表结构",
                normalizedTitle: "3.1 表结构",
                charIndex: 5630
            }, {
                level: 3,
                title: "3.2 管理后台",
                slug: "_3-2-管理后台",
                normalizedTitle: "3.2 管理后台",
                charIndex: 9046
            }, {
                level: 2,
                title: "4. 销售退货",
                slug: "_4-销售退货",
                normalizedTitle: "4. 销售退货",
                charIndex: 9325
            }, {
                level: 3,
                title: "4.1 表结构",
                slug: "_4-1-表结构",
                normalizedTitle: "4.1 表结构",
                charIndex: 9419
            }, {
                level: 3,
                title: "4.2 管理后台",
                slug: "_4-2-管理后台",
                normalizedTitle: "4.2 管理后台",
                charIndex: 12897
            }, {
                level: 2,
                title: "5. 销售收款",
                slug: "_5-销售收款",
                normalizedTitle: "5. 销售收款",
                charIndex: 13179
            }],
            headersStr: "1. 客户 1.1 表结构 1.2 管理后台 2. 销售订单 2.1 表结构 2.2 管理后台 3. 销售出库 3.1 表结构 3.2 管理后台 4. 销售退货 4.1 表结构 4.2 管理后台 5. 销售收款",
            content: "友情提示：“销售”和“采购”目前是基本一致的，只是“销售”是向“客户”卖，“采购”是从“供应商”买。\n\n销售模块，由 yudao-module-erp-biz 后端模块的 sale 包实现，主要有销售订单、销售出库、销售退货等功能。如下图所示：\n\n\n\n它的整体流程，如下图所示：\n\n\n\n\n# 1. 客户\n\n客户，由 ErpCustomerController 提供接口，所有销售都是针对客户进行操作的。\n\n\n# 1.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `erp_customer` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '客户编号',\n  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '客户名称',\n  `contact` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '联系人',\n  `mobile` varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '手机号码',\n  `telephone` varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '联系电话',\n  `email` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '电子邮箱',\n  `fax` varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '传真',\n  `remark` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '备注',\n  `status` tinyint NOT NULL COMMENT '开启状态',\n  `sort` int NOT NULL COMMENT '排序',\n  `tax_no` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '纳税人识别号',\n  `tax_percent` decimal(24,6) DEFAULT NULL COMMENT '税率',\n  `bank_name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '开户行',\n  `bank_account` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '开户账号',\n  `bank_address` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '开户地址',\n  PRIMARY KEY (`id` DESC)\n) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='ERP 客户表';\n\n\n都是一些信息字段，仅仅用于展示，没有什么特殊逻辑。\n\n\n# 1.2 管理后台\n\n对应 [ERP 系统 -> 销售管理 -> 客户信息] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/erp/sale/customer 目录。\n\n\n\n\n# 2. 销售订单\n\n销售订单，由 ErpSaleOrderController 提供接口，它不会直接影响库存，只有在出库、退货等操作才会影响库存。\n\n\n# 2.1 表结构\n\nerp_sale_order 表和 erp_sale_order_items 表，分别对应销售订单和销售订单项。\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `erp_sale_order` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  \n  `no` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '销售单编号',\n  \n  `status` tinyint NOT NULL COMMENT '销售状态',\n  `order_time` datetime NOT NULL COMMENT '下单时间',\n  \n  `customer_id` bigint NOT NULL COMMENT '客户编号',\n  `account_id` bigint DEFAULT NULL COMMENT '结算账户编号',\n  `sale_user_id` bigint DEFAULT NULL COMMENT '销售用户编号',\n  \n  `total_count` decimal(24,6) NOT NULL COMMENT '合计数量',\n  `total_price` decimal(24,6) NOT NULL COMMENT '合计价格，单位：元',\n  `total_product_price` decimal(24,6) NOT NULL COMMENT '合计产品价格，单位：元',\n  `total_tax_price` decimal(24,6) NOT NULL COMMENT '合计税额，单位：元',\n  `discount_percent` decimal(24,6) NOT NULL COMMENT '优惠率，百分比',\n  `discount_price` decimal(24,6) NOT NULL COMMENT '优惠金额，单位：元',\n  `deposit_price` decimal(24,6) NOT NULL DEFAULT '0.000000' COMMENT '定金金额，单位：元',\n  \n  `file_url` varchar(512) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '附件地址',\n  `remark` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT '备注',\n  \n  `out_count` decimal(24,6) NOT NULL DEFAULT '0.000000' COMMENT '销售出库数量',\n  `return_count` decimal(24,6) NOT NULL DEFAULT '0.000000' COMMENT '销售退货数量',\n  \n  PRIMARY KEY (`id`),\n  UNIQUE KEY `no` (`no`)\n) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='ERP 销售订单表';\n\n\n① no：销售单号，一般是系统自动生成的，目前格式是 {prefix}{yyyyMMdd}{6 位自增}。具体可见 ErpNoRedisDAO 类。\n\n② status：销售状态，统一使用 ErpAuditStatus 枚举类，只有“未审批”、“已审批”两个状态。\n\n③ customer_id：客户编号，关联 erp_customer 表。\n\naccount_id：结算账户编号，关联后续的 erp_account 表。暂时不用关注，它用于销售的收款。\n\n④ total_count、total_price、total_product_price、total_tax_price、discount_percent、discount_price 和 deposit_price：合计数量、合计价格、合计产品价格、合计税额、优惠率、优惠金额和定金金额。\n\n⑤ out_count：该销售订单已经出库的数量。一个订单可以被多次销售出库，但是不能超过最大的 total_count，所以需要记录已经出库的数量。\n\n⑥ return_count：该销售订单已经退货的数量。一个订单可以被多次销售退货，但是不能超过最大的 total_count，所以需要记录已经退货的数量。\n\n----------------------------------------\n\nCREATE TABLE `erp_sale_order_items` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  \n  `order_id` bigint NOT NULL COMMENT '销售订单编号',\n  \n  `product_id` bigint NOT NULL COMMENT '产品编号',\n  \n  `product_unit_id` bigint NOT NULL COMMENT '产品单位单位',\n  `product_price` decimal(24,6) NOT NULL COMMENT '产品单价',\n  `count` decimal(24,6) NOT NULL COMMENT '数量',\n  `total_price` decimal(24,6) NOT NULL COMMENT '总价',\n  `tax_percent` decimal(24,6) DEFAULT NULL COMMENT '税率，百分比',\n  `tax_price` decimal(24,6) DEFAULT NULL COMMENT '税额，单位：元',\n  \n  `remark` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT '备注',\n  \n  `out_count` decimal(24,6) NOT NULL DEFAULT '0.000000' COMMENT '销售出库数量',\n  `return_count` decimal(24,6) NOT NULL DEFAULT '0.000000' COMMENT '销售退货数量',\n  \n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='ERP 销售订单项表';\n\n\n① order_id：销售订单编号，关联到上面的 erp_sale_order 表。\n\n② product_id：产品编号。\n\n注意，因为销售订单不直接涉及库存，所以它并没有 warehouse_id 字段，也就是说它不关心库存的具体仓库。\n\n③ product_unit_id、product_price、count、total_price、tax_percent 和 tax_price：产品单位编号、产品单价、数量、总价、税率和税额。\n\n其中 total_price 等于 product_price * count + tax_price。（额外多了税额）\n\n④ in_count 和 return_count：同 erp_sale_order 表，只是它表示的是该订单“项”的出库数量和退货数量，当然它也不能超过最大的 count。\n\n\n# 2.2 管理后台\n\n对应 [ERP 系统 -> 销售管理 -> 销售订单] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/erp/sale/order 目录。\n\n\n\n① 点击「新增」按钮，随便填写一些信息，点击「确认」按钮，即可新增一条销售订单。\n\n\n\n② 点击该销售订单的「审批」按钮，审批通过该销售订单，此时状态会变成“已审批”，但是并不会影响库存。\n\n\n# 3. 销售出库\n\n销售出库，由 ErpSaleOutController 提供接口，它会影响（减少）库存。总的来说，它的逻辑和 其它出库 基本一致，只是它是针对销售的出库。\n\n\n# 3.1 表结构\n\nerp_sale_out 表和 erp_sale_out_items 表，分别对应销售出库和销售出库项。\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `erp_sale_out` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  `no` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '销售出库编号',\n \n  `status` tinyint NOT NULL COMMENT '出库状态',\n  `out_time` datetime NOT NULL COMMENT '出库时间',\n\n  `customer_id` bigint NOT NULL COMMENT '客户编号',\n  `account_id` bigint NOT NULL COMMENT '结算账户编号',\n  `sale_user_id` bigint DEFAULT NULL COMMENT '销售用户编号',\n\n  `order_id` bigint NOT NULL COMMENT '销售订单编号',\n  `order_no` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '销售订单号',\n  \n  `total_count` decimal(24,6) NOT NULL COMMENT '合计数量',\n  `total_price` decimal(24,6) NOT NULL COMMENT '合计价格，单位：元',\n  `total_product_price` decimal(24,6) NOT NULL COMMENT '合计产品价格，单位：元',\n  `total_tax_price` decimal(24,6) NOT NULL COMMENT '合计税额，单位：元',\n  `discount_percent` decimal(24,6) NOT NULL COMMENT '优惠率，百分比',\n  `discount_price` decimal(24,6) NOT NULL COMMENT '优惠金额，单位：元',\n  `other_price` decimal(24,6) NOT NULL DEFAULT '0.000000' COMMENT '其它金额，单位：元',\n\n  `receipt_price` decimal(24,6) NOT NULL DEFAULT '0.000000' COMMENT '已收款金额，单位：元',\n  \n  `file_url` varchar(512) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '附件地址',\n  `remark` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT '备注',\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `no` (`no`)\n) ENGINE=InnoDB AUTO_INCREMENT=15 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='ERP 销售出库表';\n\n\n① no：销售出库编号，一般是系统自动生成的，目前格式是 {prefix}{yyyyMMdd}{6 位自增}。具体可见 ErpNoRedisDAO 类。\n\n② status：出库状态，统一使用 ErpAuditStatus 枚举类，只有“未审批”、“已审批”两个状态。\n\n③ customer_id：客户编号，关联 erp_customer 表。\n\naccount_id：结算账户编号，关联后续的 erp_account 表。暂时不用关注，它用于销售的收款。\n\n④ order_id 和 order_no：销售订单编号和销售订单号，关联到上面的 erp_sale_order 表。\n\n⑤ total_count、total_price、total_product_price、total_tax_price、discount_percent、discount_price 和 other_price：合计数量、合计价格、合计产品价格、合计税额、优惠率、优惠金额和其它金额。\n\n其中，total_price 等于 total_product_price + total_tax_price + other_price - discount_price。\n\n⑥ receipt_price：已收款金额，单位：元。暂时不用关注，它用于销售的收款。\n\n----------------------------------------\n\nCREATE TABLE `erp_sale_out_items` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  \n  `out_id` bigint NOT NULL COMMENT '销售出库编号',\n  \n  `order_item_id` bigint NOT NULL COMMENT '销售订单项编号',\n  \n  `warehouse_id` bigint NOT NULL COMMENT '仓库编号',\n  `product_id` bigint NOT NULL COMMENT '产品编号',\n  \n  `product_unit_id` bigint NOT NULL COMMENT '产品单位单位',\n  `product_price` decimal(24,6) NOT NULL COMMENT '产品单价',\n  `count` decimal(24,6) NOT NULL COMMENT '数量',\n  `total_price` decimal(24,6) NOT NULL COMMENT '总价',\n  `tax_percent` decimal(24,6) DEFAULT NULL COMMENT '税率，百分比',\n  `tax_price` decimal(24,6) DEFAULT NULL COMMENT '税额，单位：元',\n\n  `remark` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT '备注',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=27 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='ERP 销售出库项表';\n\n\n① out_id：销售出库编号，关联到上面的 erp_sale_out 表。\n\n② order_item_id：销售订单项编号，关联到上面的 erp_sale_order_items 表，因为它需要对应的 out_count 字段。\n\n③ warehouse_id 和 product_id：分别关联到仓库和产品，因为它涉及到库存变更。\n\n④ product_unit_id、product_price、count、total_price、tax_percent 和 tax_price：产品单位编号、产品单价、数量、总价、税率和税额。\n\n其中 total_price 等于 product_price * count + tax_price。（额外多了税额）\n\n\n# 3.2 管理后台\n\n对应 [ERP 系统 -> 销售管理 -> 销售出库] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/erp/sale/out 目录。\n\n\n\n① 点击「新增」按钮，随便填写一些信息，点击「确认」按钮，即可新增一条销售出库。\n\n\n\n② 点击该销售出库的「审批」按钮，审批通过该销售出库，此时状态会变成“已审批”，同时会减少对应的库存、新增库存明细。如下图所示：\n\n\n\n③ 点击该销售出库的「反审批」按钮，反审批该销售出库，此时状态会变成“未审批”，同时会增加对应的库存、新增库存明细。如下图所示：\n\n\n\n\n# 4. 销售退货\n\n销售退货，由 ErpSaleReturnController 提供接口，它会影响（增加）库存。总的来说，它的逻辑和 其它入库 基本一致，只是它是针对销售的入库。\n\n\n# 4.1 表结构\n\n友情提示：销售退货相关的表，和销售出库相关的表结构基本一致。\n\nerp_sale_return 表和 erp_sale_return_items 表，分别对应销售退货和销售退货项。\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `erp_sale_return` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  `no` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '销售退货编号',\n  \n  `status` tinyint NOT NULL COMMENT '退货状态',\n  `return_time` datetime NOT NULL COMMENT '退货时间',\n\n  `customer_id` bigint NOT NULL COMMENT '客户编号',\n  `account_id` bigint NOT NULL COMMENT '结算账户编号',\n  `sale_user_id` bigint DEFAULT NULL COMMENT '销售用户编号',\n\n  `order_id` bigint NOT NULL COMMENT '销售订单编号',\n  `order_no` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '销售订单号',\n  \n  `total_count` decimal(24,6) NOT NULL COMMENT '合计数量',\n  `total_price` decimal(24,6) NOT NULL COMMENT '合计价格，单位：元',\n  `total_product_price` decimal(24,6) NOT NULL COMMENT '合计产品价格，单位：元',\n  `total_tax_price` decimal(24,6) NOT NULL COMMENT '合计税额，单位：元',\n  `discount_percent` decimal(24,6) NOT NULL COMMENT '优惠率，百分比',\n  `discount_price` decimal(24,6) NOT NULL COMMENT '优惠金额，单位：元',\n  `other_price` decimal(24,6) NOT NULL DEFAULT '0.000000' COMMENT '其它金额，单位：元',\n\n  `refund_price` decimal(24,6) NOT NULL DEFAULT '0.000000' COMMENT '已退款金额，单位：元',\n  \n  `file_url` varchar(512) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '附件地址',\n  `remark` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT '备注',\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `no` (`no`)\n) ENGINE=InnoDB AUTO_INCREMENT=23 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='ERP 销售退货表';\n\n\n① no：销售退货编号，一般是系统自动生成的，目前格式是 {prefix}{yyyyMMdd}{6 位自增}。具体可见 ErpNoRedisDAO 类。\n\n② status：退货状态，统一使用 ErpAuditStatus 枚举类，只有“未审批”、“已审批”两个状态。\n\n③ customer_id：客户编号，关联 erp_customer 表。\n\naccount_id：结算账户编号，关联后续的 erp_account 表。暂时不用关注，它用于销售的收款。\n\n④ order_id 和 order_no：销售订单编号和销售订单号，关联到上面的 erp_sale_order 表。\n\n⑤ total_count、total_price、total_product_price、total_tax_price、discount_percent、discount_price 和 other_price：合计数量、合计价格、合计产品价格、合计税额、优惠率、优惠金额和其它金额。\n\n其中，total_price 等于 total_product_price + total_tax_price + other_price - discount_price。\n\n【差异】⑥ refund_price：已退款金额，单位：元。暂时不用关注，它用于销售的收款。\n\n----------------------------------------\n\nCREATE TABLE `erp_sale_return_items` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  \n  `return_id` bigint NOT NULL COMMENT '销售退货编号',\n  \n  `order_item_id` bigint NOT NULL COMMENT '销售订单项编号',\n  \n  `warehouse_id` bigint NOT NULL COMMENT '仓库编号',\n  `product_id` bigint NOT NULL COMMENT '产品编号',\n  \n  `product_unit_id` bigint NOT NULL COMMENT '产品单位单位',\n  `product_price` decimal(24,6) NOT NULL COMMENT '产品单价',\n  `count` decimal(24,6) NOT NULL COMMENT '数量',\n  `total_price` decimal(24,6) NOT NULL COMMENT '总价',\n  `tax_percent` decimal(24,6) DEFAULT NULL COMMENT '税率，百分比',\n  `tax_price` decimal(24,6) DEFAULT NULL COMMENT '税额，单位：元',\n\n  `remark` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT '备注',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=43 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='ERP 销售退货项表';\n\n\n① return_id：销售退货编号，关联到上面的 erp_sale_return 表。\n\n② order_item_id：销售订单项编号，关联到上面的 erp_sale_order_items 表，因为它需要对应的 return_count 字段。\n\n③ warehouse_id 和 product_id：分别关联到仓库和产品，因为它涉及到库存变更。\n\n④ product_unit_id、product_price、count、total_price、tax_percent 和 tax_price：产品单位编号、产品单价、数量、总价、税率和税额。\n\n其中 total_price 等于 product_price * count + tax_price。（额外多了税额）\n\n\n# 4.2 管理后台\n\n对应 [ERP 系统 -> 销售管理 -> 销售退货] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/erp/sale/return 目录。\n\n\n\n① 点击「新增」按钮，随便填写一些信息，点击「确认」按钮，即可新增一条销售退货。\n\n\n\n② 点击该销售退货的「审批」按钮，审批通过该销售退货，此时状态会变成“已审批”，同时会增加对应的库存、新增库存明细。如下图所示：\n\n\n\n③ 点击该销售退货的「反审批」按钮，反审批该销售退货，此时状态会变成“未审批”，同时会减少对应的库存、新增库存明细。如下图所示：\n\n\n\n\n# 5. 销售收款\n\n参见 《【财务】采购付款、销售收款》 文档。",
            normalizedContent: "友情提示：“销售”和“采购”目前是基本一致的，只是“销售”是向“客户”卖，“采购”是从“供应商”买。\n\n销售模块，由 yudao-module-erp-biz 后端模块的 sale 包实现，主要有销售订单、销售出库、销售退货等功能。如下图所示：\n\n\n\n它的整体流程，如下图所示：\n\n\n\n\n# 1. 客户\n\n客户，由 erpcustomercontroller 提供接口，所有销售都是针对客户进行操作的。\n\n\n# 1.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `erp_customer` (\n  `id` bigint not null auto_increment comment '客户编号',\n  `name` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '客户名称',\n  `contact` varchar(100) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '联系人',\n  `mobile` varchar(30) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '手机号码',\n  `telephone` varchar(30) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '联系电话',\n  `email` varchar(50) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '电子邮箱',\n  `fax` varchar(30) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '传真',\n  `remark` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '备注',\n  `status` tinyint not null comment '开启状态',\n  `sort` int not null comment '排序',\n  `tax_no` varchar(50) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '纳税人识别号',\n  `tax_percent` decimal(24,6) default null comment '税率',\n  `bank_name` varchar(50) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '开户行',\n  `bank_account` varchar(50) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '开户账号',\n  `bank_address` varchar(50) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '开户地址',\n  primary key (`id` desc)\n) engine=innodb auto_increment=3 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='erp 客户表';\n\n\n都是一些信息字段，仅仅用于展示，没有什么特殊逻辑。\n\n\n# 1.2 管理后台\n\n对应 [erp 系统 -> 销售管理 -> 客户信息] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/erp/sale/customer 目录。\n\n\n\n\n# 2. 销售订单\n\n销售订单，由 erpsaleordercontroller 提供接口，它不会直接影响库存，只有在出库、退货等操作才会影响库存。\n\n\n# 2.1 表结构\n\nerp_sale_order 表和 erp_sale_order_items 表，分别对应销售订单和销售订单项。\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `erp_sale_order` (\n  `id` bigint not null auto_increment comment '编号',\n  \n  `no` varchar(255) collate utf8mb4_unicode_ci not null comment '销售单编号',\n  \n  `status` tinyint not null comment '销售状态',\n  `order_time` datetime not null comment '下单时间',\n  \n  `customer_id` bigint not null comment '客户编号',\n  `account_id` bigint default null comment '结算账户编号',\n  `sale_user_id` bigint default null comment '销售用户编号',\n  \n  `total_count` decimal(24,6) not null comment '合计数量',\n  `total_price` decimal(24,6) not null comment '合计价格，单位：元',\n  `total_product_price` decimal(24,6) not null comment '合计产品价格，单位：元',\n  `total_tax_price` decimal(24,6) not null comment '合计税额，单位：元',\n  `discount_percent` decimal(24,6) not null comment '优惠率，百分比',\n  `discount_price` decimal(24,6) not null comment '优惠金额，单位：元',\n  `deposit_price` decimal(24,6) not null default '0.000000' comment '定金金额，单位：元',\n  \n  `file_url` varchar(512) collate utf8mb4_unicode_ci default null comment '附件地址',\n  `remark` varchar(1024) character set utf8mb4 collate utf8mb4_0900_ai_ci default null comment '备注',\n  \n  `out_count` decimal(24,6) not null default '0.000000' comment '销售出库数量',\n  `return_count` decimal(24,6) not null default '0.000000' comment '销售退货数量',\n  \n  primary key (`id`),\n  unique key `no` (`no`)\n) engine=innodb auto_increment=6 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='erp 销售订单表';\n\n\n① no：销售单号，一般是系统自动生成的，目前格式是 {prefix}{yyyymmdd}{6 位自增}。具体可见 erpnoredisdao 类。\n\n② status：销售状态，统一使用 erpauditstatus 枚举类，只有“未审批”、“已审批”两个状态。\n\n③ customer_id：客户编号，关联 erp_customer 表。\n\naccount_id：结算账户编号，关联后续的 erp_account 表。暂时不用关注，它用于销售的收款。\n\n④ total_count、total_price、total_product_price、total_tax_price、discount_percent、discount_price 和 deposit_price：合计数量、合计价格、合计产品价格、合计税额、优惠率、优惠金额和定金金额。\n\n⑤ out_count：该销售订单已经出库的数量。一个订单可以被多次销售出库，但是不能超过最大的 total_count，所以需要记录已经出库的数量。\n\n⑥ return_count：该销售订单已经退货的数量。一个订单可以被多次销售退货，但是不能超过最大的 total_count，所以需要记录已经退货的数量。\n\n----------------------------------------\n\ncreate table `erp_sale_order_items` (\n  `id` bigint not null auto_increment comment '编号',\n  \n  `order_id` bigint not null comment '销售订单编号',\n  \n  `product_id` bigint not null comment '产品编号',\n  \n  `product_unit_id` bigint not null comment '产品单位单位',\n  `product_price` decimal(24,6) not null comment '产品单价',\n  `count` decimal(24,6) not null comment '数量',\n  `total_price` decimal(24,6) not null comment '总价',\n  `tax_percent` decimal(24,6) default null comment '税率，百分比',\n  `tax_price` decimal(24,6) default null comment '税额，单位：元',\n  \n  `remark` varchar(1024) character set utf8mb4 collate utf8mb4_0900_ai_ci default null comment '备注',\n  \n  `out_count` decimal(24,6) not null default '0.000000' comment '销售出库数量',\n  `return_count` decimal(24,6) not null default '0.000000' comment '销售退货数量',\n  \n  primary key (`id`)\n) engine=innodb auto_increment=7 default charset=utf8mb4 collate=utf8mb4_0900_ai_ci comment='erp 销售订单项表';\n\n\n① order_id：销售订单编号，关联到上面的 erp_sale_order 表。\n\n② product_id：产品编号。\n\n注意，因为销售订单不直接涉及库存，所以它并没有 warehouse_id 字段，也就是说它不关心库存的具体仓库。\n\n③ product_unit_id、product_price、count、total_price、tax_percent 和 tax_price：产品单位编号、产品单价、数量、总价、税率和税额。\n\n其中 total_price 等于 product_price * count + tax_price。（额外多了税额）\n\n④ in_count 和 return_count：同 erp_sale_order 表，只是它表示的是该订单“项”的出库数量和退货数量，当然它也不能超过最大的 count。\n\n\n# 2.2 管理后台\n\n对应 [erp 系统 -> 销售管理 -> 销售订单] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/erp/sale/order 目录。\n\n\n\n① 点击「新增」按钮，随便填写一些信息，点击「确认」按钮，即可新增一条销售订单。\n\n\n\n② 点击该销售订单的「审批」按钮，审批通过该销售订单，此时状态会变成“已审批”，但是并不会影响库存。\n\n\n# 3. 销售出库\n\n销售出库，由 erpsaleoutcontroller 提供接口，它会影响（减少）库存。总的来说，它的逻辑和 其它出库 基本一致，只是它是针对销售的出库。\n\n\n# 3.1 表结构\n\nerp_sale_out 表和 erp_sale_out_items 表，分别对应销售出库和销售出库项。\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `erp_sale_out` (\n  `id` bigint not null auto_increment comment '编号',\n  `no` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '销售出库编号',\n \n  `status` tinyint not null comment '出库状态',\n  `out_time` datetime not null comment '出库时间',\n\n  `customer_id` bigint not null comment '客户编号',\n  `account_id` bigint not null comment '结算账户编号',\n  `sale_user_id` bigint default null comment '销售用户编号',\n\n  `order_id` bigint not null comment '销售订单编号',\n  `order_no` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '销售订单号',\n  \n  `total_count` decimal(24,6) not null comment '合计数量',\n  `total_price` decimal(24,6) not null comment '合计价格，单位：元',\n  `total_product_price` decimal(24,6) not null comment '合计产品价格，单位：元',\n  `total_tax_price` decimal(24,6) not null comment '合计税额，单位：元',\n  `discount_percent` decimal(24,6) not null comment '优惠率，百分比',\n  `discount_price` decimal(24,6) not null comment '优惠金额，单位：元',\n  `other_price` decimal(24,6) not null default '0.000000' comment '其它金额，单位：元',\n\n  `receipt_price` decimal(24,6) not null default '0.000000' comment '已收款金额，单位：元',\n  \n  `file_url` varchar(512) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '附件地址',\n  `remark` varchar(1024) character set utf8mb4 collate utf8mb4_0900_ai_ci default null comment '备注',\n  primary key (`id`),\n  unique key `no` (`no`)\n) engine=innodb auto_increment=15 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='erp 销售出库表';\n\n\n① no：销售出库编号，一般是系统自动生成的，目前格式是 {prefix}{yyyymmdd}{6 位自增}。具体可见 erpnoredisdao 类。\n\n② status：出库状态，统一使用 erpauditstatus 枚举类，只有“未审批”、“已审批”两个状态。\n\n③ customer_id：客户编号，关联 erp_customer 表。\n\naccount_id：结算账户编号，关联后续的 erp_account 表。暂时不用关注，它用于销售的收款。\n\n④ order_id 和 order_no：销售订单编号和销售订单号，关联到上面的 erp_sale_order 表。\n\n⑤ total_count、total_price、total_product_price、total_tax_price、discount_percent、discount_price 和 other_price：合计数量、合计价格、合计产品价格、合计税额、优惠率、优惠金额和其它金额。\n\n其中，total_price 等于 total_product_price + total_tax_price + other_price - discount_price。\n\n⑥ receipt_price：已收款金额，单位：元。暂时不用关注，它用于销售的收款。\n\n----------------------------------------\n\ncreate table `erp_sale_out_items` (\n  `id` bigint not null auto_increment comment '编号',\n  \n  `out_id` bigint not null comment '销售出库编号',\n  \n  `order_item_id` bigint not null comment '销售订单项编号',\n  \n  `warehouse_id` bigint not null comment '仓库编号',\n  `product_id` bigint not null comment '产品编号',\n  \n  `product_unit_id` bigint not null comment '产品单位单位',\n  `product_price` decimal(24,6) not null comment '产品单价',\n  `count` decimal(24,6) not null comment '数量',\n  `total_price` decimal(24,6) not null comment '总价',\n  `tax_percent` decimal(24,6) default null comment '税率，百分比',\n  `tax_price` decimal(24,6) default null comment '税额，单位：元',\n\n  `remark` varchar(1024) character set utf8mb4 collate utf8mb4_0900_ai_ci default null comment '备注',\n  primary key (`id`)\n) engine=innodb auto_increment=27 default charset=utf8mb4 collate=utf8mb4_0900_ai_ci comment='erp 销售出库项表';\n\n\n① out_id：销售出库编号，关联到上面的 erp_sale_out 表。\n\n② order_item_id：销售订单项编号，关联到上面的 erp_sale_order_items 表，因为它需要对应的 out_count 字段。\n\n③ warehouse_id 和 product_id：分别关联到仓库和产品，因为它涉及到库存变更。\n\n④ product_unit_id、product_price、count、total_price、tax_percent 和 tax_price：产品单位编号、产品单价、数量、总价、税率和税额。\n\n其中 total_price 等于 product_price * count + tax_price。（额外多了税额）\n\n\n# 3.2 管理后台\n\n对应 [erp 系统 -> 销售管理 -> 销售出库] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/erp/sale/out 目录。\n\n\n\n① 点击「新增」按钮，随便填写一些信息，点击「确认」按钮，即可新增一条销售出库。\n\n\n\n② 点击该销售出库的「审批」按钮，审批通过该销售出库，此时状态会变成“已审批”，同时会减少对应的库存、新增库存明细。如下图所示：\n\n\n\n③ 点击该销售出库的「反审批」按钮，反审批该销售出库，此时状态会变成“未审批”，同时会增加对应的库存、新增库存明细。如下图所示：\n\n\n\n\n# 4. 销售退货\n\n销售退货，由 erpsalereturncontroller 提供接口，它会影响（增加）库存。总的来说，它的逻辑和 其它入库 基本一致，只是它是针对销售的入库。\n\n\n# 4.1 表结构\n\n友情提示：销售退货相关的表，和销售出库相关的表结构基本一致。\n\nerp_sale_return 表和 erp_sale_return_items 表，分别对应销售退货和销售退货项。\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `erp_sale_return` (\n  `id` bigint not null auto_increment comment '编号',\n  `no` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '销售退货编号',\n  \n  `status` tinyint not null comment '退货状态',\n  `return_time` datetime not null comment '退货时间',\n\n  `customer_id` bigint not null comment '客户编号',\n  `account_id` bigint not null comment '结算账户编号',\n  `sale_user_id` bigint default null comment '销售用户编号',\n\n  `order_id` bigint not null comment '销售订单编号',\n  `order_no` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '销售订单号',\n  \n  `total_count` decimal(24,6) not null comment '合计数量',\n  `total_price` decimal(24,6) not null comment '合计价格，单位：元',\n  `total_product_price` decimal(24,6) not null comment '合计产品价格，单位：元',\n  `total_tax_price` decimal(24,6) not null comment '合计税额，单位：元',\n  `discount_percent` decimal(24,6) not null comment '优惠率，百分比',\n  `discount_price` decimal(24,6) not null comment '优惠金额，单位：元',\n  `other_price` decimal(24,6) not null default '0.000000' comment '其它金额，单位：元',\n\n  `refund_price` decimal(24,6) not null default '0.000000' comment '已退款金额，单位：元',\n  \n  `file_url` varchar(512) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '附件地址',\n  `remark` varchar(1024) character set utf8mb4 collate utf8mb4_0900_ai_ci default null comment '备注',\n  primary key (`id`),\n  unique key `no` (`no`)\n) engine=innodb auto_increment=23 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='erp 销售退货表';\n\n\n① no：销售退货编号，一般是系统自动生成的，目前格式是 {prefix}{yyyymmdd}{6 位自增}。具体可见 erpnoredisdao 类。\n\n② status：退货状态，统一使用 erpauditstatus 枚举类，只有“未审批”、“已审批”两个状态。\n\n③ customer_id：客户编号，关联 erp_customer 表。\n\naccount_id：结算账户编号，关联后续的 erp_account 表。暂时不用关注，它用于销售的收款。\n\n④ order_id 和 order_no：销售订单编号和销售订单号，关联到上面的 erp_sale_order 表。\n\n⑤ total_count、total_price、total_product_price、total_tax_price、discount_percent、discount_price 和 other_price：合计数量、合计价格、合计产品价格、合计税额、优惠率、优惠金额和其它金额。\n\n其中，total_price 等于 total_product_price + total_tax_price + other_price - discount_price。\n\n【差异】⑥ refund_price：已退款金额，单位：元。暂时不用关注，它用于销售的收款。\n\n----------------------------------------\n\ncreate table `erp_sale_return_items` (\n  `id` bigint not null auto_increment comment '编号',\n  \n  `return_id` bigint not null comment '销售退货编号',\n  \n  `order_item_id` bigint not null comment '销售订单项编号',\n  \n  `warehouse_id` bigint not null comment '仓库编号',\n  `product_id` bigint not null comment '产品编号',\n  \n  `product_unit_id` bigint not null comment '产品单位单位',\n  `product_price` decimal(24,6) not null comment '产品单价',\n  `count` decimal(24,6) not null comment '数量',\n  `total_price` decimal(24,6) not null comment '总价',\n  `tax_percent` decimal(24,6) default null comment '税率，百分比',\n  `tax_price` decimal(24,6) default null comment '税额，单位：元',\n\n  `remark` varchar(1024) character set utf8mb4 collate utf8mb4_0900_ai_ci default null comment '备注',\n  primary key (`id`)\n) engine=innodb auto_increment=43 default charset=utf8mb4 collate=utf8mb4_0900_ai_ci comment='erp 销售退货项表';\n\n\n① return_id：销售退货编号，关联到上面的 erp_sale_return 表。\n\n② order_item_id：销售订单项编号，关联到上面的 erp_sale_order_items 表，因为它需要对应的 return_count 字段。\n\n③ warehouse_id 和 product_id：分别关联到仓库和产品，因为它涉及到库存变更。\n\n④ product_unit_id、product_price、count、total_price、tax_percent 和 tax_price：产品单位编号、产品单价、数量、总价、税率和税额。\n\n其中 total_price 等于 product_price * count + tax_price。（额外多了税额）\n\n\n# 4.2 管理后台\n\n对应 [erp 系统 -> 销售管理 -> 销售退货] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/erp/sale/return 目录。\n\n\n\n① 点击「新增」按钮，随便填写一些信息，点击「确认」按钮，即可新增一条销售退货。\n\n\n\n② 点击该销售退货的「审批」按钮，审批通过该销售退货，此时状态会变成“已审批”，同时会增加对应的库存、新增库存明细。如下图所示：\n\n\n\n③ 点击该销售退货的「反审批」按钮，反审批该销售退货，此时状态会变成“未审批”，同时会减少对应的库存、新增库存明细。如下图所示：\n\n\n\n\n# 5. 销售收款\n\n参见 《【财务】采购付款、销售收款》 文档。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "功能开启",
            frontmatter: {
                title: "功能开启",
                date: "2023-11-25T18:06:45.000Z",
                permalink: "/crm/build/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/16.CRM%E6%89%8B%E5%86%8C/02.%E5%8A%9F%E8%83%BD%E5%BC%80%E5%90%AF.html",
            relativePath: "01.开发指南/16.CRM手册/02.功能开启.md",
            key: "v-299d87aa",
            path: "/crm/build/",
            headers: [{
                level: 2,
                title: "1. 第一步，开启模块",
                slug: "_1-第一步-开启模块",
                normalizedTitle: "1. 第一步，开启模块",
                charIndex: 449
            }, {
                level: 2,
                title: "2. 第二步，导入 SQL",
                slug: "_2-第二步-导入-sql",
                normalizedTitle: "2. 第二步，导入 sql",
                charIndex: 651
            }, {
                level: 2,
                title: "3. 第三步，重启项目",
                slug: "_3-第三步-重启项目",
                normalizedTitle: "3. 第三步，重启项目",
                charIndex: 745
            }],
            headersStr: "1. 第一步，开启模块 2. 第二步，导入 SQL 3. 第三步，重启项目",
            content: "进度说明：\n\n * 管理后台，请使用 https://gitee.com/yudaocode/yudao-ui-admin-vue3 仓库的 master 分支\n * 后端项目，请使用 https://gitee.com/zhijiantianya/ruoyi-vue-pro 仓库的 master（JDK8） 或 master-jdk17（JDK17//21） 分支\n\nCRM 系统，后端由 yudao-module-crm 模块实现，前端由 yudao-ui-admin-vue3 的 crm 目录实现。\n\n考虑到编译速度，默认 yudao-module-crm 模块是关闭的，需要手动开启。步骤如下：\n\n * 第一步，开启 yudao-module-crm 模块\n * 第二步，导入 CRM 系统的 SQL 数据库脚本\n * 第三步，重启后端项目，确认功能是否生效\n\n补充说明：\n\n由于 CRM 合同、回款使用到 BPM 的审批功能，所以你需要先看 《工作流》 文档，将工作流开启！\n\n\n# 1. 第一步，开启模块\n\n① 修改根目录的 pom.xml 文件，取消 yudao-module-crm 模块的注释。如下图所示：\n\n\n\n② 修改 yudao-server 目录的 pom.xml 文件，引入 yudao-module-crm 模块。如下图所示：\n\n\n\n③ 点击 IDEA 右上角的【Reload All Maven Projects】，刷新 Maven 依赖。如下图所示：\n\n\n\n\n# 2. 第二步，导入 SQL\n\n点击 crm-2024-02-26.sql.zip 下载附件，解压出 SQL 文件，然后导入到数据库中。\n\n所以表名字，都使用 crm_ 作为前缀。\n\n\n# 3. 第三步，重启项目\n\n重启后端项目，然后访问前端的 CRM 城菜单，确认功能是否生效。如下图所示：\n\n\n\n至此，我们就成功开启了 CRM 的功能 🙂",
            normalizedContent: "进度说明：\n\n * 管理后台，请使用 https://gitee.com/yudaocode/yudao-ui-admin-vue3 仓库的 master 分支\n * 后端项目，请使用 https://gitee.com/zhijiantianya/ruoyi-vue-pro 仓库的 master（jdk8） 或 master-jdk17（jdk17//21） 分支\n\ncrm 系统，后端由 yudao-module-crm 模块实现，前端由 yudao-ui-admin-vue3 的 crm 目录实现。\n\n考虑到编译速度，默认 yudao-module-crm 模块是关闭的，需要手动开启。步骤如下：\n\n * 第一步，开启 yudao-module-crm 模块\n * 第二步，导入 crm 系统的 sql 数据库脚本\n * 第三步，重启后端项目，确认功能是否生效\n\n补充说明：\n\n由于 crm 合同、回款使用到 bpm 的审批功能，所以你需要先看 《工作流》 文档，将工作流开启！\n\n\n# 1. 第一步，开启模块\n\n① 修改根目录的 pom.xml 文件，取消 yudao-module-crm 模块的注释。如下图所示：\n\n\n\n② 修改 yudao-server 目录的 pom.xml 文件，引入 yudao-module-crm 模块。如下图所示：\n\n\n\n③ 点击 idea 右上角的【reload all maven projects】，刷新 maven 依赖。如下图所示：\n\n\n\n\n# 2. 第二步，导入 sql\n\n点击 crm-2024-02-26.sql.zip 下载附件，解压出 sql 文件，然后导入到数据库中。\n\n所以表名字，都使用 crm_ 作为前缀。\n\n\n# 3. 第三步，重启项目\n\n重启后端项目，然后访问前端的 crm 城菜单，确认功能是否生效。如下图所示：\n\n\n\n至此，我们就成功开启了 crm 的功能 🙂",
            charsets: {
                cjk: !0
            }
        }, {
            title: "CRM 演示",
            frontmatter: {
                title: "CRM 演示",
                date: "2024-02-23T08:25:56.000Z",
                permalink: "/crm-preview"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/16.CRM%E6%89%8B%E5%86%8C/01.CRM%20%E6%BC%94%E7%A4%BA.html",
            relativePath: "01.开发指南/16.CRM手册/01.CRM 演示.md",
            key: "v-ffef209a",
            path: "/crm-preview/",
            headers: [{
                level: 2,
                title: "1. 演示地址",
                slug: "_1-演示地址",
                normalizedTitle: "1. 演示地址",
                charIndex: 2
            }, {
                level: 3,
                title: "1.1 CRM 管理后台",
                slug: "_1-1-crm-管理后台",
                normalizedTitle: "1.1 crm 管理后台",
                charIndex: 14
            }, {
                level: 3,
                title: "1.2 CRM 后端",
                slug: "_1-2-crm-后端",
                normalizedTitle: "1.2 crm 后端",
                charIndex: 256
            }, {
                level: 2,
                title: "2. CRM 启动",
                slug: "_2-crm-启动",
                normalizedTitle: "2. crm 启动",
                charIndex: 451
            }, {
                level: 2,
                title: "3. CRM 交流",
                slug: "_3-crm-交流",
                normalizedTitle: "3. crm 交流",
                charIndex: 505
            }, {
                level: 2,
                title: "4. 功能描述",
                slug: "_4-功能描述",
                normalizedTitle: "4. 功能描述",
                charIndex: 537
            }, {
                level: 2,
                title: "5. 表结构",
                slug: "_5-表结构",
                normalizedTitle: "5. 表结构",
                charIndex: 584
            }, {
                level: 3,
                title: "5.1 线索管理",
                slug: "_5-1-线索管理",
                normalizedTitle: "5.1 线索管理",
                charIndex: 651
            }, {
                level: 3,
                title: "5.2 客户管理",
                slug: "_5-2-客户管理",
                normalizedTitle: "5.2 客户管理",
                charIndex: 706
            }, {
                level: 2,
                title: "5.3 商机管理",
                slug: "_5-3-商机管理",
                normalizedTitle: "5.3 商机管理",
                charIndex: 765
            }, {
                level: 2,
                title: "5.4 合同管理",
                slug: "_5-4-合同管理",
                normalizedTitle: "5.4 合同管理",
                charIndex: 829
            }, {
                level: 2,
                title: "5.5 回款管理",
                slug: "_5-5-回款管理",
                normalizedTitle: "5.5 回款管理",
                charIndex: 893
            }, {
                level: 2,
                title: "5.6 产品管理",
                slug: "_5-6-产品管理",
                normalizedTitle: "5.6 产品管理",
                charIndex: 959
            }, {
                level: 2,
                title: "5.7 通用模块",
                slug: "_5-7-通用模块",
                normalizedTitle: "5.7 通用模块",
                charIndex: 1022
            }, {
                level: 2,
                title: "5.8 数据统计",
                slug: "_5-8-数据统计",
                normalizedTitle: "5.8 数据统计",
                charIndex: 1069
            }],
            headersStr: "1. 演示地址 1.1 CRM 管理后台 1.2 CRM 后端 2. CRM 启动 3. CRM 交流 4. 功能描述 5. 表结构 5.1 线索管理 5.2 客户管理 5.3 商机管理 5.4 合同管理 5.5 回款管理 5.6 产品管理 5.7 通用模块 5.8 数据统计",
            content: "# 1. 演示地址\n\n\n# 1.1 CRM 管理后台\n\n * 演示地址：http://dashboard-vue3.yudao.iocoder.cn/\n * 菜单：“CRM 系统”下的「待办事项」「线索管理」「客户管理」「联系人管理」「客户公海」「商机管理」「合同管理」「回款计划」「还款管理」「产品管理」「数据统计」\n * 仓库：https://github.com/yudaocode/yudao-ui-admin-vue3 的 crm 目录，基于 Vue3 + Element Plus 实现\n\n\n\n\n# 1.2 CRM 后端\n\n支持 Spring Boot 单体、Spring Cloud 微服务架构\n\n * 单体仓库： https://github.com/YunaiV/ruoyi-vue-pro 的 yudao-module-crm 模块\n * 微服务仓库： https://github.com/YunaiV/yudao-cloud 的 yudao-module-crm 服务\n\n\n# 2. CRM 启动\n\n参见 《CRM 手册 —— 功能开启》 文档，一般 3 分钟就可以启动完成。\n\n\n# 3. CRM 交流\n\n专属交流社区，欢迎扫码加入。\n\n\n\n\n# 4. 功能描述\n\n主要分为 6 个核心模块：线索、客户、商机、合同、回款、产品。\n\n\n\n\n# 5. 表结构\n\nCRM 一共近 20+ 张表，具备一定的业务复杂度，对提升技术能力会有不错的帮助，平时做项目也可以参考参考。\n\n\n# 5.1 线索管理\n\n以 crm_clue 作为核心表，表结构如下：\n\n\n\n * 《【线索】线索管理》\n\n\n# 5.2 客户管理\n\n以 crm_customer 作为核心表，表结构如下：\n\n\n\n * 《【线索】线索管理》\n\n\n# 5.3 商机管理\n\n以 crm_business 作为核心表，表结构如下：\n\n\n\n * 《【商机】商机管理、商机状态》\n\n\n# 5.4 合同管理\n\n以 crm_contract 作为核心表，表结构如下：\n\n\n\n * 《【合同】合同管理、合同提醒》\n\n\n# 5.5 回款管理\n\n以 crm_receivable 作为核心表，表结构如下：\n\n\n\n * 《【回款】回款管理、回款计划》\n\n\n# 5.6 产品管理\n\n以 crm_product 作为核心表，表结构如下：\n\n\n\n * 《【产品】产品管理、产品分类》\n\n\n# 5.7 通用模块\n\n * 《【通用】数据权限》\n * 《【通用】跟进记录、待办事项》\n\n\n# 5.8 数据统计\n\nTODO 数据统计",
            normalizedContent: "# 1. 演示地址\n\n\n# 1.1 crm 管理后台\n\n * 演示地址：http://dashboard-vue3.yudao.iocoder.cn/\n * 菜单：“crm 系统”下的「待办事项」「线索管理」「客户管理」「联系人管理」「客户公海」「商机管理」「合同管理」「回款计划」「还款管理」「产品管理」「数据统计」\n * 仓库：https://github.com/yudaocode/yudao-ui-admin-vue3 的 crm 目录，基于 vue3 + element plus 实现\n\n\n\n\n# 1.2 crm 后端\n\n支持 spring boot 单体、spring cloud 微服务架构\n\n * 单体仓库： https://github.com/yunaiv/ruoyi-vue-pro 的 yudao-module-crm 模块\n * 微服务仓库： https://github.com/yunaiv/yudao-cloud 的 yudao-module-crm 服务\n\n\n# 2. crm 启动\n\n参见 《crm 手册 —— 功能开启》 文档，一般 3 分钟就可以启动完成。\n\n\n# 3. crm 交流\n\n专属交流社区，欢迎扫码加入。\n\n\n\n\n# 4. 功能描述\n\n主要分为 6 个核心模块：线索、客户、商机、合同、回款、产品。\n\n\n\n\n# 5. 表结构\n\ncrm 一共近 20+ 张表，具备一定的业务复杂度，对提升技术能力会有不错的帮助，平时做项目也可以参考参考。\n\n\n# 5.1 线索管理\n\n以 crm_clue 作为核心表，表结构如下：\n\n\n\n * 《【线索】线索管理》\n\n\n# 5.2 客户管理\n\n以 crm_customer 作为核心表，表结构如下：\n\n\n\n * 《【线索】线索管理》\n\n\n# 5.3 商机管理\n\n以 crm_business 作为核心表，表结构如下：\n\n\n\n * 《【商机】商机管理、商机状态》\n\n\n# 5.4 合同管理\n\n以 crm_contract 作为核心表，表结构如下：\n\n\n\n * 《【合同】合同管理、合同提醒》\n\n\n# 5.5 回款管理\n\n以 crm_receivable 作为核心表，表结构如下：\n\n\n\n * 《【回款】回款管理、回款计划》\n\n\n# 5.6 产品管理\n\n以 crm_product 作为核心表，表结构如下：\n\n\n\n * 《【产品】产品管理、产品分类》\n\n\n# 5.7 通用模块\n\n * 《【通用】数据权限》\n * 《【通用】跟进记录、待办事项》\n\n\n# 5.8 数据统计\n\ntodo 数据统计",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【线索】线索管理",
            frontmatter: {
                title: "【线索】线索管理",
                date: "2024-02-23T20:26:32.000Z",
                permalink: "/crm/clue"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/16.CRM%E6%89%8B%E5%86%8C/10.%E3%80%90%E7%BA%BF%E7%B4%A2%E3%80%91%E7%BA%BF%E7%B4%A2%E7%AE%A1%E7%90%86.html",
            relativePath: "01.开发指南/16.CRM手册/10.【线索】线索管理.md",
            key: "v-21141a8d",
            path: "/crm/clue/",
            headers: [{
                level: 2,
                title: "1. 表结构",
                slug: "_1-表结构",
                normalizedTitle: "1. 表结构",
                charIndex: 255
            }, {
                level: 2,
                title: "2. 管理后台",
                slug: "_2-管理后台",
                normalizedTitle: "2. 管理后台",
                charIndex: 2553
            }],
            headersStr: "1. 表结构 2. 管理后台",
            content: "CRM 线索，是指 CRM 系统中关于公司、个人和商机的原始信息，这些信息主要源自于各种渠道的交流，如活动、电话咨询、广告投放、老客户介绍、或购买来的原始数据等。\n\n\n\n这些线索有可能成为企业的潜在【客户】，当有机会沟通后客户表达出购买【产品】意向，并留下联系方式等信息后，就可以转换为【商机】。\n\n----------------------------------------\n\n线索模块，由 yudao-module-crm-biz 后端模块的 clue 包实现，只有线索功能。如下图所示：\n\n\n\n\n# 1. 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `crm_clue` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号，主键自增',\n  `name` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '线索名称',\n  \n  `owner_user_id` bigint NOT NULL COMMENT '负责人的用户编号',\n\n  `follow_up_status` bit(1) DEFAULT b'0' COMMENT '跟进状态',\n  `contact_last_time` datetime DEFAULT NULL COMMENT '最后跟进时间',\n  `contact_last_content` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '最后跟进内容',\n  `contact_next_time` datetime DEFAULT NULL COMMENT '下次联系时间',\n  \n  `transform_status` bit(1) DEFAULT b'0' COMMENT '转化状态',\n  `customer_id` bigint DEFAULT NULL COMMENT '客户编号',\n  \n  `mobile` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '手机号',\n  `telephone` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '电话',\n  `qq` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT 'QQ',\n  `wechat` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '微信',\n  `email` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '邮箱',\n  `area_id` bigint DEFAULT NULL COMMENT '地区编号',\n  `detail_address` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '详细地址',\n  `industry_id` int DEFAULT NULL COMMENT '所属行业',\n  `level` int DEFAULT NULL COMMENT '客户等级',\n  `source` int DEFAULT NULL COMMENT '客户来源',\n  `remark` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '备注',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='CRM 线索表';\n\n\n① owner_user_id 字段：线索的负责人编号，对应 system_users 表的 id 字段。在 CRM 系统中，线索、客户、商机、合同等等，都有负责人的概念，你可以理解它是“销售”的概念，负责客户的全流程跟进。\n\n后续可见 《【通用】数据权限》 文档。\n\n② follow_up_status 字段：跟进状态，true 表示已跟进，false 表示未跟进。在 CRM 系统中，线索、客户、商机、合同等等，也都有跟进状态的概念，客户是被一步步跟进，直到成交出【合同】，最后【回款】。\n\ncontact_last_time、contact_last_content、contact_next_time 字段：最后跟进时间、最后跟进内容、下次联系时间。\n\n后续可见 《【通用】跟进记录》 文档。\n\n③ transform_status 字段：转化状态，true 表示已转化，false 表示未转化。\n\n当转化后，会创建出一条客户记录，此时 customer_id 字段会指向客户的编号。\n\n④ 从 mobile 到 remark 字段：线索的基本信息，包括手机号、电话、QQ、微信、邮箱、地区、详细地址、所属行业、客户等级、客户来源、备注等。\n\n\n# 2. 管理后台\n\n对应 [CRM 系统 -> 线索管理] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/crm/clue 目录。\n\n\n\n① 点击【新增】按钮，随便填写一些信息，点击「确认」按钮，即可新增一条线索。如下图所示：\n\n\n\n② 点击“线索名称”，进入线索详情页，可以查看线索的详细信息，如下图所示：\n\n\n\n详情可以分成 3 个部分：\n\n * 顶部：线索的基本信息\n * 下面：线索的关联信息\n * 右上角：线索的操作按钮\n\n友情提示：客户、联系人、合同等其它模块的详情页，也是类似的结构，都有基本信息、关联信息、操作按钮。\n\n③ 点击【转移】按钮，可以修改线索的负责人，如下图所示：\n\n\n\n友情提示：客户、联系人、合同等其它模块的转移功能，也是类似的操作。\n\n④ 点击【转化为客户】按钮，可以将线索转化为客户。转化后，会创建出一条客户记录，此时 customer_id 字段会指向客户的编号，如下图所示：\n\n\n\n----------------------------------------\n\n如果你要批量转移线索，可参考 #451、#31",
            normalizedContent: "crm 线索，是指 crm 系统中关于公司、个人和商机的原始信息，这些信息主要源自于各种渠道的交流，如活动、电话咨询、广告投放、老客户介绍、或购买来的原始数据等。\n\n\n\n这些线索有可能成为企业的潜在【客户】，当有机会沟通后客户表达出购买【产品】意向，并留下联系方式等信息后，就可以转换为【商机】。\n\n----------------------------------------\n\n线索模块，由 yudao-module-crm-biz 后端模块的 clue 包实现，只有线索功能。如下图所示：\n\n\n\n\n# 1. 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `crm_clue` (\n  `id` bigint not null auto_increment comment '编号，主键自增',\n  `name` varchar(128) character set utf8mb4 collate utf8mb4_unicode_ci not null default '' comment '线索名称',\n  \n  `owner_user_id` bigint not null comment '负责人的用户编号',\n\n  `follow_up_status` bit(1) default b'0' comment '跟进状态',\n  `contact_last_time` datetime default null comment '最后跟进时间',\n  `contact_last_content` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '最后跟进内容',\n  `contact_next_time` datetime default null comment '下次联系时间',\n  \n  `transform_status` bit(1) default b'0' comment '转化状态',\n  `customer_id` bigint default null comment '客户编号',\n  \n  `mobile` varchar(20) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '手机号',\n  `telephone` varchar(20) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '电话',\n  `qq` varchar(20) character set utf8mb4 collate utf8mb4_unicode_ci default null comment 'qq',\n  `wechat` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '微信',\n  `email` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '邮箱',\n  `area_id` bigint default null comment '地区编号',\n  `detail_address` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '详细地址',\n  `industry_id` int default null comment '所属行业',\n  `level` int default null comment '客户等级',\n  `source` int default null comment '客户来源',\n  `remark` varchar(500) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '备注',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=8 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='crm 线索表';\n\n\n① owner_user_id 字段：线索的负责人编号，对应 system_users 表的 id 字段。在 crm 系统中，线索、客户、商机、合同等等，都有负责人的概念，你可以理解它是“销售”的概念，负责客户的全流程跟进。\n\n后续可见 《【通用】数据权限》 文档。\n\n② follow_up_status 字段：跟进状态，true 表示已跟进，false 表示未跟进。在 crm 系统中，线索、客户、商机、合同等等，也都有跟进状态的概念，客户是被一步步跟进，直到成交出【合同】，最后【回款】。\n\ncontact_last_time、contact_last_content、contact_next_time 字段：最后跟进时间、最后跟进内容、下次联系时间。\n\n后续可见 《【通用】跟进记录》 文档。\n\n③ transform_status 字段：转化状态，true 表示已转化，false 表示未转化。\n\n当转化后，会创建出一条客户记录，此时 customer_id 字段会指向客户的编号。\n\n④ 从 mobile 到 remark 字段：线索的基本信息，包括手机号、电话、qq、微信、邮箱、地区、详细地址、所属行业、客户等级、客户来源、备注等。\n\n\n# 2. 管理后台\n\n对应 [crm 系统 -> 线索管理] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/crm/clue 目录。\n\n\n\n① 点击【新增】按钮，随便填写一些信息，点击「确认」按钮，即可新增一条线索。如下图所示：\n\n\n\n② 点击“线索名称”，进入线索详情页，可以查看线索的详细信息，如下图所示：\n\n\n\n详情可以分成 3 个部分：\n\n * 顶部：线索的基本信息\n * 下面：线索的关联信息\n * 右上角：线索的操作按钮\n\n友情提示：客户、联系人、合同等其它模块的详情页，也是类似的结构，都有基本信息、关联信息、操作按钮。\n\n③ 点击【转移】按钮，可以修改线索的负责人，如下图所示：\n\n\n\n友情提示：客户、联系人、合同等其它模块的转移功能，也是类似的操作。\n\n④ 点击【转化为客户】按钮，可以将线索转化为客户。转化后，会创建出一条客户记录，此时 customer_id 字段会指向客户的编号，如下图所示：\n\n\n\n----------------------------------------\n\n如果你要批量转移线索，可参考 #451、#31",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【客户】客户管理、公海客户",
            frontmatter: {
                title: "【客户】客户管理、公海客户",
                date: "2024-02-23T21:23:59.000Z",
                permalink: "/crm/customer/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/16.CRM%E6%89%8B%E5%86%8C/20.%E3%80%90%E5%AE%A2%E6%88%B7%E3%80%91%E5%AE%A2%E6%88%B7%E7%AE%A1%E7%90%86%E3%80%81%E5%85%AC%E6%B5%B7%E5%AE%A2%E6%88%B7.html",
            relativePath: "01.开发指南/16.CRM手册/20.【客户】客户管理、公海客户.md",
            key: "v-09e8ac9a",
            path: "/crm/customer/",
            headers: [{
                level: 2,
                title: "1. 客户",
                slug: "_1-客户",
                normalizedTitle: "1. 客户",
                charIndex: 65
            }, {
                level: 3,
                title: "1. 表结构",
                slug: "_1-表结构",
                normalizedTitle: "1. 表结构",
                charIndex: 200
            }, {
                level: 3,
                title: "1.2 管理后台（客户管理）",
                slug: "_1-2-管理后台-客户管理",
                normalizedTitle: "1.2 管理后台（客户管理）",
                charIndex: 2445
            }, {
                level: 3,
                title: "1.3 管理后台（公海客户）",
                slug: "_1-3-管理后台-公海客户",
                normalizedTitle: "1.3 管理后台（公海客户）",
                charIndex: 2727
            }, {
                level: 2,
                title: "2. 客户限制配置",
                slug: "_2-客户限制配置",
                normalizedTitle: "2. 客户限制配置",
                charIndex: 2928
            }, {
                level: 3,
                title: "2.1 表结构",
                slug: "_2-1-表结构",
                normalizedTitle: "2.1 表结构",
                charIndex: 3028
            }, {
                level: 3,
                title: "2.2 管理后台",
                slug: "_2-2-管理后台",
                normalizedTitle: "2.2 管理后台",
                charIndex: 4002
            }, {
                level: 2,
                title: "3. 客户公海配置",
                slug: "_3-客户公海配置",
                normalizedTitle: "3. 客户公海配置",
                charIndex: 4108
            }, {
                level: 3,
                title: "3.1 表结构",
                slug: "_3-1-表结构",
                normalizedTitle: "3.1 表结构",
                charIndex: 4207
            }, {
                level: 3,
                title: "3.2 管理后台",
                slug: "_3-2-管理后台",
                normalizedTitle: "3.2 管理后台",
                charIndex: 5120
            }, {
                level: 2,
                title: "4. 联系人",
                slug: "_4-联系人",
                normalizedTitle: "4. 联系人",
                charIndex: 5223
            }, {
                level: 3,
                title: "4.1 表结构",
                slug: "_4-1-表结构",
                normalizedTitle: "4.1 表结构",
                charIndex: 5283
            }, {
                level: 3,
                title: "4.2 管理后台",
                slug: "_4-2-管理后台",
                normalizedTitle: "4.2 管理后台",
                charIndex: 7251
            }],
            headersStr: "1. 客户 1. 表结构 1.2 管理后台（客户管理） 1.3 管理后台（公海客户） 2. 客户限制配置 2.1 表结构 2.2 管理后台 3. 客户公海配置 3.1 表结构 3.2 管理后台 4. 联系人 4.1 表结构 4.2 管理后台",
            content: "本文接 《【线索】线索管理》，主要讲解四部分：客户信息、客户公海配置、客户限制配置、联系人。它们的表关系如下图所示：\n\n\n\n\n# 1. 客户\n\n客户模块，由 yudao-module-crm-biz 后端模块的 customer 包的 CrmCustomerController 实现，包括客户管理（我的客户）、公海客户。其中，公海客户是指没有负责人的客户，可以被人分配或者领取成为负责人。\n\n\n# 1. 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `crm_customer` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号，主键自增',\n  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '客户名称',\n  \n  `owner_user_id` bigint DEFAULT NULL COMMENT '负责人的用户编号',\n  `owner_time` datetime NOT NULL COMMENT '成为负责人的时间',\n  `lock_status` bit(1) NOT NULL DEFAULT b'0' COMMENT '锁定状态',\n  `deal_status` bit(1) NOT NULL DEFAULT b'0' COMMENT '成交状态',\n  \n  `follow_up_status` tinyint(1) NOT NULL DEFAULT '0' COMMENT '跟进状态',\n  `contact_last_time` datetime DEFAULT NULL COMMENT '最后跟进时间',\n  `contact_last_content` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '最后跟进内容',\n  `contact_next_time` datetime DEFAULT NULL COMMENT '下次联系时间',\n  \n  `mobile` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '手机',\n  `telephone` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '电话',\n  `qq` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT 'QQ',\n  `wechat` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '微信',\n  `email` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '邮箱',\n  `area_id` bigint DEFAULT NULL COMMENT '地区编号',\n  `detail_address` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '详细地址',\n  `industry_id` int DEFAULT NULL COMMENT '所属行业',\n  `level` int DEFAULT NULL COMMENT '客户等级',\n  `source` int DEFAULT NULL COMMENT '客户来源',\n  `remark` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '备注',\n  PRIMARY KEY (`id`) USING BTREE,\n  KEY `owner_user_id` (`owner_user_id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=17 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='CRM 客户表';\n\n\n友情提示：客户表的字段，和线索表的字段类似，只是多了 `lock_status`、`deal_status` 字段。\n\n① owner_user_id 字段：客户的负责人编号，和线索类似。不重复赘述，详细可见 《【通用】数据权限》 文档。\n\n差别在多了 owner_time 字段，成为负责人超过一定时间后，客户自动释放进入公海。当然，如果客户被 lock_status 锁定，或者有 deal_status 成交，就不会释放。\n\n② 从 follow_up_status 到 contact_next_time 字段：跟进相关，和线索类似。不重复赘述，详细可见 《【通用】跟进记录》 文档。\n\n③ 从 mobile 到 remark 字段：客户的基本信息，和客户一致，不重复赘述。\n\n\n# 1.2 管理后台（客户管理）\n\n对应 [CRM 系统 -> 客户管理] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/crm/customer 目录。\n\n\n\n① 点击【新增】按钮，随便填写一些信息，点击「确认」按钮，即可新增一条客户。如下图所示：\n\n\n\n② 点击“客户名称”，进入客户详情页，可以查看客户的详细信息，如下图所示：\n\n\n\n③ 点击【更改成交状态】按钮，标记客户 deal_status 为已成交，这样它就不会自动进入公海。\n\n\n\n同理，点击【更改锁定状态】按钮，标记客户 lock_status 为已锁定。\n\n\n\n\n# 1.3 管理后台（公海客户）\n\n① 点击【放入公海】按钮，将 owner_user_id 字段置空，即可放入公海。\n\n\n\n放入公海后，可以在 [CRM 系统 -> 公海客户] 菜单中，可以看到该客户。如下图所示：\n\n\n\n② 继续点击该公海客户的“客户名称”，还是进入客户详情页，如下图所示：\n\n\n\n③ 此时，可以点击【领取】或【分配】按钮，将公海客户分配给自己或者其它人。如下图所示：\n\n\n\n\n\n\n# 2. 客户限制配置\n\n客户限制配置，由 yudao-module-crm-biz 后端模块的 customer 包的 CrmCustomerLimitConfigController 实现。\n\n\n# 2.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `crm_customer_limit_config` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  \n  `type` int NOT NULL COMMENT '规则类型 1: 拥有客户数限制，2:锁定客户数限制',\n  \n  `user_ids` varchar(2048) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT '' COMMENT '规则适用人群',\n  `dept_ids` varchar(2048) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT '' COMMENT '规则适用部门',\n  \n  `max_count` int NOT NULL COMMENT '数量上限',\n  `deal_count_enabled` tinyint DEFAULT NULL COMMENT '成交客户是否占有拥有客户数(当 type = 1 时)',\n  \n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='CRM 客户限制配置表';\n\n\n① type 字段：规则类型，1 表示拥有客户数限制，2 表示锁定客户数限制。这样的话，可以避免一个人拥有太多客户，或者锁定太多客户。\n\n② user_ids 和 dept_ids 字段：规则适用人群和部门，可以根据人群和部门来限制客户数量。\n\n③ max_count 字段：数量上限，即最多拥有或者锁定的客户数量。\n\ndeal_count_enabled 字段：成交客户是否占有拥有客户数，当 type = 1 时，表示成交客户是否占有拥有客户数。这样的话，可以避免一个人拥有太多成交客户。\n\n\n# 2.2 管理后台\n\n对应 [CRM 系统 -> 系统配置 -> 客户限制配置] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/crm/limitConfig 目录。\n\n\n\n\n\n\n# 3. 客户公海配置\n\n客户公海配置，由 yudao-module-crm-biz 后端模块的 customer 包的 CrmCustomerPoolConfigController 实现。\n\n\n# 3.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `crm_customer_pool_config` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  \n  `enabled` tinyint(1) NOT NULL COMMENT '是否启用客户公海',\n  `contact_expire_days` int DEFAULT NULL COMMENT '未跟进放入公海天数',\n  `deal_expire_days` int DEFAULT NULL COMMENT '未成交放入公海天数',\n  \n  `notify_enabled` tinyint(1) DEFAULT NULL COMMENT '是否开启提前提醒',\n  `notify_days` int DEFAULT NULL COMMENT '提前提醒天数',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='CRM 客户公海配置表';\n\n\n① enabled 字段：是否启用客户公海。如果启用，那么超过 contact_expire_days 天未跟进的客户，或者超过 deal_expire_days 天未成交的客户，就会自动进入公海。\n\n目前，该功能是通过 CrmCustomerAutoPutPoolJob 定时任务实现的。你可以参考 《定时任务》 文档，自己配置每 5 分钟执行一次。\n\n② notify_enabled 字段：是否开启提前提醒。如果开启，那么超过 notify_days 天未跟进的客户，或者超过 notify_days 天未成交的客户，可以在 [CRM 系统 -> 待办事项] 菜单中，看到提醒。如下图所示：\n\n\n\n\n# 3.2 管理后台\n\n对应 [CRM 系统 -> 系统配置 -> 客户公海配置] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/crm/poolConfig 目录。\n\n\n\n\n# 4. 联系人\n\n联系人模块，由 yudao-module-crm-biz 后端模块的 contact 包实现。\n\n\n# 4.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `crm_contact` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键',\n  `name` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '联系人名称',\n  `customer_id` bigint DEFAULT NULL COMMENT '客户编号',\n\n  `owner_user_id` varchar(256) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '负责人用户编号',\n  \n  `contact_last_time` datetime DEFAULT NULL COMMENT '最后跟进时间',\n  `contact_last_content` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '最后跟进内容',\n  `contact_next_time` datetime DEFAULT NULL COMMENT '下次联系时间',\n  \n  `mobile` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '手机号',\n  `telephone` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '电话',\n  `email` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '电子邮箱',\n  `qq` int DEFAULT NULL,\n  `wechat` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL,\n  `area_id` bigint DEFAULT NULL COMMENT '地区',\n  `detail_address` varchar(256) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '地址',\n  \n  `sex` int DEFAULT NULL COMMENT '性别',\n  `master` bit(1) DEFAULT NULL COMMENT '是否关键决策人',\n  `parent_id` bigint DEFAULT NULL COMMENT '直系上属',\n  `post` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '职务',\n  `tenant_id` bigint DEFAULT NULL,\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=16 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='CRM 联系人';\n\n\n① customer_id 字段：联系人所属的客户编号，它必须关联到客户表的 id 字段。\n\n② owner_user_id 字段：联系人的负责人编号，和线索类似。不重复赘述，详细可见 《【通用】数据权限》 文档。\n\n③ 从 contact_last_time 到 contact_next_time 字段：跟进相关，和线索类似。不重复赘述，详细可见 《【通用】跟进记录》 文档。\n\n④ 从 mobile 到 detail_address 字段：联系人的基本信息，和客户一致，不重复赘述。\n\n差异的点，是额外增加了 sex、master、parent_id、post 字段。不过它们也是信息字段，没有什么特殊逻辑。\n\n\n# 4.2 管理后台\n\n对应 [CRM 系统 -> 联系人管理] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/crm/contact 目录。\n\n\n\n① 点击【新增】按钮，随便填写一些信息，点击「确认」按钮，即可新增一条联系人。如下图所示：\n\n\n\n② 点击“联系人名称”，进入联系人详情页，可以查看联系人的详细信息，如下图所示：\n\n\n\n具体操作比较简单，只有【编辑】、【转移】，所以联系人本质上还是客户的信息补充。",
            normalizedContent: "本文接 《【线索】线索管理》，主要讲解四部分：客户信息、客户公海配置、客户限制配置、联系人。它们的表关系如下图所示：\n\n\n\n\n# 1. 客户\n\n客户模块，由 yudao-module-crm-biz 后端模块的 customer 包的 crmcustomercontroller 实现，包括客户管理（我的客户）、公海客户。其中，公海客户是指没有负责人的客户，可以被人分配或者领取成为负责人。\n\n\n# 1. 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `crm_customer` (\n  `id` bigint not null auto_increment comment '编号，主键自增',\n  `name` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '客户名称',\n  \n  `owner_user_id` bigint default null comment '负责人的用户编号',\n  `owner_time` datetime not null comment '成为负责人的时间',\n  `lock_status` bit(1) not null default b'0' comment '锁定状态',\n  `deal_status` bit(1) not null default b'0' comment '成交状态',\n  \n  `follow_up_status` tinyint(1) not null default '0' comment '跟进状态',\n  `contact_last_time` datetime default null comment '最后跟进时间',\n  `contact_last_content` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '最后跟进内容',\n  `contact_next_time` datetime default null comment '下次联系时间',\n  \n  `mobile` varchar(20) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '手机',\n  `telephone` varchar(20) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '电话',\n  `qq` varchar(20) character set utf8mb4 collate utf8mb4_unicode_ci default null comment 'qq',\n  `wechat` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '微信',\n  `email` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '邮箱',\n  `area_id` bigint default null comment '地区编号',\n  `detail_address` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '详细地址',\n  `industry_id` int default null comment '所属行业',\n  `level` int default null comment '客户等级',\n  `source` int default null comment '客户来源',\n  `remark` varchar(500) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '备注',\n  primary key (`id`) using btree,\n  key `owner_user_id` (`owner_user_id`) using btree\n) engine=innodb auto_increment=17 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='crm 客户表';\n\n\n友情提示：客户表的字段，和线索表的字段类似，只是多了 `lock_status`、`deal_status` 字段。\n\n① owner_user_id 字段：客户的负责人编号，和线索类似。不重复赘述，详细可见 《【通用】数据权限》 文档。\n\n差别在多了 owner_time 字段，成为负责人超过一定时间后，客户自动释放进入公海。当然，如果客户被 lock_status 锁定，或者有 deal_status 成交，就不会释放。\n\n② 从 follow_up_status 到 contact_next_time 字段：跟进相关，和线索类似。不重复赘述，详细可见 《【通用】跟进记录》 文档。\n\n③ 从 mobile 到 remark 字段：客户的基本信息，和客户一致，不重复赘述。\n\n\n# 1.2 管理后台（客户管理）\n\n对应 [crm 系统 -> 客户管理] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/crm/customer 目录。\n\n\n\n① 点击【新增】按钮，随便填写一些信息，点击「确认」按钮，即可新增一条客户。如下图所示：\n\n\n\n② 点击“客户名称”，进入客户详情页，可以查看客户的详细信息，如下图所示：\n\n\n\n③ 点击【更改成交状态】按钮，标记客户 deal_status 为已成交，这样它就不会自动进入公海。\n\n\n\n同理，点击【更改锁定状态】按钮，标记客户 lock_status 为已锁定。\n\n\n\n\n# 1.3 管理后台（公海客户）\n\n① 点击【放入公海】按钮，将 owner_user_id 字段置空，即可放入公海。\n\n\n\n放入公海后，可以在 [crm 系统 -> 公海客户] 菜单中，可以看到该客户。如下图所示：\n\n\n\n② 继续点击该公海客户的“客户名称”，还是进入客户详情页，如下图所示：\n\n\n\n③ 此时，可以点击【领取】或【分配】按钮，将公海客户分配给自己或者其它人。如下图所示：\n\n\n\n\n\n\n# 2. 客户限制配置\n\n客户限制配置，由 yudao-module-crm-biz 后端模块的 customer 包的 crmcustomerlimitconfigcontroller 实现。\n\n\n# 2.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `crm_customer_limit_config` (\n  `id` bigint not null auto_increment comment '编号',\n  \n  `type` int not null comment '规则类型 1: 拥有客户数限制，2:锁定客户数限制',\n  \n  `user_ids` varchar(2048) character set utf8mb4 collate utf8mb4_unicode_ci default '' comment '规则适用人群',\n  `dept_ids` varchar(2048) character set utf8mb4 collate utf8mb4_unicode_ci default '' comment '规则适用部门',\n  \n  `max_count` int not null comment '数量上限',\n  `deal_count_enabled` tinyint default null comment '成交客户是否占有拥有客户数(当 type = 1 时)',\n  \n  primary key (`id`) using btree\n) engine=innodb auto_increment=2 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='crm 客户限制配置表';\n\n\n① type 字段：规则类型，1 表示拥有客户数限制，2 表示锁定客户数限制。这样的话，可以避免一个人拥有太多客户，或者锁定太多客户。\n\n② user_ids 和 dept_ids 字段：规则适用人群和部门，可以根据人群和部门来限制客户数量。\n\n③ max_count 字段：数量上限，即最多拥有或者锁定的客户数量。\n\ndeal_count_enabled 字段：成交客户是否占有拥有客户数，当 type = 1 时，表示成交客户是否占有拥有客户数。这样的话，可以避免一个人拥有太多成交客户。\n\n\n# 2.2 管理后台\n\n对应 [crm 系统 -> 系统配置 -> 客户限制配置] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/crm/limitconfig 目录。\n\n\n\n\n\n\n# 3. 客户公海配置\n\n客户公海配置，由 yudao-module-crm-biz 后端模块的 customer 包的 crmcustomerpoolconfigcontroller 实现。\n\n\n# 3.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `crm_customer_pool_config` (\n  `id` bigint not null auto_increment comment '编号',\n  \n  `enabled` tinyint(1) not null comment '是否启用客户公海',\n  `contact_expire_days` int default null comment '未跟进放入公海天数',\n  `deal_expire_days` int default null comment '未成交放入公海天数',\n  \n  `notify_enabled` tinyint(1) default null comment '是否开启提前提醒',\n  `notify_days` int default null comment '提前提醒天数',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=2 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='crm 客户公海配置表';\n\n\n① enabled 字段：是否启用客户公海。如果启用，那么超过 contact_expire_days 天未跟进的客户，或者超过 deal_expire_days 天未成交的客户，就会自动进入公海。\n\n目前，该功能是通过 crmcustomerautoputpooljob 定时任务实现的。你可以参考 《定时任务》 文档，自己配置每 5 分钟执行一次。\n\n② notify_enabled 字段：是否开启提前提醒。如果开启，那么超过 notify_days 天未跟进的客户，或者超过 notify_days 天未成交的客户，可以在 [crm 系统 -> 待办事项] 菜单中，看到提醒。如下图所示：\n\n\n\n\n# 3.2 管理后台\n\n对应 [crm 系统 -> 系统配置 -> 客户公海配置] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/crm/poolconfig 目录。\n\n\n\n\n# 4. 联系人\n\n联系人模块，由 yudao-module-crm-biz 后端模块的 contact 包实现。\n\n\n# 4.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `crm_contact` (\n  `id` bigint not null auto_increment comment '主键',\n  `name` varchar(128) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '联系人名称',\n  `customer_id` bigint default null comment '客户编号',\n\n  `owner_user_id` varchar(256) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '负责人用户编号',\n  \n  `contact_last_time` datetime default null comment '最后跟进时间',\n  `contact_last_content` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '最后跟进内容',\n  `contact_next_time` datetime default null comment '下次联系时间',\n  \n  `mobile` varchar(16) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '手机号',\n  `telephone` varchar(16) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '电话',\n  `email` varchar(128) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '电子邮箱',\n  `qq` int default null,\n  `wechat` varchar(128) character set utf8mb4 collate utf8mb4_unicode_ci default null,\n  `area_id` bigint default null comment '地区',\n  `detail_address` varchar(256) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '地址',\n  \n  `sex` int default null comment '性别',\n  `master` bit(1) default null comment '是否关键决策人',\n  `parent_id` bigint default null comment '直系上属',\n  `post` varchar(32) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '职务',\n  `tenant_id` bigint default null,\n  primary key (`id`) using btree\n) engine=innodb auto_increment=16 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='crm 联系人';\n\n\n① customer_id 字段：联系人所属的客户编号，它必须关联到客户表的 id 字段。\n\n② owner_user_id 字段：联系人的负责人编号，和线索类似。不重复赘述，详细可见 《【通用】数据权限》 文档。\n\n③ 从 contact_last_time 到 contact_next_time 字段：跟进相关，和线索类似。不重复赘述，详细可见 《【通用】跟进记录》 文档。\n\n④ 从 mobile 到 detail_address 字段：联系人的基本信息，和客户一致，不重复赘述。\n\n差异的点，是额外增加了 sex、master、parent_id、post 字段。不过它们也是信息字段，没有什么特殊逻辑。\n\n\n# 4.2 管理后台\n\n对应 [crm 系统 -> 联系人管理] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/crm/contact 目录。\n\n\n\n① 点击【新增】按钮，随便填写一些信息，点击「确认」按钮，即可新增一条联系人。如下图所示：\n\n\n\n② 点击“联系人名称”，进入联系人详情页，可以查看联系人的详细信息，如下图所示：\n\n\n\n具体操作比较简单，只有【编辑】、【转移】，所以联系人本质上还是客户的信息补充。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【商机】商机管理、商机状态",
            frontmatter: {
                title: "【商机】商机管理、商机状态",
                date: "2024-02-23T23:24:52.000Z",
                permalink: "/crm/business/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/16.CRM%E6%89%8B%E5%86%8C/30.%E3%80%90%E5%95%86%E6%9C%BA%E3%80%91%E5%95%86%E6%9C%BA%E7%AE%A1%E7%90%86%E3%80%81%E5%95%86%E6%9C%BA%E7%8A%B6%E6%80%81.html",
            relativePath: "01.开发指南/16.CRM手册/30.【商机】商机管理、商机状态.md",
            key: "v-54f886d0",
            path: "/crm/business/",
            headers: [{
                level: 2,
                title: "1. 商机状态",
                slug: "_1-商机状态",
                normalizedTitle: "1. 商机状态",
                charIndex: 245
            }, {
                level: 3,
                title: "1.1 表结构",
                slug: "_1-1-表结构",
                normalizedTitle: "1.1 表结构",
                charIndex: 336
            }, {
                level: 3,
                title: "1.2 管理后台",
                slug: "_1-2-管理后台",
                normalizedTitle: "1.2 管理后台",
                charIndex: 1821
            }, {
                level: 2,
                title: "2. 商机",
                slug: "_2-商机",
                normalizedTitle: "2. 商机",
                charIndex: 1958
            }, {
                level: 3,
                title: "2.1 表结构",
                slug: "_2-1-表结构",
                normalizedTitle: "2.1 表结构",
                charIndex: 2039
            }, {
                level: 3,
                title: "2.2 管理后台",
                slug: "_2-2-管理后台",
                normalizedTitle: "2.2 管理后台",
                charIndex: 4737
            }, {
                level: 2,
                title: "3. 联系人与商机的关联",
                slug: "_3-联系人与商机的关联",
                normalizedTitle: "3. 联系人与商机的关联",
                charIndex: 5004
            }, {
                level: 3,
                title: "3.1 表结构",
                slug: "_3-1-表结构",
                normalizedTitle: "3.1 表结构",
                charIndex: 5108
            }, {
                level: 3,
                title: "3.2 管理后台",
                slug: "_3-2-管理后台",
                normalizedTitle: "3.2 管理后台",
                charIndex: 5480
            }],
            headersStr: "1. 商机状态 1.1 表结构 1.2 管理后台 2. 商机 2.1 表结构 2.2 管理后台 3. 联系人与商机的关联 3.1 表结构 3.2 管理后台",
            content: "CRM 商机，是指 CRM 系统中可能转化为实际销售的潜在业务机会【商机】，这些机会有可能转化为实际的销售【合同】。\n\n\n\n一个商机，通常需要经过一系列的销售阶段，如挖掘、资格验证、需求分析、价值评估等，最后才能成为一笔实际的交易。因此，整体的表结构如下：\n\n\n\n----------------------------------------\n\n商机模块，由 yudao-module-crm-biz 后端模块的 business 包实现，包括两个部分：商机信息、商机状态配置。\n\n\n# 1. 商机状态\n\n商机状态，由 yudao-module-crm-biz 后端模块的 business 包的 CrmBusinessStatusController 实现。\n\n\n# 1.1 表结构\n\n> 【商机状态组表】省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `crm_business_status_type` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键',\n  `name` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '状态组名',\n  \n  `dept_ids` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '使用的部门编号',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='CRM 商机状态组表';\n\n\n为什么需要商机状态组表？因为不同的商机，它的状态流程是不一样的。比如：\n\n * 状态组 1：“初步接触”、“需求分析”、“方案制定”、“商务谈判”、“合同签订”、“赢单”、“输单”、“无效”等等\n * 状态组 2：“功能演示”、“直接付款”、“赢单”、“输单”、“无效”等等。\n\n当然无论哪种状态组，结束时必然是 CrmBusinessEndStatusEnum 枚举，对应“赢单”、“输单”、“无效”三种。\n\n① name 字段：状态组名字。\n\n② dept_ids 字段：哪些部门可以使用该状态组。如果不设置，默认全公司。\n\n> 【商机状态（阶段）表】省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `crm_business_status` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键',\n  `type_id` bigint NOT NULL COMMENT '状态类型编号',\n  `name` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '状态类型名',\n  `percent` decimal(24,6) NOT NULL COMMENT '赢单率',\n  `sort` int NOT NULL DEFAULT '1' COMMENT '排序',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='CRM 商机状态表';\n\n\n① type_id 字段：状态类型（阶段）编号，对应 crm_business_status_type 表的 id 字段。\n\n② name 字段：状态类型（阶段）名字。percent 字段：赢单率，即该状态下的商机最终成交的概率。\n\n当然，这 2 个本质也是字段，没什么特殊逻辑。\n\n\n# 1.2 管理后台\n\n对应 [CRM 系统 -> 系统配置 -> 商机状态配置] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/crm/business/status 目录。\n\n\n\n点击【新增】按钮，可以新增商机状态组，如下图所示：\n\n\n\n\n# 2. 商机\n\n商机，由 yudao-module-crm-biz 后端模块的 business 包的 CrmBusinessController 实现。\n\n\n# 2.1 表结构\n\n> 【商机表】省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `crm_business` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  `name` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '商机名称',\n  `customer_id` bigint NOT NULL COMMENT '客户编号',\n\n  `owner_user_id` bigint DEFAULT NULL COMMENT '负责人的用户编号',\n  \n  `follow_up_status` bit(1) DEFAULT b'0' COMMENT '跟进状态',\n  `contact_last_time` datetime DEFAULT NULL COMMENT '最后跟进时间',\n  `contact_next_time` datetime DEFAULT NULL COMMENT '下次联系时间',\n  \n  `status_type_id` bigint DEFAULT NULL COMMENT '商机状态类型编号',\n  `status_id` bigint DEFAULT NULL COMMENT '商机状态编号',\n  `end_status` tinyint DEFAULT NULL COMMENT '结束状态：1-赢单 2-输单3-无效',\n  \n  `deal_time` datetime DEFAULT NULL COMMENT '预计成交日期',\n  `remark` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT '备注',\n\n  `total_product_price` decimal(24,6) DEFAULT NULL COMMENT '产品总金额，单位：元',\n  `discount_percent` decimal(24,6) DEFAULT NULL COMMENT '整单折扣，百分比',\n  `total_price` decimal(24,6) DEFAULT NULL COMMENT '商机总金额，单位：元',\n\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='CRM 商机表';\n\n\n① customer_id 字段：客户编号，对应 crm_customer 表的 id 字段，必填。\n\n② owner_user_id 字段：，商机的负责人编号，和线索类似。不重复赘述，详细可见 《【通用】数据权限》 文档。\n\n③ 从 follow_up_status 到 contact_next_time 字段：跟进相关，和线索类似。不重复赘述，详细可见 《【通用】跟进记录》 文档。\n\n④ status_type_id 字段：商机状态类型编号，对应 crm_business_status_type 表的 id 字段。status_id 字段：商机状态编号，对应 crm_business_status 表的 id 字段。\n\n当商机结束时，会记录 end_status 字段，对应 CrmBusinessEndStatusEnum 枚举，最终就是“赢单”、“输单”、“无效”三种。\n\n⑤ total_product_price、discount_percent、total_price 字段：商机的金额相关，关系是 total_price = total_product_price * discount_percent。\n\n其中，total_product_price 字段是 crm_business_product 表的 total_price * count 的累加。\n\n> 【商机产品表】省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `crm_business_product` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键',\n  \n  `business_id` bigint NOT NULL COMMENT '商机编号',\n  `product_id` bigint NOT NULL COMMENT '产品编号',\n  \n  `product_price` decimal(24,6) NOT NULL COMMENT '产品单价',\n  `business_price` decimal(24,6) NOT NULL COMMENT '商机价格',\n  `count` decimal(24,6) NOT NULL COMMENT '数量',\n  `total_price` decimal(24,6) NOT NULL COMMENT '总计价格',\n  \n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=33 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC COMMENT='CRM 商机产品关联表';\n\n\n① business_id 字段：商机编号，对应 crm_business 表的 id 字段。\n\nproduct_id 字段：产品编号，对应 crm_product 表的 id 字段。\n\n② product_price 字段：产品单价，冗余，来自 crm_product 表的 price 字段。目的是，和 business_price 字段比较，看看是否有折扣。\n\ncount、total_price 字段：数量、总计价格。\n\n\n# 2.2 管理后台\n\n对应 [CRM 系统 -> 商机管理] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/crm/business 目录。\n\n\n\n① 点击【新增】按钮，随便填写一些信息，点击「确认」按钮，即可新增一条商机。如下图所示：\n\n\n\n② 点击“商机名称”，进入商机详情页，可以查看商机的详细信息，如下图所示：\n\n\n\n③ 点击【变更商机状态】按钮，可以变更商机的状态，如下图所示：\n\n\n\n可以多次变更，直到 end_status 字段有值，即商机结束，即“赢单”、“输单”、“无效”三种。\n\n\n# 3. 联系人与商机的关联\n\n联系人与商机之间，可以进行关联。这个功能，由 yudao-module-crm-biz 后端模块的 contact 包的 CrmContactController 实现。\n\n\n# 3.1 表结构\n\nCREATE TABLE `crm_contact_business` (\n  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',\n  `contact_id` int DEFAULT NULL COMMENT '联系人id',\n  `business_id` int DEFAULT NULL COMMENT '商机id',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=34 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='CRM 联系人商机关联表';\n\n\n比较简单，就是 contact_id 字段和 business_id 字段的关联。\n\n\n# 3.2 管理后台\n\n① 在联系人详情页，在 [商机] 标签页，可以查看联系人关联的商机，如下图所示：\n\n\n\n * 点击【创建商机】按钮，可以创建一个新的商机，同时关联到当前联系人\n * 点击【关联】按钮，可以关联已有的商机到当前联系人。但是要注意，只能关联联系人 customer_id 字段相同的商机\n\n② 在商机详情页，在 [联系人] 标签页，可以查看商机关联的联系人，如下图所示：\n\n\n\n * 点击【创建联系人】按钮，可以创建一个新的联系人，同时关联到当前商机\n * 点击【关联】按钮，可以关联已有的联系人到当前商机。但是要注意，只能关联商机 customer_id 字段相同的联系人",
            normalizedContent: "crm 商机，是指 crm 系统中可能转化为实际销售的潜在业务机会【商机】，这些机会有可能转化为实际的销售【合同】。\n\n\n\n一个商机，通常需要经过一系列的销售阶段，如挖掘、资格验证、需求分析、价值评估等，最后才能成为一笔实际的交易。因此，整体的表结构如下：\n\n\n\n----------------------------------------\n\n商机模块，由 yudao-module-crm-biz 后端模块的 business 包实现，包括两个部分：商机信息、商机状态配置。\n\n\n# 1. 商机状态\n\n商机状态，由 yudao-module-crm-biz 后端模块的 business 包的 crmbusinessstatuscontroller 实现。\n\n\n# 1.1 表结构\n\n> 【商机状态组表】省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `crm_business_status_type` (\n  `id` bigint not null auto_increment comment '主键',\n  `name` varchar(100) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '状态组名',\n  \n  `dept_ids` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '使用的部门编号',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=6 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='crm 商机状态组表';\n\n\n为什么需要商机状态组表？因为不同的商机，它的状态流程是不一样的。比如：\n\n * 状态组 1：“初步接触”、“需求分析”、“方案制定”、“商务谈判”、“合同签订”、“赢单”、“输单”、“无效”等等\n * 状态组 2：“功能演示”、“直接付款”、“赢单”、“输单”、“无效”等等。\n\n当然无论哪种状态组，结束时必然是 crmbusinessendstatusenum 枚举，对应“赢单”、“输单”、“无效”三种。\n\n① name 字段：状态组名字。\n\n② dept_ids 字段：哪些部门可以使用该状态组。如果不设置，默认全公司。\n\n> 【商机状态（阶段）表】省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `crm_business_status` (\n  `id` bigint not null auto_increment comment '主键',\n  `type_id` bigint not null comment '状态类型编号',\n  `name` varchar(100) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '状态类型名',\n  `percent` decimal(24,6) not null comment '赢单率',\n  `sort` int not null default '1' comment '排序',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=9 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='crm 商机状态表';\n\n\n① type_id 字段：状态类型（阶段）编号，对应 crm_business_status_type 表的 id 字段。\n\n② name 字段：状态类型（阶段）名字。percent 字段：赢单率，即该状态下的商机最终成交的概率。\n\n当然，这 2 个本质也是字段，没什么特殊逻辑。\n\n\n# 1.2 管理后台\n\n对应 [crm 系统 -> 系统配置 -> 商机状态配置] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/crm/business/status 目录。\n\n\n\n点击【新增】按钮，可以新增商机状态组，如下图所示：\n\n\n\n\n# 2. 商机\n\n商机，由 yudao-module-crm-biz 后端模块的 business 包的 crmbusinesscontroller 实现。\n\n\n# 2.1 表结构\n\n> 【商机表】省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `crm_business` (\n  `id` bigint not null auto_increment comment '编号',\n  `name` varchar(100) character set utf8mb4 collate utf8mb4_0900_ai_ci not null comment '商机名称',\n  `customer_id` bigint not null comment '客户编号',\n\n  `owner_user_id` bigint default null comment '负责人的用户编号',\n  \n  `follow_up_status` bit(1) default b'0' comment '跟进状态',\n  `contact_last_time` datetime default null comment '最后跟进时间',\n  `contact_next_time` datetime default null comment '下次联系时间',\n  \n  `status_type_id` bigint default null comment '商机状态类型编号',\n  `status_id` bigint default null comment '商机状态编号',\n  `end_status` tinyint default null comment '结束状态：1-赢单 2-输单3-无效',\n  \n  `deal_time` datetime default null comment '预计成交日期',\n  `remark` varchar(500) character set utf8mb4 collate utf8mb4_0900_ai_ci default null comment '备注',\n\n  `total_product_price` decimal(24,6) default null comment '产品总金额，单位：元',\n  `discount_percent` decimal(24,6) default null comment '整单折扣，百分比',\n  `total_price` decimal(24,6) default null comment '商机总金额，单位：元',\n\n  primary key (`id`) using btree\n) engine=innodb auto_increment=12 default charset=utf8mb4 collate=utf8mb4_0900_ai_ci comment='crm 商机表';\n\n\n① customer_id 字段：客户编号，对应 crm_customer 表的 id 字段，必填。\n\n② owner_user_id 字段：，商机的负责人编号，和线索类似。不重复赘述，详细可见 《【通用】数据权限》 文档。\n\n③ 从 follow_up_status 到 contact_next_time 字段：跟进相关，和线索类似。不重复赘述，详细可见 《【通用】跟进记录》 文档。\n\n④ status_type_id 字段：商机状态类型编号，对应 crm_business_status_type 表的 id 字段。status_id 字段：商机状态编号，对应 crm_business_status 表的 id 字段。\n\n当商机结束时，会记录 end_status 字段，对应 crmbusinessendstatusenum 枚举，最终就是“赢单”、“输单”、“无效”三种。\n\n⑤ total_product_price、discount_percent、total_price 字段：商机的金额相关，关系是 total_price = total_product_price * discount_percent。\n\n其中，total_product_price 字段是 crm_business_product 表的 total_price * count 的累加。\n\n> 【商机产品表】省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `crm_business_product` (\n  `id` bigint not null auto_increment comment '主键',\n  \n  `business_id` bigint not null comment '商机编号',\n  `product_id` bigint not null comment '产品编号',\n  \n  `product_price` decimal(24,6) not null comment '产品单价',\n  `business_price` decimal(24,6) not null comment '商机价格',\n  `count` decimal(24,6) not null comment '数量',\n  `total_price` decimal(24,6) not null comment '总计价格',\n  \n  primary key (`id`) using btree\n) engine=innodb auto_increment=33 default charset=utf8mb4 collate=utf8mb4_unicode_ci row_format=dynamic comment='crm 商机产品关联表';\n\n\n① business_id 字段：商机编号，对应 crm_business 表的 id 字段。\n\nproduct_id 字段：产品编号，对应 crm_product 表的 id 字段。\n\n② product_price 字段：产品单价，冗余，来自 crm_product 表的 price 字段。目的是，和 business_price 字段比较，看看是否有折扣。\n\ncount、total_price 字段：数量、总计价格。\n\n\n# 2.2 管理后台\n\n对应 [crm 系统 -> 商机管理] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/crm/business 目录。\n\n\n\n① 点击【新增】按钮，随便填写一些信息，点击「确认」按钮，即可新增一条商机。如下图所示：\n\n\n\n② 点击“商机名称”，进入商机详情页，可以查看商机的详细信息，如下图所示：\n\n\n\n③ 点击【变更商机状态】按钮，可以变更商机的状态，如下图所示：\n\n\n\n可以多次变更，直到 end_status 字段有值，即商机结束，即“赢单”、“输单”、“无效”三种。\n\n\n# 3. 联系人与商机的关联\n\n联系人与商机之间，可以进行关联。这个功能，由 yudao-module-crm-biz 后端模块的 contact 包的 crmcontactcontroller 实现。\n\n\n# 3.1 表结构\n\ncreate table `crm_contact_business` (\n  `id` int not null auto_increment comment '主键',\n  `contact_id` int default null comment '联系人id',\n  `business_id` int default null comment '商机id',\n  primary key (`id`)\n) engine=innodb auto_increment=34 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='crm 联系人商机关联表';\n\n\n比较简单，就是 contact_id 字段和 business_id 字段的关联。\n\n\n# 3.2 管理后台\n\n① 在联系人详情页，在 [商机] 标签页，可以查看联系人关联的商机，如下图所示：\n\n\n\n * 点击【创建商机】按钮，可以创建一个新的商机，同时关联到当前联系人\n * 点击【关联】按钮，可以关联已有的商机到当前联系人。但是要注意，只能关联联系人 customer_id 字段相同的商机\n\n② 在商机详情页，在 [联系人] 标签页，可以查看商机关联的联系人，如下图所示：\n\n\n\n * 点击【创建联系人】按钮，可以创建一个新的联系人，同时关联到当前商机\n * 点击【关联】按钮，可以关联已有的联系人到当前商机。但是要注意，只能关联商机 customer_id 字段相同的联系人",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【合同】合同管理、合同提醒",
            frontmatter: {
                title: "【合同】合同管理、合同提醒",
                date: "2024-02-24T07:29:32.000Z",
                permalink: "/crm/contract"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/16.CRM%E6%89%8B%E5%86%8C/40.%E3%80%90%E5%90%88%E5%90%8C%E3%80%91%E5%90%88%E5%90%8C%E7%AE%A1%E7%90%86%E3%80%81%E5%90%88%E5%90%8C%E6%8F%90%E9%86%92.html",
            relativePath: "01.开发指南/16.CRM手册/40.【合同】合同管理、合同提醒.md",
            key: "v-42013c00",
            path: "/crm/contract/",
            headers: [{
                level: 2,
                title: "1. 合同",
                slug: "_1-合同",
                normalizedTitle: "1. 合同",
                charIndex: 69
            }, {
                level: 3,
                title: "1. 表结构",
                slug: "_1-表结构",
                normalizedTitle: "1. 表结构",
                charIndex: 158
            }, {
                level: 3,
                title: "2. 管理后台",
                slug: "_2-管理后台",
                normalizedTitle: "2. 管理后台",
                charIndex: 3200
            }, {
                level: 2,
                title: "2. 合同配置",
                slug: "_2-合同配置",
                normalizedTitle: "2. 合同配置",
                charIndex: 3709
            }, {
                level: 3,
                title: "2.1 表结构",
                slug: "_2-1-表结构",
                normalizedTitle: "2.1 表结构",
                charIndex: 3802
            }, {
                level: 3,
                title: "2.2 管理后台",
                slug: "_2-2-管理后台",
                normalizedTitle: "2.2 管理后台",
                charIndex: 4355
            }],
            headersStr: "1. 合同 1. 表结构 2. 管理后台 2. 合同配置 2.1 表结构 2.2 管理后台",
            content: "合同模块，由 yudao-module-crm-biz 后端模块的 contract 包实现，已经和 BPM 工作流 打通审批。\n\n\n# 1. 合同\n\n合同，由 yudao-module-crm-biz 后端模块的 business 包的 CrmContractController 实现。表关系如下：\n\n\n\n\n# 1. 表结构\n\n> 【合同表】省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `crm_contract` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号，主键自增',\n  `name` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '合同名称',\n  `no` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '合同编号',\n  \n  `customer_id` bigint NOT NULL COMMENT '客户编号',\n  `business_id` bigint DEFAULT NULL COMMENT '商机编号',\n  \n  `contact_last_time` datetime DEFAULT NULL COMMENT '最后跟进时间',\n  \n  `owner_user_id` bigint DEFAULT NULL COMMENT '负责人的用户编号',\n  \n  `process_instance_id` varchar(64) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '工作流编号',\n  `audit_status` tinyint NOT NULL DEFAULT '0' COMMENT '审批状态',\n\n  `total_product_price` decimal(24,6) DEFAULT NULL COMMENT '产品总金额',\n  `discount_percent` decimal(24,6) DEFAULT NULL COMMENT '整单折扣',\n  `total_price` decimal(10,2) DEFAULT NULL COMMENT '合同总金额',\n  \n  `order_date` datetime DEFAULT NULL COMMENT '下单日期',\n  `start_time` datetime DEFAULT NULL COMMENT '开始时间',\n  `end_time` datetime DEFAULT NULL COMMENT '结束时间',\n  `sign_contact_id` bigint DEFAULT NULL COMMENT '联系人编号',\n  `sign_user_id` bigint DEFAULT NULL COMMENT '公司签约人',\n  \n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='CRM 合同表';\n\n\n① no 字段：合同编号，系统自动生成的，目前格式是 {prefix}{yyyyMMdd}{6 位自增}。具体可见 ErpNoRedisDAO 类。\n\n② customer_id 字段：客户编号，对应 crm_customer 表的 id 字段，必填。\n\n③ business_id 字段：商机编号，对应 crm_business 表的 id 字段，选填。在选择商机时，会自动带出商机的 crm_business_product 表的产品信息，稍后会看到\n\n④ contact_last_time 字段：跟进相关，和线索类似。不重复赘述，详细可见 《【通用】跟进记录》 文档。\n\n⑤ owner_user_id 字段：合同的负责人编号，和线索类似。不重复赘述，详细可见 《【通用】数据权限》 文档。\n\n⑥ process_instance_id 字段：工作流编号，用于和 BPM 工作流 打通审批。提交审批后，会自动创建一个工作流实例，并记录到该字段。\n\naudit_status 字段：审批结果，目前由 CrmAuditStatusEnum 枚举，目前有 5 个状态：未提交、审批中、审批通过、审批不通过、已取消。\n\n⑤ total_product_price、discount_percent、total_price 字段：合同的金额相关，关系是 total_price = total_product_price * discount_percent。\n\n其中，total_product_price 字段是 crm_contract_product 表的 total_price * count 的累加。\n\n⑥ 从 order_date 到 sign_user_id 字段：合同的信息字段，比较简单，不重复赘述。\n\n> 【合同产品表】省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `crm_contract_product` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键',\n  \n  `contract_id` bigint NOT NULL COMMENT '合同编号',\n  `product_id` bigint NOT NULL COMMENT '产品编号',\n  \n  `product_price` decimal(24,6) NOT NULL COMMENT '产品单价',\n  `contract_price` decimal(24,6) NOT NULL COMMENT '合同价格',\n  `count` decimal(24,6) NOT NULL COMMENT '数量',\n  `total_price` decimal(24,6) NOT NULL COMMENT '总计价格',\n  \n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=39 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC COMMENT='CRM 合同产品关联表';\n\n\n友情提示：整体和商机产品表 `crm_business_product` 类似。因为本身商机进一步转化后，就是合同。\n\n① contract_id 字段：合同编号，对应 crm_contract 表的 id 字段。\n\nproduct_id 字段：产品编号，对应 crm_product 表的 id 字段。\n\n② product_price 字段：产品单价，冗余，来自 crm_product 表的 price 字段。目的是，和 contract_price 字段比较，看看是否有折扣。\n\ncount、total_price 字段：数量、总计价格。\n\n\n# 2. 管理后台\n\n对应 [CRM 系统 -> 合同管理] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/crm/contract 目录。\n\n\n\n① 点击【新增】按钮，随便填写一些信息，点击「确认」按钮，即可新增一条合同。如下图所示：\n\n\n\n② 点击【提交审批】按钮，可以提交审批。如下图所示：\n\n\n\n友情提示：\n\n合同对应的审批流程，需要自己在 [工作流程 -> 流程管理 -> 流程模型] 菜单，配置一个流程标识为 crm-contract-audit 的流程模型。如下图所示：\n\n\n\n如果不了解怎么配置的同学，可以学习下 《BPM 工作流》 的文档。\n\n提交完成后，会自动创建一个工作流实例，并记录到 process_instance_id 字段。之后可点击【查看审批】按钮，查看审批详情。如下图所示：\n\n\n\n点击审批【通过】按钮，将合同审批通过，此时它会回调 CrmContractResultListener 监听器，更新合同的 audit_status 字段为审批通过。如下图所示：\n\n\n\n③ 点击“合同名称”，进入合同详情页，可以查看合同的详细信息，如下图所示：\n\n\n\n\n# 2. 合同配置\n\n客户公海配置，由 yudao-module-crm-biz 后端模块的 contract 包的 CrmContractConfigController 实现。\n\n\n# 2.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `crm_contract_config` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  `notify_enabled` tinyint(1) DEFAULT NULL COMMENT '是否开启提前提醒',\n  `notify_days` int DEFAULT NULL COMMENT '提前提醒天数',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='CRM 合同配置表';\n\n\n目前主要是合同提醒功能。\n\nnotify_enabled 字段：是否开启提前提醒。如果开启，合同的结束时间 end_time 超过今天，并且小于 notify_days 天的，可以在 [CRM 系统 -> 待办事项] 菜单中，看到提醒。如下图所示：\n\n\n\n\n# 2.2 管理后台\n\n对应 [CRM 系统 -> 系统配置 -> 合同配置] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/contract/config 目录。\n\n",
            normalizedContent: "合同模块，由 yudao-module-crm-biz 后端模块的 contract 包实现，已经和 bpm 工作流 打通审批。\n\n\n# 1. 合同\n\n合同，由 yudao-module-crm-biz 后端模块的 business 包的 crmcontractcontroller 实现。表关系如下：\n\n\n\n\n# 1. 表结构\n\n> 【合同表】省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `crm_contract` (\n  `id` bigint not null auto_increment comment '编号，主键自增',\n  `name` varchar(128) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '合同名称',\n  `no` varchar(128) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '合同编号',\n  \n  `customer_id` bigint not null comment '客户编号',\n  `business_id` bigint default null comment '商机编号',\n  \n  `contact_last_time` datetime default null comment '最后跟进时间',\n  \n  `owner_user_id` bigint default null comment '负责人的用户编号',\n  \n  `process_instance_id` varchar(64) collate utf8mb4_unicode_ci default null comment '工作流编号',\n  `audit_status` tinyint not null default '0' comment '审批状态',\n\n  `total_product_price` decimal(24,6) default null comment '产品总金额',\n  `discount_percent` decimal(24,6) default null comment '整单折扣',\n  `total_price` decimal(10,2) default null comment '合同总金额',\n  \n  `order_date` datetime default null comment '下单日期',\n  `start_time` datetime default null comment '开始时间',\n  `end_time` datetime default null comment '结束时间',\n  `sign_contact_id` bigint default null comment '联系人编号',\n  `sign_user_id` bigint default null comment '公司签约人',\n  \n  primary key (`id`) using btree\n) engine=innodb auto_increment=8 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='crm 合同表';\n\n\n① no 字段：合同编号，系统自动生成的，目前格式是 {prefix}{yyyymmdd}{6 位自增}。具体可见 erpnoredisdao 类。\n\n② customer_id 字段：客户编号，对应 crm_customer 表的 id 字段，必填。\n\n③ business_id 字段：商机编号，对应 crm_business 表的 id 字段，选填。在选择商机时，会自动带出商机的 crm_business_product 表的产品信息，稍后会看到\n\n④ contact_last_time 字段：跟进相关，和线索类似。不重复赘述，详细可见 《【通用】跟进记录》 文档。\n\n⑤ owner_user_id 字段：合同的负责人编号，和线索类似。不重复赘述，详细可见 《【通用】数据权限》 文档。\n\n⑥ process_instance_id 字段：工作流编号，用于和 bpm 工作流 打通审批。提交审批后，会自动创建一个工作流实例，并记录到该字段。\n\naudit_status 字段：审批结果，目前由 crmauditstatusenum 枚举，目前有 5 个状态：未提交、审批中、审批通过、审批不通过、已取消。\n\n⑤ total_product_price、discount_percent、total_price 字段：合同的金额相关，关系是 total_price = total_product_price * discount_percent。\n\n其中，total_product_price 字段是 crm_contract_product 表的 total_price * count 的累加。\n\n⑥ 从 order_date 到 sign_user_id 字段：合同的信息字段，比较简单，不重复赘述。\n\n> 【合同产品表】省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `crm_contract_product` (\n  `id` bigint not null auto_increment comment '主键',\n  \n  `contract_id` bigint not null comment '合同编号',\n  `product_id` bigint not null comment '产品编号',\n  \n  `product_price` decimal(24,6) not null comment '产品单价',\n  `contract_price` decimal(24,6) not null comment '合同价格',\n  `count` decimal(24,6) not null comment '数量',\n  `total_price` decimal(24,6) not null comment '总计价格',\n  \n  primary key (`id`) using btree\n) engine=innodb auto_increment=39 default charset=utf8mb4 collate=utf8mb4_unicode_ci row_format=dynamic comment='crm 合同产品关联表';\n\n\n友情提示：整体和商机产品表 `crm_business_product` 类似。因为本身商机进一步转化后，就是合同。\n\n① contract_id 字段：合同编号，对应 crm_contract 表的 id 字段。\n\nproduct_id 字段：产品编号，对应 crm_product 表的 id 字段。\n\n② product_price 字段：产品单价，冗余，来自 crm_product 表的 price 字段。目的是，和 contract_price 字段比较，看看是否有折扣。\n\ncount、total_price 字段：数量、总计价格。\n\n\n# 2. 管理后台\n\n对应 [crm 系统 -> 合同管理] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/crm/contract 目录。\n\n\n\n① 点击【新增】按钮，随便填写一些信息，点击「确认」按钮，即可新增一条合同。如下图所示：\n\n\n\n② 点击【提交审批】按钮，可以提交审批。如下图所示：\n\n\n\n友情提示：\n\n合同对应的审批流程，需要自己在 [工作流程 -> 流程管理 -> 流程模型] 菜单，配置一个流程标识为 crm-contract-audit 的流程模型。如下图所示：\n\n\n\n如果不了解怎么配置的同学，可以学习下 《bpm 工作流》 的文档。\n\n提交完成后，会自动创建一个工作流实例，并记录到 process_instance_id 字段。之后可点击【查看审批】按钮，查看审批详情。如下图所示：\n\n\n\n点击审批【通过】按钮，将合同审批通过，此时它会回调 crmcontractresultlistener 监听器，更新合同的 audit_status 字段为审批通过。如下图所示：\n\n\n\n③ 点击“合同名称”，进入合同详情页，可以查看合同的详细信息，如下图所示：\n\n\n\n\n# 2. 合同配置\n\n客户公海配置，由 yudao-module-crm-biz 后端模块的 contract 包的 crmcontractconfigcontroller 实现。\n\n\n# 2.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `crm_contract_config` (\n  `id` bigint not null auto_increment comment '编号',\n  `notify_enabled` tinyint(1) default null comment '是否开启提前提醒',\n  `notify_days` int default null comment '提前提醒天数',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=2 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='crm 合同配置表';\n\n\n目前主要是合同提醒功能。\n\nnotify_enabled 字段：是否开启提前提醒。如果开启，合同的结束时间 end_time 超过今天，并且小于 notify_days 天的，可以在 [crm 系统 -> 待办事项] 菜单中，看到提醒。如下图所示：\n\n\n\n\n# 2.2 管理后台\n\n对应 [crm 系统 -> 系统配置 -> 合同配置] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/contract/config 目录。\n\n",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【产品】产品管理、产品分类",
            frontmatter: {
                title: "【产品】产品管理、产品分类",
                date: "2024-02-24T08:22:32.000Z",
                permalink: "/crm/product/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/16.CRM%E6%89%8B%E5%86%8C/60.%E3%80%90%E4%BA%A7%E5%93%81%E3%80%91%E4%BA%A7%E5%93%81%E7%AE%A1%E7%90%86%E3%80%81%E4%BA%A7%E5%93%81%E5%88%86%E7%B1%BB.html",
            relativePath: "01.开发指南/16.CRM手册/60.【产品】产品管理、产品分类.md",
            key: "v-41341d4b",
            path: "/crm/product/",
            headers: [{
                level: 2,
                title: "1. 产品分类",
                slug: "_1-产品分类",
                normalizedTitle: "1. 产品分类",
                charIndex: 170
            }, {
                level: 3,
                title: "1.1 表结构",
                slug: "_1-1-表结构",
                normalizedTitle: "1.1 表结构",
                charIndex: 225
            }, {
                level: 3,
                title: "1.2 管理后台",
                slug: "_1-2-管理后台",
                normalizedTitle: "1.2 管理后台",
                charIndex: 730
            }, {
                level: 2,
                title: "2. 产品管理",
                slug: "_2-产品管理",
                normalizedTitle: "2. 产品管理",
                charIndex: 837
            }, {
                level: 3,
                title: "2.1 表结构",
                slug: "_2-1-表结构",
                normalizedTitle: "2.1 表结构",
                charIndex: 884
            }, {
                level: 3,
                title: "2.2 管理后台",
                slug: "_2-2-管理后台",
                normalizedTitle: "2.2 管理后台",
                charIndex: 1903
            }],
            headersStr: "1. 产品分类 1.1 表结构 1.2 管理后台 2. 产品管理 2.1 表结构 2.2 管理后台",
            content: "友情提示：\n\n考虑到 ERP 和 CRM 的解耦，CRM 独立做了一个产品模块。\n\n如果你的系统即用到 ERP 又用到 CRM，并且希望使用一套产品，则可以以 ERP 产品为主进行改造。\n\n产品模块，由 yudao-module-crm-biz 后端模块的 product 包实现，主要有产品信息、产品分类等功能。如下图所示：\n\n\n\n\n# 1. 产品分类\n\n产品分类，由 CrmProductCategoryController 提供接口。\n\n\n# 1.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `crm_product_category` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '分类编号',\n  `name` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '分类名称',\n  \n  `parent_id` bigint NOT NULL COMMENT '父级编号',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='CRM 产品分类表';\n\n\n分类目前支持 2 级分类，即 parent_id 为 0 的是一级分类，否则是二级分类。\n\n\n# 1.2 管理后台\n\n对应 [CRM 系统 -> 系统配置 -> 产品分类] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/crm/product/category 目录。\n\n\n\n\n# 2. 产品管理\n\n产品管理，由 CrmProductController 提供接口。\n\n\n# 2.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `crm_product` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '产品编号',\n  `name` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '产品名称',\n  \n  `category_id` bigint NOT NULL COMMENT '产品分类编号',\n  `unit` tinyint DEFAULT NULL COMMENT '单位',\n  `status` tinyint NOT NULL DEFAULT '1' COMMENT '状态',\n\n  `owner_user_id` bigint NOT NULL COMMENT '负责人的用户编号',  \n  `no` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '产品编码',\n  `price` decimal(24,6) DEFAULT '0.000000' COMMENT '价格，单位：元',\n  `description` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '产品描述',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='CRM 产品表';\n\n\n① unit 字段：产品单位，对应 crm_product_unit 数据字典。\n\n② status 字段：产品状态，0 开启、1 禁用。\n\n③ category_id 字段：产品分类编号，对应 crm_product_category 表。\n\n其它字段，都是一些信息字段，暂时没有什么特殊逻辑。\n\n\n# 2.2 管理后台\n\n对应 [CRM 系统 -> 产品管理 -> 产品管理] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/crm/product 目录。\n\n\n\n① 点击【新增】按钮，随便填写一些信息，点击「确认」按钮，即可新增一个产品。如下图所示：\n\n\n\n④ 点击“产品名称”，进入产品详情页，可以查看产品的详细信息，如下图所示：\n\n",
            normalizedContent: "友情提示：\n\n考虑到 erp 和 crm 的解耦，crm 独立做了一个产品模块。\n\n如果你的系统即用到 erp 又用到 crm，并且希望使用一套产品，则可以以 erp 产品为主进行改造。\n\n产品模块，由 yudao-module-crm-biz 后端模块的 product 包实现，主要有产品信息、产品分类等功能。如下图所示：\n\n\n\n\n# 1. 产品分类\n\n产品分类，由 crmproductcategorycontroller 提供接口。\n\n\n# 1.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `crm_product_category` (\n  `id` bigint not null auto_increment comment '分类编号',\n  `name` varchar(100) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '分类名称',\n  \n  `parent_id` bigint not null comment '父级编号',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=7 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='crm 产品分类表';\n\n\n分类目前支持 2 级分类，即 parent_id 为 0 的是一级分类，否则是二级分类。\n\n\n# 1.2 管理后台\n\n对应 [crm 系统 -> 系统配置 -> 产品分类] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/crm/product/category 目录。\n\n\n\n\n# 2. 产品管理\n\n产品管理，由 crmproductcontroller 提供接口。\n\n\n# 2.1 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `crm_product` (\n  `id` bigint not null auto_increment comment '产品编号',\n  `name` varchar(100) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '产品名称',\n  \n  `category_id` bigint not null comment '产品分类编号',\n  `unit` tinyint default null comment '单位',\n  `status` tinyint not null default '1' comment '状态',\n\n  `owner_user_id` bigint not null comment '负责人的用户编号',  \n  `no` varchar(20) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '产品编码',\n  `price` decimal(24,6) default '0.000000' comment '价格，单位：元',\n  `description` varchar(100) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '产品描述',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=6 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='crm 产品表';\n\n\n① unit 字段：产品单位，对应 crm_product_unit 数据字典。\n\n② status 字段：产品状态，0 开启、1 禁用。\n\n③ category_id 字段：产品分类编号，对应 crm_product_category 表。\n\n其它字段，都是一些信息字段，暂时没有什么特殊逻辑。\n\n\n# 2.2 管理后台\n\n对应 [crm 系统 -> 产品管理 -> 产品管理] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/crm/product 目录。\n\n\n\n① 点击【新增】按钮，随便填写一些信息，点击「确认」按钮，即可新增一个产品。如下图所示：\n\n\n\n④ 点击“产品名称”，进入产品详情页，可以查看产品的详细信息，如下图所示：\n\n",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【回款】回款管理、回款计划",
            frontmatter: {
                title: "【回款】回款管理、回款计划",
                date: "2024-02-24T08:19:21.000Z",
                permalink: "/crm/receivable/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/16.CRM%E6%89%8B%E5%86%8C/50.%E3%80%90%E5%9B%9E%E6%AC%BE%E3%80%91%E5%9B%9E%E6%AC%BE%E7%AE%A1%E7%90%86%E3%80%81%E5%9B%9E%E6%AC%BE%E8%AE%A1%E5%88%92.html",
            relativePath: "01.开发指南/16.CRM手册/50.【回款】回款管理、回款计划.md",
            key: "v-343e687c",
            path: "/crm/receivable/",
            headers: [{
                level: 2,
                title: "1. 回款",
                slug: "_1-回款",
                normalizedTitle: "1. 回款",
                charIndex: 185
            }, {
                level: 3,
                title: "1. 表结构",
                slug: "_1-表结构",
                normalizedTitle: "1. 表结构",
                charIndex: 270
            }, {
                level: 3,
                title: "2.2 管理后台",
                slug: "_2-2-管理后台",
                normalizedTitle: "2.2 管理后台",
                charIndex: 1872
            }, {
                level: 2,
                title: "2. 回款计划",
                slug: "_2-回款计划",
                normalizedTitle: "2. 回款计划",
                charIndex: 2545
            }, {
                level: 3,
                title: "2.1 表结构",
                slug: "_2-1-表结构",
                normalizedTitle: "2.1 表结构",
                charIndex: 2638
            }, {
                level: 3,
                title: "2.2 管理后台",
                slug: "_2-2-管理后台-2",
                normalizedTitle: "2.2 管理后台",
                charIndex: 1872
            }],
            headersStr: "1. 回款 1. 表结构 2.2 管理后台 2. 回款计划 2.1 表结构 2.2 管理后台",
            content: "CRM 回款，主要指的是在销售过程中，企业与客户签订销售【合同】后，从客户那里实际收到的款项的记录。\n\n回款模块，由 yudao-module-crm-biz 后端模块的 receivable 包实现，已经和 BPM 工作流 打通审批。\n\n目前有两种回款链路，因此表关系如下图所示：\n\n * 【合同】=>【回款】\n * 【合同】=>【回款计划】=>【回款】\n\n\n\n\n# 1. 回款\n\n回款，由 yudao-module-crm-biz 后端模块的 receivable 包的 CrmReceivableController 实现。\n\n\n# 1. 表结构\n\n> 【回款表】省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `crm_receivable` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT 'ID',\n  `no` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '回款编号',\n  \n  `customer_id` bigint NOT NULL COMMENT '客户ID',\n  `contract_id` bigint NOT NULL COMMENT '合同ID',\n  \n  `plan_id` bigint DEFAULT NULL COMMENT '回款计划ID',\n  \n  `owner_user_id` bigint DEFAULT NULL COMMENT '负责人的用户编号',\n  \n  `audit_status` tinyint NOT NULL COMMENT '审批状态',\n  `process_instance_id` varchar(64) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '工作流编号',\n\n  `price` decimal(24,6) NOT NULL COMMENT '回款金额',\n  \n  `return_time` datetime DEFAULT NULL COMMENT '回款日期',\n  `return_type` int DEFAULT NULL COMMENT '回款方式',\n  `remark` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '备注',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=29 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='CRM 回款管理';\n\n\n① no 字段：回款编号，系统自动生成的，目前格式是 {prefix}{yyyyMMdd}{6 位自增}。具体可见 ErpNoRedisDAO 类。\n\n② customer_id 和 contract_id 字段：客户编号和合同编号，对应 crm_customer 表和 crm_contract 表的 id 字段，必填。\n\n③ plan_id 字段：回款计划编号，对应 crm_receivable_plan 表的 id 字段，选填。只有在【合同】=>【回款计划】=>【回款】的情况下，才会有值。\n\n④ owner_user_id 字段：回款的负责人编号，和线索类似。不重复赘述，详细可见 《【通用】数据权限》 文档。\n\n⑤ process_instance_id 字段：工作流编号，用于和 BPM 工作流 打通审批。提交审批后，会自动创建一个工作流实例，并记录到该字段。\n\naudit_status 字段：审批结果，目前由 CrmAuditStatusEnum 枚举，目前有 5 个状态：未提交、审批中、审批通过、审批不通过、已取消。\n\n⑥ price 字段：回款金额。一个合同可能有多次回款，它总的回款金额不能超过合同金额。\n\n⑦ return_time、return_type、remark 字段：回款日期、回款方式、备注。就是信息字段，没什么特殊逻辑。\n\n\n# 2.2 管理后台\n\n对应 [CRM 系统 -> 回款管理] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/crm/receivable 目录。\n\n\n\n① 参考 《【合同】合同管理、合同提醒》 文档，创建一个合同。注意，必须审核通过，才能进行回款。\n\n② 点击【新增】按钮，随便填写一些信息，点击「确认」按钮，即可新增一条回款。如下图所示：\n\n\n\n这样，我们就完成了【合同】=>【回款】的整个回款链路。\n\n② 点击【提交审批】按钮，可以提交审批。如下图所示：\n\n\n\n友情提示：\n\n回款对应的审批流程，需要自己在 [工作流程 -> 流程管理 -> 流程模型] 菜单，配置一个流程标识为 crm-receivable-audit 的流程模型。如下图所示：\n\n\n\n如果不了解怎么配置的同学，可以学习下 《BPM 工作流》 的文档。\n\n提交完成后，会自动创建一个工作流实例，并记录到 process_instance_id 字段。之后可点击【查看审批】按钮，查看审批详情。如下图所示：\n\n\n\n点击审批【通过】按钮，将回款审批通过，此时它会回调 CrmReceivableResultListener 监听器，更新回款的 audit_status 字段为审批通过。如下图所示：\n\n\n\n③ 点击“回款编号”，进入回款详情页，可以查看回款的详细信息，如下图所示：\n\n\n\n----------------------------------------\n\n另外，也可以在【合同】的详情页，进行【回款】的创建。如下图所示：\n\n\n\n\n# 2. 回款计划\n\n回款计划，由 yudao-module-crm-biz 后端模块的 receivable 包的 CrmReceivablePlanController 实现。\n\n\n# 2.1 表结构\n\n> 【回款计划表】省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `crm_receivable_plan` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT 'ID',\n  \n  `period` bigint NOT NULL COMMENT '期数',\n  \n  `customer_id` bigint NOT NULL COMMENT '客户编号',\n  `contract_id` bigint NOT NULL COMMENT '合同编号',\n  \n  `owner_user_id` bigint DEFAULT NULL COMMENT '负责人编号',\n  \n  `receivable_id` bigint DEFAULT NULL COMMENT '回款编号',\n  \n  `return_time` datetime DEFAULT NULL COMMENT '计划回款日期',\n  `return_type` tinyint DEFAULT NULL COMMENT '计划还款方式',\n  `price` decimal(24,6) NOT NULL COMMENT '计划回款金额',\n  `remind_days` bigint DEFAULT NULL COMMENT '提前几天提醒',\n  `remind_time` datetime DEFAULT NULL COMMENT '提醒日期',\n  `remark` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '备注',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='CRM 回款计划';\n\n\n由于 crm_receivable_plan 是 crm_receivable 的计划（草稿），所以结构上非常相似。\n\n① period 字段：期数，比如第一期、第二期、第三期等。目前是基于 contract_id 在 crm_receivable_plan 表中的最大期数加 1。\n\n② customer_id 和 contract_id 字段：客户编号和合同编号，对应 crm_customer 表和 crm_contract 表的 id 字段，必填。\n\n③ owner_user_id 字段：回款计划的负责人编号，和线索类似。不重复赘述，详细可见 《【通用】数据权限》 文档。\n\n④ receivable_id 字段：回款编号，对应 crm_receivable 表的 id 字段，选填。\n\n只有在【合同】=>【回款计划】=>【回款】的情况下，才会有值。即基于【回款计划】创建【回款】时，会将【回款】的 id 字段记录到这里。\n\n⑤ return_time、return_type、price、remind_days、remind_time、remark 字段：回款日期、回款方式、回款金额、提醒天数、提醒日期、备注。就是信息字段，没什么特殊逻辑。\n\n不过 remind_time 字段，有点特殊，它是 return_time 字段减去 remind_days 字段的日期，后续用于提醒，如下图所示：\n\n\n\n\n# 2.2 管理后台\n\n对应 [CRM 系统 -> 回款计划] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/crm/receivable/plan 目录。\n\n\n\n① 点击【新增】按钮，随便填写一些信息，点击「确认」按钮，即可新增一条回款计划。如下图所示：\n\n\n\n② 点击【创建回款】按钮，可以创建回款。如下图所示：\n\n\n\n这样，我们就完成了【合同】=>【回款计划】=>【回款】的整个回款链路。\n\n③ 点击“期数”，进入回款计划详情页，可以查看回款计划的详细信息，如下图所示：\n\n\n\n----------------------------------------\n\n另外，也可以在【合同】的详情页，进行【回款计划】的创建。如下图所示：\n\n",
            normalizedContent: "crm 回款，主要指的是在销售过程中，企业与客户签订销售【合同】后，从客户那里实际收到的款项的记录。\n\n回款模块，由 yudao-module-crm-biz 后端模块的 receivable 包实现，已经和 bpm 工作流 打通审批。\n\n目前有两种回款链路，因此表关系如下图所示：\n\n * 【合同】=>【回款】\n * 【合同】=>【回款计划】=>【回款】\n\n\n\n\n# 1. 回款\n\n回款，由 yudao-module-crm-biz 后端模块的 receivable 包的 crmreceivablecontroller 实现。\n\n\n# 1. 表结构\n\n> 【回款表】省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `crm_receivable` (\n  `id` bigint not null auto_increment comment 'id',\n  `no` varchar(100) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '回款编号',\n  \n  `customer_id` bigint not null comment '客户id',\n  `contract_id` bigint not null comment '合同id',\n  \n  `plan_id` bigint default null comment '回款计划id',\n  \n  `owner_user_id` bigint default null comment '负责人的用户编号',\n  \n  `audit_status` tinyint not null comment '审批状态',\n  `process_instance_id` varchar(64) collate utf8mb4_unicode_ci default null comment '工作流编号',\n\n  `price` decimal(24,6) not null comment '回款金额',\n  \n  `return_time` datetime default null comment '回款日期',\n  `return_type` int default null comment '回款方式',\n  `remark` varchar(500) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '备注',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=29 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='crm 回款管理';\n\n\n① no 字段：回款编号，系统自动生成的，目前格式是 {prefix}{yyyymmdd}{6 位自增}。具体可见 erpnoredisdao 类。\n\n② customer_id 和 contract_id 字段：客户编号和合同编号，对应 crm_customer 表和 crm_contract 表的 id 字段，必填。\n\n③ plan_id 字段：回款计划编号，对应 crm_receivable_plan 表的 id 字段，选填。只有在【合同】=>【回款计划】=>【回款】的情况下，才会有值。\n\n④ owner_user_id 字段：回款的负责人编号，和线索类似。不重复赘述，详细可见 《【通用】数据权限》 文档。\n\n⑤ process_instance_id 字段：工作流编号，用于和 bpm 工作流 打通审批。提交审批后，会自动创建一个工作流实例，并记录到该字段。\n\naudit_status 字段：审批结果，目前由 crmauditstatusenum 枚举，目前有 5 个状态：未提交、审批中、审批通过、审批不通过、已取消。\n\n⑥ price 字段：回款金额。一个合同可能有多次回款，它总的回款金额不能超过合同金额。\n\n⑦ return_time、return_type、remark 字段：回款日期、回款方式、备注。就是信息字段，没什么特殊逻辑。\n\n\n# 2.2 管理后台\n\n对应 [crm 系统 -> 回款管理] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/crm/receivable 目录。\n\n\n\n① 参考 《【合同】合同管理、合同提醒》 文档，创建一个合同。注意，必须审核通过，才能进行回款。\n\n② 点击【新增】按钮，随便填写一些信息，点击「确认」按钮，即可新增一条回款。如下图所示：\n\n\n\n这样，我们就完成了【合同】=>【回款】的整个回款链路。\n\n② 点击【提交审批】按钮，可以提交审批。如下图所示：\n\n\n\n友情提示：\n\n回款对应的审批流程，需要自己在 [工作流程 -> 流程管理 -> 流程模型] 菜单，配置一个流程标识为 crm-receivable-audit 的流程模型。如下图所示：\n\n\n\n如果不了解怎么配置的同学，可以学习下 《bpm 工作流》 的文档。\n\n提交完成后，会自动创建一个工作流实例，并记录到 process_instance_id 字段。之后可点击【查看审批】按钮，查看审批详情。如下图所示：\n\n\n\n点击审批【通过】按钮，将回款审批通过，此时它会回调 crmreceivableresultlistener 监听器，更新回款的 audit_status 字段为审批通过。如下图所示：\n\n\n\n③ 点击“回款编号”，进入回款详情页，可以查看回款的详细信息，如下图所示：\n\n\n\n----------------------------------------\n\n另外，也可以在【合同】的详情页，进行【回款】的创建。如下图所示：\n\n\n\n\n# 2. 回款计划\n\n回款计划，由 yudao-module-crm-biz 后端模块的 receivable 包的 crmreceivableplancontroller 实现。\n\n\n# 2.1 表结构\n\n> 【回款计划表】省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `crm_receivable_plan` (\n  `id` bigint not null auto_increment comment 'id',\n  \n  `period` bigint not null comment '期数',\n  \n  `customer_id` bigint not null comment '客户编号',\n  `contract_id` bigint not null comment '合同编号',\n  \n  `owner_user_id` bigint default null comment '负责人编号',\n  \n  `receivable_id` bigint default null comment '回款编号',\n  \n  `return_time` datetime default null comment '计划回款日期',\n  `return_type` tinyint default null comment '计划还款方式',\n  `price` decimal(24,6) not null comment '计划回款金额',\n  `remind_days` bigint default null comment '提前几天提醒',\n  `remind_time` datetime default null comment '提醒日期',\n  `remark` varchar(500) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '备注',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=7 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='crm 回款计划';\n\n\n由于 crm_receivable_plan 是 crm_receivable 的计划（草稿），所以结构上非常相似。\n\n① period 字段：期数，比如第一期、第二期、第三期等。目前是基于 contract_id 在 crm_receivable_plan 表中的最大期数加 1。\n\n② customer_id 和 contract_id 字段：客户编号和合同编号，对应 crm_customer 表和 crm_contract 表的 id 字段，必填。\n\n③ owner_user_id 字段：回款计划的负责人编号，和线索类似。不重复赘述，详细可见 《【通用】数据权限》 文档。\n\n④ receivable_id 字段：回款编号，对应 crm_receivable 表的 id 字段，选填。\n\n只有在【合同】=>【回款计划】=>【回款】的情况下，才会有值。即基于【回款计划】创建【回款】时，会将【回款】的 id 字段记录到这里。\n\n⑤ return_time、return_type、price、remind_days、remind_time、remark 字段：回款日期、回款方式、回款金额、提醒天数、提醒日期、备注。就是信息字段，没什么特殊逻辑。\n\n不过 remind_time 字段，有点特殊，它是 return_time 字段减去 remind_days 字段的日期，后续用于提醒，如下图所示：\n\n\n\n\n# 2.2 管理后台\n\n对应 [crm 系统 -> 回款计划] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/crm/receivable/plan 目录。\n\n\n\n① 点击【新增】按钮，随便填写一些信息，点击「确认」按钮，即可新增一条回款计划。如下图所示：\n\n\n\n② 点击【创建回款】按钮，可以创建回款。如下图所示：\n\n\n\n这样，我们就完成了【合同】=>【回款计划】=>【回款】的整个回款链路。\n\n③ 点击“期数”，进入回款计划详情页，可以查看回款计划的详细信息，如下图所示：\n\n\n\n----------------------------------------\n\n另外，也可以在【合同】的详情页，进行【回款计划】的创建。如下图所示：\n\n",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【通用】数据权限",
            frontmatter: {
                title: "【通用】数据权限",
                date: "2024-02-23T21:51:38.000Z",
                permalink: "/crm/permission/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/16.CRM%E6%89%8B%E5%86%8C/90.%E3%80%90%E9%80%9A%E7%94%A8%E3%80%91%E6%95%B0%E6%8D%AE%E6%9D%83%E9%99%90.html",
            relativePath: "01.开发指南/16.CRM手册/90.【通用】数据权限.md",
            key: "v-7c10611a",
            path: "/crm/permission/",
            headers: [{
                level: 2,
                title: "1. 表结构",
                slug: "_1-表结构",
                normalizedTitle: "1. 表结构",
                charIndex: 464
            }, {
                level: 3,
                title: "1.1 OWNER 负责人",
                slug: "_1-1-owner-负责人",
                normalizedTitle: "1.1 owner 负责人",
                charIndex: 1174
            }, {
                level: 3,
                title: "1.2 WRITE 读写、READ 只读",
                slug: "_1-2-write-读写、read-只读",
                normalizedTitle: "1.2 write 读写、read 只读",
                charIndex: 1391
            }, {
                level: 2,
                title: "3. 后端实现",
                slug: "_3-后端实现",
                normalizedTitle: "3. 后端实现",
                charIndex: 1657
            }, {
                level: 3,
                title: "2.1 操作校验",
                slug: "_2-1-操作校验",
                normalizedTitle: "2.1 操作校验",
                charIndex: 1669
            }, {
                level: 3,
                title: "2.2 查询过滤",
                slug: "_2-2-查询过滤",
                normalizedTitle: "2.2 查询过滤",
                charIndex: 2015
            }],
            headersStr: "1. 表结构 1.1 OWNER 负责人 1.2 WRITE 读写、READ 只读 3. 后端实现 2.1 操作校验 2.2 查询过滤",
            content: "数据权限，由 yudao-module-crm-biz 后端模块的 permission 包实现，支持某个人对某个数据（线索、客户、商机、合同等等），有对应的权限。\n\n目前权限由 CrmPermissionLevelEnum 枚举，包括 3 种：OWNER（负责人）、WRITE（读写）、READ（只读），并且 OWNER > WRITE > READ。\n\n友情提示：\n\n为什么不使用全局封装的 [《数据权限》])(/data-permission) 呢？\n\n目前 CRM 系统的数据权限比较灵活，部分功能无法很好的支持。例如说：\n\n * 全局的数据权限，只支持对某个数据的操作权限，而 CRM 需要分 OWNER、WRITE、READ 三种权限\n * 全局的数据全量，对关联数据的权限控制，无法很好的支持。例如说：对某个客户有 WRITE 权限时，可以 WRITE 它下面的联系人、商机、合同等等\n\n你可以理解全局的数据权限是基于 DB（DAO）层面实现的，而 CRM 的数据权限是基于 Service 层面实现的。\n\n\n# 1. 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `crm_permission` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n\n  `user_id` bigint NOT NULL DEFAULT '0' COMMENT '用户编号',\n  \n  `biz_type` tinyint NOT NULL DEFAULT '100' COMMENT '数据类型',\n  `biz_id` bigint NOT NULL DEFAULT '0' COMMENT '数据编号',\n  \n  `level` int NOT NULL DEFAULT '0' COMMENT '会员等级',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=86 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='CRM 数据权限表';\n\n\n基本就是三要素：\n\n * 人：user_id 字段\n * 数据：biz_type + biz_id 字段。其中 biz_type 由 CrmBizTypeEnum 枚举，包括线索、客户、联系人、商机、合同、回款等等\n * 权限：level 字段。由 CrmPermissionLevelEnum 枚举，包括 OWNER、WRITE、READ 三种\n\n\n# 1.1 OWNER 负责人\n\n① 每个数据在新增时，会插入一条 OWNER 的权限。例如说，新增一个客户，会插入一条 OWNER 的权限。如下图所示：\n\n\n\n② 每个数据在转移时，会对新、老负责人的权限做不同的处理。例如说，联系人转移给其他人，会更新对应的权限。如下图所示：\n\n\n\n * 老负责人，会将对应的 crm_permission 的 level 更新为 READ\n * 新负责人，会插入一条 OWNER 的权限\n\n\n\n\n# 1.2 WRITE 读写、READ 只读\n\n在每个数据的详情界面，有一个 [团队成员] 的功能，可以查看当前数据的权限，同时可以修改 WRITE 和 READ 的权限。如下图所示：\n\n\n\n这是一个通用的功能，不需要每个数据都实现一遍，在 CrmPermissionController 已经统一实现。如下图所示：\n\n\n\n友情提示：为什么转移负责人不能在 CrmPermissionController 统一实现呢？\n\n考虑到查询方便，每个数据记录自身会有 owner_user_id 字段，转移时需要更新，所以没一起实现。\n\n\n# 3. 后端实现\n\n\n# 2.1 操作校验\n\n操作校验，通过 @CrmPermission 注解实现，只要添加在 Service 方法上，即可实现对应的权限校验。\n\n\n\n① 使用示例，如下图所示：\n\n\n\n② 通过 Spring AOP 实现，可见 CrmPermissionAspect 类，如下图所示：\n\n\n\n通过这个类，我们也可以看出为什么要有 crm_permission 表。如果没有这个表，我们需要查询每个业务的数据，通过它们的字段，判断当前用户是否有权限，这样拓展性比较差。\n\n③ 【CRM 管理员】的角色枚举是 crm_admin，它和全局的【超级管理员】 super_admin 是分开的。如下图所示：\n\n\n\n也就是说，把【CRM 管理员】分配给某个人时，可以查询和操作所有 CRM 的数据。\n\n\n# 2.2 查询过滤\n\n在数据的列表界面，我们需要在 DB 数据库查询的时候，就将没有 READ 权限的数据过滤掉。\n\n疑问：为什么不通过类似 `@CrmPermission` 注解实现呢？\n\n可以实现，但是会查询特别多没权限的数据到内存中，导致性能比较差。\n\n这个无法通用实现，目前是每个业务 Mapper 拼接 SQL 实现，通过联表查询 crm_permission 表，进行过滤。如下图所示：\n\n\n\n核心的拼接逻辑在 CrmPermissionUtils 的 #appendPermissionCondition(...) 方法里，不是很复杂，可以自己瞅瞅。如下图所示：\n\n\n\n另外，CRM 系统的所有管理界面，都有一个 CrmSceneTypeEnum 枚举，分成 3 种场景：OWNER 我负责的，INVOLVED 我参与的、SUBORDINATE 下属负责的，也是通过上面查询实现的。\n\n\n\n画外音\n\n看到这里，在回过头看为什么不基于全局的 [《数据权限》])(/data-permission) 实现，是不是有点明白了呢？\n\n在设计系统的数据权限，我们总是渴望通过全局的、自动化的方式实现。但是，实际上，业务的数据权限是非常复杂的，很难通过全局的方式实现。\n\n因此，我们需要在业务层面，实现对应的数据权限逻辑。嘿嘿~",
            normalizedContent: "数据权限，由 yudao-module-crm-biz 后端模块的 permission 包实现，支持某个人对某个数据（线索、客户、商机、合同等等），有对应的权限。\n\n目前权限由 crmpermissionlevelenum 枚举，包括 3 种：owner（负责人）、write（读写）、read（只读），并且 owner > write > read。\n\n友情提示：\n\n为什么不使用全局封装的 [《数据权限》])(/data-permission) 呢？\n\n目前 crm 系统的数据权限比较灵活，部分功能无法很好的支持。例如说：\n\n * 全局的数据权限，只支持对某个数据的操作权限，而 crm 需要分 owner、write、read 三种权限\n * 全局的数据全量，对关联数据的权限控制，无法很好的支持。例如说：对某个客户有 write 权限时，可以 write 它下面的联系人、商机、合同等等\n\n你可以理解全局的数据权限是基于 db（dao）层面实现的，而 crm 的数据权限是基于 service 层面实现的。\n\n\n# 1. 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `crm_permission` (\n  `id` bigint not null auto_increment comment '编号',\n\n  `user_id` bigint not null default '0' comment '用户编号',\n  \n  `biz_type` tinyint not null default '100' comment '数据类型',\n  `biz_id` bigint not null default '0' comment '数据编号',\n  \n  `level` int not null default '0' comment '会员等级',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=86 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='crm 数据权限表';\n\n\n基本就是三要素：\n\n * 人：user_id 字段\n * 数据：biz_type + biz_id 字段。其中 biz_type 由 crmbiztypeenum 枚举，包括线索、客户、联系人、商机、合同、回款等等\n * 权限：level 字段。由 crmpermissionlevelenum 枚举，包括 owner、write、read 三种\n\n\n# 1.1 owner 负责人\n\n① 每个数据在新增时，会插入一条 owner 的权限。例如说，新增一个客户，会插入一条 owner 的权限。如下图所示：\n\n\n\n② 每个数据在转移时，会对新、老负责人的权限做不同的处理。例如说，联系人转移给其他人，会更新对应的权限。如下图所示：\n\n\n\n * 老负责人，会将对应的 crm_permission 的 level 更新为 read\n * 新负责人，会插入一条 owner 的权限\n\n\n\n\n# 1.2 write 读写、read 只读\n\n在每个数据的详情界面，有一个 [团队成员] 的功能，可以查看当前数据的权限，同时可以修改 write 和 read 的权限。如下图所示：\n\n\n\n这是一个通用的功能，不需要每个数据都实现一遍，在 crmpermissioncontroller 已经统一实现。如下图所示：\n\n\n\n友情提示：为什么转移负责人不能在 crmpermissioncontroller 统一实现呢？\n\n考虑到查询方便，每个数据记录自身会有 owner_user_id 字段，转移时需要更新，所以没一起实现。\n\n\n# 3. 后端实现\n\n\n# 2.1 操作校验\n\n操作校验，通过 @crmpermission 注解实现，只要添加在 service 方法上，即可实现对应的权限校验。\n\n\n\n① 使用示例，如下图所示：\n\n\n\n② 通过 spring aop 实现，可见 crmpermissionaspect 类，如下图所示：\n\n\n\n通过这个类，我们也可以看出为什么要有 crm_permission 表。如果没有这个表，我们需要查询每个业务的数据，通过它们的字段，判断当前用户是否有权限，这样拓展性比较差。\n\n③ 【crm 管理员】的角色枚举是 crm_admin，它和全局的【超级管理员】 super_admin 是分开的。如下图所示：\n\n\n\n也就是说，把【crm 管理员】分配给某个人时，可以查询和操作所有 crm 的数据。\n\n\n# 2.2 查询过滤\n\n在数据的列表界面，我们需要在 db 数据库查询的时候，就将没有 read 权限的数据过滤掉。\n\n疑问：为什么不通过类似 `@crmpermission` 注解实现呢？\n\n可以实现，但是会查询特别多没权限的数据到内存中，导致性能比较差。\n\n这个无法通用实现，目前是每个业务 mapper 拼接 sql 实现，通过联表查询 crm_permission 表，进行过滤。如下图所示：\n\n\n\n核心的拼接逻辑在 crmpermissionutils 的 #appendpermissioncondition(...) 方法里，不是很复杂，可以自己瞅瞅。如下图所示：\n\n\n\n另外，crm 系统的所有管理界面，都有一个 crmscenetypeenum 枚举，分成 3 种场景：owner 我负责的，involved 我参与的、subordinate 下属负责的，也是通过上面查询实现的。\n\n\n\n画外音\n\n看到这里，在回过头看为什么不基于全局的 [《数据权限》])(/data-permission) 实现，是不是有点明白了呢？\n\n在设计系统的数据权限，我们总是渴望通过全局的、自动化的方式实现。但是，实际上，业务的数据权限是非常复杂的，很难通过全局的方式实现。\n\n因此，我们需要在业务层面，实现对应的数据权限逻辑。嘿嘿~",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【通用】跟进记录、待办事项",
            frontmatter: {
                title: "【通用】跟进记录、待办事项",
                date: "2024-02-23T21:55:57.000Z",
                permalink: "/crm/follow-up/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/16.CRM%E6%89%8B%E5%86%8C/91.%E3%80%90%E9%80%9A%E7%94%A8%E3%80%91%E8%B7%9F%E8%BF%9B%E8%AE%B0%E5%BD%95%E3%80%81%E5%BE%85%E5%8A%9E%E4%BA%8B%E9%A1%B9.html",
            relativePath: "01.开发指南/16.CRM手册/91.【通用】跟进记录、待办事项.md",
            key: "v-773f7e1e",
            path: "/crm/follow-up/",
            headers: [{
                level: 2,
                title: "1. 表结构",
                slug: "_1-表结构",
                normalizedTitle: "1. 表结构",
                charIndex: 78
            }, {
                level: 2,
                title: "2. 管理后台",
                slug: "_2-管理后台",
                normalizedTitle: "2. 管理后台",
                charIndex: 1353
            }, {
                level: 2,
                title: "2. 待办事项",
                slug: "_2-待办事项",
                normalizedTitle: "2. 待办事项",
                charIndex: 1622
            }],
            headersStr: "1. 表结构 2. 管理后台 2. 待办事项",
            content: "跟进记录，由 yudao-module-crm-biz 后端模块的 followup 包实现，支持线索、客户、联系人、商机、合同等对象的跟进记录。\n\n\n# 1. 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\nCREATE TABLE `crm_follow_up_record` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  \n  `biz_type` int DEFAULT NULL COMMENT '数据类型',\n  `biz_id` bigint DEFAULT NULL COMMENT '数据编号',\n\n  `next_time` datetime DEFAULT NULL COMMENT '下次联系时间',  \n  `type` int DEFAULT NULL COMMENT '跟进类型',\n  `content` varchar(512) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT '' COMMENT '跟进内容',\n  `pic_urls` varchar(1024) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '图片',\n  `file_urls` varchar(1024) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '附件',\n  \n  `business_ids` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT '' COMMENT '关联的商机编号数组',\n  `contact_ids` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT '' COMMENT '关联的联系人编号数组',\n   PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=33 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC COMMENT='CRM 跟进记录';\n\n\n① biz_type、biz_id 字段：关联被跟进的对象，其中 biz_type 由 CrmBizTypeEnum 枚举，包括线索、客户、联系人、商机、合同等等。\n\n② 从 type 到 file_urls 字段：跟进记录的基本信息，包括跟进类型、跟进内容、下次联系时间、图片、附件等等。比较重要的是 next_time 字段，用于提醒用户下次联系时间。\n\n③ business_ids、contact_ids 字段：关联的商机编号数组、关联的联系人编号数组。例如说，某个跟进记录关联了 3 个商机、2 个联系人。\n\n\n# 2. 管理后台\n\n在每个数据的详情界面，有一个 [跟进记录] 的功能，可以查看、新增、删除跟进记录。如下图所示：\n\n\n\n① 点击【写跟进】按钮，会弹出一个对话框，可以填写跟进记录的基本信息。如下图所示：\n\n\n\n② 确认后，会新增一条跟进记录。另外，在这个过程中，会更新对应对象的 next_time 字段，用于提醒用户下次联系时间。如下图所示：\n\n\n\n也就是说，crm_follow_up_record 用于记录每一次跟进，biz_type + biz_id 对应的对象（客户、商机、联系人等等）自己也会记录最后一次的跟进信息。\n\n\n# 2. 待办事项\n\n对应 [CRM 系统 -> 待办事项] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/crm/backlog 目录。如下图所示：\n\n\n\n它目前没有单独的表存储，或者专属的后端模块，而是通过每个对象的 Controller 实现的。比如说，客户的待办事项是通过 CrmCustomerController 实现的。如下图所示：\n\n",
            normalizedContent: "跟进记录，由 yudao-module-crm-biz 后端模块的 followup 包实现，支持线索、客户、联系人、商机、合同等对象的跟进记录。\n\n\n# 1. 表结构\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\ncreate table `crm_follow_up_record` (\n  `id` bigint not null auto_increment comment '编号',\n  \n  `biz_type` int default null comment '数据类型',\n  `biz_id` bigint default null comment '数据编号',\n\n  `next_time` datetime default null comment '下次联系时间',  \n  `type` int default null comment '跟进类型',\n  `content` varchar(512) character set utf8mb4 collate utf8mb4_unicode_ci default '' comment '跟进内容',\n  `pic_urls` varchar(1024) collate utf8mb4_unicode_ci default null comment '图片',\n  `file_urls` varchar(1024) collate utf8mb4_unicode_ci default null comment '附件',\n  \n  `business_ids` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci default '' comment '关联的商机编号数组',\n  `contact_ids` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci default '' comment '关联的联系人编号数组',\n   primary key (`id`) using btree\n) engine=innodb auto_increment=33 default charset=utf8mb4 collate=utf8mb4_unicode_ci row_format=dynamic comment='crm 跟进记录';\n\n\n① biz_type、biz_id 字段：关联被跟进的对象，其中 biz_type 由 crmbiztypeenum 枚举，包括线索、客户、联系人、商机、合同等等。\n\n② 从 type 到 file_urls 字段：跟进记录的基本信息，包括跟进类型、跟进内容、下次联系时间、图片、附件等等。比较重要的是 next_time 字段，用于提醒用户下次联系时间。\n\n③ business_ids、contact_ids 字段：关联的商机编号数组、关联的联系人编号数组。例如说，某个跟进记录关联了 3 个商机、2 个联系人。\n\n\n# 2. 管理后台\n\n在每个数据的详情界面，有一个 [跟进记录] 的功能，可以查看、新增、删除跟进记录。如下图所示：\n\n\n\n① 点击【写跟进】按钮，会弹出一个对话框，可以填写跟进记录的基本信息。如下图所示：\n\n\n\n② 确认后，会新增一条跟进记录。另外，在这个过程中，会更新对应对象的 next_time 字段，用于提醒用户下次联系时间。如下图所示：\n\n\n\n也就是说，crm_follow_up_record 用于记录每一次跟进，biz_type + biz_id 对应的对象（客户、商机、联系人等等）自己也会记录最后一次的跟进信息。\n\n\n# 2. 待办事项\n\n对应 [crm 系统 -> 待办事项] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/crm/backlog 目录。如下图所示：\n\n\n\n它目前没有单独的表存储，或者专属的后端模块，而是通过每个对象的 controller 实现的。比如说，客户的待办事项是通过 crmcustomercontroller 实现的。如下图所示：\n\n",
            charsets: {
                cjk: !0
            }
        }, {
            title: "功能开启",
            frontmatter: {
                title: "功能开启",
                date: "2024-05-25T11:55:50.000Z",
                permalink: "/ai/build/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/17.AI%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%89%8B%E5%86%8C/02.%E5%8A%9F%E8%83%BD%E5%BC%80%E5%90%AF.html",
            relativePath: "01.开发指南/17.AI大模型手册/02.功能开启.md",
            key: "v-7845bd88",
            path: "/ai/build/",
            headers: [{
                level: 2,
                title: "1. 第一步，开启模块",
                slug: "_1-第一步-开启模块",
                normalizedTitle: "1. 第一步，开启模块",
                charIndex: 437
            }, {
                level: 2,
                title: "2. 第二步，导入 SQL",
                slug: "_2-第二步-导入-sql",
                normalizedTitle: "2. 第二步，导入 sql",
                charIndex: 637
            }, {
                level: 2,
                title: "3. 第三步，重启项目",
                slug: "_3-第三步-重启项目",
                normalizedTitle: "3. 第三步，重启项目",
                charIndex: 729
            }],
            headersStr: "1. 第一步，开启模块 2. 第二步，导入 SQL 3. 第三步，重启项目",
            content: "进度说明：\n\n * 管理后台，请使用 https://gitee.com/yudaocode/yudao-ui-admin-vue3 仓库的 master 分支\n * 后端项目，请使用 https://gitee.com/zhijiantianya/ruoyi-vue-pro 仓库的 master-jdk17 分支\n\n注意！仅支持 JDK 17/21 使用，因为基于 Spring AI 实现，它基于 Spring Boot 3.X 构建，所以最低要求 JDK 17！！！\n\nAI 系统，后端由 yudao-module-ai 模块实现，前端由 yudao-ui-admin-vue3 的 ai 目录实现。\n\n考虑到编译速度，默认 yudao-module-ai 模块是关闭的，需要手动开启。步骤如下：\n\n * 第一步，开启 yudao-module-ai 模块\n * 第二步，导入 AI 系统的 SQL 数据库脚本\n * 第三步，重启后端项目，确认功能是否生效\n\n\n# 1. 第一步，开启模块\n\n① 修改根目录的 pom.xml 文件，取消 yudao-module-ai 模块的注释。如下图所示：\n\n\n\n② 修改 yudao-server 目录的 pom.xml 文件，引入 yudao-module-ai 模块。如下图所示：\n\n\n\n③ 点击 IDEA 右上角的【Reload All Maven Projects】，刷新 Maven 依赖。如下图所示：\n\n\n\n\n# 2. 第二步，导入 SQL\n\n点击 ai-2024-07-07.sql.zip 下载附件，解压出 SQL 文件，然后导入到数据库中。\n\n所以表名字，都使用 ai_ 作为前缀。\n\n\n# 3. 第三步，重启项目\n\n重启后端项目，然后访问前端的 AI 城菜单，确认功能是否生效。如下图所示：\n\n\n\n至此，我们就成功开启了 AI 的功能 🙂\n\n可以访问 [AI 大模型 -> AI 对话] 菜单，点击左上角的【新建对话】按钮后，确认右上角的模型是“deepseek”后，就可以和 AI 大模型聊起来了！\n\n友情提示：如果你碰到 Spring AI 相关的包，无法从 Maven 仓库下载下来，可以参考如下的链接解决：\n\nhttps://t.zsxq.com/gFtUj",
            normalizedContent: "进度说明：\n\n * 管理后台，请使用 https://gitee.com/yudaocode/yudao-ui-admin-vue3 仓库的 master 分支\n * 后端项目，请使用 https://gitee.com/zhijiantianya/ruoyi-vue-pro 仓库的 master-jdk17 分支\n\n注意！仅支持 jdk 17/21 使用，因为基于 spring ai 实现，它基于 spring boot 3.x 构建，所以最低要求 jdk 17！！！\n\nai 系统，后端由 yudao-module-ai 模块实现，前端由 yudao-ui-admin-vue3 的 ai 目录实现。\n\n考虑到编译速度，默认 yudao-module-ai 模块是关闭的，需要手动开启。步骤如下：\n\n * 第一步，开启 yudao-module-ai 模块\n * 第二步，导入 ai 系统的 sql 数据库脚本\n * 第三步，重启后端项目，确认功能是否生效\n\n\n# 1. 第一步，开启模块\n\n① 修改根目录的 pom.xml 文件，取消 yudao-module-ai 模块的注释。如下图所示：\n\n\n\n② 修改 yudao-server 目录的 pom.xml 文件，引入 yudao-module-ai 模块。如下图所示：\n\n\n\n③ 点击 idea 右上角的【reload all maven projects】，刷新 maven 依赖。如下图所示：\n\n\n\n\n# 2. 第二步，导入 sql\n\n点击 ai-2024-07-07.sql.zip 下载附件，解压出 sql 文件，然后导入到数据库中。\n\n所以表名字，都使用 ai_ 作为前缀。\n\n\n# 3. 第三步，重启项目\n\n重启后端项目，然后访问前端的 ai 城菜单，确认功能是否生效。如下图所示：\n\n\n\n至此，我们就成功开启了 ai 的功能 🙂\n\n可以访问 [ai 大模型 -> ai 对话] 菜单，点击左上角的【新建对话】按钮后，确认右上角的模型是“deepseek”后，就可以和 ai 大模型聊起来了！\n\n友情提示：如果你碰到 spring ai 相关的包，无法从 maven 仓库下载下来，可以参考如下的链接解决：\n\nhttps://t.zsxq.com/gftuj",
            charsets: {
                cjk: !0
            }
        }, {
            title: "AI 大模型演示",
            frontmatter: {
                title: "AI 大模型演示",
                date: "2024-05-25T11:56:16.000Z",
                permalink: "/ai-preview"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/17.AI%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%89%8B%E5%86%8C/01.AI%20%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%BC%94%E7%A4%BA.html",
            relativePath: "01.开发指南/17.AI大模型手册/01.AI 大模型演示.md",
            key: "v-062f207d",
            path: "/ai-preview/",
            headers: [{
                level: 2,
                title: "1. 演示地址",
                slug: "_1-演示地址",
                normalizedTitle: "1. 演示地址",
                charIndex: 2
            }, {
                level: 3,
                title: "1.1 管理后台",
                slug: "_1-1-管理后台",
                normalizedTitle: "1.1 管理后台",
                charIndex: 14
            }, {
                level: 3,
                title: "1.2 AI 后端",
                slug: "_1-2-ai-后端",
                normalizedTitle: "1.2 ai 后端",
                charIndex: 233
            }, {
                level: 2,
                title: "2. AI 启动",
                slug: "_2-ai-启动",
                normalizedTitle: "2. ai 启动",
                charIndex: 425
            }, {
                level: 2,
                title: "3. AI 交流群",
                slug: "_3-ai-交流群",
                normalizedTitle: "3. ai 交流群",
                charIndex: 662
            }, {
                level: 2,
                title: "4. 功能描述",
                slug: "_4-功能描述",
                normalizedTitle: "4. 功能描述",
                charIndex: 694
            }, {
                level: 3,
                title: "4.1 模型接入",
                slug: "_4-1-模型接入",
                normalizedTitle: "4.1 模型接入",
                charIndex: 736
            }, {
                level: 3,
                title: "4.2 AI 对话聊天",
                slug: "_4-2-ai-对话聊天",
                normalizedTitle: "4.2 ai 对话聊天",
                charIndex: 1517
            }, {
                level: 3,
                title: "4.3 AI 绘画创作",
                slug: "_4-3-ai-绘画创作",
                normalizedTitle: "4.3 ai 绘画创作",
                charIndex: 1557
            }, {
                level: 3,
                title: "4.4 AI 音乐创作",
                slug: "_4-4-ai-音乐创作",
                normalizedTitle: "4.4 ai 音乐创作",
                charIndex: 1597
            }, {
                level: 3,
                title: "4.5 AI 写作助手",
                slug: "_4-5-ai-写作助手",
                normalizedTitle: "4.5 ai 写作助手",
                charIndex: 1635
            }, {
                level: 3,
                title: "4.6 AI 思维导图",
                slug: "_4-6-ai-思维导图",
                normalizedTitle: "4.6 ai 思维导图",
                charIndex: 1675
            }],
            headersStr: "1. 演示地址 1.1 管理后台 1.2 AI 后端 2. AI 启动 3. AI 交流群 4. 功能描述 4.1 模型接入 4.2 AI 对话聊天 4.3 AI 绘画创作 4.4 AI 音乐创作 4.5 AI 写作助手 4.6 AI 思维导图",
            content: "# 1. 演示地址\n\n\n# 1.1 管理后台\n\n * 演示地址：http://dashboard-vue3.yudao.iocoder.cn/ 【暂未部署】\n * 菜单：“AI 大模型”下的「AI 聊天」「AI 绘画」「AI 写作」「AI 脑图」「AI 音乐」「控制台」等等\n * 仓库：https://github.com/yudaocode/yudao-ui-admin-vue3 的 ai 目录，基于 Vue3 + Element Plus 实现\n\n\n\n\n# 1.2 AI 后端\n\n支持 Spring Boot 单体、Spring Cloud 微服务架构\n\n * 单体仓库： https://github.com/YunaiV/ruoyi-vue-pro 的 yudao-module-ai 模块\n * 微服务仓库： https://github.com/YunaiV/yudao-cloud 的 yudao-module-ai 服务\n\n\n# 2. AI 启动\n\n参见 《AI 手册 —— 功能开启》 文档，一般 3 分钟就可以启动完成。\n\n已经内置多个 AI 大模型（相关密钥已配置）：\n\n * 国内：【阿里】通义千问、【深度求索】DeepSeek、【字节】豆包、【腾讯】混元、【百度】文心一言、【SiliconFlow】硅基流动、【讯飞】星火、【智谱】GLM\n * 国外：【OpenAI】GPT、【Meta】Llama、【Google】Gemini、【Stability】Stable Diffusion\n\n\n# 3. AI 交流群\n\n专属交流社区，欢迎扫码加入。\n\n\n\n\n# 4. 功能描述\n\n主要分为 5 个核心模块：对话、绘画、写作、脑图、音乐。\n\n\n# 4.1 模型接入\n\n\n\n模型（可点击链接，查看申请/部署文档）             国内/国外   是否开源（私有化部署）\n《【阿里】通义千问》                      国内      √\n《【深度求索】DeepSeek》                国内      √\n《【字节】豆包》                        国内      √\n《【腾讯】混元》                        国内      √\n《【百度】文心一言》                      国内      \n《【SiliconFlow】硅基流动》             国内      \n《【讯飞】星火认知》                      国内      \n《【智谱】GLM》                       国内      √\n《【讯飞】星火认知》                      国内      \n                                        \n《【OpenAI】ChatGPT》               国外      \n《【Meta】LLAMA》                   国外      √\n《【微软 OpenAI】ChatGPT》            国外      \n《【谷歌】Gemini》                    国外      √(Gemma)\n《【Stability】Stable Diffusion》   国外      √\n《【Midjourney】Midjourney》        国外      √\n《【Suno AI】Suno》                 国外      \n\n\n# 4.2 AI 对话聊天\n\n详细说明，可见 《AI 对话聊天》 文档\n\n\n\n\n# 4.3 AI 绘画创作\n\n详细说明，可见 《AI 绘画创作》 文档\n\n\n\n\n# 4.4 AI 音乐创作\n\n详细可见，可见 《AI 音乐创作》 文档\n\n\n# 4.5 AI 写作助手\n\n详细可见，可见 《AI 写作助手》 文档\n\n\n\n\n# 4.6 AI 思维导图\n\n详细可见，可见 《AI 思维导图》 文档\n\n",
            normalizedContent: "# 1. 演示地址\n\n\n# 1.1 管理后台\n\n * 演示地址：http://dashboard-vue3.yudao.iocoder.cn/ 【暂未部署】\n * 菜单：“ai 大模型”下的「ai 聊天」「ai 绘画」「ai 写作」「ai 脑图」「ai 音乐」「控制台」等等\n * 仓库：https://github.com/yudaocode/yudao-ui-admin-vue3 的 ai 目录，基于 vue3 + element plus 实现\n\n\n\n\n# 1.2 ai 后端\n\n支持 spring boot 单体、spring cloud 微服务架构\n\n * 单体仓库： https://github.com/yunaiv/ruoyi-vue-pro 的 yudao-module-ai 模块\n * 微服务仓库： https://github.com/yunaiv/yudao-cloud 的 yudao-module-ai 服务\n\n\n# 2. ai 启动\n\n参见 《ai 手册 —— 功能开启》 文档，一般 3 分钟就可以启动完成。\n\n已经内置多个 ai 大模型（相关密钥已配置）：\n\n * 国内：【阿里】通义千问、【深度求索】deepseek、【字节】豆包、【腾讯】混元、【百度】文心一言、【siliconflow】硅基流动、【讯飞】星火、【智谱】glm\n * 国外：【openai】gpt、【meta】llama、【google】gemini、【stability】stable diffusion\n\n\n# 3. ai 交流群\n\n专属交流社区，欢迎扫码加入。\n\n\n\n\n# 4. 功能描述\n\n主要分为 5 个核心模块：对话、绘画、写作、脑图、音乐。\n\n\n# 4.1 模型接入\n\n\n\n模型（可点击链接，查看申请/部署文档）             国内/国外   是否开源（私有化部署）\n《【阿里】通义千问》                      国内      √\n《【深度求索】deepseek》                国内      √\n《【字节】豆包》                        国内      √\n《【腾讯】混元》                        国内      √\n《【百度】文心一言》                      国内      \n《【siliconflow】硅基流动》             国内      \n《【讯飞】星火认知》                      国内      \n《【智谱】glm》                       国内      √\n《【讯飞】星火认知》                      国内      \n                                        \n《【openai】chatgpt》               国外      \n《【meta】llama》                   国外      √\n《【微软 openai】chatgpt》            国外      \n《【谷歌】gemini》                    国外      √(gemma)\n《【stability】stable diffusion》   国外      √\n《【midjourney】midjourney》        国外      √\n《【suno ai】suno》                 国外      \n\n\n# 4.2 ai 对话聊天\n\n详细说明，可见 《ai 对话聊天》 文档\n\n\n\n\n# 4.3 ai 绘画创作\n\n详细说明，可见 《ai 绘画创作》 文档\n\n\n\n\n# 4.4 ai 音乐创作\n\n详细可见，可见 《ai 音乐创作》 文档\n\n\n# 4.5 ai 写作助手\n\n详细可见，可见 《ai 写作助手》 文档\n\n\n\n\n# 4.6 ai 思维导图\n\n详细可见，可见 《ai 思维导图》 文档\n\n",
            charsets: {
                cjk: !0
            }
        }, {
            title: "AI 聊天对话",
            frontmatter: {
                title: "AI 聊天对话",
                date: "2024-05-30T19:30:05.000Z",
                permalink: "/ai/chat/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/17.AI%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%89%8B%E5%86%8C/11.AI%20%E5%AF%B9%E8%AF%9D%E8%81%8A%E5%A4%A9.html",
            relativePath: "01.开发指南/17.AI大模型手册/11.AI 对话聊天.md",
            key: "v-58fea08e",
            path: "/ai/chat/",
            headers: [{
                level: 2,
                title: "1. API 秘钥表",
                slug: "_1-api-秘钥表",
                normalizedTitle: "1. api 秘钥表",
                charIndex: 331
            }, {
                level: 3,
                title: "1.1 表结构",
                slug: "_1-1-表结构",
                normalizedTitle: "1.1 表结构",
                charIndex: 383
            }, {
                level: 3,
                title: "1.2 管理后台",
                slug: "_1-2-管理后台",
                normalizedTitle: "1.2 管理后台",
                charIndex: 1550
            }, {
                level: 2,
                title: "2. 聊天模型表",
                slug: "_2-聊天模型表",
                normalizedTitle: "2. 聊天模型表",
                charIndex: 1723
            }, {
                level: 3,
                title: "2.1 表结构",
                slug: "_2-1-表结构",
                normalizedTitle: "2.1 表结构",
                charIndex: 1760
            }, {
                level: 3,
                title: "2.2 管理后台",
                slug: "_2-2-管理后台",
                normalizedTitle: "2.2 管理后台",
                charIndex: 3199
            }, {
                level: 2,
                title: "3. 聊天角色表",
                slug: "_3-聊天角色表",
                normalizedTitle: "3. 聊天角色表",
                charIndex: 3376
            }, {
                level: 3,
                title: "3.1 表结构",
                slug: "_3-1-表结构",
                normalizedTitle: "3.1 表结构",
                charIndex: 3442
            }, {
                level: 3,
                title: "3.2 管理后台",
                slug: "_3-2-管理后台",
                normalizedTitle: "3.2 管理后台",
                charIndex: 4978
            }, {
                level: 2,
                title: "4. 聊天对话",
                slug: "_4-聊天对话",
                normalizedTitle: "4. 聊天对话",
                charIndex: 5307
            }, {
                level: 3,
                title: "4.1 表结构【聊天对话表】",
                slug: "_4-1-表结构【聊天对话表】",
                normalizedTitle: "4.1 表结构【聊天对话表】",
                charIndex: 5400
            }, {
                level: 3,
                title: "4.2 表结构【聊天消息表】",
                slug: "_4-2-表结构【聊天消息表】",
                normalizedTitle: "4.2 表结构【聊天消息表】",
                charIndex: 6693
            }, {
                level: 3,
                title: "4.3 管理后台",
                slug: "_4-3-管理后台",
                normalizedTitle: "4.3 管理后台",
                charIndex: 8016
            }],
            headersStr: "1. API 秘钥表 1.1 表结构 1.2 管理后台 2. 聊天模型表 2.1 表结构 2.2 管理后台 3. 聊天角色表 3.1 表结构 3.2 管理后台 4. 聊天对话 4.1 表结构【聊天对话表】 4.2 表结构【聊天消息表】 4.3 管理后台",
            content: "AI 对话，基于 LLM 大模型，实现智能聊天的功能。\n\n说白了，就是和机器人聊天。高级点，就是智能问答！\n\n\n\n整个功能，涉及到 5 个表（上图可以看到 4 个）：\n\n * 【配置】ai_api_key：API 秘钥表\n * 【配置】ai_chat_model：聊天模型表\n * 【配置】ai_chat_role：聊天角色表\n * 【对话】ai_chat_conversation：聊天对话表\n * 【对话】ai_chat_message：聊天消息表\n\n下面，我们逐个表进行介绍，这个过程中也会讲讲对应的功能。\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\n\n# 1. API 秘钥表\n\nAPI 秘钥表，顾名思义，就是存储 AI 大模型的 API 密钥的表。\n\n\n# 1.1 表结构\n\nCREATE TABLE `ai_api_key` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  `name` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '名称',\n  `platform` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '平台',\n  `api_key` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '密钥',\n  `url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '自定义 API 地址',\n  `status` int NOT NULL COMMENT '状态',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='AI API 密钥表';\n\n\n① platform 字段：表示平台，对应 AiPlatformEnum 枚举，目前支持多个 AI 大模型：\n\n * 国内：【百度】文心一言、【阿里】通义千问、【讯飞】星火\n * 国外：【OpenAI】GPT、【Meta】Llama、【Google】Gemini\n\n② api_key 字段：表示 API 密钥，对应不同的平台的密钥，例如说 OpenAI 的 API KEY。但是要注意，有些平台是多个值，例如说文心一言是 appKey + secretKey 组合，那它在 api_key 就是 ${appKey}|${secretKey}。\n\nurl 字段：表示自定义 API 地址。一般情况下不需要配置，除非你有自定义的需求，例如说 OpenAI 使用 API 中转。\n\n具体它们怎么配置，或者怎么部署，可见对应的文档：\n\n * 国内模型：《通义千问》、《DeepSeek》、《豆包》、《混元》、《文心一言》、《硅基流动》、《讯飞星火》、《智谱 GLM》\n * 国外模型：《OpenAI（ChatGPT）》、《LLAMA》、《微软 OpenAI（ChatGPT）》、《谷歌 Gemini》\n\n友情提示：\n\n一般情况下，建议先使用 《DeepSeek》 模型，因为免费送了一些 tokens，可以先体验一下。\n\n\n# 1.2 管理后台\n\n前端对应 [AI 大模型 -> 控制台 -> API 密钥] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/ai/model/apiKey 目录。\n\n\n\n它的后端 HTTP 接口，由 yudao-module-ai 模块的 model 包的 AiApiKeyController 实现。\n\n\n# 2. 聊天模型表\n\n聊天模型表，配置每个平台下有哪些可用的模型。\n\n\n# 2.1 表结构\n\nCREATE TABLE `ai_chat_model` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  `name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '模型名字',\n  `sort` int NOT NULL COMMENT '排序',\n  `status` tinyint NOT NULL COMMENT '状态',\n  \n  `key_id` bigint NOT NULL COMMENT 'API 秘钥编号',\n  `platform` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '模型平台',\n\n  `model` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '模型标识',\n\n  `temperature` double DEFAULT NULL COMMENT '温度参数',\n  `max_tokens` int DEFAULT NULL COMMENT '单条回复的最大 Token 数量',\n  `max_contexts` int DEFAULT NULL COMMENT '上下文的最大 Message 数量',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=15 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='AI 聊天模型表';\n\n\n① key_id 字段：表示 API 秘钥编号，对应 ai_api_key 表的 id 字段。\n\nplatform 字段：表示模型平台，冗余 ai_api_key 表的 platform 字段。\n\n② model 字段：表示模型标识，对应不同的平台的模型标识，例如说 OpenAI 的 gpt-3.5-turbo、gpt-4-turbo，通义千问的 qwen-plus、qwen-max 等等。\n\n③ temperature 字段：表示温度参数，对应不同的平台的温度参数，例如说 OpenAI 的 temperature。\n\nmax_tokens 字段：表示单条回复的最大 Token 数量，对应不同的平台的最大 Token 数量，例如说 OpenAI 的 gpt-3.5-turbo 为 4096，gpt-4 为 8192。\n\nmax_contexts 字段：表示上下文的最大 Message 数量。因为模型的上下文是有上限的，所以和模型对话时，不会把历史的所有消息都发送过去，而是选择最近的 max_contexts 组消息。会有一些难理解，具体可以看看 AiChatMessageServiceImpl 的 #filterContextMessages(...) 方法。\n\n疑问：为什么 ai_api_key 和 ai_chat_model 表是分开的？\n\n一个平台有多个模型，它们会共用一个 API 密钥，所以是分开的，方便管理。\n\n\n# 2.2 管理后台\n\n前端对应 [AI 大模型 -> 控制台 -> 聊天模型] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/ai/model/chatModel 目录。\n\n\n\n它的后端 HTTP 接口，由 yudao-module-ai 模块的 model 包的 AiChatModelController 实现。\n\n\n# 3. 聊天角色表\n\n聊天角色表，配置机器人扮演怎么样的角色，例如说：通用 AI 助手、Python 专家、客服小姐姐等等。\n\n\n# 3.1 表结构\n\nCREATE TABLE `ai_chat_role` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '角色编号',\n  `name` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '角色名称',\n  `avatar` varchar(256) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '头像',\n  `description` varchar(256) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '角色描述',\n  `status` tinyint DEFAULT NULL COMMENT '状态',\n  `sort` int NOT NULL DEFAULT '0' COMMENT '角色排序',\n  \n  `user_id` bigint DEFAULT NULL COMMENT '用户编号',\n  `public_status` bit(1) NOT NULL COMMENT '是否公开',\n  `category` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '角色类别',\n  \n  `model_id` bigint DEFAULT NULL COMMENT '模型编号',\n\n  `system_message` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '角色上下文',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='AI 聊天角色表';\n\n\n① user_id 字段：对应 system_users 表的 id 字段，表示哪个用户创建的角色。\n\npublic_status 字段：表示是否公开。如果是公开，那么其他用户也可以使用这个角色，一般由管理员创建。如果是私有，那么只有创建者 user_id 可以使用。\n\ncategory 字段：公开角色的所属类别，例如说：助手、编程开发、娱乐等等。\n\n② model_id 字段：表示角色绑定的默认模型，对应 ai_chat_model 表的 id 字段。当然，也可以不绑定，此时使用 ai_chat_model 排序 sort 最小的模型。\n\n③ system_message 字段：表示角色上下文，或者说角色设定。例如说 “Python 专家” 对应如下\n\n> “ 我希望你能作为一名 python 专家。\n> \n> 我将向你提供有关我的技术问题的所有信息，而你的角色是解决我的问题。\n> \n> 你应该用你的计算机科学、网络基础设施和 IT 安全知识来解决我的问题。在你的回答中，使用聪明的、简单的、为各种层次的人所理解的语言会有帮助。\n> \n> 逐步解释你的解决方案并使用要点是很有帮助的。尽量避免过多的技术细节，但在必要时使用它们。我希望你用解决方案来回答，而不是写任何解释。\n> \n> ”\n\n\n# 3.2 管理后台\n\n① 前端对应 [AI 大模型 -> 控制台 -> 聊天角色] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/ai/model/chatRole 目录，提供给管理员使用，创建公开角色。\n\n\n\n它的后端 HTTP 接口，由 yudao-module-ai 模块的 model 包的 AiChatRoleController 实现。\n\n② 前端聊天界面的【角色仓库】，对应 yudao-ui-admin-vue3 项目的 TODO 目录，提供给用户使用，创建私有角色。\n\n\n\n * 可以点击【使用】按钮，使用对应的角色创建对话\n * 也可以点击【公共角色】标签，按分类查看公开角色列表，也支持【使用】按钮\n\n\n# 4. 聊天对话\n\n聊天对话，一共有 2 个表，分别是 ai_chat_conversation 和 ai_chat_message。前者是对话的基本信息，后者是对话的消息列表。\n\n\n# 4.1 表结构【聊天对话表】\n\nCREATE TABLE `ai_chat_conversation` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '对话编号',\n  `title` varchar(256) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '对话标题',\n  `pinned` bit(1) NOT NULL COMMENT '是否置顶',\n  `pinned_time` datetime DEFAULT NULL COMMENT '置顶时间',\n  \n  `user_id` bigint NOT NULL COMMENT '用户编号',\n  \n  `role_id` bigint DEFAULT NULL COMMENT '聊天角色',\n\n  `model_id` bigint NOT NULL COMMENT '模型编号',\n  `model` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '模型标识',\n  \n  `system_message` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '角色设定',\n  `temperature` double NOT NULL COMMENT '温度参数',\n  `max_tokens` int NOT NULL COMMENT '单条回复的最大 Token 数量',\n  `max_contexts` int NOT NULL COMMENT '上下文的最大 Message 数量',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=1781604279872581716 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='AI 聊天对话表';\n\n\n① user_id 字段：对应 system_users 表的 id 字段，表示哪个用户创建的对话。\n\n② role_id 字段：表示对话使用的角色，对应 ai_chat_role 表的 id 字段。如果没有使用角色，则为空，此时是点击聊天界面的【新建对话】产生的。\n\n③ model_id 字段：表示对话使用的模型，对应 ai_chat_model 表的 id 字段。每个对话可以随时切换它所使用的模型。\n\nmodel 字段：表示模型标识，冗余 ai_chat_model 表的 model 字段。\n\n\n\nsystem_message、temperature、max_tokens、max_contexts 字段：就是对话的配置，上图也已经看到。\n\n\n# 4.2 表结构【聊天消息表】\n\nCREATE TABLE `ai_chat_message` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '消息编号',\n\n  `conversation_id` bigint NOT NULL COMMENT '对话编号',\n  `user_id` bigint NOT NULL COMMENT '用户编号',\n  `role_id` bigint DEFAULT NULL COMMENT '角色编号',\n\n  `model` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '模型标识',\n  `model_id` bigint NOT NULL COMMENT '模型编号',  \n\n  `type` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '消息类型',  \n  `reply_id` bigint DEFAULT NULL COMMENT '回复编号',\n\n  `content` varchar(2048) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '消息内容',\n  `use_context` bit(1) NOT NULL DEFAULT b'0' COMMENT '是否携带上下文',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=2147 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='AI 聊天消息表';\n\n\n① conversation_id、user_id、role_id 字段：关联到 ai_chat_conversation 表的相关字段。\n\n② model、model_id 字段：该消息所使用的模型。因为对话可以随时切换模型，所以消息也需要记录。\n\n③ type 字段：消息类型，对应 Spring AI 提供的 MessageType 枚举类，目前表里有 user 用户发送、assistant 模型回复。\n\nreply_id 字段：表示回复的消息编号。用户每次发送消息，会记录一条 user 类型的消息，然后模型回复的消息，会记录一条 assistant 类型的消息，这两条消息通过 reply_id 对应的。\n\n④ content 字段：消息内容，对应用户发送的消息或者模型回复的消息。\n\n⑤ use_context 字段：表示是否携带上下文。如果为 true 时，表示这条消息会携带上下文，此时调用模型时，会带该会话的最后 max_contexts 组消息。\n\n注意，它是在消息发送框的左下角的蓝色 switch 【上下文】小按钮噢！\n\n\n# 4.3 管理后台\n\n① 前端对应 [AI 大模型 -> AI 对话] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/ai/chat/index 目录。上面已经有很多图了，就不重复截图了！\n\n它的后端 HTTP 接口，由 yudao-module-ai 模块的 chat 包的 AiChatConversationController、AiChatMessageController 实现。\n\n最最最关键的代码！！！大家可以重点看看！！！\n\nAiChatMessageController 提供的 #sendChatMessageStream(...) 流式消息接口。\n\n它的内部，调用 Spring AI 的 StreamingChatClient 来实现大模型的调用。\n\n② 前端对应 [AI 大模型 -> 控制台 -> 聊天管理] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/ai/chat/manager 目录，提供给管理员使用，查看对话列表、消息列表。\n\n",
            normalizedContent: "ai 对话，基于 llm 大模型，实现智能聊天的功能。\n\n说白了，就是和机器人聊天。高级点，就是智能问答！\n\n\n\n整个功能，涉及到 5 个表（上图可以看到 4 个）：\n\n * 【配置】ai_api_key：api 秘钥表\n * 【配置】ai_chat_model：聊天模型表\n * 【配置】ai_chat_role：聊天角色表\n * 【对话】ai_chat_conversation：聊天对话表\n * 【对话】ai_chat_message：聊天消息表\n\n下面，我们逐个表进行介绍，这个过程中也会讲讲对应的功能。\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\n\n# 1. api 秘钥表\n\napi 秘钥表，顾名思义，就是存储 ai 大模型的 api 密钥的表。\n\n\n# 1.1 表结构\n\ncreate table `ai_api_key` (\n  `id` bigint not null auto_increment comment '编号',\n  `name` varchar(255) collate utf8mb4_unicode_ci not null comment '名称',\n  `platform` varchar(255) collate utf8mb4_unicode_ci not null comment '平台',\n  `api_key` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '密钥',\n  `url` varchar(255) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '自定义 api 地址',\n  `status` int not null comment '状态',\n  primary key (`id`)\n) engine=innodb auto_increment=7 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='ai api 密钥表';\n\n\n① platform 字段：表示平台，对应 aiplatformenum 枚举，目前支持多个 ai 大模型：\n\n * 国内：【百度】文心一言、【阿里】通义千问、【讯飞】星火\n * 国外：【openai】gpt、【meta】llama、【google】gemini\n\n② api_key 字段：表示 api 密钥，对应不同的平台的密钥，例如说 openai 的 api key。但是要注意，有些平台是多个值，例如说文心一言是 appkey + secretkey 组合，那它在 api_key 就是 ${appkey}|${secretkey}。\n\nurl 字段：表示自定义 api 地址。一般情况下不需要配置，除非你有自定义的需求，例如说 openai 使用 api 中转。\n\n具体它们怎么配置，或者怎么部署，可见对应的文档：\n\n * 国内模型：《通义千问》、《deepseek》、《豆包》、《混元》、《文心一言》、《硅基流动》、《讯飞星火》、《智谱 glm》\n * 国外模型：《openai（chatgpt）》、《llama》、《微软 openai（chatgpt）》、《谷歌 gemini》\n\n友情提示：\n\n一般情况下，建议先使用 《deepseek》 模型，因为免费送了一些 tokens，可以先体验一下。\n\n\n# 1.2 管理后台\n\n前端对应 [ai 大模型 -> 控制台 -> api 密钥] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/ai/model/apikey 目录。\n\n\n\n它的后端 http 接口，由 yudao-module-ai 模块的 model 包的 aiapikeycontroller 实现。\n\n\n# 2. 聊天模型表\n\n聊天模型表，配置每个平台下有哪些可用的模型。\n\n\n# 2.1 表结构\n\ncreate table `ai_chat_model` (\n  `id` bigint not null auto_increment comment '编号',\n  `name` varchar(64) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '模型名字',\n  `sort` int not null comment '排序',\n  `status` tinyint not null comment '状态',\n  \n  `key_id` bigint not null comment 'api 秘钥编号',\n  `platform` varchar(32) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '模型平台',\n\n  `model` varchar(64) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '模型标识',\n\n  `temperature` double default null comment '温度参数',\n  `max_tokens` int default null comment '单条回复的最大 token 数量',\n  `max_contexts` int default null comment '上下文的最大 message 数量',\n  primary key (`id`)\n) engine=innodb auto_increment=15 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='ai 聊天模型表';\n\n\n① key_id 字段：表示 api 秘钥编号，对应 ai_api_key 表的 id 字段。\n\nplatform 字段：表示模型平台，冗余 ai_api_key 表的 platform 字段。\n\n② model 字段：表示模型标识，对应不同的平台的模型标识，例如说 openai 的 gpt-3.5-turbo、gpt-4-turbo，通义千问的 qwen-plus、qwen-max 等等。\n\n③ temperature 字段：表示温度参数，对应不同的平台的温度参数，例如说 openai 的 temperature。\n\nmax_tokens 字段：表示单条回复的最大 token 数量，对应不同的平台的最大 token 数量，例如说 openai 的 gpt-3.5-turbo 为 4096，gpt-4 为 8192。\n\nmax_contexts 字段：表示上下文的最大 message 数量。因为模型的上下文是有上限的，所以和模型对话时，不会把历史的所有消息都发送过去，而是选择最近的 max_contexts 组消息。会有一些难理解，具体可以看看 aichatmessageserviceimpl 的 #filtercontextmessages(...) 方法。\n\n疑问：为什么 ai_api_key 和 ai_chat_model 表是分开的？\n\n一个平台有多个模型，它们会共用一个 api 密钥，所以是分开的，方便管理。\n\n\n# 2.2 管理后台\n\n前端对应 [ai 大模型 -> 控制台 -> 聊天模型] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/ai/model/chatmodel 目录。\n\n\n\n它的后端 http 接口，由 yudao-module-ai 模块的 model 包的 aichatmodelcontroller 实现。\n\n\n# 3. 聊天角色表\n\n聊天角色表，配置机器人扮演怎么样的角色，例如说：通用 ai 助手、python 专家、客服小姐姐等等。\n\n\n# 3.1 表结构\n\ncreate table `ai_chat_role` (\n  `id` bigint not null auto_increment comment '角色编号',\n  `name` varchar(128) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '角色名称',\n  `avatar` varchar(256) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '头像',\n  `description` varchar(256) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '角色描述',\n  `status` tinyint default null comment '状态',\n  `sort` int not null default '0' comment '角色排序',\n  \n  `user_id` bigint default null comment '用户编号',\n  `public_status` bit(1) not null comment '是否公开',\n  `category` varchar(32) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '角色类别',\n  \n  `model_id` bigint default null comment '模型编号',\n\n  `system_message` varchar(1024) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '角色上下文',\n  primary key (`id`)\n) engine=innodb auto_increment=13 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='ai 聊天角色表';\n\n\n① user_id 字段：对应 system_users 表的 id 字段，表示哪个用户创建的角色。\n\npublic_status 字段：表示是否公开。如果是公开，那么其他用户也可以使用这个角色，一般由管理员创建。如果是私有，那么只有创建者 user_id 可以使用。\n\ncategory 字段：公开角色的所属类别，例如说：助手、编程开发、娱乐等等。\n\n② model_id 字段：表示角色绑定的默认模型，对应 ai_chat_model 表的 id 字段。当然，也可以不绑定，此时使用 ai_chat_model 排序 sort 最小的模型。\n\n③ system_message 字段：表示角色上下文，或者说角色设定。例如说 “python 专家” 对应如下\n\n> “ 我希望你能作为一名 python 专家。\n> \n> 我将向你提供有关我的技术问题的所有信息，而你的角色是解决我的问题。\n> \n> 你应该用你的计算机科学、网络基础设施和 it 安全知识来解决我的问题。在你的回答中，使用聪明的、简单的、为各种层次的人所理解的语言会有帮助。\n> \n> 逐步解释你的解决方案并使用要点是很有帮助的。尽量避免过多的技术细节，但在必要时使用它们。我希望你用解决方案来回答，而不是写任何解释。\n> \n> ”\n\n\n# 3.2 管理后台\n\n① 前端对应 [ai 大模型 -> 控制台 -> 聊天角色] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/ai/model/chatrole 目录，提供给管理员使用，创建公开角色。\n\n\n\n它的后端 http 接口，由 yudao-module-ai 模块的 model 包的 aichatrolecontroller 实现。\n\n② 前端聊天界面的【角色仓库】，对应 yudao-ui-admin-vue3 项目的 todo 目录，提供给用户使用，创建私有角色。\n\n\n\n * 可以点击【使用】按钮，使用对应的角色创建对话\n * 也可以点击【公共角色】标签，按分类查看公开角色列表，也支持【使用】按钮\n\n\n# 4. 聊天对话\n\n聊天对话，一共有 2 个表，分别是 ai_chat_conversation 和 ai_chat_message。前者是对话的基本信息，后者是对话的消息列表。\n\n\n# 4.1 表结构【聊天对话表】\n\ncreate table `ai_chat_conversation` (\n  `id` bigint not null auto_increment comment '对话编号',\n  `title` varchar(256) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '对话标题',\n  `pinned` bit(1) not null comment '是否置顶',\n  `pinned_time` datetime default null comment '置顶时间',\n  \n  `user_id` bigint not null comment '用户编号',\n  \n  `role_id` bigint default null comment '聊天角色',\n\n  `model_id` bigint not null comment '模型编号',\n  `model` varchar(32) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '模型标识',\n  \n  `system_message` varchar(1024) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '角色设定',\n  `temperature` double not null comment '温度参数',\n  `max_tokens` int not null comment '单条回复的最大 token 数量',\n  `max_contexts` int not null comment '上下文的最大 message 数量',\n  primary key (`id`)\n) engine=innodb auto_increment=1781604279872581716 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='ai 聊天对话表';\n\n\n① user_id 字段：对应 system_users 表的 id 字段，表示哪个用户创建的对话。\n\n② role_id 字段：表示对话使用的角色，对应 ai_chat_role 表的 id 字段。如果没有使用角色，则为空，此时是点击聊天界面的【新建对话】产生的。\n\n③ model_id 字段：表示对话使用的模型，对应 ai_chat_model 表的 id 字段。每个对话可以随时切换它所使用的模型。\n\nmodel 字段：表示模型标识，冗余 ai_chat_model 表的 model 字段。\n\n\n\nsystem_message、temperature、max_tokens、max_contexts 字段：就是对话的配置，上图也已经看到。\n\n\n# 4.2 表结构【聊天消息表】\n\ncreate table `ai_chat_message` (\n  `id` bigint not null auto_increment comment '消息编号',\n\n  `conversation_id` bigint not null comment '对话编号',\n  `user_id` bigint not null comment '用户编号',\n  `role_id` bigint default null comment '角色编号',\n\n  `model` varchar(32) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '模型标识',\n  `model_id` bigint not null comment '模型编号',  \n\n  `type` varchar(16) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '消息类型',  \n  `reply_id` bigint default null comment '回复编号',\n\n  `content` varchar(2048) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '消息内容',\n  `use_context` bit(1) not null default b'0' comment '是否携带上下文',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=2147 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='ai 聊天消息表';\n\n\n① conversation_id、user_id、role_id 字段：关联到 ai_chat_conversation 表的相关字段。\n\n② model、model_id 字段：该消息所使用的模型。因为对话可以随时切换模型，所以消息也需要记录。\n\n③ type 字段：消息类型，对应 spring ai 提供的 messagetype 枚举类，目前表里有 user 用户发送、assistant 模型回复。\n\nreply_id 字段：表示回复的消息编号。用户每次发送消息，会记录一条 user 类型的消息，然后模型回复的消息，会记录一条 assistant 类型的消息，这两条消息通过 reply_id 对应的。\n\n④ content 字段：消息内容，对应用户发送的消息或者模型回复的消息。\n\n⑤ use_context 字段：表示是否携带上下文。如果为 true 时，表示这条消息会携带上下文，此时调用模型时，会带该会话的最后 max_contexts 组消息。\n\n注意，它是在消息发送框的左下角的蓝色 switch 【上下文】小按钮噢！\n\n\n# 4.3 管理后台\n\n① 前端对应 [ai 大模型 -> ai 对话] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/ai/chat/index 目录。上面已经有很多图了，就不重复截图了！\n\n它的后端 http 接口，由 yudao-module-ai 模块的 chat 包的 aichatconversationcontroller、aichatmessagecontroller 实现。\n\n最最最关键的代码！！！大家可以重点看看！！！\n\naichatmessagecontroller 提供的 #sendchatmessagestream(...) 流式消息接口。\n\n它的内部，调用 spring ai 的 streamingchatclient 来实现大模型的调用。\n\n② 前端对应 [ai 大模型 -> 控制台 -> 聊天管理] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/ai/chat/manager 目录，提供给管理员使用，查看对话列表、消息列表。\n\n",
            charsets: {
                cjk: !0
            }
        }, {
            title: "AI 写作助手",
            frontmatter: {
                title: "AI 写作助手",
                date: "2024-07-06T19:26:46.000Z",
                permalink: "/ai/write/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/17.AI%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%89%8B%E5%86%8C/14.AI%20%E5%86%99%E4%BD%9C%E5%8A%A9%E6%89%8B.html",
            relativePath: "01.开发指南/17.AI大模型手册/14.AI 写作助手.md",
            key: "v-e6e74c38",
            path: "/ai/write/",
            headers: [{
                level: 2,
                title: "1. API 秘钥表",
                slug: "_1-api-秘钥表",
                normalizedTitle: "1. api 秘钥表",
                charIndex: 203
            }, {
                level: 3,
                title: "1.1 补充说明",
                slug: "_1-1-补充说明",
                normalizedTitle: "1.1 补充说明",
                charIndex: 479
            }, {
                level: 2,
                title: "2. 写作记录表",
                slug: "_2-写作记录表",
                normalizedTitle: "2. 写作记录表",
                charIndex: 687
            }, {
                level: 3,
                title: "2.1 表结构",
                slug: "_2-1-表结构",
                normalizedTitle: "2.1 表结构",
                charIndex: 727
            }, {
                level: 2,
                title: "2.2 管理后台",
                slug: "_2-2-管理后台",
                normalizedTitle: "2.2 管理后台",
                charIndex: 2441
            }],
            headersStr: "1. API 秘钥表 1.1 补充说明 2. 写作记录表 2.1 表结构 2.2 管理后台",
            content: "AI 写作，基于 LLM 大模型，实现文章的撰写、回复的功能。\n\n\n\n整个功能，涉及到 2 个表：\n\n * 【配置】ai_api_key：API 秘钥表\n * 【写作】ai_write：写作记录表\n\n下面，我们逐个表进行介绍，这个过程中也会讲讲对应的功能。\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\n\n# 1. API 秘钥表\n\n在 《AI 对话》 中，我们已经介绍了 API 秘钥表，这里就不再赘述了。\n\n你想使用哪个模型写作，可以参考对应的文档，进行配置：\n\n * 国内模型：《通义千问》、《DeepSeek》、《豆包》、《混元》、《文心一言》、《硅基流动》、《讯飞星火》、《智谱 GLM》\n * 国外模型：《OpenAI（ChatGPT）》、《LLAMA》、《【微软 OpenAI】ChatGPT》 、《谷歌 Gemini》\n\n友情提示：\n\n一般情况下，建议先使用 《DeepSeek》 模型，因为免费送了一些 tokens，可以先体验一下。\n\n\n# 1.1 补充说明\n\nAI 写作时，使用什么模型和 system prompt 呢？它分成两种情况：\n\n① 情况一：通过【聊天角色】中的“写作助手”进行配置。如下图所示：\n\n\n\n② 情况二：如果没有配置，那就会使用 ai_chat_model 表中的第一个模型（排序 sort 最小的）。同时，它对应的 system prompt 在 AiChatRoleEnum 的 AI_WRITE_ROLE 进行配置。\n\n\n# 2. 写作记录表\n\n写作记录表，用户每发起一次写作，都会记录一条记录。\n\n\n# 2.1 表结构\n\nCREATE TABLE `ai_write` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  `user_id` bigint NOT NULL COMMENT '用户编号',\n  \n  `type` int DEFAULT NULL COMMENT '写作类型',\n  `original_content` varchar(5120) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL COMMENT '原文',\n  \n  `platform` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL COMMENT '平台',\n  `model` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL COMMENT '模型',\n  \n  `prompt` varchar(512) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin NOT NULL COMMENT '生成内容提示',\n  `generated_content` varchar(5120) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL COMMENT '生成的内容',\n  \n  `length` tinyint DEFAULT NULL COMMENT '长度提示词',\n  `format` tinyint DEFAULT NULL COMMENT '格式提示词',\n  `tone` tinyint DEFAULT NULL COMMENT '语气提示词',\n  `language` tinyint DEFAULT NULL COMMENT '语言提示词',\n  \n  `error_message` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL COMMENT '错误信息',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=225 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_bin COMMENT='AI 写作表';\n\n\n① user_id 字段：对应 system_users 表的 id 字段，表示哪个用户生成的写作。\n\n② type 字段：表示写作类型，对应 AiWriteTypeEnum 枚举，目前有两个类型：撰写文章、回复文章。\n\n当回复文章时，original_content 字段表示原文（被回复文章）。\n\n③ platform 字段：表示平台，对应 AiPlatformEnum 枚举，目前支持多个 AI 大模型。\n\nmodel 字段：表示模型标识，对应不同的平台的模型标识，例如说 OpenAI 的 gpt-3.5-turbo、gpt-4-turbo，通义千问的 qwen-plus、qwen-max 等等。\n\n④ prompt 字段：表示生成内容提示，用户输入的文本。\n\ngenerated_content 字段：表示生成的内容，AI 生成的文本。\n\n⑤ length、format、tone、language 字段：表示长度、格式、语气、语言提示词。它们是有数据字典枚举，分别对应 ai_write_length、ai_write_format、ai_write_tone、ai_write_language。\n\n⑥ error_message 字段：表示错误信息。由于写作是 stream 流式生成，所以可能会出现错误，这时会记录错误信息。\n\n\n# 2.2 管理后台\n\n① 前端对应 [AI 大模型 -> AI 写作] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/ai/write/index 目录，提供给普通用户使用，生成写作。\n\n\n\n它的后端 HTTP 接口，由 yudao-module-ai 模块的 write 包的 AiWriteController 实现。\n\n最最最关键的代码！！！大家可以重点看看！！！\n\nAiWriteController 提供的 #generateWriteContent(...) 写作接口。\n\n它的内部，调用 Spring AI 的 StreamingChatClient 来实现大模型的调用。\n\n② 前端对应 [AI 大模型 -> 控制台 -> 写作管理] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/ai/write/mananger 目录，提供给管理员使用，查看写作记录。\n\n",
            normalizedContent: "ai 写作，基于 llm 大模型，实现文章的撰写、回复的功能。\n\n\n\n整个功能，涉及到 2 个表：\n\n * 【配置】ai_api_key：api 秘钥表\n * 【写作】ai_write：写作记录表\n\n下面，我们逐个表进行介绍，这个过程中也会讲讲对应的功能。\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\n\n# 1. api 秘钥表\n\n在 《ai 对话》 中，我们已经介绍了 api 秘钥表，这里就不再赘述了。\n\n你想使用哪个模型写作，可以参考对应的文档，进行配置：\n\n * 国内模型：《通义千问》、《deepseek》、《豆包》、《混元》、《文心一言》、《硅基流动》、《讯飞星火》、《智谱 glm》\n * 国外模型：《openai（chatgpt）》、《llama》、《【微软 openai】chatgpt》 、《谷歌 gemini》\n\n友情提示：\n\n一般情况下，建议先使用 《deepseek》 模型，因为免费送了一些 tokens，可以先体验一下。\n\n\n# 1.1 补充说明\n\nai 写作时，使用什么模型和 system prompt 呢？它分成两种情况：\n\n① 情况一：通过【聊天角色】中的“写作助手”进行配置。如下图所示：\n\n\n\n② 情况二：如果没有配置，那就会使用 ai_chat_model 表中的第一个模型（排序 sort 最小的）。同时，它对应的 system prompt 在 aichatroleenum 的 ai_write_role 进行配置。\n\n\n# 2. 写作记录表\n\n写作记录表，用户每发起一次写作，都会记录一条记录。\n\n\n# 2.1 表结构\n\ncreate table `ai_write` (\n  `id` bigint not null auto_increment comment '编号',\n  `user_id` bigint not null comment '用户编号',\n  \n  `type` int default null comment '写作类型',\n  `original_content` varchar(5120) character set utf8mb4 collate utf8mb4_0900_bin default null comment '原文',\n  \n  `platform` varchar(255) character set utf8mb4 collate utf8mb4_0900_bin not null comment '平台',\n  `model` varchar(255) character set utf8mb4 collate utf8mb4_0900_bin not null comment '模型',\n  \n  `prompt` varchar(512) character set utf8mb4 collate utf8mb4_0900_bin not null comment '生成内容提示',\n  `generated_content` varchar(5120) character set utf8mb4 collate utf8mb4_0900_bin default null comment '生成的内容',\n  \n  `length` tinyint default null comment '长度提示词',\n  `format` tinyint default null comment '格式提示词',\n  `tone` tinyint default null comment '语气提示词',\n  `language` tinyint default null comment '语言提示词',\n  \n  `error_message` varchar(255) character set utf8mb4 collate utf8mb4_0900_bin default null comment '错误信息',\n  primary key (`id`) using btree\n) engine=innodb auto_increment=225 default charset=utf8mb4 collate=utf8mb4_0900_bin comment='ai 写作表';\n\n\n① user_id 字段：对应 system_users 表的 id 字段，表示哪个用户生成的写作。\n\n② type 字段：表示写作类型，对应 aiwritetypeenum 枚举，目前有两个类型：撰写文章、回复文章。\n\n当回复文章时，original_content 字段表示原文（被回复文章）。\n\n③ platform 字段：表示平台，对应 aiplatformenum 枚举，目前支持多个 ai 大模型。\n\nmodel 字段：表示模型标识，对应不同的平台的模型标识，例如说 openai 的 gpt-3.5-turbo、gpt-4-turbo，通义千问的 qwen-plus、qwen-max 等等。\n\n④ prompt 字段：表示生成内容提示，用户输入的文本。\n\ngenerated_content 字段：表示生成的内容，ai 生成的文本。\n\n⑤ length、format、tone、language 字段：表示长度、格式、语气、语言提示词。它们是有数据字典枚举，分别对应 ai_write_length、ai_write_format、ai_write_tone、ai_write_language。\n\n⑥ error_message 字段：表示错误信息。由于写作是 stream 流式生成，所以可能会出现错误，这时会记录错误信息。\n\n\n# 2.2 管理后台\n\n① 前端对应 [ai 大模型 -> ai 写作] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/ai/write/index 目录，提供给普通用户使用，生成写作。\n\n\n\n它的后端 http 接口，由 yudao-module-ai 模块的 write 包的 aiwritecontroller 实现。\n\n最最最关键的代码！！！大家可以重点看看！！！\n\naiwritecontroller 提供的 #generatewritecontent(...) 写作接口。\n\n它的内部，调用 spring ai 的 streamingchatclient 来实现大模型的调用。\n\n② 前端对应 [ai 大模型 -> 控制台 -> 写作管理] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/ai/write/mananger 目录，提供给管理员使用，查看写作记录。\n\n",
            charsets: {
                cjk: !0
            }
        }, {
            title: "AI 绘画创作",
            frontmatter: {
                title: "AI 绘画创作",
                date: "2024-06-02T12:31:02.000Z",
                permalink: "/ai/image"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/17.AI%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%89%8B%E5%86%8C/12.AI%20%E7%BB%98%E7%94%BB%E5%88%9B%E4%BD%9C.html",
            relativePath: "01.开发指南/17.AI大模型手册/12.AI 绘画创作.md",
            key: "v-70a39a82",
            path: "/ai/image/",
            headers: [{
                level: 2,
                title: "1. API 秘钥表",
                slug: "_1-api-秘钥表",
                normalizedTitle: "1. api 秘钥表",
                charIndex: 438
            }, {
                level: 2,
                title: "2. 绘画记录表",
                slug: "_2-绘画记录表",
                normalizedTitle: "2. 绘画记录表",
                charIndex: 861
            }, {
                level: 3,
                title: "2.1 表结构",
                slug: "_2-1-表结构",
                normalizedTitle: "2.1 表结构",
                charIndex: 907
            }, {
                level: 3,
                title: "2.2 管理后台",
                slug: "_2-2-管理后台",
                normalizedTitle: "2.2 管理后台",
                charIndex: 2964
            }],
            headersStr: "1. API 秘钥表 2. 绘画记录表 2.1 表结构 2.2 管理后台",
            content: "AI 绘画，基于 LLM 大模型，实现使用文本生成图片的功能。目前接入的是：\n\n * OpenAI 的 DALL 模型\n * StabilityAI 的 Stable Diffusion 模型\n * Midjourney 的 Midjourney 模型\n\n\n\n整个功能，涉及到 2 个表：\n\n * 【配置】ai_api_key：API 秘钥表\n * 【绘画】ai_image：绘画记录表\n\n下面，我们逐个表进行介绍，这个过程中也会讲讲对应的功能。\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\n补充说明：\n\nAI 绘画只是 AI 在 Image 图片中的一种场景，实际还有图片解析（识别）、图片合并等等，后续根据情况接入。\n\n不过有一点比较尴尬，项目所使用的 Spring AI 库，目前只支持“文本生成图片”的功能，其它功能貌似没有计划，这样导致后续需要自己逐个集成！\n\n\n# 1. API 秘钥表\n\n在 《AI 对话》 中，我们已经介绍了 API 秘钥表，这里就不再赘述了。\n\n你想使用哪个模型绘画，可以参考对应的文档，进行配置：\n\n * 通义千问的万象模型：《【模型接入】通义千问》\n * 文心一言的 ernie_Vilg 模型：《【模型接入】文心一言》\n * 智谱 GLM 的 CogView 模型：《【模型接入】智谱 GLM》\n * OpenAI 的 DALL 模型：《【模型接入】OpenAI》\n * StabilityAI 的 Stable Diffusion 模型：《【模型接入】Stable Diffusion》\n * Midjourney 的 Midjourney 模型：《【模型接入】Midjourney》\n\n另外，文心一言、星火等模型，也可以用来绘画，后续会看情况接入！\n\n友情提示：\n\n一般情况下，建议先使用 《【模型接入】通义千问》 模块，因为免费送了一些 tokens，可以先体验一下。\n\n\n# 2. 绘画记录表\n\n绘画记录表，用户每发起一次“文本生成图片”，都会记录一条记录。\n\n\n# 2.1 表结构\n\nCREATE TABLE `ai_image` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  `user_id` bigint NOT NULL COMMENT '用户编号',\n  `public_status` bit(1) NOT NULL COMMENT '是否发布',\n\n  `platform` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '平台',\n  `model` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '模型',\n  \n  `prompt` varchar(2000) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '提示词',\n  `width` int NOT NULL COMMENT '图片宽度',\n  `height` int NOT NULL COMMENT '图片高度',\n  `options` json DEFAULT NULL COMMENT '绘制参数',\n  \n  `status` tinyint NOT NULL COMMENT '绘画状态',\n  `pic_url` varchar(2048) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '图片地址',\n  `error_message` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '错误信息',\n  \n  `task_id` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL COMMENT '任务编号',\n  `buttons` varchar(2048) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_bin DEFAULT NULL COMMENT 'mj buttons 按钮',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=131 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='AI 绘画表';\n\n\n① user_id 字段：对应 system_users 表的 id 字段，表示哪个用户生成的图片。\n\npublic_status 字段：表示是否发布，默认为 false 不发布（不公开）。管理员可以在后台操作，设置某个图片为发布（公开）。\n\n② platform 字段：表示平台，对应 AiPlatformEnum 枚举，目前支持多个 AI 大模型。\n\nmodel 字段：表示模型标识，对应不同的平台的模型标识，例如说 OpenAI 的 dall-e-3、dall-e-2，StabilityAI 的 stable-diffusion-v1-6 等等。\n\n③ prompt 字段：表示提示词，用户输入的文本。\n\nwidth、height 字段：表示图片的宽度、高度。\n\noptions 字段：表示绘制参数，JSON 格式，因为不同平台有不同的参数。例如说：OpenAI 的 OpenAiImageOptions、StabilityAI 的 StabilityAiImageOptions 拓展参数。\n\n④ status 字段：表示绘画状态，对应 AiImageStatusEnum 枚举，目前有 10 进行中、20 生成成功、30 生成失败。因为绘图比较耗时，所以它的整体流程是：\n\n * 用户发起绘画请求，先插入一条状态为 10 进行中的 ai_image 记录\n * 后端异步调用 AI 大模型，生成图片。生成成功后，更新状态为 20 生成成功\n * 前端轮询查询，如果状态为 20 生成成功，就显示图片\n\npic_url 字段：表示图片地址，生成成功后，会把图片地址存储在这里。\n\nerror_message 字段：表示错误信息，生成失败后，会把错误信息存储在这里。\n\n⑤ task_id 字段：Midjourney 的生成图片是异步的，所以需要一个任务编号，用来查询生成状态。\n\nbuttons 字段：Midjourney 生成图片后，会返回一些按钮，用来操作图片。这个字段存储这些按钮。\n\n\n# 2.2 管理后台\n\n① 前端对应 [AI 大模型 -> AI 绘图] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/ai/image/index 目录，提供给普通用户使用，生成图片。\n\n\n\n它的后端 HTTP 接口，由 yudao-module-ai 模块的 image 包的 AiImageController 实现。\n\n最最最关键的代码！！！大家可以重点看看！！！\n\nAiImageController 提供的 #drawImage(...) 生成图片接口。\n\n它的内部，调用 Spring AI 的 ImageModel 来实现大模型的调用。\n\n另外，通义千问、文心一言、智谱等模型的绘图，在【其它】里面使用。TODO 芋艿：重新截图\n\n② 前端对应 [AI 大模型 -> 控制台 -> 绘图管理] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/ai/image/mananger 目录，提供给管理员使用，查看绘画记录。\n\n",
            normalizedContent: "ai 绘画，基于 llm 大模型，实现使用文本生成图片的功能。目前接入的是：\n\n * openai 的 dall 模型\n * stabilityai 的 stable diffusion 模型\n * midjourney 的 midjourney 模型\n\n\n\n整个功能，涉及到 2 个表：\n\n * 【配置】ai_api_key：api 秘钥表\n * 【绘画】ai_image：绘画记录表\n\n下面，我们逐个表进行介绍，这个过程中也会讲讲对应的功能。\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\n补充说明：\n\nai 绘画只是 ai 在 image 图片中的一种场景，实际还有图片解析（识别）、图片合并等等，后续根据情况接入。\n\n不过有一点比较尴尬，项目所使用的 spring ai 库，目前只支持“文本生成图片”的功能，其它功能貌似没有计划，这样导致后续需要自己逐个集成！\n\n\n# 1. api 秘钥表\n\n在 《ai 对话》 中，我们已经介绍了 api 秘钥表，这里就不再赘述了。\n\n你想使用哪个模型绘画，可以参考对应的文档，进行配置：\n\n * 通义千问的万象模型：《【模型接入】通义千问》\n * 文心一言的 ernie_vilg 模型：《【模型接入】文心一言》\n * 智谱 glm 的 cogview 模型：《【模型接入】智谱 glm》\n * openai 的 dall 模型：《【模型接入】openai》\n * stabilityai 的 stable diffusion 模型：《【模型接入】stable diffusion》\n * midjourney 的 midjourney 模型：《【模型接入】midjourney》\n\n另外，文心一言、星火等模型，也可以用来绘画，后续会看情况接入！\n\n友情提示：\n\n一般情况下，建议先使用 《【模型接入】通义千问》 模块，因为免费送了一些 tokens，可以先体验一下。\n\n\n# 2. 绘画记录表\n\n绘画记录表，用户每发起一次“文本生成图片”，都会记录一条记录。\n\n\n# 2.1 表结构\n\ncreate table `ai_image` (\n  `id` bigint not null auto_increment comment '编号',\n  `user_id` bigint not null comment '用户编号',\n  `public_status` bit(1) not null comment '是否发布',\n\n  `platform` varchar(64) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '平台',\n  `model` varchar(64) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '模型',\n  \n  `prompt` varchar(2000) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '提示词',\n  `width` int not null comment '图片宽度',\n  `height` int not null comment '图片高度',\n  `options` json default null comment '绘制参数',\n  \n  `status` tinyint not null comment '绘画状态',\n  `pic_url` varchar(2048) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '图片地址',\n  `error_message` varchar(1024) character set utf8mb4 collate utf8mb4_unicode_ci default null comment '错误信息',\n  \n  `task_id` varchar(1024) character set utf8mb4 collate utf8mb4_0900_bin default null comment '任务编号',\n  `buttons` varchar(2048) character set utf8mb4 collate utf8mb4_0900_bin default null comment 'mj buttons 按钮',\n  primary key (`id`)\n) engine=innodb auto_increment=131 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='ai 绘画表';\n\n\n① user_id 字段：对应 system_users 表的 id 字段，表示哪个用户生成的图片。\n\npublic_status 字段：表示是否发布，默认为 false 不发布（不公开）。管理员可以在后台操作，设置某个图片为发布（公开）。\n\n② platform 字段：表示平台，对应 aiplatformenum 枚举，目前支持多个 ai 大模型。\n\nmodel 字段：表示模型标识，对应不同的平台的模型标识，例如说 openai 的 dall-e-3、dall-e-2，stabilityai 的 stable-diffusion-v1-6 等等。\n\n③ prompt 字段：表示提示词，用户输入的文本。\n\nwidth、height 字段：表示图片的宽度、高度。\n\noptions 字段：表示绘制参数，json 格式，因为不同平台有不同的参数。例如说：openai 的 openaiimageoptions、stabilityai 的 stabilityaiimageoptions 拓展参数。\n\n④ status 字段：表示绘画状态，对应 aiimagestatusenum 枚举，目前有 10 进行中、20 生成成功、30 生成失败。因为绘图比较耗时，所以它的整体流程是：\n\n * 用户发起绘画请求，先插入一条状态为 10 进行中的 ai_image 记录\n * 后端异步调用 ai 大模型，生成图片。生成成功后，更新状态为 20 生成成功\n * 前端轮询查询，如果状态为 20 生成成功，就显示图片\n\npic_url 字段：表示图片地址，生成成功后，会把图片地址存储在这里。\n\nerror_message 字段：表示错误信息，生成失败后，会把错误信息存储在这里。\n\n⑤ task_id 字段：midjourney 的生成图片是异步的，所以需要一个任务编号，用来查询生成状态。\n\nbuttons 字段：midjourney 生成图片后，会返回一些按钮，用来操作图片。这个字段存储这些按钮。\n\n\n# 2.2 管理后台\n\n① 前端对应 [ai 大模型 -> ai 绘图] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/ai/image/index 目录，提供给普通用户使用，生成图片。\n\n\n\n它的后端 http 接口，由 yudao-module-ai 模块的 image 包的 aiimagecontroller 实现。\n\n最最最关键的代码！！！大家可以重点看看！！！\n\naiimagecontroller 提供的 #drawimage(...) 生成图片接口。\n\n它的内部，调用 spring ai 的 imagemodel 来实现大模型的调用。\n\n另外，通义千问、文心一言、智谱等模型的绘图，在【其它】里面使用。todo 芋艿：重新截图\n\n② 前端对应 [ai 大模型 -> 控制台 -> 绘图管理] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/ai/image/mananger 目录，提供给管理员使用，查看绘画记录。\n\n",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【模型接入】OpenAI",
            frontmatter: {
                title: "【模型接入】OpenAI",
                date: "2024-06-01T17:06:49.000Z",
                permalink: "/ai/openai"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/17.AI%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%89%8B%E5%86%8C/80.%E3%80%90%E6%A8%A1%E5%9E%8B%E6%8E%A5%E5%85%A5%E3%80%91OpenAI.html",
            relativePath: "01.开发指南/17.AI大模型手册/80.【模型接入】OpenAI.md",
            key: "v-176d8495",
            path: "/ai/openai/",
            headers: [{
                level: 2,
                title: "1. 申请密钥",
                slug: "_1-申请密钥",
                normalizedTitle: "1. 申请密钥",
                charIndex: 248
            }, {
                level: 3,
                title: "1.1 方式一：官方 API 申请",
                slug: "_1-1-方式一-官方-api-申请",
                normalizedTitle: "1.1 方式一：官方 api 申请",
                charIndex: 581
            }, {
                level: 3,
                title: "1.2 方式二：中转 API 申请",
                slug: "_1-2-方式二-中转-api-申请",
                normalizedTitle: "1.2 方式二：中转 api 申请",
                charIndex: 867
            }, {
                level: 3,
                title: "1.3 补充说明",
                slug: "_1-3-补充说明",
                normalizedTitle: "1.3 补充说明",
                charIndex: 1168
            }, {
                level: 2,
                title: "2. 如何使用？",
                slug: "_2-如何使用",
                normalizedTitle: "2. 如何使用？",
                charIndex: 1357
            }],
            headersStr: "1. 申请密钥 1.1 方式一：官方 API 申请 1.2 方式二：中转 API 申请 1.3 补充说明 2. 如何使用？",
            content: "项目基于 Spring AI 提供的 spring-ai-openai，实现 OpenAI 的接入：\n\n功能      模型                SPRING AI 客户端\nAI 对话   gpt3.5、gpt4.0 等   OpenAI Chat\nAI 绘画   DALL              OpenAI Image Generation\n\n友情提示：\n\n如果你使用的是微软 Azure 提供的 OpenAI 服务，可阅读 《【模型接入】微软 OpenAI》 文档。\n\n\n# 1. 申请密钥\n\n由于 OpenAI 是非开源的模型，所以无法私有化部署，需要去官网申请 API Key，然后通过 Spring AI 提供的客户端接入。\n\n不过，目前市面上有很多 OpenAI 的中转 API 服务，通过购买这些服务，也能实现接入。\n\n疑问：什么是“中转 API 服务”？\n\n简单来说，就是有人通过一定的渠道，获取了大量的 OpenAI、MidJourney 等 API 账号，然后部署一个 API 池子（服务）。\n\n中转人卖给你一个 API KEY 令牌，你就可以把 AI 请求发送到他的池子：池子采取一定的算法选取一个 API 账号帮你把请求发送到大模型后端，然后再把大模型返回的结果转发给你。\n\n下面，我们来看看这两种方式怎么申请？\n\n\n# 1.1 方式一：官方 API 申请\n\n可以参考 《OpenAI API keys 的申请和测试小结 》 进行申请。\n\n会略微麻烦一些，我自己是直接采用了“方式二：中转 API 申请”。\n\n----------------------------------------\n\n申请完成后，可以在我们系统的 [AI 大模型 -> 控制台 -> API 密钥] 菜单，进行密钥的配置。只需要填写“密钥”，不需要填写“自定义 API URL”（因为 Spring AI 默认官方地址）。如下图所示：\n\n\n\n友情提示：官方的 API 禁止国内直接访问，需要有 VPN 代理~\n\n\n# 1.2 方式二：中转 API 申请\n\n提供中转 API 服务的有很多，也可以 Google 直接搜索“openai API 中转”，例如说：\n\n * 毫秒 API 【临时体验，可少量充值体验】\n * Wildcard 的 API 随心用 【生产使用】\n\n友情提示：少量购买，可以使用体验即可！\n\n----------------------------------------\n\n购买完成后，可以在我们系统的 [AI 大模型 -> 控制台 -> API 密钥] 菜单，进行密钥的配置。需要填写“密钥” + “自定义 API URL”（因为让 Spring AI 使用该地址）。如下图所示：\n\n\n\n\n# 1.3 补充说明\n\n如果后续你要体验 《AI 对话》 ，需要在 [AI 大模型 -> 控制台 -> 聊天模型] 菜单，配置对应的聊天模型。注意，每个模型标识的 max_tokens（回复数 Token 数）是不同的。\n\n例如说：gpt-3.5-turbo 是 4096，gpt-4-turbo 是 8192。\n\n不确定的话，就填写 4096 先~跑通之后，再网上查查。\n\n\n# 2. 如何使用？\n\n① 如果你的项目里需要直接通过 @Resource 注入 OpenAiChatModel、OpenAiImageModel 等对象，需要把 application.yaml 配置文件里的 spring.ai.openai 配置项，替换成你的！\n\nspring:\n  ai:\n    openai:\n      api-key: # 你的密钥\n      base-url: # 如果是中转 API，这里填写中转 API 的地址；如果是官方的，这里不需要填写\n\n\n② 如果你希望使用 [AI 大模型 -> 控制台 -> API 密钥] 菜单的密钥配置，则可以通过 AiApiKeyService 的 #getChatModel(...) 或 #getImageModel(...) 方法，获取对应的模型对象。\n\n----------------------------------------\n\n① 和 ② 这两者的后续使用，就是标准的 Spring AI 客户端的使用，调用对应的方法即可。\n\n另外，OpenAIChatModelTests 和 OpenAiImageModelTests 里有对应的测试用例，可以参考。",
            normalizedContent: "项目基于 spring ai 提供的 spring-ai-openai，实现 openai 的接入：\n\n功能      模型                spring ai 客户端\nai 对话   gpt3.5、gpt4.0 等   openai chat\nai 绘画   dall              openai image generation\n\n友情提示：\n\n如果你使用的是微软 azure 提供的 openai 服务，可阅读 《【模型接入】微软 openai》 文档。\n\n\n# 1. 申请密钥\n\n由于 openai 是非开源的模型，所以无法私有化部署，需要去官网申请 api key，然后通过 spring ai 提供的客户端接入。\n\n不过，目前市面上有很多 openai 的中转 api 服务，通过购买这些服务，也能实现接入。\n\n疑问：什么是“中转 api 服务”？\n\n简单来说，就是有人通过一定的渠道，获取了大量的 openai、midjourney 等 api 账号，然后部署一个 api 池子（服务）。\n\n中转人卖给你一个 api key 令牌，你就可以把 ai 请求发送到他的池子：池子采取一定的算法选取一个 api 账号帮你把请求发送到大模型后端，然后再把大模型返回的结果转发给你。\n\n下面，我们来看看这两种方式怎么申请？\n\n\n# 1.1 方式一：官方 api 申请\n\n可以参考 《openai api keys 的申请和测试小结 》 进行申请。\n\n会略微麻烦一些，我自己是直接采用了“方式二：中转 api 申请”。\n\n----------------------------------------\n\n申请完成后，可以在我们系统的 [ai 大模型 -> 控制台 -> api 密钥] 菜单，进行密钥的配置。只需要填写“密钥”，不需要填写“自定义 api url”（因为 spring ai 默认官方地址）。如下图所示：\n\n\n\n友情提示：官方的 api 禁止国内直接访问，需要有 vpn 代理~\n\n\n# 1.2 方式二：中转 api 申请\n\n提供中转 api 服务的有很多，也可以 google 直接搜索“openai api 中转”，例如说：\n\n * 毫秒 api 【临时体验，可少量充值体验】\n * wildcard 的 api 随心用 【生产使用】\n\n友情提示：少量购买，可以使用体验即可！\n\n----------------------------------------\n\n购买完成后，可以在我们系统的 [ai 大模型 -> 控制台 -> api 密钥] 菜单，进行密钥的配置。需要填写“密钥” + “自定义 api url”（因为让 spring ai 使用该地址）。如下图所示：\n\n\n\n\n# 1.3 补充说明\n\n如果后续你要体验 《ai 对话》 ，需要在 [ai 大模型 -> 控制台 -> 聊天模型] 菜单，配置对应的聊天模型。注意，每个模型标识的 max_tokens（回复数 token 数）是不同的。\n\n例如说：gpt-3.5-turbo 是 4096，gpt-4-turbo 是 8192。\n\n不确定的话，就填写 4096 先~跑通之后，再网上查查。\n\n\n# 2. 如何使用？\n\n① 如果你的项目里需要直接通过 @resource 注入 openaichatmodel、openaiimagemodel 等对象，需要把 application.yaml 配置文件里的 spring.ai.openai 配置项，替换成你的！\n\nspring:\n  ai:\n    openai:\n      api-key: # 你的密钥\n      base-url: # 如果是中转 api，这里填写中转 api 的地址；如果是官方的，这里不需要填写\n\n\n② 如果你希望使用 [ai 大模型 -> 控制台 -> api 密钥] 菜单的密钥配置，则可以通过 aiapikeyservice 的 #getchatmodel(...) 或 #getimagemodel(...) 方法，获取对应的模型对象。\n\n----------------------------------------\n\n① 和 ② 这两者的后续使用，就是标准的 spring ai 客户端的使用，调用对应的方法即可。\n\n另外，openaichatmodeltests 和 openaiimagemodeltests 里有对应的测试用例，可以参考。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "AI 音乐创作",
            frontmatter: {
                title: "AI 音乐创作",
                date: "2024-06-29T11:05:04.000Z",
                permalink: "/ai/music/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/17.AI%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%89%8B%E5%86%8C/13.AI%20%E9%9F%B3%E4%B9%90%E5%88%9B%E4%BD%9C.html",
            relativePath: "01.开发指南/17.AI大模型手册/13.AI 音乐创作.md",
            key: "v-c13f42f0",
            path: "/ai/music/",
            headers: [{
                level: 2,
                title: "1. API 秘钥表",
                slug: "_1-api-秘钥表",
                normalizedTitle: "1. api 秘钥表",
                charIndex: 262
            }, {
                level: 2,
                title: "2. 音乐记录表",
                slug: "_2-音乐记录表",
                normalizedTitle: "2. 音乐记录表",
                charIndex: 283
            }, {
                level: 3,
                title: "2.1 表结构",
                slug: "_2-1-表结构",
                normalizedTitle: "2.1 表结构",
                charIndex: 302
            }, {
                level: 3,
                title: "2.2 管理后台",
                slug: "_2-2-管理后台",
                normalizedTitle: "2.2 管理后台",
                charIndex: 320
            }],
            headersStr: "1. API 秘钥表 2. 音乐记录表 2.1 表结构 2.2 管理后台",
            content: "AI 音乐，基于 LLM 大模型，实现使用文本生成音乐的功能。目前接入的是：\n\n * SunoAI 的 Suno 模型\n\nTODO 后端目前已经接完，前端界面还在搞，预计 9 月上旬。\n\n整个功能，涉及到 2 个表：\n\n * 【配置】ai_api_key：API 秘钥表\n * 【绘画】ai_music：音乐记录表\n\n下面，我们逐个表进行介绍，这个过程中也会讲讲对应的功能。\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\n\n# 1. API 秘钥表\n\nTODO\n\n\n# 2. 音乐记录表\n\nTODO\n\n\n# 2.1 表结构\n\nTODO\n\n\n# 2.2 管理后台\n\nTODO",
            normalizedContent: "ai 音乐，基于 llm 大模型，实现使用文本生成音乐的功能。目前接入的是：\n\n * sunoai 的 suno 模型\n\ntodo 后端目前已经接完，前端界面还在搞，预计 9 月上旬。\n\n整个功能，涉及到 2 个表：\n\n * 【配置】ai_api_key：api 秘钥表\n * 【绘画】ai_music：音乐记录表\n\n下面，我们逐个表进行介绍，这个过程中也会讲讲对应的功能。\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\n\n# 1. api 秘钥表\n\ntodo\n\n\n# 2. 音乐记录表\n\ntodo\n\n\n# 2.1 表结构\n\ntodo\n\n\n# 2.2 管理后台\n\ntodo",
            charsets: {
                cjk: !0
            }
        }, {
            title: "AI 思维导图",
            frontmatter: {
                title: "AI 思维导图",
                date: "2024-07-06T19:26:55.000Z",
                permalink: "/ai/mindmap/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/17.AI%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%89%8B%E5%86%8C/15.AI%20%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.html",
            relativePath: "01.开发指南/17.AI大模型手册/15.AI 思维导图.md",
            key: "v-43441f7a",
            path: "/ai/mindmap/",
            headers: [{
                level: 2,
                title: "1. API 秘钥表",
                slug: "_1-api-秘钥表",
                normalizedTitle: "1. api 秘钥表",
                charIndex: 269
            }, {
                level: 3,
                title: "1.1 补充说明",
                slug: "_1-1-补充说明",
                normalizedTitle: "1.1 补充说明",
                charIndex: 549
            }, {
                level: 2,
                title: "2. 思维导图记录表",
                slug: "_2-思维导图记录表",
                normalizedTitle: "2. 思维导图记录表",
                charIndex: 765
            }, {
                level: 3,
                title: "2.1 表结构",
                slug: "_2-1-表结构",
                normalizedTitle: "2.1 表结构",
                charIndex: 811
            }, {
                level: 3,
                title: "2.2 管理后台",
                slug: "_2-2-管理后台",
                normalizedTitle: "2.2 管理后台",
                charIndex: 1843
            }],
            headersStr: "1. API 秘钥表 1.1 补充说明 2. 思维导图记录表 2.1 表结构 2.2 管理后台",
            content: "AI 思维导图，基于 LLM 大模型，实现智能思维导图的功能。\n\n它的实现原理，是根据 prompt 提示词生成 markdown 内容，之后再通过 markdown 转换成思维导图。\n\n\n\n整个功能，涉及到 2 个表：\n\n * 【配置】ai_api_key：API 秘钥表\n * 【导图】ai_mind_map：思维导图记录表\n\n下面，我们逐个表进行介绍，这个过程中也会讲讲对应的功能。\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\n\n# 1. API 秘钥表\n\n在 《AI 对话》 中，我们已经介绍了 API 秘钥表，这里就不再赘述了。\n\n你想使用哪个模型生成思维导图，可以参考对应的文档，进行配置：\n\n * 国内模型：《通义千问》、《DeepSeek》、《豆包》、《混元》、《文心一言》、《硅基流动》、《讯飞星火》、《智谱 GLM》\n * 国外模型：《OpenAI（ChatGPT）》、《LLAMA》、《【微软 OpenAI】ChatGPT》 、《谷歌 Gemini》\n\n友情提示：\n\n一般情况下，建议先使用 《DeepSeek》 模型，因为免费送了一些 tokens，可以先体验一下。\n\n\n# 1.1 补充说明\n\nAI 生成思维导图时，使用什么模型和 system prompt 呢？它分成两种情况：\n\n① 情况一：通过【聊天角色】中的“导图助手 ”进行配置。如下图所示：\n\n\n\n② 情况二：如果没有配置，那就会使用 ai_chat_model 表中的第一个模型（排序 sort 最小的）。同时，它对应的 system prompt 在 AiChatRoleEnum 的 AI_MIND_MAP_ROLE 进行配置。\n\n\n# 2. 思维导图记录表\n\n思维导图记录表，用户每发起一次思维导图，都会记录一条记录。\n\n\n# 2.1 表结构\n\nCREATE TABLE `ai_mind_map` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '编号',\n  `user_id` bigint NOT NULL COMMENT '用户编号',\n  \n  `platform` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '平台',\n  `model` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '模型',\n  \n  `prompt` text COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '生成内容提示',\n  `generated_content` text COLLATE utf8mb4_unicode_ci COMMENT '生成的思维导图内容',\n   \n   `error_message` varchar(1024) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '错误信息',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='AI 思维导图表';\n\n\n① user_id 字段：对应 system_users 表的 id 字段，表示哪个用户生成的思维导图。\n\n② platform 字段：表示平台，对应 AiPlatformEnum 枚举，目前支持多个 AI 大模型。\n\nmodel 字段：表示模型标识，对应不同的平台的模型标识，例如说 OpenAI 的 gpt-3.5-turbo、gpt-4-turbo，通义千问的 qwen-plus、qwen-max 等等。\n\n③ prompt 字段：表示生成内容提示，即生成思维导图的提示词。\n\ngenerated_content 字段：表示生成的思维导图内容，markdown 格式。\n\n④ error_message 字段：表示错误信息，如果生成失败，会记录错误信息。\n\n\n# 2.2 管理后台\n\n① 前端对应 [AI 大模型 -> AI 思维导图] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/ai/mindmap/index 目录，提供给普通用户使用，生成思维导图。\n\n\n\n它的后端 HTTP 接口，由 yudao-module-ai 模块的 mindmap 包的 AiMindMapController 实现。\n\n最最最关键的代码！！！大家可以重点看看！！！\n\nAiMindMapController 提供的 #generateMindMap(...) 生成思维导图接口。\n\n它的内部，调用 Spring AI 的 StreamingChatClient 来实现大模型的调用。\n\n② 前端对应 [AI 大模型 -> 控制台 -> 导图管理] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/ai/mindmap/mananger 目录，提供给管理员使用，查看思维导图记录。\n\n",
            normalizedContent: "ai 思维导图，基于 llm 大模型，实现智能思维导图的功能。\n\n它的实现原理，是根据 prompt 提示词生成 markdown 内容，之后再通过 markdown 转换成思维导图。\n\n\n\n整个功能，涉及到 2 个表：\n\n * 【配置】ai_api_key：api 秘钥表\n * 【导图】ai_mind_map：思维导图记录表\n\n下面，我们逐个表进行介绍，这个过程中也会讲讲对应的功能。\n\n> 省略 creator/create_time/updater/update_time/deleted/tenant_id 等通用字段\n\n\n# 1. api 秘钥表\n\n在 《ai 对话》 中，我们已经介绍了 api 秘钥表，这里就不再赘述了。\n\n你想使用哪个模型生成思维导图，可以参考对应的文档，进行配置：\n\n * 国内模型：《通义千问》、《deepseek》、《豆包》、《混元》、《文心一言》、《硅基流动》、《讯飞星火》、《智谱 glm》\n * 国外模型：《openai（chatgpt）》、《llama》、《【微软 openai】chatgpt》 、《谷歌 gemini》\n\n友情提示：\n\n一般情况下，建议先使用 《deepseek》 模型，因为免费送了一些 tokens，可以先体验一下。\n\n\n# 1.1 补充说明\n\nai 生成思维导图时，使用什么模型和 system prompt 呢？它分成两种情况：\n\n① 情况一：通过【聊天角色】中的“导图助手 ”进行配置。如下图所示：\n\n\n\n② 情况二：如果没有配置，那就会使用 ai_chat_model 表中的第一个模型（排序 sort 最小的）。同时，它对应的 system prompt 在 aichatroleenum 的 ai_mind_map_role 进行配置。\n\n\n# 2. 思维导图记录表\n\n思维导图记录表，用户每发起一次思维导图，都会记录一条记录。\n\n\n# 2.1 表结构\n\ncreate table `ai_mind_map` (\n  `id` bigint not null auto_increment comment '编号',\n  `user_id` bigint not null comment '用户编号',\n  \n  `platform` varchar(64) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '平台',\n  `model` varchar(50) character set utf8mb4 collate utf8mb4_unicode_ci not null comment '模型',\n  \n  `prompt` text collate utf8mb4_unicode_ci not null comment '生成内容提示',\n  `generated_content` text collate utf8mb4_unicode_ci comment '生成的思维导图内容',\n   \n   `error_message` varchar(1024) collate utf8mb4_unicode_ci default null comment '错误信息',\n  primary key (`id`)\n) engine=innodb auto_increment=4 default charset=utf8mb4 collate=utf8mb4_unicode_ci comment='ai 思维导图表';\n\n\n① user_id 字段：对应 system_users 表的 id 字段，表示哪个用户生成的思维导图。\n\n② platform 字段：表示平台，对应 aiplatformenum 枚举，目前支持多个 ai 大模型。\n\nmodel 字段：表示模型标识，对应不同的平台的模型标识，例如说 openai 的 gpt-3.5-turbo、gpt-4-turbo，通义千问的 qwen-plus、qwen-max 等等。\n\n③ prompt 字段：表示生成内容提示，即生成思维导图的提示词。\n\ngenerated_content 字段：表示生成的思维导图内容，markdown 格式。\n\n④ error_message 字段：表示错误信息，如果生成失败，会记录错误信息。\n\n\n# 2.2 管理后台\n\n① 前端对应 [ai 大模型 -> ai 思维导图] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/ai/mindmap/index 目录，提供给普通用户使用，生成思维导图。\n\n\n\n它的后端 http 接口，由 yudao-module-ai 模块的 mindmap 包的 aimindmapcontroller 实现。\n\n最最最关键的代码！！！大家可以重点看看！！！\n\naimindmapcontroller 提供的 #generatemindmap(...) 生成思维导图接口。\n\n它的内部，调用 spring ai 的 streamingchatclient 来实现大模型的调用。\n\n② 前端对应 [ai 大模型 -> 控制台 -> 导图管理] 菜单，对应 yudao-ui-admin-vue3 项目的 @/views/ai/mindmap/mananger 目录，提供给管理员使用，查看思维导图记录。\n\n",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【模型接入】通义千问",
            frontmatter: {
                title: "【模型接入】通义千问",
                date: "2024-06-01T18:57:59.000Z",
                permalink: "/ai/tongyi"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/17.AI%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%89%8B%E5%86%8C/81.%E3%80%90%E6%A8%A1%E5%9E%8B%E6%8E%A5%E5%85%A5%E3%80%91%E9%80%9A%E4%B9%89%E5%8D%83%E9%97%AE.html",
            relativePath: "01.开发指南/17.AI大模型手册/81.【模型接入】通义千问.md",
            key: "v-25aac8de",
            path: "/ai/tongyi/",
            headers: [{
                level: 2,
                title: "1. 申请密钥（私有部署）",
                slug: "_1-申请密钥-私有部署",
                normalizedTitle: "1. 申请密钥（私有部署）",
                charIndex: 172
            }, {
                level: 3,
                title: "1.1 方式一：申请阿里云密钥",
                slug: "_1-1-方式一-申请阿里云密钥",
                normalizedTitle: "1.1 方式一：申请阿里云密钥",
                charIndex: 393
            }, {
                level: 3,
                title: "1.2 方式二：私有化部署",
                slug: "_1-2-方式二-私有化部署",
                normalizedTitle: "1.2 方式二：私有化部署",
                charIndex: 753
            }, {
                level: 3,
                title: "1.3 补充说明",
                slug: "_1-3-补充说明",
                normalizedTitle: "1.3 补充说明",
                charIndex: 1088
            }, {
                level: 2,
                title: "2. 如何使用？",
                slug: "_2-如何使用",
                normalizedTitle: "2. 如何使用？",
                charIndex: 1298
            }],
            headersStr: "1. 申请密钥（私有部署） 1.1 方式一：申请阿里云密钥 1.2 方式二：私有化部署 1.3 补充说明 2. 如何使用？",
            content: "项目基于 Spring Cloud Alibaba AI 的 spring-cloud-alibaba-starters，实现 通义千问 的接入：\n\n功能      模型     SPRING AI 客户端\nAI 对话   通义千问   TongYiChatModel\nAI 绘画   通义万象   TongYiImagesModel\n\n\n# 1. 申请密钥（私有部署）\n\n通义千问有开源版本，提供包括 18 亿、70 亿、140 亿和 720亿 等多个规模的版本，所以我们可以私有化部署。\n\n当然，能力更强的模型，就需要使用阿里云提供的大模型服务。\n\n下面，我们来看看这两种方式怎么申请（部署）？\n\n友情提示：\n\n一般情况下，建议先采用“方式一：申请阿里云密钥”，因为阿里云提供了一定的免费额度，具体可以看 阿里云计费管理（需要登录），搜“免费额度”或者“限时免费”关键字。\n\n\n# 1.1 方式一：申请阿里云密钥\n\n参考 《阿里云大模型 —— 快速模型》 文档，重点是“开通 DashScope 并创建 API-KEY”部分，其它都不用关注。一般 1-2 分钟就可以申请完成！\n\n----------------------------------------\n\n申请完成后，可以在我们系统的 [AI 大模型 -> 控制台 -> API 密钥] 菜单，进行密钥的配置。只需要填写“密钥”，不需要填写“自定义 API URL”（因为 Spring AI 默认官方地址）。如下图所示：\n\n\n\n具体它有哪些模型，还是可以通过 阿里云计费管理（需要登录） 查看。例如说：qwen-turbo、qwen-max、qwen-max-1201、qwen-max-longcontext、qwen-plus。\n\n\n# 1.2 方式二：私有化部署\n\n① 访问 https://ollama.ai/download，下载对应系统 Ollama 客户端，然后安装。\n\n② 安装完成后，在命令中执行 ollama run qwen 命令，一键部署 通义千问开源模型，默认跑的是 qwen:4b 模型。\n\n----------------------------------------\n\n部署完成后，可以在我们系统的 [AI 大模型 -> 控制台 -> API 密钥] 菜单，进行密钥的配置。需要填写“密钥” + “自定义 API URL”（因为让 Spring AI 使用该地址）。如下图所示：\n\n\n\n注意：使用该方式时，后续配置模型名时，需要使用 qwen:4b ！！！例如说：\n\n\n\n\n# 1.3 补充说明\n\n① 【对话】如果后续你要体验 《AI 对话》 ，需要在 [AI 大模型 -> 控制台 -> 聊天模型] 菜单，配置对应的聊天模型。注意，每个模型标识的 max_tokens（回复数 Token 数）是不同的。\n\n目前 官方文档 介绍，一般是 1500 或 2000。\n\n不确定的话，就填写 1500 先~跑通之后，再网上查查。\n\n② 【绘图】你可以参考 《AI 绘画》 ，实现文字生成图片。\n\n\n# 2. 如何使用？\n\n① 如果你的项目里需要直接通过 @Resource 注入 TongYiChatModel、TongYiImageModel 等对象，需要把 application.yaml 配置文件里的 spring.ai.dashscope. 配置项，替换成你的！\n\nps：暂时不支持“方式二：私有化部署”。（后续会支持！）\n\nspring:\n  ai:\n    dashscope: # 通义千问\n    api-key: sk-71800982914041848008480000000000\n\n\n② 如果你希望使用 [AI 大模型 -> 控制台 -> API 密钥] 菜单的密钥配置，则可以通过 AiApiKeyService 的 #getChatModel(...) 或 #getImageModel(...) 方法，获取对应的模型对象。\n\n----------------------------------------\n\n① 和 ② 这两者的后续使用，就是标准的 Spring AI 客户端的使用，调用对应的方法即可。\n\n另外，QianWenChatModelTests 里有对应的测试用例，可以参考。",
            normalizedContent: "项目基于 spring cloud alibaba ai 的 spring-cloud-alibaba-starters，实现 通义千问 的接入：\n\n功能      模型     spring ai 客户端\nai 对话   通义千问   tongyichatmodel\nai 绘画   通义万象   tongyiimagesmodel\n\n\n# 1. 申请密钥（私有部署）\n\n通义千问有开源版本，提供包括 18 亿、70 亿、140 亿和 720亿 等多个规模的版本，所以我们可以私有化部署。\n\n当然，能力更强的模型，就需要使用阿里云提供的大模型服务。\n\n下面，我们来看看这两种方式怎么申请（部署）？\n\n友情提示：\n\n一般情况下，建议先采用“方式一：申请阿里云密钥”，因为阿里云提供了一定的免费额度，具体可以看 阿里云计费管理（需要登录），搜“免费额度”或者“限时免费”关键字。\n\n\n# 1.1 方式一：申请阿里云密钥\n\n参考 《阿里云大模型 —— 快速模型》 文档，重点是“开通 dashscope 并创建 api-key”部分，其它都不用关注。一般 1-2 分钟就可以申请完成！\n\n----------------------------------------\n\n申请完成后，可以在我们系统的 [ai 大模型 -> 控制台 -> api 密钥] 菜单，进行密钥的配置。只需要填写“密钥”，不需要填写“自定义 api url”（因为 spring ai 默认官方地址）。如下图所示：\n\n\n\n具体它有哪些模型，还是可以通过 阿里云计费管理（需要登录） 查看。例如说：qwen-turbo、qwen-max、qwen-max-1201、qwen-max-longcontext、qwen-plus。\n\n\n# 1.2 方式二：私有化部署\n\n① 访问 https://ollama.ai/download，下载对应系统 ollama 客户端，然后安装。\n\n② 安装完成后，在命令中执行 ollama run qwen 命令，一键部署 通义千问开源模型，默认跑的是 qwen:4b 模型。\n\n----------------------------------------\n\n部署完成后，可以在我们系统的 [ai 大模型 -> 控制台 -> api 密钥] 菜单，进行密钥的配置。需要填写“密钥” + “自定义 api url”（因为让 spring ai 使用该地址）。如下图所示：\n\n\n\n注意：使用该方式时，后续配置模型名时，需要使用 qwen:4b ！！！例如说：\n\n\n\n\n# 1.3 补充说明\n\n① 【对话】如果后续你要体验 《ai 对话》 ，需要在 [ai 大模型 -> 控制台 -> 聊天模型] 菜单，配置对应的聊天模型。注意，每个模型标识的 max_tokens（回复数 token 数）是不同的。\n\n目前 官方文档 介绍，一般是 1500 或 2000。\n\n不确定的话，就填写 1500 先~跑通之后，再网上查查。\n\n② 【绘图】你可以参考 《ai 绘画》 ，实现文字生成图片。\n\n\n# 2. 如何使用？\n\n① 如果你的项目里需要直接通过 @resource 注入 tongyichatmodel、tongyiimagemodel 等对象，需要把 application.yaml 配置文件里的 spring.ai.dashscope. 配置项，替换成你的！\n\nps：暂时不支持“方式二：私有化部署”。（后续会支持！）\n\nspring:\n  ai:\n    dashscope: # 通义千问\n    api-key: sk-71800982914041848008480000000000\n\n\n② 如果你希望使用 [ai 大模型 -> 控制台 -> api 密钥] 菜单的密钥配置，则可以通过 aiapikeyservice 的 #getchatmodel(...) 或 #getimagemodel(...) 方法，获取对应的模型对象。\n\n----------------------------------------\n\n① 和 ② 这两者的后续使用，就是标准的 spring ai 客户端的使用，调用对应的方法即可。\n\n另外，qianwenchatmodeltests 里有对应的测试用例，可以参考。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【模型接入】字节豆包",
            frontmatter: {
                title: "【模型接入】字节豆包",
                date: "2025-02-24T09:24:35.000Z",
                permalink: "/ai/doubao"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/17.AI%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%89%8B%E5%86%8C/83.%E3%80%90%E6%A8%A1%E5%9E%8B%E6%8E%A5%E5%85%A5%E3%80%91%E5%AD%97%E8%8A%82%E8%B1%86%E5%8C%85.html",
            relativePath: "01.开发指南/17.AI大模型手册/83.【模型接入】字节豆包.md",
            key: "v-fbfa8048",
            path: "/ai/doubao/",
            headers: [{
                level: 2,
                title: "1. 申请密钥",
                slug: "_1-申请密钥",
                normalizedTitle: "1. 申请密钥",
                charIndex: 227
            }, {
                level: 3,
                title: "1.1 申请字节密钥",
                slug: "_1-1-申请字节密钥",
                normalizedTitle: "1.1 申请字节密钥",
                charIndex: 305
            }, {
                level: 3,
                title: "1.2 补充说明",
                slug: "_1-2-补充说明",
                normalizedTitle: "1.2 补充说明",
                charIndex: 589
            }, {
                level: 2,
                title: "2. 如何使用？",
                slug: "_2-如何使用",
                normalizedTitle: "2. 如何使用？",
                charIndex: 797
            }],
            headersStr: "1. 申请密钥 1.1 申请字节密钥 1.2 补充说明 2. 如何使用？",
            content: "项目基于 Spring AI + 自己实现的 models/doubao，实现 doubao 豆包大模型 的接入：\n\n功能      模型                                 SPRING AI 客户端\nAI 对话   doubao-1.5-pro、doubao-1.5-lite 等   DouBaoChatModel\nAI 绘画   doubt-t2i-drawing 等                暂未接入\n\n\n# 1. 申请密钥\n\n由于字节豆包是非开源的模型，所以无法私有化部署，需要去官网申请 API Key，然后通过 Spring AI 提供的客户端接入。\n\n\n# 1.1 申请字节密钥\n\n① 在 火山引擎 上，注册一个账号。\n\n② 在 系统设置 -> API Key 管理 上，创建一个 API Key 密钥。\n\n\n\n③ 在 智能广场 -> 模型广场 上，选择“Doubao-1.5-lite-32k”模型，进行开通。\n\n\n\n----------------------------------------\n\n申请完成后，可以在我们系统的 [AI 大模型 -> 控制台 -> API 密钥] 菜单，进行密钥的配置。需要填写“密钥” + “自定义 API URL”（因为让 Spring AI 使用该地址）。如下图所示：\n\n\n\n\n# 1.2 补充说明\n\n① 【对话】如果后续你要体验 《AI 对话》 ，需要在 [AI 大模型 -> 控制台 -> 聊天模型] 菜单，配置对应的聊天模型。注意，每个模型标识的 max_tokens（回复数 Token 数）一般是 4096。\n\n具体有哪些模型，可以点击 模型广场 进行查看。例如说：doubao-1-5-lite-32k-250115、doubao-1-5-pro-32k-250115 等等。\n\n\n# 2. 如何使用？\n\n① 如果你的项目里需要直接通过 @Resource 注入 DouBaoChatModel 等对象，需要把 application.yaml 配置文件里的 yudao.ai.doubao 配置项，替换成你的！\n\nyudao:\n  ai:\n    doubao: # 字节豆包\n      enable: true\n      api-key: 5c1b5747-26d2-4ebd-a4e0-dd0e8d8b4272\n      model: doubao-1-5-lite-32k-250115\n\n\n② 如果你希望使用 [AI 大模型 -> 控制台 -> API 密钥] 菜单的密钥配置，则可以通过 AiApiKeyService 的 #getChatModel(...) 方法，获取对应的模型对象。\n\n----------------------------------------\n\n① 和 ② 这两者的后续使用，就是标准的 Spring AI 客户端的使用，调用对应的方法即可。\n\n另外，DouBaoChatModelTests 里有对应的测试用例，可以参考。",
            normalizedContent: "项目基于 spring ai + 自己实现的 models/doubao，实现 doubao 豆包大模型 的接入：\n\n功能      模型                                 spring ai 客户端\nai 对话   doubao-1.5-pro、doubao-1.5-lite 等   doubaochatmodel\nai 绘画   doubt-t2i-drawing 等                暂未接入\n\n\n# 1. 申请密钥\n\n由于字节豆包是非开源的模型，所以无法私有化部署，需要去官网申请 api key，然后通过 spring ai 提供的客户端接入。\n\n\n# 1.1 申请字节密钥\n\n① 在 火山引擎 上，注册一个账号。\n\n② 在 系统设置 -> api key 管理 上，创建一个 api key 密钥。\n\n\n\n③ 在 智能广场 -> 模型广场 上，选择“doubao-1.5-lite-32k”模型，进行开通。\n\n\n\n----------------------------------------\n\n申请完成后，可以在我们系统的 [ai 大模型 -> 控制台 -> api 密钥] 菜单，进行密钥的配置。需要填写“密钥” + “自定义 api url”（因为让 spring ai 使用该地址）。如下图所示：\n\n\n\n\n# 1.2 补充说明\n\n① 【对话】如果后续你要体验 《ai 对话》 ，需要在 [ai 大模型 -> 控制台 -> 聊天模型] 菜单，配置对应的聊天模型。注意，每个模型标识的 max_tokens（回复数 token 数）一般是 4096。\n\n具体有哪些模型，可以点击 模型广场 进行查看。例如说：doubao-1-5-lite-32k-250115、doubao-1-5-pro-32k-250115 等等。\n\n\n# 2. 如何使用？\n\n① 如果你的项目里需要直接通过 @resource 注入 doubaochatmodel 等对象，需要把 application.yaml 配置文件里的 yudao.ai.doubao 配置项，替换成你的！\n\nyudao:\n  ai:\n    doubao: # 字节豆包\n      enable: true\n      api-key: 5c1b5747-26d2-4ebd-a4e0-dd0e8d8b4272\n      model: doubao-1-5-lite-32k-250115\n\n\n② 如果你希望使用 [ai 大模型 -> 控制台 -> api 密钥] 菜单的密钥配置，则可以通过 aiapikeyservice 的 #getchatmodel(...) 方法，获取对应的模型对象。\n\n----------------------------------------\n\n① 和 ② 这两者的后续使用，就是标准的 spring ai 客户端的使用，调用对应的方法即可。\n\n另外，doubaochatmodeltests 里有对应的测试用例，可以参考。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【模型接入】硅基流动",
            frontmatter: {
                title: "【模型接入】硅基流动",
                date: "2025-02-24T09:24:35.000Z",
                permalink: "/ai/siliconflow"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/17.AI%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%89%8B%E5%86%8C/85.%E3%80%90%E6%A8%A1%E5%9E%8B%E6%8E%A5%E5%85%A5%E3%80%91%E7%A1%85%E5%9F%BA%E6%B5%81%E5%8A%A8.html",
            relativePath: "01.开发指南/17.AI大模型手册/85.【模型接入】硅基流动.md",
            key: "v-50756546",
            path: "/ai/siliconflow/",
            headers: [{
                level: 2,
                title: "1. 申请密钥",
                slug: "_1-申请密钥",
                normalizedTitle: "1. 申请密钥",
                charIndex: 145
            }, {
                level: 3,
                title: "1.1 申请密钥",
                slug: "_1-1-申请密钥",
                normalizedTitle: "1.1 申请密钥",
                charIndex: 217
            }, {
                level: 3,
                title: "1.2 补充说明",
                slug: "_1-2-补充说明",
                normalizedTitle: "1.2 补充说明",
                charIndex: 441
            }, {
                level: 2,
                title: "2. 如何使用？",
                slug: "_2-如何使用",
                normalizedTitle: "2. 如何使用？",
                charIndex: 660
            }],
            headersStr: "1. 申请密钥 1.1 申请密钥 1.2 补充说明 2. 如何使用？",
            content: "项目基于 Spring AI + 自己实现的 models/siliconflow，实现 硅基流动 的接入：\n\n功能      模型     SPRING AI 客户端\nAI 对话   对话模型   SiliconFlowChatModel\nAI 绘画   生图模型   暂未接入\n\n\n# 1. 申请密钥\n\n目前硅基流动主要是部署开源模型，所以需要去官网申请 API Key，然后通过 Spring AI 提供的客户端接入。\n\n\n# 1.1 申请密钥\n\n① 在 硅基流动 上，注册一个账号。\n\n② 在 管理 -> API Key 管理 上，创建一个 API Key 密钥。\n\n----------------------------------------\n\n申请完成后，可以在我们系统的 [AI 大模型 -> 控制台 -> API 密钥] 菜单，进行密钥的配置。需要填写“密钥” + “自定义 API URL”（因为让 Spring AI 使用该地址）。如下图所示：\n\n\n\n\n# 1.2 补充说明\n\n① 【对话】如果后续你要体验 《AI 对话》 ，需要在 [AI 大模型 -> 控制台 -> 聊天模型] 菜单，配置对应的聊天模型。注意，每个模型标识的 max_tokens（回复数 Token 数）一般是 4096。\n\n具体有哪些模型，可以点击 对话模型 进行查看。例如说：deepseek-ai/DeepSeek-R1-Distill-Qwen-7B、deepseek-ai/DeepSeek-R1 等等。\n\n\n# 2. 如何使用？\n\n① 如果你的项目里需要直接通过 @Resource 注入 SiliconFlowChatModel 等对象，需要把 application.yaml 配置文件里的 yudao.ai.siliconflow 配置项，替换成你的！\n\nyudao:\n  ai:\n    siliconflow: # 硅基流动\n      enable: true\n      api-key: sk-epsakfenqnyzoxhmbucsxlhkdqlcbnimslqoivkshalvdozz\n      model: deepseek-ai/DeepSeek-R1-Distill-Qwen-7B\n\n\n② 如果你希望使用 [AI 大模型 -> 控制台 -> API 密钥] 菜单的密钥配置，则可以通过 AiApiKeyService 的 #getChatModel(...) 方法，获取对应的模型对象。\n\n----------------------------------------\n\n① 和 ② 这两者的后续使用，就是标准的 Spring AI 客户端的使用，调用对应的方法即可。\n\n另外，SiliconFlowChatModelTests 里有对应的测试用例，可以参考。",
            normalizedContent: "项目基于 spring ai + 自己实现的 models/siliconflow，实现 硅基流动 的接入：\n\n功能      模型     spring ai 客户端\nai 对话   对话模型   siliconflowchatmodel\nai 绘画   生图模型   暂未接入\n\n\n# 1. 申请密钥\n\n目前硅基流动主要是部署开源模型，所以需要去官网申请 api key，然后通过 spring ai 提供的客户端接入。\n\n\n# 1.1 申请密钥\n\n① 在 硅基流动 上，注册一个账号。\n\n② 在 管理 -> api key 管理 上，创建一个 api key 密钥。\n\n----------------------------------------\n\n申请完成后，可以在我们系统的 [ai 大模型 -> 控制台 -> api 密钥] 菜单，进行密钥的配置。需要填写“密钥” + “自定义 api url”（因为让 spring ai 使用该地址）。如下图所示：\n\n\n\n\n# 1.2 补充说明\n\n① 【对话】如果后续你要体验 《ai 对话》 ，需要在 [ai 大模型 -> 控制台 -> 聊天模型] 菜单，配置对应的聊天模型。注意，每个模型标识的 max_tokens（回复数 token 数）一般是 4096。\n\n具体有哪些模型，可以点击 对话模型 进行查看。例如说：deepseek-ai/deepseek-r1-distill-qwen-7b、deepseek-ai/deepseek-r1 等等。\n\n\n# 2. 如何使用？\n\n① 如果你的项目里需要直接通过 @resource 注入 siliconflowchatmodel 等对象，需要把 application.yaml 配置文件里的 yudao.ai.siliconflow 配置项，替换成你的！\n\nyudao:\n  ai:\n    siliconflow: # 硅基流动\n      enable: true\n      api-key: sk-epsakfenqnyzoxhmbucsxlhkdqlcbnimslqoivkshalvdozz\n      model: deepseek-ai/deepseek-r1-distill-qwen-7b\n\n\n② 如果你希望使用 [ai 大模型 -> 控制台 -> api 密钥] 菜单的密钥配置，则可以通过 aiapikeyservice 的 #getchatmodel(...) 方法，获取对应的模型对象。\n\n----------------------------------------\n\n① 和 ② 这两者的后续使用，就是标准的 spring ai 客户端的使用，调用对应的方法即可。\n\n另外，siliconflowchatmodeltests 里有对应的测试用例，可以参考。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【模型接入】腾讯混元",
            frontmatter: {
                title: "【模型接入】腾讯混元",
                date: "2025-02-24T09:24:35.000Z",
                permalink: "/ai/hunyuan"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/17.AI%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%89%8B%E5%86%8C/84.%E3%80%90%E6%A8%A1%E5%9E%8B%E6%8E%A5%E5%85%A5%E3%80%91%E8%85%BE%E8%AE%AF%E6%B7%B7%E5%85%83.html",
            relativePath: "01.开发指南/17.AI大模型手册/84.【模型接入】腾讯混元.md",
            key: "v-a46abea8",
            path: "/ai/hunyuan/",
            headers: [{
                level: 2,
                title: "1. 申请密钥",
                slug: "_1-申请密钥",
                normalizedTitle: "1. 申请密钥",
                charIndex: 221
            }, {
                level: 3,
                title: "1.1 申请腾讯密钥",
                slug: "_1-1-申请腾讯密钥",
                normalizedTitle: "1.1 申请腾讯密钥",
                charIndex: 299
            }, {
                level: 3,
                title: "1.2 补充说明",
                slug: "_1-2-补充说明",
                normalizedTitle: "1.2 补充说明",
                charIndex: 524
            }, {
                level: 2,
                title: "2. 如何使用？",
                slug: "_2-如何使用",
                normalizedTitle: "2. 如何使用？",
                charIndex: 707
            }],
            headersStr: "1. 申请密钥 1.1 申请腾讯密钥 1.2 补充说明 2. 如何使用？",
            content: "项目基于 Spring AI + 自己实现的 models/hunyuan，实现 hunyuan 混元大模型 的接入：\n\n功能      模型                              SPRING AI 客户端\nAI 对话   hunyuan-turbo、hunyuan-large 等   HunYuanChatModel\nAI 绘画   混元生图 等                          暂未接入\n\n\n# 1. 申请密钥\n\n由于腾讯混元是非开源的模型，所以无法私有化部署，需要去官网申请 API Key，然后通过 Spring AI 提供的客户端接入。\n\n\n# 1.1 申请腾讯密钥\n\n① 在 腾讯云 上，注册一个账号。\n\n② 在 管理 -> API Key 管理 上，创建一个 API Key 密钥。\n\n----------------------------------------\n\n申请完成后，可以在我们系统的 [AI 大模型 -> 控制台 -> API 密钥] 菜单，进行密钥的配置。需要填写“密钥” + “自定义 API URL”（因为让 Spring AI 使用该地址）。如下图所示：\n\n\n\n\n# 1.2 补充说明\n\n① 【对话】如果后续你要体验 《AI 对话》 ，需要在 [AI 大模型 -> 控制台 -> 聊天模型] 菜单，配置对应的聊天模型。注意，每个模型标识的 max_tokens（回复数 Token 数）一般是 4096。\n\n具体有哪些模型，可以点击 混元生文 进行查看。例如说：hunyuan-turbo、hunyuan-large 等等。\n\n\n# 2. 如何使用？\n\n① 如果你的项目里需要直接通过 @Resource 注入 HunYuanChatModel 等对象，需要把 application.yaml 配置文件里的 yudao.ai.hunyuan 配置项，替换成你的！\n\nyudao:\n  ai:\n    hunyuan: # 腾讯混元\n      enable: true\n      api-key: 5c1b5747-26d2-4ebd-a4e0-dd0e8d8b4272\n      model: hunyuan-1-5-lite-32k-250115\n\n\n② 如果你希望使用 [AI 大模型 -> 控制台 -> API 密钥] 菜单的密钥配置，则可以通过 AiApiKeyService 的 #getChatModel(...) 方法，获取对应的模型对象。\n\n----------------------------------------\n\n① 和 ② 这两者的后续使用，就是标准的 Spring AI 客户端的使用，调用对应的方法即可。\n\n另外，HunYuanChatModelTests 里有对应的测试用例，可以参考。",
            normalizedContent: "项目基于 spring ai + 自己实现的 models/hunyuan，实现 hunyuan 混元大模型 的接入：\n\n功能      模型                              spring ai 客户端\nai 对话   hunyuan-turbo、hunyuan-large 等   hunyuanchatmodel\nai 绘画   混元生图 等                          暂未接入\n\n\n# 1. 申请密钥\n\n由于腾讯混元是非开源的模型，所以无法私有化部署，需要去官网申请 api key，然后通过 spring ai 提供的客户端接入。\n\n\n# 1.1 申请腾讯密钥\n\n① 在 腾讯云 上，注册一个账号。\n\n② 在 管理 -> api key 管理 上，创建一个 api key 密钥。\n\n----------------------------------------\n\n申请完成后，可以在我们系统的 [ai 大模型 -> 控制台 -> api 密钥] 菜单，进行密钥的配置。需要填写“密钥” + “自定义 api url”（因为让 spring ai 使用该地址）。如下图所示：\n\n\n\n\n# 1.2 补充说明\n\n① 【对话】如果后续你要体验 《ai 对话》 ，需要在 [ai 大模型 -> 控制台 -> 聊天模型] 菜单，配置对应的聊天模型。注意，每个模型标识的 max_tokens（回复数 token 数）一般是 4096。\n\n具体有哪些模型，可以点击 混元生文 进行查看。例如说：hunyuan-turbo、hunyuan-large 等等。\n\n\n# 2. 如何使用？\n\n① 如果你的项目里需要直接通过 @resource 注入 hunyuanchatmodel 等对象，需要把 application.yaml 配置文件里的 yudao.ai.hunyuan 配置项，替换成你的！\n\nyudao:\n  ai:\n    hunyuan: # 腾讯混元\n      enable: true\n      api-key: 5c1b5747-26d2-4ebd-a4e0-dd0e8d8b4272\n      model: hunyuan-1-5-lite-32k-250115\n\n\n② 如果你希望使用 [ai 大模型 -> 控制台 -> api 密钥] 菜单的密钥配置，则可以通过 aiapikeyservice 的 #getchatmodel(...) 方法，获取对应的模型对象。\n\n----------------------------------------\n\n① 和 ② 这两者的后续使用，就是标准的 spring ai 客户端的使用，调用对应的方法即可。\n\n另外，hunyuanchatmodeltests 里有对应的测试用例，可以参考。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【模型接入】DeepSeek",
            frontmatter: {
                title: "【模型接入】DeepSeek",
                date: "2024-07-06T17:15:22.000Z",
                permalink: "/ai/deep-seek"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/17.AI%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%89%8B%E5%86%8C/82.%E3%80%90%E6%A8%A1%E5%9E%8B%E6%8E%A5%E5%85%A5%E3%80%91DeepSeek.html",
            relativePath: "01.开发指南/17.AI大模型手册/82.【模型接入】DeepSeek.md",
            key: "v-d71b1316",
            path: "/ai/deep-seek/",
            headers: [{
                level: 2,
                title: "1. 申请密钥",
                slug: "_1-申请密钥",
                normalizedTitle: "1. 申请密钥",
                charIndex: 224
            }, {
                level: 3,
                title: "1.1 方式一：官方 API 申请",
                slug: "_1-1-方式一-官方-api-申请",
                normalizedTitle: "1.1 方式一：官方 api 申请",
                charIndex: 425
            }, {
                level: 3,
                title: "1.2 方式二：私有化部署",
                slug: "_1-2-方式二-私有化部署",
                normalizedTitle: "1.2 方式二：私有化部署",
                charIndex: 692
            }, {
                level: 3,
                title: "1.3 方式三：云厂商部署",
                slug: "_1-3-方式三-云厂商部署",
                normalizedTitle: "1.3 方式三：云厂商部署",
                charIndex: 1136
            }, {
                level: 3,
                title: "1.3 补充说明",
                slug: "_1-3-补充说明",
                normalizedTitle: "1.3 补充说明",
                charIndex: 1200
            }, {
                level: 2,
                title: "2. 如何使用？",
                slug: "_2-如何使用",
                normalizedTitle: "2. 如何使用？",
                charIndex: 1385
            }, {
                level: 2,
                title: "3. 云厂商部署",
                slug: "_3-云厂商部署",
                normalizedTitle: "3. 云厂商部署",
                charIndex: 1154
            }, {
                level: 3,
                title: "3.1 阿里云 API",
                slug: "_3-1-阿里云-api",
                normalizedTitle: "3.1 阿里云 api",
                charIndex: 2400
            }, {
                level: 3,
                title: "3.2 腾讯云 API",
                slug: "_3-2-腾讯云-api",
                normalizedTitle: "3.2 腾讯云 api",
                charIndex: 2512
            }, {
                level: 3,
                title: "3.3 字节火山云 API",
                slug: "_3-3-字节火山云-api",
                normalizedTitle: "3.3 字节火山云 api",
                charIndex: 2719
            }, {
                level: 3,
                title: "3.4 百度 API",
                slug: "_3-4-百度-api",
                normalizedTitle: "3.4 百度 api",
                charIndex: 2797
            }, {
                level: 3,
                title: "3.5 硅基流动 API",
                slug: "_3-5-硅基流动-api",
                normalizedTitle: "3.5 硅基流动 api",
                charIndex: 2818
            }],
            headersStr: "1. 申请密钥 1.1 方式一：官方 API 申请 1.2 方式二：私有化部署 1.3 方式三：云厂商部署 1.3 补充说明 2. 如何使用？ 3. 云厂商部署 3.1 阿里云 API 3.2 腾讯云 API 3.3 字节火山云 API 3.4 百度 API 3.5 硅基流动 API",
            content: "项目基于 Spring AI + 自己实现的 models/deepseek，实现 DeepSeek 的接入：\n\n功能      模型                                SPRING AI 客户端\nAI 对话   deepseek-chat、deepseek-reasoner   DeepSeekChatModel\nAI 绘画   暂不支持                              暂不支持\n\n\n# 1. 申请密钥\n\nDeepSeek 目前有 3 种 方式，可以进行使用：\n\n① 方式一：官方 API：DeepSeek 提供官方 API 服务，并且价格非常便宜，一般建议直接采用这种方式使用。\n\n② 方式二：私有化部署：DeepSeek 是开源模型，所以可以本地私有化部署使用。\n\n③ 方式三：云厂商部署：类似阿里云、字节、腾讯等厂商，私有化部署了 DeepSeek，然后提供 API 服务。\n\n\n# 1.1 方式一：官方 API 申请\n\n① 在 DeepSeek 开放平台 上，注册一个账号。目前，默认注册就送 500w tokens，还是蛮爽的。\n\n② 在 API keys 菜单，创建一个 API key 即可。\n\n----------------------------------------\n\n申请完成后，可以在我们系统的 [AI 大模型 -> 控制台 -> API 密钥] 菜单，进行密钥的配置。只需要填写“密钥”，不需要填写“自定义 API URL”（因为 Spring AI 默认官方地址）。如下图所示：\n\n\n\n\n# 1.2 方式二：私有化部署\n\n① 访问 https://ollama.ai/download，下载对应系统 Ollama 客户端，然后安装。\n\n② 安装完成后，在命令中执行 ollama run deepseek-r1 命令，一键部署 deepseek-r1 开源模型，默认跑的是 deepseek-r1:7b 模型。\n\n----------------------------------------\n\n部署完成后，可以在我们系统的 [AI 大模型 -> 控制台 -> API 密钥] 菜单，进行密钥的配置。需要填写“密钥” + “自定义 API URL”（因为让 Spring AI 使用该地址）。如下图所示：\n\n\n\n如果想部署 deepseek 的其它模型，可以搜索 deepseek 文档，执行不同的 ollama run 命令即可。\n\n注意：使用该方式时，后续配置模型名时，需要使用 deepseek-r1 而不是 deepseek-reasoner！！！例如说：\n\n\n\n\n# 1.3 方式三：云厂商部署\n\n参见「3. 云厂商部署」小节。\n\n一般建议先通过方式一或方式二跑通，再考虑使用方式三哈。\n\n\n# 1.3 补充说明\n\n如果后续你要体验 《AI 对话》 ，需要在 [AI 大模型 -> 控制台 -> 聊天模型] 菜单，配置对应的聊天模型。注意，每个模型标识的 max_tokens（回复数 Token 数）可能没有限制，可以先填写 4096。\n\n具体有哪些模型，可以去官方文档查看。例如说：deepseek-chat、deepseek-reasoner 等等。\n\n\n# 2. 如何使用？\n\n① 如果你的项目里需要直接通过 @Resource 注入 DeepSeekChatModel 等对象，需要把 application.yaml 配置文件里的 yudao.ai.deep-seek 配置项，替换成你的！\n\nyudao:\n  ai:\n    deep-seek:\n      enable: true\n      api-key: sk-e94db327cc7d457d99a8de8810fc6b12 # 你的 API Key\n      model: deepseek-chat\n\n\n② 如果你希望使用 [AI 大模型 -> 控制台 -> API 密钥] 菜单的密钥配置，则可以通过 AiApiKeyService 的 #getChatModel(...) 方法，获取对应的模型对象。\n\n----------------------------------------\n\n① 和 ② 这两者的后续使用，就是标准的 Spring AI 客户端的使用，调用对应的方法即可。\n\n另外，DeepSeekChatModelTests 里有对应的测试用例，可以参考。\n\n\n# 3. 云厂商部署\n\n注意，目前如下云厂商，不能返回 think 过程，实际是有 think 的：\n\n        V3         R1         THINKING 是否返回\n阿里云     TODO 没跑通   TODO 没跑通   TODO 没跑通\n腾讯云     √          √          TODO 待 spring ai 修复\n字节火山云   √          √          TODO 待 spring ai 修复\n百度      TODO 没跑通   TODO 没跑通   TODO 没跑通\n硅基流动    √          √          TODO 待 spring ai 修复\n\nTODO 目前 Spring AI 阿里云的 SDK 有问题，需要等待修复。\n\nTODO 目前 Spring AI 百度的 SDK 有问题，需要等待修复。\n\nTODO 目前 Spring AI 返回的 reasoning_content 没有很好的处理，需要在等等 https://github.com/spring-projects/spring-ai/pull/2192\n\n\n# 3.1 阿里云 API\n\n① 参考 《【模型接入】通义千问》 文档，申请阿里云密钥，并配置 API 密钥。\n\n② 配置聊天模型，如下图所示：\n\n\n\n具体有哪些模型名，可见 《阿里云 DeepSeek-R1》 文档。\n\n\n# 3.2 腾讯云 API\n\n① 参考 《腾讯云知识引擎原子能力 —— API KEY 管理》 文档，申请腾讯 API Key，无需配置 API 密钥。\n\n② 配置 API 密钥，如下图所示：\n\n\n\n其中，API URL 是 https://api.lkeap.cloud.tencent.com 。\n\n③ 配置聊天模型，如下图所示：\n\n\n\n具体有哪些模型名，可见 《腾讯云 DeepSeek-R1》 文档。\n\n\n# 3.3 字节火山云 API\n\n① 参考 《【模型接入】字节豆包》 文档，申请字节密钥，并配置 API 密钥。\n\n② 配置聊天模型，如下图所示：\n\n\n\n\n# 3.4 百度 API\n\nTODO\n\n\n# 3.5 硅基流动 API\n\n① 参考 《【模型接入】硅基流动》 文档，申请硅基密钥，并配置 API 密钥。\n\n② 配置聊天模型，如下图所示：\n\n\n\n具体有哪些模型名，可在 https://cloud.siliconflow.cn/models?types=chat 搜 “deepseek” 关键字。",
            normalizedContent: "项目基于 spring ai + 自己实现的 models/deepseek，实现 deepseek 的接入：\n\n功能      模型                                spring ai 客户端\nai 对话   deepseek-chat、deepseek-reasoner   deepseekchatmodel\nai 绘画   暂不支持                              暂不支持\n\n\n# 1. 申请密钥\n\ndeepseek 目前有 3 种 方式，可以进行使用：\n\n① 方式一：官方 api：deepseek 提供官方 api 服务，并且价格非常便宜，一般建议直接采用这种方式使用。\n\n② 方式二：私有化部署：deepseek 是开源模型，所以可以本地私有化部署使用。\n\n③ 方式三：云厂商部署：类似阿里云、字节、腾讯等厂商，私有化部署了 deepseek，然后提供 api 服务。\n\n\n# 1.1 方式一：官方 api 申请\n\n① 在 deepseek 开放平台 上，注册一个账号。目前，默认注册就送 500w tokens，还是蛮爽的。\n\n② 在 api keys 菜单，创建一个 api key 即可。\n\n----------------------------------------\n\n申请完成后，可以在我们系统的 [ai 大模型 -> 控制台 -> api 密钥] 菜单，进行密钥的配置。只需要填写“密钥”，不需要填写“自定义 api url”（因为 spring ai 默认官方地址）。如下图所示：\n\n\n\n\n# 1.2 方式二：私有化部署\n\n① 访问 https://ollama.ai/download，下载对应系统 ollama 客户端，然后安装。\n\n② 安装完成后，在命令中执行 ollama run deepseek-r1 命令，一键部署 deepseek-r1 开源模型，默认跑的是 deepseek-r1:7b 模型。\n\n----------------------------------------\n\n部署完成后，可以在我们系统的 [ai 大模型 -> 控制台 -> api 密钥] 菜单，进行密钥的配置。需要填写“密钥” + “自定义 api url”（因为让 spring ai 使用该地址）。如下图所示：\n\n\n\n如果想部署 deepseek 的其它模型，可以搜索 deepseek 文档，执行不同的 ollama run 命令即可。\n\n注意：使用该方式时，后续配置模型名时，需要使用 deepseek-r1 而不是 deepseek-reasoner！！！例如说：\n\n\n\n\n# 1.3 方式三：云厂商部署\n\n参见「3. 云厂商部署」小节。\n\n一般建议先通过方式一或方式二跑通，再考虑使用方式三哈。\n\n\n# 1.3 补充说明\n\n如果后续你要体验 《ai 对话》 ，需要在 [ai 大模型 -> 控制台 -> 聊天模型] 菜单，配置对应的聊天模型。注意，每个模型标识的 max_tokens（回复数 token 数）可能没有限制，可以先填写 4096。\n\n具体有哪些模型，可以去官方文档查看。例如说：deepseek-chat、deepseek-reasoner 等等。\n\n\n# 2. 如何使用？\n\n① 如果你的项目里需要直接通过 @resource 注入 deepseekchatmodel 等对象，需要把 application.yaml 配置文件里的 yudao.ai.deep-seek 配置项，替换成你的！\n\nyudao:\n  ai:\n    deep-seek:\n      enable: true\n      api-key: sk-e94db327cc7d457d99a8de8810fc6b12 # 你的 api key\n      model: deepseek-chat\n\n\n② 如果你希望使用 [ai 大模型 -> 控制台 -> api 密钥] 菜单的密钥配置，则可以通过 aiapikeyservice 的 #getchatmodel(...) 方法，获取对应的模型对象。\n\n----------------------------------------\n\n① 和 ② 这两者的后续使用，就是标准的 spring ai 客户端的使用，调用对应的方法即可。\n\n另外，deepseekchatmodeltests 里有对应的测试用例，可以参考。\n\n\n# 3. 云厂商部署\n\n注意，目前如下云厂商，不能返回 think 过程，实际是有 think 的：\n\n        v3         r1         thinking 是否返回\n阿里云     todo 没跑通   todo 没跑通   todo 没跑通\n腾讯云     √          √          todo 待 spring ai 修复\n字节火山云   √          √          todo 待 spring ai 修复\n百度      todo 没跑通   todo 没跑通   todo 没跑通\n硅基流动    √          √          todo 待 spring ai 修复\n\ntodo 目前 spring ai 阿里云的 sdk 有问题，需要等待修复。\n\ntodo 目前 spring ai 百度的 sdk 有问题，需要等待修复。\n\ntodo 目前 spring ai 返回的 reasoning_content 没有很好的处理，需要在等等 https://github.com/spring-projects/spring-ai/pull/2192\n\n\n# 3.1 阿里云 api\n\n① 参考 《【模型接入】通义千问》 文档，申请阿里云密钥，并配置 api 密钥。\n\n② 配置聊天模型，如下图所示：\n\n\n\n具体有哪些模型名，可见 《阿里云 deepseek-r1》 文档。\n\n\n# 3.2 腾讯云 api\n\n① 参考 《腾讯云知识引擎原子能力 —— api key 管理》 文档，申请腾讯 api key，无需配置 api 密钥。\n\n② 配置 api 密钥，如下图所示：\n\n\n\n其中，api url 是 https://api.lkeap.cloud.tencent.com 。\n\n③ 配置聊天模型，如下图所示：\n\n\n\n具体有哪些模型名，可见 《腾讯云 deepseek-r1》 文档。\n\n\n# 3.3 字节火山云 api\n\n① 参考 《【模型接入】字节豆包》 文档，申请字节密钥，并配置 api 密钥。\n\n② 配置聊天模型，如下图所示：\n\n\n\n\n# 3.4 百度 api\n\ntodo\n\n\n# 3.5 硅基流动 api\n\n① 参考 《【模型接入】硅基流动》 文档，申请硅基密钥，并配置 api 密钥。\n\n② 配置聊天模型，如下图所示：\n\n\n\n具体有哪些模型名，可在 https://cloud.siliconflow.cn/models?types=chat 搜 “deepseek” 关键字。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【模型接入】文心一言",
            frontmatter: {
                title: "【模型接入】文心一言",
                date: "2024-06-02T09:24:35.000Z",
                permalink: "/ai/yiyan"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/17.AI%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%89%8B%E5%86%8C/89.%E3%80%90%E6%A8%A1%E5%9E%8B%E6%8E%A5%E5%85%A5%E3%80%91%E6%96%87%E5%BF%83%E4%B8%80%E8%A8%80.html",
            relativePath: "01.开发指南/17.AI大模型手册/89.【模型接入】文心一言.md",
            key: "v-a07ad6d0",
            path: "/ai/yiyan/",
            headers: [{
                level: 2,
                title: "1. 申请密钥",
                slug: "_1-申请密钥",
                normalizedTitle: "1. 申请密钥",
                charIndex: 308
            }, {
                level: 3,
                title: "1.1 申请百度云密钥",
                slug: "_1-1-申请百度云密钥",
                normalizedTitle: "1.1 申请百度云密钥",
                charIndex: 386
            }, {
                level: 3,
                title: "1.2 补充说明",
                slug: "_1-2-补充说明",
                normalizedTitle: "1.2 补充说明",
                charIndex: 648
            }, {
                level: 2,
                title: "2. 如何使用？",
                slug: "_2-如何使用",
                normalizedTitle: "2. 如何使用？",
                charIndex: 936
            }],
            headersStr: "1. 申请密钥 1.1 申请百度云密钥 1.2 补充说明 2. 如何使用？",
            content: "友情提示：\n\n百度千帆 API 提供了 V2 版本，目前 Spring AI 不兼容，可关键 https://github.com/spring-projects/spring-ai/issues/2179 进展\n\n项目基于 Spring AI 提供的 spring-ai-qianfan，实现 文心一言 的接入：\n\n功能      模型                      SPRING AI 客户端\nAI 对话   ERNIE-4.0、ERNIE-3.5 等   QianFanChatModel\nAI 绘画   ernie_Vilg              QianFanImageModel\n\n\n# 1. 申请密钥\n\n由于文心一言是非开源的模型，所以无法私有化部署，需要去官网申请 API Key，然后通过 Spring AI 提供的客户端接入。\n\n\n# 1.1 申请百度云密钥\n\n① 在 百度智能云 上，注册一个账号。\n\n② 在百度智能云上，创建一个 应用，获得到 API Key、Secret Key。\n\n\n\n----------------------------------------\n\n申请完成后，可以在我们系统的 [AI 大模型 -> 控制台 -> API 密钥] 菜单，进行密钥的配置。只需要填写“密钥”（${API Key}|${Secret Key}），不需要填写“自定义 API URL”（因为 Spring AI 默认官方地址）。如下图所示：\n\n\n\n\n# 1.2 补充说明\n\n① 【对话】如果后续你要体验 《AI 对话》 ，需要在 [AI 大模型 -> 控制台 -> 聊天模型] 菜单，配置对应的聊天模型。注意，每个模型标识的 max_tokens（回复数 Token 数）一般是 2048。\n\n具体有哪些模型，可以点击 千帆大模型平台 进行查看。例如说：ernie_speed、ernie-tiny-8k 等等。\n\n② 【绘图】你可以参考 《AI 绘画》 ，实现文字生成图片。\n\n注意，分辨率只允许选择 1024x1024、768x768、768x1024、1024x768、576x1024、1024x576 这几个。\n\n\n# 2. 如何使用？\n\n① 如果你的项目里需要直接通过 @Resource 注入 QianFanChatModel、QianFanImageModel 等对象，需要把 application.yaml 配置文件里的 spring.ai.qianfan 配置项，替换成你的！\n\nspring:\n  ai:\n    qianfan: # 文心一言\n      api-key: x0cuLZ7XsaTCU08vuJWO87Lg\n      secret-key: R9mYF9dl9KASgi5RUq0FQt3wRisSnOcK\n\n\n② 如果你希望使用 [AI 大模型 -> 控制台 -> API 密钥] 菜单的密钥配置，则可以通过 AiApiKeyService 的 #getChatModel(...) 或 #getImageModel(...) 方法，获取对应的模型对象。\n\n----------------------------------------\n\n① 和 ② 这两者的后续使用，就是标准的 Spring AI 客户端的使用，调用对应的方法即可。\n\n另外，YiYanChatModelTests 里有对应的测试用例，可以参考。",
            normalizedContent: "友情提示：\n\n百度千帆 api 提供了 v2 版本，目前 spring ai 不兼容，可关键 https://github.com/spring-projects/spring-ai/issues/2179 进展\n\n项目基于 spring ai 提供的 spring-ai-qianfan，实现 文心一言 的接入：\n\n功能      模型                      spring ai 客户端\nai 对话   ernie-4.0、ernie-3.5 等   qianfanchatmodel\nai 绘画   ernie_vilg              qianfanimagemodel\n\n\n# 1. 申请密钥\n\n由于文心一言是非开源的模型，所以无法私有化部署，需要去官网申请 api key，然后通过 spring ai 提供的客户端接入。\n\n\n# 1.1 申请百度云密钥\n\n① 在 百度智能云 上，注册一个账号。\n\n② 在百度智能云上，创建一个 应用，获得到 api key、secret key。\n\n\n\n----------------------------------------\n\n申请完成后，可以在我们系统的 [ai 大模型 -> 控制台 -> api 密钥] 菜单，进行密钥的配置。只需要填写“密钥”（${api key}|${secret key}），不需要填写“自定义 api url”（因为 spring ai 默认官方地址）。如下图所示：\n\n\n\n\n# 1.2 补充说明\n\n① 【对话】如果后续你要体验 《ai 对话》 ，需要在 [ai 大模型 -> 控制台 -> 聊天模型] 菜单，配置对应的聊天模型。注意，每个模型标识的 max_tokens（回复数 token 数）一般是 2048。\n\n具体有哪些模型，可以点击 千帆大模型平台 进行查看。例如说：ernie_speed、ernie-tiny-8k 等等。\n\n② 【绘图】你可以参考 《ai 绘画》 ，实现文字生成图片。\n\n注意，分辨率只允许选择 1024x1024、768x768、768x1024、1024x768、576x1024、1024x576 这几个。\n\n\n# 2. 如何使用？\n\n① 如果你的项目里需要直接通过 @resource 注入 qianfanchatmodel、qianfanimagemodel 等对象，需要把 application.yaml 配置文件里的 spring.ai.qianfan 配置项，替换成你的！\n\nspring:\n  ai:\n    qianfan: # 文心一言\n      api-key: x0culz7xsatcu08vujwo87lg\n      secret-key: r9myf9dl9kasgi5ruq0fqt3wrissnock\n\n\n② 如果你希望使用 [ai 大模型 -> 控制台 -> api 密钥] 菜单的密钥配置，则可以通过 aiapikeyservice 的 #getchatmodel(...) 或 #getimagemodel(...) 方法，获取对应的模型对象。\n\n----------------------------------------\n\n① 和 ② 这两者的后续使用，就是标准的 spring ai 客户端的使用，调用对应的方法即可。\n\n另外，yiyanchatmodeltests 里有对应的测试用例，可以参考。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【模型接入】微软 OpenAI",
            frontmatter: {
                title: "【模型接入】微软 OpenAI",
                date: "2024-08-10T14:38:15.000Z",
                permalink: "/ai/azure-openai"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/17.AI%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%89%8B%E5%86%8C/93.%E3%80%90%E6%A8%A1%E5%9E%8B%E6%8E%A5%E5%85%A5%E3%80%91%E5%BE%AE%E8%BD%AF%20OpenAI.html",
            relativePath: "01.开发指南/17.AI大模型手册/93.【模型接入】微软 OpenAI.md",
            key: "v-2487171a",
            path: "/ai/azure-openai/",
            headers: [{
                level: 2,
                title: "1. 申请密钥",
                slug: "_1-申请密钥",
                normalizedTitle: "1. 申请密钥",
                charIndex: 215
            }, {
                level: 3,
                title: "1.1 Azure API 申请",
                slug: "_1-1-azure-api-申请",
                normalizedTitle: "1.1 azure api 申请",
                charIndex: 227
            }, {
                level: 3,
                title: "1.2 补充说明",
                slug: "_1-2-补充说明",
                normalizedTitle: "1.2 补充说明",
                charIndex: 465
            }, {
                level: 2,
                title: "2. 如何使用？",
                slug: "_2-如何使用",
                normalizedTitle: "2. 如何使用？",
                charIndex: 650
            }],
            headersStr: "1. 申请密钥 1.1 Azure API 申请 1.2 补充说明 2. 如何使用？",
            content: "项目基于 Spring AI 提供的 spring-ai-azure-openai，实现微软 Azure 上部署的 OpenAI 的接入：\n\n功能      模型                SPRING AI 客户端\nAI 对话   gpt3.5、gpt4.0 等   Azure OpenAI Chat\nAI 绘画   DALL              Azure OpenAI Image Generation\n\n\n# 1. 申请密钥\n\n\n# 1.1 Azure API 申请\n\n可以在 微软 Azure AI 进行申请申请。\n\n我暂时没申请过，是由 社区小伙伴 提供密钥进行接入的，应该不复杂。\n\n申请完成后，应该会有类似的模型列表。如下图所示：\n\n\n\n----------------------------------------\n\n购买完成后，可以在我们系统的 [AI 大模型 -> 控制台 -> API 密钥] 菜单，进行密钥的配置。需要填写“密钥” + “自定义 API URL”。如下图所示：\n\n\n\n\n# 1.2 补充说明\n\n如果后续你要体验 《AI 对话》 ，需要在 [AI 大模型 -> 控制台 -> 聊天模型] 菜单，配置对应的聊天模型。注意，每个模型标识的 max_tokens（回复数 Token 数）是不同的。\n\n\n\n例如说：gpt-35-turbo 是 4096，gpt-4o 是 8192。\n\n不确定的话，就填写 4096 先~跑通之后，再网上查查。\n\n\n# 2. 如何使用？\n\n① 如果你的项目里需要直接通过 @Resource 注入 AzureOpenAIChatModel 等对象，需要把 application.yaml 配置文件里的 spring.ai.openai 配置项，替换成你的！\n\nspring:\n  ai:\n    azure: # OpenAI 微软\n      openai:\n        endpoint: https://eastusprejade.openai.azure.com\n        api-key: xxx\n\n\n② 如果你希望使用 [AI 大模型 -> 控制台 -> API 密钥] 菜单的密钥配置，则可以通过 AiApiKeyService 的 #getChatModel(...)，获取对应的模型对象。\n\n----------------------------------------\n\n① 和 ② 这两者的后续使用，就是标准的 Spring AI 客户端的使用，调用对应的方法即可。\n\n另外，AzureOpenAIChatModelTests 里有对应的测试用例，可以参考。",
            normalizedContent: "项目基于 spring ai 提供的 spring-ai-azure-openai，实现微软 azure 上部署的 openai 的接入：\n\n功能      模型                spring ai 客户端\nai 对话   gpt3.5、gpt4.0 等   azure openai chat\nai 绘画   dall              azure openai image generation\n\n\n# 1. 申请密钥\n\n\n# 1.1 azure api 申请\n\n可以在 微软 azure ai 进行申请申请。\n\n我暂时没申请过，是由 社区小伙伴 提供密钥进行接入的，应该不复杂。\n\n申请完成后，应该会有类似的模型列表。如下图所示：\n\n\n\n----------------------------------------\n\n购买完成后，可以在我们系统的 [ai 大模型 -> 控制台 -> api 密钥] 菜单，进行密钥的配置。需要填写“密钥” + “自定义 api url”。如下图所示：\n\n\n\n\n# 1.2 补充说明\n\n如果后续你要体验 《ai 对话》 ，需要在 [ai 大模型 -> 控制台 -> 聊天模型] 菜单，配置对应的聊天模型。注意，每个模型标识的 max_tokens（回复数 token 数）是不同的。\n\n\n\n例如说：gpt-35-turbo 是 4096，gpt-4o 是 8192。\n\n不确定的话，就填写 4096 先~跑通之后，再网上查查。\n\n\n# 2. 如何使用？\n\n① 如果你的项目里需要直接通过 @resource 注入 azureopenaichatmodel 等对象，需要把 application.yaml 配置文件里的 spring.ai.openai 配置项，替换成你的！\n\nspring:\n  ai:\n    azure: # openai 微软\n      openai:\n        endpoint: https://eastusprejade.openai.azure.com\n        api-key: xxx\n\n\n② 如果你希望使用 [ai 大模型 -> 控制台 -> api 密钥] 菜单的密钥配置，则可以通过 aiapikeyservice 的 #getchatmodel(...)，获取对应的模型对象。\n\n----------------------------------------\n\n① 和 ② 这两者的后续使用，就是标准的 spring ai 客户端的使用，调用对应的方法即可。\n\n另外，azureopenaichatmodeltests 里有对应的测试用例，可以参考。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【模型接入】智谱 GLM",
            frontmatter: {
                title: "【模型接入】智谱 GLM",
                date: "2024-07-06T17:15:22.000Z",
                permalink: "/ai/glm"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/17.AI%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%89%8B%E5%86%8C/91.%E3%80%90%E6%A8%A1%E5%9E%8B%E6%8E%A5%E5%85%A5%E3%80%91%E6%99%BA%E8%B0%B1%20GLM.html",
            relativePath: "01.开发指南/17.AI大模型手册/91.【模型接入】智谱 GLM.md",
            key: "v-cf80555e",
            path: "/ai/glm/",
            headers: [{
                level: 2,
                title: "1. 申请密钥",
                slug: "_1-申请密钥",
                normalizedTitle: "1. 申请密钥",
                charIndex: 196
            }, {
                level: 3,
                title: "1.1 申请智谱 AI 密钥",
                slug: "_1-1-申请智谱-ai-密钥",
                normalizedTitle: "1.1 申请智谱 ai 密钥",
                charIndex: 276
            }, {
                level: 3,
                title: "1.2 补充说明",
                slug: "_1-2-补充说明",
                normalizedTitle: "1.2 补充说明",
                charIndex: 540
            }, {
                level: 2,
                title: "2. 如何使用？",
                slug: "_2-如何使用",
                normalizedTitle: "2. 如何使用？",
                charIndex: 748
            }],
            headersStr: "1. 申请密钥 1.1 申请智谱 AI 密钥 1.2 补充说明 2. 如何使用？",
            content: "项目基于 Spring AI 提供的 spring-ai-zhipuai，实现 智谱 GLM 的接入：\n\n功能      模型                    SPRING AI 客户端\nAI 对话   GLM-4、GLM-3-Turbo 等   ZhiPuAiChatModel\nAI 绘画   CogView               ZhiPuAiImageModel\n\n\n# 1. 申请密钥\n\n智谱 AI 有开源模型，可以私有化部署。\n\n不过它最新、最强的模型 GLM-4 是没有开源的，所以只能通过官方的 API 服务接入。\n\n\n# 1.1 申请智谱 AI 密钥\n\n① 在 智谱 AI 开放平台 上，注册一个账号。目前，默认注册就送 2500w tokens，还是蛮爽的。\n\n② 在 API keys 菜单，复制系统默认 API key 即可。\n\n----------------------------------------\n\n申请完成后，可以在我们系统的 [AI 大模型 -> 控制台 -> API 密钥] 菜单，进行密钥的配置。只需要填写“密钥”，不需要填写“自定义 API URL”（因为 Spring AI 默认官方地址）。如下图所示：\n\n\n\n\n# 1.2 补充说明\n\n① 【对话】如果后续你要体验 《AI 对话》 ，需要在 [AI 大模型 -> 控制台 -> 聊天模型] 菜单，配置对应的聊天模型。注意，每个模型标识的 max_tokens（回复数 Token 数）默认 1024，最大是 4095。\n\n具体有哪些模型，可以去官方文档查看。例如说：GLM-4、GLM-3-Turbo 等等。\n\n② 【绘图】你可以参考 《AI 绘画》 ，实现文字生成图片。\n\n\n# 2. 如何使用？\n\n① 如果你的项目里需要直接通过 @Resource 注入 ZhiPuAiChatModel、ZhiPuAiImageModel 等对象，需要把 application.yaml 配置文件里的 yudao.ai.zhipuai 配置项，替换成你的！\n\nspring:\n  ai:\n    zhipuai: # 智谱 AI\n      api-key: 32f84543e54eee31f8d56b2bd6020573.3vh9idLJZ2ZhxDEs\n\n\n② 如果你希望使用 [AI 大模型 -> 控制台 -> API 密钥] 菜单的密钥配置，则可以通过 AiApiKeyService 的 #getChatModel(...) 或 #getImageModel(...) 方法，获取对应的模型对象。\n\n----------------------------------------\n\n① 和 ② 这两者的后续使用，就是标准的 Spring AI 客户端的使用，调用对应的方法即可。\n\n另外，ZhiPuAiChatModelTests 里有对应的测试用例，可以参考。",
            normalizedContent: "项目基于 spring ai 提供的 spring-ai-zhipuai，实现 智谱 glm 的接入：\n\n功能      模型                    spring ai 客户端\nai 对话   glm-4、glm-3-turbo 等   zhipuaichatmodel\nai 绘画   cogview               zhipuaiimagemodel\n\n\n# 1. 申请密钥\n\n智谱 ai 有开源模型，可以私有化部署。\n\n不过它最新、最强的模型 glm-4 是没有开源的，所以只能通过官方的 api 服务接入。\n\n\n# 1.1 申请智谱 ai 密钥\n\n① 在 智谱 ai 开放平台 上，注册一个账号。目前，默认注册就送 2500w tokens，还是蛮爽的。\n\n② 在 api keys 菜单，复制系统默认 api key 即可。\n\n----------------------------------------\n\n申请完成后，可以在我们系统的 [ai 大模型 -> 控制台 -> api 密钥] 菜单，进行密钥的配置。只需要填写“密钥”，不需要填写“自定义 api url”（因为 spring ai 默认官方地址）。如下图所示：\n\n\n\n\n# 1.2 补充说明\n\n① 【对话】如果后续你要体验 《ai 对话》 ，需要在 [ai 大模型 -> 控制台 -> 聊天模型] 菜单，配置对应的聊天模型。注意，每个模型标识的 max_tokens（回复数 token 数）默认 1024，最大是 4095。\n\n具体有哪些模型，可以去官方文档查看。例如说：glm-4、glm-3-turbo 等等。\n\n② 【绘图】你可以参考 《ai 绘画》 ，实现文字生成图片。\n\n\n# 2. 如何使用？\n\n① 如果你的项目里需要直接通过 @resource 注入 zhipuaichatmodel、zhipuaiimagemodel 等对象，需要把 application.yaml 配置文件里的 yudao.ai.zhipuai 配置项，替换成你的！\n\nspring:\n  ai:\n    zhipuai: # 智谱 ai\n      api-key: 32f84543e54eee31f8d56b2bd6020573.3vh9idljz2zhxdes\n\n\n② 如果你希望使用 [ai 大模型 -> 控制台 -> api 密钥] 菜单的密钥配置，则可以通过 aiapikeyservice 的 #getchatmodel(...) 或 #getimagemodel(...) 方法，获取对应的模型对象。\n\n----------------------------------------\n\n① 和 ② 这两者的后续使用，就是标准的 spring ai 客户端的使用，调用对应的方法即可。\n\n另外，zhipuaichatmodeltests 里有对应的测试用例，可以参考。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【模型接入】LLAMA",
            frontmatter: {
                title: "【模型接入】LLAMA",
                date: "2024-06-01T22:31:03.000Z",
                permalink: "/ai/llama"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/17.AI%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%89%8B%E5%86%8C/90.%E3%80%90%E6%A8%A1%E5%9E%8B%E6%8E%A5%E5%85%A5%E3%80%91LLAMA.html",
            relativePath: "01.开发指南/17.AI大模型手册/90.【模型接入】LLAMA.md",
            key: "v-eb35368e",
            path: "/ai/llama/",
            headers: [{
                level: 2,
                title: "1. 申请密钥（私有部署）",
                slug: "_1-申请密钥-私有部署",
                normalizedTitle: "1. 申请密钥（私有部署）",
                charIndex: 158
            }, {
                level: 3,
                title: "1.1 私有化部署",
                slug: "_1-1-私有化部署",
                normalizedTitle: "1.1 私有化部署",
                charIndex: 207
            }, {
                level: 3,
                title: "1.2 补充说明",
                slug: "_1-2-补充说明",
                normalizedTitle: "1.2 补充说明",
                charIndex: 464
            }, {
                level: 2,
                title: "2. 如何使用？",
                slug: "_2-如何使用",
                normalizedTitle: "2. 如何使用？",
                charIndex: 585
            }],
            headersStr: "1. 申请密钥（私有部署） 1.1 私有化部署 1.2 补充说明 2. 如何使用？",
            content: "项目基于 Spring AI 提供的 spring-ai-ollama，实现 Llama 的接入：\n\n功能      模型              SPRING AI 客户端\nAI 对话   llama3、llama2   Ollama Chat\nAI 绘画   llama3 支持生成图片   暂未支持\n\n\n# 1. 申请密钥（私有部署）\n\nLlama 是 Meta 开源的模型，所以可以私有化部署。\n\n\n# 1.1 私有化部署\n\n① 访问 Ollama 官网，下载对应系统 Ollama 客户端，然后安装。\n\n② 安装完成后，在命令中执行 ollama run llama3 命令，一键部署 llama3 模型。\n\n----------------------------------------\n\n部署完成后，可以在我们系统的 [AI 大模型 -> 控制台 -> API 密钥] 菜单，进行密钥的配置。需要填写“密钥” + “自定义 API URL”（因为让 Spring AI 使用该地址）。如下图所示：\n\n\n\n\n# 1.2 补充说明\n\n如果后续你要体验 《AI 对话》 ，需要在 [AI 大模型 -> 控制台 -> 聊天模型] 菜单，配置对应的聊天模型为 llama3，然后它的 max_tokens（回复数 Token 数）填写 4096 即可。\n\n\n# 2. 如何使用？\n\n① 如果你的项目里需要直接通过 @Resource 注入 OllamaChatModel 等对象，需要把 application.yaml 配置文件里的 spring.ai.ollama 配置项，替换成你的！\n\nspring:\n  ai:\n    ollama:\n      base-url: http://127.0.0.1:11434 # 你的私有化部署地址\n      chat:\n        model: llama3\n\n\n② 如果你希望使用 [AI 大模型 -> 控制台 -> API 密钥] 菜单的密钥配置，则可以通过 AiApiKeyService 的 #getChatModel(...) 方法，获取对应的模型对象。\n\n----------------------------------------\n\n① 和 ② 这两者的后续使用，就是标准的 Spring AI 客户端的使用，调用对应的方法即可。\n\n另外，LlamaChatModelTests 里有对应的测试用例，可以参考。",
            normalizedContent: "项目基于 spring ai 提供的 spring-ai-ollama，实现 llama 的接入：\n\n功能      模型              spring ai 客户端\nai 对话   llama3、llama2   ollama chat\nai 绘画   llama3 支持生成图片   暂未支持\n\n\n# 1. 申请密钥（私有部署）\n\nllama 是 meta 开源的模型，所以可以私有化部署。\n\n\n# 1.1 私有化部署\n\n① 访问 ollama 官网，下载对应系统 ollama 客户端，然后安装。\n\n② 安装完成后，在命令中执行 ollama run llama3 命令，一键部署 llama3 模型。\n\n----------------------------------------\n\n部署完成后，可以在我们系统的 [ai 大模型 -> 控制台 -> api 密钥] 菜单，进行密钥的配置。需要填写“密钥” + “自定义 api url”（因为让 spring ai 使用该地址）。如下图所示：\n\n\n\n\n# 1.2 补充说明\n\n如果后续你要体验 《ai 对话》 ，需要在 [ai 大模型 -> 控制台 -> 聊天模型] 菜单，配置对应的聊天模型为 llama3，然后它的 max_tokens（回复数 token 数）填写 4096 即可。\n\n\n# 2. 如何使用？\n\n① 如果你的项目里需要直接通过 @resource 注入 ollamachatmodel 等对象，需要把 application.yaml 配置文件里的 spring.ai.ollama 配置项，替换成你的！\n\nspring:\n  ai:\n    ollama:\n      base-url: http://127.0.0.1:11434 # 你的私有化部署地址\n      chat:\n        model: llama3\n\n\n② 如果你希望使用 [ai 大模型 -> 控制台 -> api 密钥] 菜单的密钥配置，则可以通过 aiapikeyservice 的 #getchatmodel(...) 方法，获取对应的模型对象。\n\n----------------------------------------\n\n① 和 ② 这两者的后续使用，就是标准的 spring ai 客户端的使用，调用对应的方法即可。\n\n另外，llamachatmodeltests 里有对应的测试用例，可以参考。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【模型接入】讯飞星火",
            frontmatter: {
                title: "【模型接入】讯飞星火",
                date: "2024-06-02T10:07:22.000Z",
                permalink: "/ai/xinghuo"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/17.AI%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%89%8B%E5%86%8C/92.%E3%80%90%E6%A8%A1%E5%9E%8B%E6%8E%A5%E5%85%A5%E3%80%91%E8%AE%AF%E9%A3%9E%E6%98%9F%E7%81%AB.html",
            relativePath: "01.开发指南/17.AI大模型手册/92.【模型接入】讯飞星火.md",
            key: "v-11c4deaa",
            path: "/ai/xinghuo/",
            headers: [{
                level: 2,
                title: "1. 申请密钥",
                slug: "_1-申请密钥",
                normalizedTitle: "1. 申请密钥",
                charIndex: 228
            }, {
                level: 3,
                title: "1.1 申请讯飞密钥",
                slug: "_1-1-申请讯飞密钥",
                normalizedTitle: "1.1 申请讯飞密钥",
                charIndex: 306
            }, {
                level: 3,
                title: "1.2 补充说明",
                slug: "_1-2-补充说明",
                normalizedTitle: "1.2 补充说明",
                charIndex: 615
            }, {
                level: 2,
                title: "2. 如何使用？",
                slug: "_2-如何使用",
                normalizedTitle: "2. 如何使用？",
                charIndex: 789
            }],
            headersStr: "1. 申请密钥 1.1 申请讯飞密钥 1.2 补充说明 2. 如何使用？",
            content: "项目基于 Spring AI + 自己实现的 models/xinghu，实现 讯飞星火大模型 的接入：\n\n功能      模型                        SPRING AI 客户端\nAI 对话   generalv3、generalv3.5 等   XingHuoChatModel\nAI 绘画   暂未接入                      暂未支持\n\n补充说明：\n\n讯飞星火支持 图片生成，未来我们也会进行集成。\n\n\n# 1. 申请密钥\n\n由于讯飞星火是非开源的模型，所以无法私有化部署，需要去官网申请 API Key，然后通过 Spring AI 提供的客户端接入。\n\n\n# 1.1 申请讯飞密钥\n\n① 在 讯飞星火 上，注册一个账号。\n\n② 在 讯飞星火 上，点击【免费试用】按钮，创建一个应用。\n\n③ 在 我的应用 里，点击该应用的名字，然后选择【Spark3.5 Max】菜单，获得到 APISecret、APIKey。\n\n\n\n----------------------------------------\n\n申请完成后，可以在我们系统的 [AI 大模型 -> 控制台 -> API 密钥] 菜单，进行密钥的配置。只需要填写“密钥”（${appKey}|{secretKey}），不需要填写“自定义 API URL”（因为 Spring AI 默认官方地址）。如下图所示：\n\n\n\n\n# 1.2 补充说明\n\n如果后续你要体验 《AI 对话》 ，需要在 [AI 大模型 -> 控制台 -> 聊天模型] 菜单，配置对应的聊天模型。注意，每个模型标识的 max_tokens（回复数 Token 数）默认是 4096，最大 8192。\n\n具体有哪些模型，可以去官方文档查看。例如说：generalv3.5、generalv3 等等。\n\n\n# 2. 如何使用？\n\n① 如果你的项目里需要直接通过 @Resource 注入 XingHuoChatModel 等对象，需要把 application.yaml 配置文件里的 yudao.ai.xinghuo 配置项，替换成你的！\n\nyudao:\n  ai:\n    xinghuo:\n      enable: true\n      appKey: cb6415c19d6162cda07b47316fcb0416\n      secretKey: Y2JiYTIxZjA3MDMxMjNjZjQzYzVmNzdh\n      model: generalv3.5\n\n\n② 如果你希望使用 [AI 大模型 -> 控制台 -> API 密钥] 菜单的密钥配置，则可以通过 AiApiKeyService 的 #getChatModel(...)，获取对应的模型对象。\n\n----------------------------------------\n\n① 和 ② 这两者的后续使用，就是标准的 Spring AI 客户端的使用，调用对应的方法即可。\n\n另外，XingHuoChatModelTests 里有对应的测试用例，可以参考。",
            normalizedContent: "项目基于 spring ai + 自己实现的 models/xinghu，实现 讯飞星火大模型 的接入：\n\n功能      模型                        spring ai 客户端\nai 对话   generalv3、generalv3.5 等   xinghuochatmodel\nai 绘画   暂未接入                      暂未支持\n\n补充说明：\n\n讯飞星火支持 图片生成，未来我们也会进行集成。\n\n\n# 1. 申请密钥\n\n由于讯飞星火是非开源的模型，所以无法私有化部署，需要去官网申请 api key，然后通过 spring ai 提供的客户端接入。\n\n\n# 1.1 申请讯飞密钥\n\n① 在 讯飞星火 上，注册一个账号。\n\n② 在 讯飞星火 上，点击【免费试用】按钮，创建一个应用。\n\n③ 在 我的应用 里，点击该应用的名字，然后选择【spark3.5 max】菜单，获得到 apisecret、apikey。\n\n\n\n----------------------------------------\n\n申请完成后，可以在我们系统的 [ai 大模型 -> 控制台 -> api 密钥] 菜单，进行密钥的配置。只需要填写“密钥”（${appkey}|{secretkey}），不需要填写“自定义 api url”（因为 spring ai 默认官方地址）。如下图所示：\n\n\n\n\n# 1.2 补充说明\n\n如果后续你要体验 《ai 对话》 ，需要在 [ai 大模型 -> 控制台 -> 聊天模型] 菜单，配置对应的聊天模型。注意，每个模型标识的 max_tokens（回复数 token 数）默认是 4096，最大 8192。\n\n具体有哪些模型，可以去官方文档查看。例如说：generalv3.5、generalv3 等等。\n\n\n# 2. 如何使用？\n\n① 如果你的项目里需要直接通过 @resource 注入 xinghuochatmodel 等对象，需要把 application.yaml 配置文件里的 yudao.ai.xinghuo 配置项，替换成你的！\n\nyudao:\n  ai:\n    xinghuo:\n      enable: true\n      appkey: cb6415c19d6162cda07b47316fcb0416\n      secretkey: y2jiytixzja3mdmxmjnjzjqzyzvmnzdh\n      model: generalv3.5\n\n\n② 如果你希望使用 [ai 大模型 -> 控制台 -> api 密钥] 菜单的密钥配置，则可以通过 aiapikeyservice 的 #getchatmodel(...)，获取对应的模型对象。\n\n----------------------------------------\n\n① 和 ② 这两者的后续使用，就是标准的 spring ai 客户端的使用，调用对应的方法即可。\n\n另外，xinghuochatmodeltests 里有对应的测试用例，可以参考。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【模型接入】谷歌 Gemini",
            frontmatter: {
                title: "【模型接入】谷歌 Gemini",
                date: "2024-06-02T10:04:22.000Z",
                permalink: "/ai/gemini"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/17.AI%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%89%8B%E5%86%8C/94.%E3%80%90%E6%A8%A1%E5%9E%8B%E6%8E%A5%E5%85%A5%E3%80%91%E8%B0%B7%E6%AD%8C%20Gemini.html",
            relativePath: "01.开发指南/17.AI大模型手册/94.【模型接入】谷歌 Gemini.md",
            key: "v-3203ab40",
            path: "/ai/gemini/",
            headers: [{
                level: 2,
                title: "1. Gemini 接入现状？",
                slug: "_1-gemini-接入现状",
                normalizedTitle: "1. gemini 接入现状？",
                charIndex: 2
            }, {
                level: 2,
                title: "2. Gemma 如何接入？",
                slug: "_2-gemma-如何接入",
                normalizedTitle: "2. gemma 如何接入？",
                charIndex: 236
            }],
            headersStr: "1. Gemini 接入现状？ 2. Gemma 如何接入？",
            content: "# 1. Gemini 接入现状？\n\n项目暂未完成对 Gemini 的接入，主要有两点原因：\n\n① 虽然 Spring AI 的 spring-ai-vertex-ai-gemini 对 Gemini 的集成，但是它的 API 认证方式 很奇怪（和主流大模型 API 差异很大），没跑通，所以暂时放弃。\n\n② Gemini 目前应该是不如 OpenAI（ChatGPT），所以优先级不高。\n\n所以，等后续 Gemini 变强，并且流行度更高之后，我们再进行接入！\n\n\n# 2. Gemma 如何接入？\n\nGemma 是 Gemini 的开源版本，可以进行私有化部署。\n\n整个的接入，类似 《【模型接入】LLAMA》。下面，我简单写下，有疑问可以星球提问哈！主要是，貌似也没听说哪个团队或者朋友在使用~\n\n① 访问 Ollama 官网，下载对应系统 Ollama 客户端，然后安装。\n\n② 安装完成后，在命令中执行 ollama run gemma 命令，一键部署 gemma 模型。\n\n③ 之后，需要使用 Spring AI 的 spring-ai-ollama 进行接入。\n\n不知道它怎么使用的话，可以看看 《Spring AI : Java Integration with Large Language Models Simplified》 博客。",
            normalizedContent: "# 1. gemini 接入现状？\n\n项目暂未完成对 gemini 的接入，主要有两点原因：\n\n① 虽然 spring ai 的 spring-ai-vertex-ai-gemini 对 gemini 的集成，但是它的 api 认证方式 很奇怪（和主流大模型 api 差异很大），没跑通，所以暂时放弃。\n\n② gemini 目前应该是不如 openai（chatgpt），所以优先级不高。\n\n所以，等后续 gemini 变强，并且流行度更高之后，我们再进行接入！\n\n\n# 2. gemma 如何接入？\n\ngemma 是 gemini 的开源版本，可以进行私有化部署。\n\n整个的接入，类似 《【模型接入】llama》。下面，我简单写下，有疑问可以星球提问哈！主要是，貌似也没听说哪个团队或者朋友在使用~\n\n① 访问 ollama 官网，下载对应系统 ollama 客户端，然后安装。\n\n② 安装完成后，在命令中执行 ollama run gemma 命令，一键部署 gemma 模型。\n\n③ 之后，需要使用 spring ai 的 spring-ai-ollama 进行接入。\n\n不知道它怎么使用的话，可以看看 《spring ai : java integration with large language models simplified》 博客。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【模型接入】Suno",
            frontmatter: {
                title: "【模型接入】Suno",
                date: "2024-06-29T10:54:45.000Z",
                permalink: "/ai/suno/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/17.AI%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%89%8B%E5%86%8C/97.%E3%80%90%E6%A8%A1%E5%9E%8B%E6%8E%A5%E5%85%A5%E3%80%91Suno.html",
            relativePath: "01.开发指南/17.AI大模型手册/97.【模型接入】Suno.md",
            key: "v-3a8738bf",
            path: "/ai/suno/",
            headers: [{
                level: 2,
                title: "1. 申请密钥",
                slug: "_1-申请密钥",
                normalizedTitle: "1. 申请密钥",
                charIndex: 309
            }, {
                level: 2,
                title: "2. 如何使用？",
                slug: "_2-如何使用",
                normalizedTitle: "2. 如何使用？",
                charIndex: 589
            }],
            headersStr: "1. 申请密钥 2. 如何使用？",
            content: "Suno AI，简称 Suno，是一款生成式人工智能音乐创作程序，旨在产生人声与乐器相结合的逼真歌曲。2023 年 12 月 20 日，Suno AI 在推出网络应用程序并与微软建立合作关系后，开始广泛使用。\n\n由于 Suno 没有直接提供 API 接口，所以大家一般通过 https://github.com/gcui-art/suno-api 项目，模拟用户操作，实现 API 形式调用 AI 生成音乐。\n\n也因此，Spring AI 肯定是不集成 Suno 的，所以我们实现的 models/suno 包下的 SunoApi 类，基于上述的 suno-api 代理，调用 Suno 实现音乐生成的功能。\n\n\n# 1. 申请密钥\n\n可参考 https://github.com/gcui-art/suno-api/blob/main/README_CN.md 文档，申请 Suno 账号，并搭建 suno-api 代理。\n\n我是采用【本地运行】的方式，因为 Vercel 部署需要 VPN 访问，比较麻烦。\n\n----------------------------------------\n\n申请完成后，可以在我们系统的 [AI 大模型 -> 控制台 -> API 密钥] 菜单，进行密钥的配置。需要填写“密钥” + “自定义 API URL”。如下图所示：\n\n\n\n\n# 2. 如何使用？\n\n① 如果你的项目里需要直接通过 @Resource 注入 SunoApi 对象，需要把 application.yaml 配置文件里的 yudao.ai.suno 配置项，替换成你的！\n\nyudao:\n  ai:\n    suno:\n      enable: true\n      base-url: http://127.0.0.1:3001\n\n\n另外，由于 Suno 生成音乐是异步的，可以把项目的 AiSunoSyncJob 定时器类，配置每 1 分钟执行一次，同步音乐生成的结果。怎么使用定时器，可以参考 《定时任务》 文档。\n\n② 如果你希望使用 [AI 大模型 -> 控制台 -> API 密钥] 菜单的密钥配置，则可以通过 AiApiKeyService 的 #getSunoApi() 方法，获取对应的 SunoApi 对象。\n\n另外，SunoApiTests 里有对应的测试用例，可以参考。",
            normalizedContent: "suno ai，简称 suno，是一款生成式人工智能音乐创作程序，旨在产生人声与乐器相结合的逼真歌曲。2023 年 12 月 20 日，suno ai 在推出网络应用程序并与微软建立合作关系后，开始广泛使用。\n\n由于 suno 没有直接提供 api 接口，所以大家一般通过 https://github.com/gcui-art/suno-api 项目，模拟用户操作，实现 api 形式调用 ai 生成音乐。\n\n也因此，spring ai 肯定是不集成 suno 的，所以我们实现的 models/suno 包下的 sunoapi 类，基于上述的 suno-api 代理，调用 suno 实现音乐生成的功能。\n\n\n# 1. 申请密钥\n\n可参考 https://github.com/gcui-art/suno-api/blob/main/readme_cn.md 文档，申请 suno 账号，并搭建 suno-api 代理。\n\n我是采用【本地运行】的方式，因为 vercel 部署需要 vpn 访问，比较麻烦。\n\n----------------------------------------\n\n申请完成后，可以在我们系统的 [ai 大模型 -> 控制台 -> api 密钥] 菜单，进行密钥的配置。需要填写“密钥” + “自定义 api url”。如下图所示：\n\n\n\n\n# 2. 如何使用？\n\n① 如果你的项目里需要直接通过 @resource 注入 sunoapi 对象，需要把 application.yaml 配置文件里的 yudao.ai.suno 配置项，替换成你的！\n\nyudao:\n  ai:\n    suno:\n      enable: true\n      base-url: http://127.0.0.1:3001\n\n\n另外，由于 suno 生成音乐是异步的，可以把项目的 aisunosyncjob 定时器类，配置每 1 分钟执行一次，同步音乐生成的结果。怎么使用定时器，可以参考 《定时任务》 文档。\n\n② 如果你希望使用 [ai 大模型 -> 控制台 -> api 密钥] 菜单的密钥配置，则可以通过 aiapikeyservice 的 #getsunoapi() 方法，获取对应的 sunoapi 对象。\n\n另外，sunoapitests 里有对应的测试用例，可以参考。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【模型接入】Midjourney",
            frontmatter: {
                title: "【模型接入】Midjourney",
                date: "2024-06-29T09:48:38.000Z",
                permalink: "/ai/midjourney/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/17.AI%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%89%8B%E5%86%8C/96.%E3%80%90%E6%A8%A1%E5%9E%8B%E6%8E%A5%E5%85%A5%E3%80%91Midjourney.html",
            relativePath: "01.开发指南/17.AI大模型手册/96.【模型接入】Midjourney.md",
            key: "v-8117d9da",
            path: "/ai/midjourney/",
            headers: [{
                level: 2,
                title: "1. 申请密钥",
                slug: "_1-申请密钥",
                normalizedTitle: "1. 申请密钥",
                charIndex: 371
            }, {
                level: 2,
                title: "2. 如何使用？",
                slug: "_2-如何使用",
                normalizedTitle: "2. 如何使用？",
                charIndex: 718
            }],
            headersStr: "1. 申请密钥 2. 如何使用？",
            content: "Midjourney 是一个由位于美国加州旧金山的同名研究实验室开发之人工智能程序，可根据文本生成图像，于 2022 年 7 月 12 日进入公开测试阶段，用户可透过 Discord 的机器人指令进行操作。\n\n由于 Midjourney 没有直接提供 API 接口，所以大家一般通过 https://github.com/novicezk/midjourney-proxy/ 项目，代理 MidJourney 的 Discord 频道，实现 API 形式调用 AI 绘图。\n\n也因此，Spring AI 肯定是不集成 Midjourney 的，所以我们实现的 models/midjourney 包下的 MidjourneyApi 类，基于上述的 midjourney-proxy 代理，调用 Midjourney 实现绘图的功能。\n\n\n# 1. 申请密钥\n\n可参考 https://github.com/novicezk/midjourney-proxy/blob/main/README_CN.md 文档，申请相关账号，并搭建 midjourney-proxy 代理。\n\n不过这个方式比较麻烦，我自己暂时没跑通。我是在 毫秒 API 注册了一个账号，然后通过他们的 API 代理 Midjourney 的。这个是需要付费的，测试的话，建议只小额充值 1-10 块。\n\n----------------------------------------\n\n申请完成后，可以在我们系统的 [AI 大模型 -> 控制台 -> API 密钥] 菜单，进行密钥的配置。需要填写“密钥” + “自定义 API URL”。如下图所示：\n\n\n\n\n# 2. 如何使用？\n\n① 如果你的项目里需要直接通过 @Resource 注入 MidjourneyApi 对象，需要把 application.yaml 配置文件里的 yudao.ai.midjourney 配置项，替换成你的！\n\nyudao:\n  ai:\n    midjourney:\n      enable: true\n      base-url: https://api.holdai.top/mj\n      api-key: sk-dZEPiVaNcT3FHhef51996bAa0bC74806BeAb620dA5Da10Bf\n      notify-url: http://java.nat300.top/admin-api/ai/image/midjourney/notify\n\n\n * base-url：Midjourney 代理的地址，相关的接口文档可见 https://gpt-best.apifox.cn/doc-3530863\n * notify-url：Midjourney 生成图片后的回调地址，因为 Midjourney 生成图片是异步的，所以需要回调通知。这个 URL 可以分成两个小部分：\n   * http://java.nat300.top：你的服务器地址。如果你没外网，可以通过 《内网穿透》 解决\n   * /admin-api/ai/image/midjourney/notify：对应 AiImageController 的 #midjourneyNotify(...) 方法\n\n另外，考虑到 Midjourney 回调失败的情况，可以把项目的 AiMidjourneySyncJob 定时器类，配置每 1 分钟执行一次，检查是否有未回调的图片。怎么使用定时器，可以参考 《定时任务》 文档。\n\n② 如果你希望使用 [AI 大模型 -> 控制台 -> API 密钥] 菜单的密钥配置，则可以通过 AiApiKeyService 的 #getMidjourneyApi() 方法，获取对应的 MidjourneyApi 对象。\n\n另外，MidjourneyApiTests 里有对应的测试用例，可以参考。",
            normalizedContent: "midjourney 是一个由位于美国加州旧金山的同名研究实验室开发之人工智能程序，可根据文本生成图像，于 2022 年 7 月 12 日进入公开测试阶段，用户可透过 discord 的机器人指令进行操作。\n\n由于 midjourney 没有直接提供 api 接口，所以大家一般通过 https://github.com/novicezk/midjourney-proxy/ 项目，代理 midjourney 的 discord 频道，实现 api 形式调用 ai 绘图。\n\n也因此，spring ai 肯定是不集成 midjourney 的，所以我们实现的 models/midjourney 包下的 midjourneyapi 类，基于上述的 midjourney-proxy 代理，调用 midjourney 实现绘图的功能。\n\n\n# 1. 申请密钥\n\n可参考 https://github.com/novicezk/midjourney-proxy/blob/main/readme_cn.md 文档，申请相关账号，并搭建 midjourney-proxy 代理。\n\n不过这个方式比较麻烦，我自己暂时没跑通。我是在 毫秒 api 注册了一个账号，然后通过他们的 api 代理 midjourney 的。这个是需要付费的，测试的话，建议只小额充值 1-10 块。\n\n----------------------------------------\n\n申请完成后，可以在我们系统的 [ai 大模型 -> 控制台 -> api 密钥] 菜单，进行密钥的配置。需要填写“密钥” + “自定义 api url”。如下图所示：\n\n\n\n\n# 2. 如何使用？\n\n① 如果你的项目里需要直接通过 @resource 注入 midjourneyapi 对象，需要把 application.yaml 配置文件里的 yudao.ai.midjourney 配置项，替换成你的！\n\nyudao:\n  ai:\n    midjourney:\n      enable: true\n      base-url: https://api.holdai.top/mj\n      api-key: sk-dzepivanct3fhhef51996baa0bc74806beab620da5da10bf\n      notify-url: http://java.nat300.top/admin-api/ai/image/midjourney/notify\n\n\n * base-url：midjourney 代理的地址，相关的接口文档可见 https://gpt-best.apifox.cn/doc-3530863\n * notify-url：midjourney 生成图片后的回调地址，因为 midjourney 生成图片是异步的，所以需要回调通知。这个 url 可以分成两个小部分：\n   * http://java.nat300.top：你的服务器地址。如果你没外网，可以通过 《内网穿透》 解决\n   * /admin-api/ai/image/midjourney/notify：对应 aiimagecontroller 的 #midjourneynotify(...) 方法\n\n另外，考虑到 midjourney 回调失败的情况，可以把项目的 aimidjourneysyncjob 定时器类，配置每 1 分钟执行一次，检查是否有未回调的图片。怎么使用定时器，可以参考 《定时任务》 文档。\n\n② 如果你希望使用 [ai 大模型 -> 控制台 -> api 密钥] 菜单的密钥配置，则可以通过 aiapikeyservice 的 #getmidjourneyapi() 方法，获取对应的 midjourneyapi 对象。\n\n另外，midjourneyapitests 里有对应的测试用例，可以参考。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【模型接入】Stable Diffusion",
            frontmatter: {
                title: "【模型接入】Stable Diffusion",
                date: "2024-06-02T12:03:39.000Z",
                permalink: "/ai/stable-diffusion"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/17.AI%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%89%8B%E5%86%8C/95.%E3%80%90%E6%A8%A1%E5%9E%8B%E6%8E%A5%E5%85%A5%E3%80%91Stable%20Diffusion.html",
            relativePath: "01.开发指南/17.AI大模型手册/95.【模型接入】Stable Diffusion.md",
            key: "v-5b0d6144",
            path: "/ai/stable-diffusion/",
            headers: [{
                level: 2,
                title: "1. 申请密钥（私有部署）",
                slug: "_1-申请密钥-私有部署",
                normalizedTitle: "1. 申请密钥（私有部署）",
                charIndex: 127
            }, {
                level: 3,
                title: "1.1 方式一：申请 Stability 密钥",
                slug: "_1-1-方式一-申请-stability-密钥",
                normalizedTitle: "1.1 方式一：申请 stability 密钥",
                charIndex: 311
            }, {
                level: 3,
                title: "1.2 方式二：私有化部署",
                slug: "_1-2-方式二-私有化部署",
                normalizedTitle: "1.2 方式二：私有化部署",
                charIndex: 642
            }, {
                level: 3,
                title: "1.3 补充说明",
                slug: "_1-3-补充说明",
                normalizedTitle: "1.3 补充说明",
                charIndex: 1223
            }, {
                level: 2,
                title: "2. 如何使用？",
                slug: "_2-如何使用",
                normalizedTitle: "2. 如何使用？",
                charIndex: 1266
            }],
            headersStr: "1. 申请密钥（私有部署） 1.1 方式一：申请 Stability 密钥 1.2 方式二：私有化部署 1.3 补充说明 2. 如何使用？",
            content: "项目基于 Spring AI 提供的 spring-ai-stability-ai，实现 Stable Diffusion 的接入，提供 AI 作图的功能。\n\n对应的 Spring AI 客户端为 StabilityAiImageClient。\n\n\n# 1. 申请密钥（私有部署）\n\n由于 Stable Diffusion 是开源模型，所以可以私有化部署。\n\n而它的开源它的公司 Stability AI，提供了对应的云服务，可以直接使用。\n\n下面，我们来看看这两种方式怎么申请（部署）？\n\n友情提示：一般情况下，如果是为了体验 AI 作图，建议直接采用“方式一：申请 Stability 密钥”，更加简单方便！\n\n\n# 1.1 方式一：申请 Stability 密钥\n\n① 访问 Stability AI，注册账号。\n\n② 访问 API Keys ，获得一个 API Key。\n\n\n\n----------------------------------------\n\n申请完成后，可以在我们系统的 [AI 大模型 -> 控制台 -> API 密钥] 菜单，进行密钥的配置。只需要填写“密钥”，不需要填写“自定义 API URL”（因为 Spring AI 默认官方地址）。如下图所示：\n\n\n\nps：默认官方赠送了 25 Credits，够生成几百张图。如果用完的情况下，要么再申请一个账号，要么参考 《Stable Diffusion 3 会员 API 充值教学》 充值。\n\n\n# 1.2 方式二：私有化部署\n\n友情提示：虽然 Stable Diffusion 可以私有化部署，但是 Spring AI 没兼容私有化部署后的 HTTP API！\n\n这样就导致，即使私有化部署，项目还是无法对接使用！等后续我们看看，怎么可以兼容一下！！！\n\n① 方式一：参考 https://github.com/AbdBarho/stable-diffusion-webui-docker/wiki/Setup 文档，使用 Docker 部署。不过要注意，如果你是 MacOS + 苹果芯片，不支持！\n\n② 方式二：参考 https://devwl.com/posts/stable-diffusion-webui/ 文档，直接本机部署。我是 MacOS + 苹果芯片，已经跑通！如果你要开启 API 功能，启动命令得是\n\n./webui.sh --api\n\n\n这样，你在 http://127.0.0.1:7860/docs 地址，就可以看到 /sdapi/v1/txt2img 文字生成图片 API。不过正如我前面所说的，Spring AI 没兼容该接口！！！\n\n③ 方式三：参考 https://www.cnblogs.com/Serverless/p/18101931 文档，使用 Serverless 部署。不过我没试过，只是提供个资料哈~\n\n\n# 1.3 补充说明\n\n后续，你就可以参考 《AI 绘画》 ，实现文字生成图片。\n\n\n# 2. 如何使用？\n\n① 如果你的项目里需要直接通过 @Resource 注入 OpenAiImageClient 等对象，需要把 application.yaml 配置文件里的 spring.ai.stabilityai 配置项，替换成你的！\n\nspring:\n  ai:\n    stabilityai:\n      api-key: sk-e53UqbboF8QJCscYvzJscJxJXoFcFg4iJjl1oqgE7baJETmx # 你的密钥\n\n\n② 如果你希望使用 [AI 大模型 -> 控制台 -> API 密钥] 菜单的密钥配置，则可以通过 AiApiKeyService 的 #getImageModel(...) 方法，获取对应的模型对象。\n\n----------------------------------------\n\n① 和 ② 这两者的后续使用，就是标准的 Spring AI 客户端的使用，调用对应的方法即可。\n\n另外，StabilityAiImageModelTests 里有对应的测试用例，可以参考。",
            normalizedContent: "项目基于 spring ai 提供的 spring-ai-stability-ai，实现 stable diffusion 的接入，提供 ai 作图的功能。\n\n对应的 spring ai 客户端为 stabilityaiimageclient。\n\n\n# 1. 申请密钥（私有部署）\n\n由于 stable diffusion 是开源模型，所以可以私有化部署。\n\n而它的开源它的公司 stability ai，提供了对应的云服务，可以直接使用。\n\n下面，我们来看看这两种方式怎么申请（部署）？\n\n友情提示：一般情况下，如果是为了体验 ai 作图，建议直接采用“方式一：申请 stability 密钥”，更加简单方便！\n\n\n# 1.1 方式一：申请 stability 密钥\n\n① 访问 stability ai，注册账号。\n\n② 访问 api keys ，获得一个 api key。\n\n\n\n----------------------------------------\n\n申请完成后，可以在我们系统的 [ai 大模型 -> 控制台 -> api 密钥] 菜单，进行密钥的配置。只需要填写“密钥”，不需要填写“自定义 api url”（因为 spring ai 默认官方地址）。如下图所示：\n\n\n\nps：默认官方赠送了 25 credits，够生成几百张图。如果用完的情况下，要么再申请一个账号，要么参考 《stable diffusion 3 会员 api 充值教学》 充值。\n\n\n# 1.2 方式二：私有化部署\n\n友情提示：虽然 stable diffusion 可以私有化部署，但是 spring ai 没兼容私有化部署后的 http api！\n\n这样就导致，即使私有化部署，项目还是无法对接使用！等后续我们看看，怎么可以兼容一下！！！\n\n① 方式一：参考 https://github.com/abdbarho/stable-diffusion-webui-docker/wiki/setup 文档，使用 docker 部署。不过要注意，如果你是 macos + 苹果芯片，不支持！\n\n② 方式二：参考 https://devwl.com/posts/stable-diffusion-webui/ 文档，直接本机部署。我是 macos + 苹果芯片，已经跑通！如果你要开启 api 功能，启动命令得是\n\n./webui.sh --api\n\n\n这样，你在 http://127.0.0.1:7860/docs 地址，就可以看到 /sdapi/v1/txt2img 文字生成图片 api。不过正如我前面所说的，spring ai 没兼容该接口！！！\n\n③ 方式三：参考 https://www.cnblogs.com/serverless/p/18101931 文档，使用 serverless 部署。不过我没试过，只是提供个资料哈~\n\n\n# 1.3 补充说明\n\n后续，你就可以参考 《ai 绘画》 ，实现文字生成图片。\n\n\n# 2. 如何使用？\n\n① 如果你的项目里需要直接通过 @resource 注入 openaiimageclient 等对象，需要把 application.yaml 配置文件里的 spring.ai.stabilityai 配置项，替换成你的！\n\nspring:\n  ai:\n    stabilityai:\n      api-key: sk-e53uqbbof8qjcscyvzjscjxjxofcfg4ijjl1oqge7bajetmx # 你的密钥\n\n\n② 如果你希望使用 [ai 大模型 -> 控制台 -> api 密钥] 菜单的密钥配置，则可以通过 aiapikeyservice 的 #getimagemodel(...) 方法，获取对应的模型对象。\n\n----------------------------------------\n\n① 和 ② 这两者的后续使用，就是标准的 spring ai 客户端的使用，调用对应的方法即可。\n\n另外，stabilityaiimagemodeltests 里有对应的测试用例，可以参考。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "功能开启",
            frontmatter: {
                title: "功能开启",
                permalink: "/mp/build",
                date: "2023-01-29T11:41:26.000Z"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/18.%E5%85%AC%E4%BC%97%E5%8F%B7%E6%89%8B%E5%86%8C/01.%E5%8A%9F%E8%83%BD%E5%BC%80%E5%90%AF.html",
            relativePath: "01.开发指南/18.公众号手册/01.功能开启.md",
            key: "v-3d6744a0",
            path: "/mp/build/",
            headers: [{
                level: 2,
                title: "1. 第一步，开启模块",
                slug: "_1-第一步-开启模块",
                normalizedTitle: "1. 第一步，开启模块",
                charIndex: 558
            }, {
                level: 2,
                title: "2. 第二步，导入 SQL",
                slug: "_2-第二步-导入-sql",
                normalizedTitle: "2. 第二步，导入 sql",
                charIndex: 758
            }, {
                level: 2,
                title: "3. 第三步，重启项目",
                slug: "_3-第三步-重启项目",
                normalizedTitle: "3. 第三步，重启项目",
                charIndex: 894
            }],
            headersStr: "1. 第一步，开启模块 2. 第二步，导入 SQL 3. 第三步，重启项目",
            content: "微信公众号的功能，由 yudao-module-mp 模块实现，对应前端代码为 @/views/mp 目录。\n\n主要包括如下 10 个功能（菜单）：\n\n\n\n功能       描述\n账号管理     配置接入的微信公众号，可支持多个公众号\n数据统计     统计公众号的用户增减、累计用户、消息概况、接口分析等数据\n粉丝管理     查看已关注、取关的粉丝列表，可对粉丝进行同步、打标签等操作\n消息管理     查看粉丝发送的消息列表，可主动回复粉丝消息\n自动回复     自动回复粉丝发送的消息，支持关注回复、消息回复、关键字回复\n标签管理     对公众号的标签进行创建、查询、修改、删除等操作\n菜单管理     自定义公众号的菜单，也可以从公众号同步菜单\n素材管理     管理公众号的图片、语音、视频等素材，支持在线播放语音、视频\n图文草稿箱    新增常用的图文素材到草稿箱，可发布到公众号\n图文发表记录   查看已发布成功的图文素材，支持删除操作\n\n考虑到编译速度，默认 yudao-module-mp 模块是关闭的，需要手动开启。步骤如下：\n\n * 第一步，开启 yudao-module-mp 模块\n * 第二步，导入公众号的 SQL 数据库脚本\n * 第三步，重启后端项目，确认功能是否生效\n\n\n# 1. 第一步，开启模块\n\n① 修改根目录的 pom.xml 文件，取消 yudao-module-mp 模块的注释。如下图所示：\n\n\n\n② 修改 yudao-server 目录的 pom.xml 文件，引入 yudao-module-mp 模块。如下图所示：\n\n\n\n③ 点击 IDEA 右上角的【Reload All Maven Projects】，刷新 Maven 依赖。如下图所示：\n\n\n\n\n# 2. 第二步，导入 SQL\n\n点击 mp-2024-01-05.sql.zip 下载附件，解压出 SQL 文件，然后导入到数据库中。 如下图所示：\n\n友情提示：↑↑↑ mp.sql 是可以点击下载的！ ↑↑↑\n\n\n\n以 mp_ 作为前缀的表，就是公众号模块的表。\n\n\n# 3. 第三步，重启项目\n\n重启后端项目，然后访问前端的公众号菜单，确认功能是否生效。如下图所示：\n\n\n\n至此，我们就成功开启了公众号的功能 🙂",
            normalizedContent: "微信公众号的功能，由 yudao-module-mp 模块实现，对应前端代码为 @/views/mp 目录。\n\n主要包括如下 10 个功能（菜单）：\n\n\n\n功能       描述\n账号管理     配置接入的微信公众号，可支持多个公众号\n数据统计     统计公众号的用户增减、累计用户、消息概况、接口分析等数据\n粉丝管理     查看已关注、取关的粉丝列表，可对粉丝进行同步、打标签等操作\n消息管理     查看粉丝发送的消息列表，可主动回复粉丝消息\n自动回复     自动回复粉丝发送的消息，支持关注回复、消息回复、关键字回复\n标签管理     对公众号的标签进行创建、查询、修改、删除等操作\n菜单管理     自定义公众号的菜单，也可以从公众号同步菜单\n素材管理     管理公众号的图片、语音、视频等素材，支持在线播放语音、视频\n图文草稿箱    新增常用的图文素材到草稿箱，可发布到公众号\n图文发表记录   查看已发布成功的图文素材，支持删除操作\n\n考虑到编译速度，默认 yudao-module-mp 模块是关闭的，需要手动开启。步骤如下：\n\n * 第一步，开启 yudao-module-mp 模块\n * 第二步，导入公众号的 sql 数据库脚本\n * 第三步，重启后端项目，确认功能是否生效\n\n\n# 1. 第一步，开启模块\n\n① 修改根目录的 pom.xml 文件，取消 yudao-module-mp 模块的注释。如下图所示：\n\n\n\n② 修改 yudao-server 目录的 pom.xml 文件，引入 yudao-module-mp 模块。如下图所示：\n\n\n\n③ 点击 idea 右上角的【reload all maven projects】，刷新 maven 依赖。如下图所示：\n\n\n\n\n# 2. 第二步，导入 sql\n\n点击 mp-2024-01-05.sql.zip 下载附件，解压出 sql 文件，然后导入到数据库中。 如下图所示：\n\n友情提示：↑↑↑ mp.sql 是可以点击下载的！ ↑↑↑\n\n\n\n以 mp_ 作为前缀的表，就是公众号模块的表。\n\n\n# 3. 第三步，重启项目\n\n重启后端项目，然后访问前端的公众号菜单，确认功能是否生效。如下图所示：\n\n\n\n至此，我们就成功开启了公众号的功能 🙂",
            charsets: {
                cjk: !0
            }
        }, {
            title: "公众号接入",
            frontmatter: {
                title: "公众号接入",
                permalink: "/mp/account",
                date: "2023-01-29T14:37:26.000Z"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/18.%E5%85%AC%E4%BC%97%E5%8F%B7%E6%89%8B%E5%86%8C/02.%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A5%E5%85%A5.html",
            relativePath: "01.开发指南/18.公众号手册/02.公众号接入.md",
            key: "v-bd370bb0",
            path: "/mp/account/",
            headers: [{
                level: 2,
                title: "1. 配置步骤",
                slug: "_1-配置步骤",
                normalizedTitle: "1. 配置步骤",
                charIndex: 90
            }, {
                level: 3,
                title: "第一步，申请公众号（可选）",
                slug: "第一步-申请公众号-可选",
                normalizedTitle: "第一步，申请公众号（可选）",
                charIndex: 32
            }, {
                level: 3,
                title: "第二步，添加公众号账号",
                slug: "第二步-添加公众号账号",
                normalizedTitle: "第二步，添加公众号账号",
                charIndex: 243
            }, {
                level: 3,
                title: "第三步，配置接入信息",
                slug: "第三步-配置接入信息",
                normalizedTitle: "第三步，配置接入信息",
                charIndex: 301
            }, {
                level: 2,
                title: "2. 实现代码",
                slug: "_2-实现代码",
                normalizedTitle: "2. 实现代码",
                charIndex: 468
            }, {
                level: 3,
                title: "2.1 表结构",
                slug: "_2-1-表结构",
                normalizedTitle: "2.1 表结构",
                charIndex: 502
            }, {
                level: 3,
                title: "2.2 账号管理界面",
                slug: "_2-2-账号管理界面",
                normalizedTitle: "2.2 账号管理界面",
                charIndex: 547
            }, {
                level: 3,
                title: "2.3 配置接入回调",
                slug: "_2-3-配置接入回调",
                normalizedTitle: "2.3 配置接入回调",
                charIndex: 614
            }, {
                level: 3,
                title: "2.4 消息处理",
                slug: "_2-4-消息处理",
                normalizedTitle: "2.4 消息处理",
                charIndex: 822
            }],
            headersStr: "1. 配置步骤 第一步，申请公众号（可选） 第二步，添加公众号账号 第三步，配置接入信息 2. 实现代码 2.1 表结构 2.2 账号管理界面 2.3 配置接入回调 2.4 消息处理",
            content: "本章节，讲解如果将你的公众号，接入到系统中。步骤如下：\n\n * 第一步，申请公众号（可选）\n * 第二步，在系统中，添加公众号账号\n * 第三步，在公众号中，配置接入信息\n\n\n# 1. 配置步骤\n\n本小节，手把手教你如何将公众号接入到系统中。\n\n\n# 第一步，申请公众号（可选）\n\n友情提示：如果你已经有公众号，可以忽略这一步。\n\n① 如果你还没有公众号，可以申请一个测试帐号。\n\n\n\n申请地址：微信公众平台接口测试帐号申请\n\n② 申请完成后，获得一个测试号。如下图所示：\n\n\n\n\n# 第二步，添加公众号账号\n\n点击 [公众号管理 -> 账号管理] 菜单，添加一个公众号账号。如下图所示：\n\n\n\n\n# 第三步，配置接入信息\n\n① 由于公众号通知需要外网地址，可参考 《内网穿透》 文档，将本地的 48080 端口，转发到外网中。这里，我的域名是 http://yunai.natapp1.cc。\n\n② 打开微信公众号界面，填写 URL 和 Token 信息。如下图所示：\n\n\n\n点击提交后，看到“配置成功”提示，说明配置成功。\n\n\n# 2. 实现代码\n\n本小节，将介绍如何实现公众号接入的代码。\n\n\n# 2.1 表结构\n\n公众号账号对应 mp_account 表，结构如下图所示：\n\n\n\n\n# 2.2 账号管理界面\n\n * 前端：/@views/mp/account\n * 后端：MpAccountController\n\n\n# 2.3 配置接入回调\n\n在 第三步，配置接入信息 时，微信公众号会回调系统的 GET /admin-api/mp/open/{appID} 接口，进行接入配置的验证。对应 MpOpenController 类的 checkSignature 方法，如下图所示：\n\n\n\n对应 《微信公众号官方文档 —— 接入指南》 文档。\n\n友情提示：\n\n项目使用的微信工具开发包是 weixin-java-mp，超级好用！\n\n\n# 2.4 消息处理\n\n配置接入完成后，用户发给公众号的消息，公众号都会回调到 POST /admin-api/mp/open/{appID} 接口，进行消息的处理。对应 MpOpenController 类的 handleMessage 方法，如下图所示：\n\n\n\n核心逻辑是第二步，再解析到消息后，交给 WxMpMessageRouter 进行消息的处理。WxMpMessageRouter 在 DefaultMpServiceFactory 初始化，设置每种消息对应的 handler 处理器。如下图所示：\n\n\n\n具体每个处理器的实现，后续每个章节单独详细讲解。",
            normalizedContent: "本章节，讲解如果将你的公众号，接入到系统中。步骤如下：\n\n * 第一步，申请公众号（可选）\n * 第二步，在系统中，添加公众号账号\n * 第三步，在公众号中，配置接入信息\n\n\n# 1. 配置步骤\n\n本小节，手把手教你如何将公众号接入到系统中。\n\n\n# 第一步，申请公众号（可选）\n\n友情提示：如果你已经有公众号，可以忽略这一步。\n\n① 如果你还没有公众号，可以申请一个测试帐号。\n\n\n\n申请地址：微信公众平台接口测试帐号申请\n\n② 申请完成后，获得一个测试号。如下图所示：\n\n\n\n\n# 第二步，添加公众号账号\n\n点击 [公众号管理 -> 账号管理] 菜单，添加一个公众号账号。如下图所示：\n\n\n\n\n# 第三步，配置接入信息\n\n① 由于公众号通知需要外网地址，可参考 《内网穿透》 文档，将本地的 48080 端口，转发到外网中。这里，我的域名是 http://yunai.natapp1.cc。\n\n② 打开微信公众号界面，填写 url 和 token 信息。如下图所示：\n\n\n\n点击提交后，看到“配置成功”提示，说明配置成功。\n\n\n# 2. 实现代码\n\n本小节，将介绍如何实现公众号接入的代码。\n\n\n# 2.1 表结构\n\n公众号账号对应 mp_account 表，结构如下图所示：\n\n\n\n\n# 2.2 账号管理界面\n\n * 前端：/@views/mp/account\n * 后端：mpaccountcontroller\n\n\n# 2.3 配置接入回调\n\n在 第三步，配置接入信息 时，微信公众号会回调系统的 get /admin-api/mp/open/{appid} 接口，进行接入配置的验证。对应 mpopencontroller 类的 checksignature 方法，如下图所示：\n\n\n\n对应 《微信公众号官方文档 —— 接入指南》 文档。\n\n友情提示：\n\n项目使用的微信工具开发包是 weixin-java-mp，超级好用！\n\n\n# 2.4 消息处理\n\n配置接入完成后，用户发给公众号的消息，公众号都会回调到 post /admin-api/mp/open/{appid} 接口，进行消息的处理。对应 mpopencontroller 类的 handlemessage 方法，如下图所示：\n\n\n\n核心逻辑是第二步，再解析到消息后，交给 wxmpmessagerouter 进行消息的处理。wxmpmessagerouter 在 defaultmpservicefactory 初始化，设置每种消息对应的 handler 处理器。如下图所示：\n\n\n\n具体每个处理器的实现，后续每个章节单独详细讲解。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "公众号消息",
            frontmatter: {
                title: "公众号消息",
                date: "2023-01-29T20:25:27.000Z",
                permalink: "/mp/message"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/18.%E5%85%AC%E4%BC%97%E5%8F%B7%E6%89%8B%E5%86%8C/05.%E5%85%AC%E4%BC%97%E5%8F%B7%E6%B6%88%E6%81%AF.html",
            relativePath: "01.开发指南/18.公众号手册/05.公众号消息.md",
            key: "v-9cf724c4",
            path: "/mp/message/",
            headers: [{
                level: 2,
                title: "1. 表结构",
                slug: "_1-表结构",
                normalizedTitle: "1. 表结构",
                charIndex: 52
            }, {
                level: 2,
                title: "2. 消息管理界面",
                slug: "_2-消息管理界面",
                normalizedTitle: "2. 消息管理界面",
                charIndex: 261
            }, {
                level: 2,
                title: "3.【接收】",
                slug: "_3-【接收】",
                normalizedTitle: "3.【接收】",
                charIndex: 327
            }, {
                level: 3,
                title: "3.1 接收普通消息",
                slug: "_3-1-接收普通消息",
                normalizedTitle: "3.1 接收普通消息",
                charIndex: 338
            }, {
                level: 3,
                title: "3.2 接收事件消息",
                slug: "_3-2-接收事件消息",
                normalizedTitle: "3.2 接收事件消息",
                charIndex: 482
            }, {
                level: 2,
                title: "4.【发送】",
                slug: "_4-【发送】",
                normalizedTitle: "4.【发送】",
                charIndex: 600
            }, {
                level: 3,
                title: "4.1 被动回复用户消息",
                slug: "_4-1-被动回复用户消息",
                normalizedTitle: "4.1 被动回复用户消息",
                charIndex: 611
            }, {
                level: 3,
                title: "4.2 主动发送客服消息",
                slug: "_4-2-主动发送客服消息",
                normalizedTitle: "4.2 主动发送客服消息",
                charIndex: 777
            }],
            headersStr: "1. 表结构 2. 消息管理界面 3.【接收】 3.1 接收普通消息 3.2 接收事件消息 4.【发送】 4.1 被动回复用户消息 4.2 主动发送客服消息",
            content: "本章节，讲解公众号消息的相关内容，对应 [公众号管理 -> 消息管理] 菜单。如下图所示：\n\n\n\n\n# 1. 表结构\n\n公众号消息对应 mp_message 表，结构如下图所示：\n\n\n\n① type 字段：消息类型，包括文本、图片、语音、视频、小视频、图文、音乐、地理位置、链接、事件等类型，对应 mp_message_type 字典。\n\n② send_from 字段：消息发送方，分成两类：\n\n * 【接收】用户发送给公众号：接收普通消息、接收事件推送\n * 【发送】公众号发给用户：被动回复用户消息、客服消息\n\n\n# 2. 消息管理界面\n\n * 前端：/@views/mp/message\n * 后端：MpMessageController\n\n\n# 3.【接收】\n\n\n# 3.1 接收普通消息\n\n> 对应 《微信公众号官方文档 —— 接收普通消息》 文档。\n\n当用户向公众账号发消息时，会被 MessageReceiveHandler 处理，记录到 mp_message 表，消息类型为文本、图片、语音、视频、小视频、地理位置、链接。如下图所示：\n\n\n\n\n# 3.2 接收事件消息\n\n> 对应 《微信公众号官方文档 —— 接收事件推送》 文档。\n\n在用户和公众号产交互的过程中，会被 MessageReceiveHandler 处理，记录到 mp_message 表，消息类型仅为事件。\n\n\n# 4.【发送】\n\n\n# 4.1 被动回复用户消息\n\n> 对应 《微信公众号官方文档 —— 被动回复用户消息》 文档。\n\n在被动回复用户消息时，统一由 MpMessageServiceImpl 的 sendOutMessage 方法来构建回复消息，也会记录到 mp_message 表，消息类型为文本、图片、语音、视频、音乐、图文。如下图所示：\n\n\n\n\n# 4.2 主动发送客服消息\n\n> 对应 《微信公众号官方文档 —— 客服消息》 文档。\n\n点击消息管理界面的【消息】按钮，可以主动发送客服消息给用户。如下图所示：\n\n\n\n主动发送客服消息，统一由 MpMessageServiceImpl 的 sendKefuMessage 方法来构建客服消息，也会记录到 mp_message 表，消息类型为文本、图片、语音、视频、音乐、图文。如下图所示：\n\n",
            normalizedContent: "本章节，讲解公众号消息的相关内容，对应 [公众号管理 -> 消息管理] 菜单。如下图所示：\n\n\n\n\n# 1. 表结构\n\n公众号消息对应 mp_message 表，结构如下图所示：\n\n\n\n① type 字段：消息类型，包括文本、图片、语音、视频、小视频、图文、音乐、地理位置、链接、事件等类型，对应 mp_message_type 字典。\n\n② send_from 字段：消息发送方，分成两类：\n\n * 【接收】用户发送给公众号：接收普通消息、接收事件推送\n * 【发送】公众号发给用户：被动回复用户消息、客服消息\n\n\n# 2. 消息管理界面\n\n * 前端：/@views/mp/message\n * 后端：mpmessagecontroller\n\n\n# 3.【接收】\n\n\n# 3.1 接收普通消息\n\n> 对应 《微信公众号官方文档 —— 接收普通消息》 文档。\n\n当用户向公众账号发消息时，会被 messagereceivehandler 处理，记录到 mp_message 表，消息类型为文本、图片、语音、视频、小视频、地理位置、链接。如下图所示：\n\n\n\n\n# 3.2 接收事件消息\n\n> 对应 《微信公众号官方文档 —— 接收事件推送》 文档。\n\n在用户和公众号产交互的过程中，会被 messagereceivehandler 处理，记录到 mp_message 表，消息类型仅为事件。\n\n\n# 4.【发送】\n\n\n# 4.1 被动回复用户消息\n\n> 对应 《微信公众号官方文档 —— 被动回复用户消息》 文档。\n\n在被动回复用户消息时，统一由 mpmessageserviceimpl 的 sendoutmessage 方法来构建回复消息，也会记录到 mp_message 表，消息类型为文本、图片、语音、视频、音乐、图文。如下图所示：\n\n\n\n\n# 4.2 主动发送客服消息\n\n> 对应 《微信公众号官方文档 —— 客服消息》 文档。\n\n点击消息管理界面的【消息】按钮，可以主动发送客服消息给用户。如下图所示：\n\n\n\n主动发送客服消息，统一由 mpmessageserviceimpl 的 sendkefumessage 方法来构建客服消息，也会记录到 mp_message 表，消息类型为文本、图片、语音、视频、音乐、图文。如下图所示：\n\n",
            charsets: {
                cjk: !0
            }
        }, {
            title: "公众号标签",
            frontmatter: {
                title: "公众号标签",
                date: "2023-01-29T17:57:32.000Z",
                permalink: "/mp/tag"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/18.%E5%85%AC%E4%BC%97%E5%8F%B7%E6%89%8B%E5%86%8C/04.%E5%85%AC%E4%BC%97%E5%8F%B7%E6%A0%87%E7%AD%BE.html",
            relativePath: "01.开发指南/18.公众号手册/04.公众号标签.md",
            key: "v-6cfef11d",
            path: "/mp/tag/",
            headers: [{
                level: 2,
                title: "1. 表结构",
                slug: "_1-表结构",
                normalizedTitle: "1. 表结构",
                charIndex: 94
            }, {
                level: 2,
                title: "2. 标签管理界面",
                slug: "_2-标签管理界面",
                normalizedTitle: "2. 标签管理界面",
                charIndex: 196
            }, {
                level: 2,
                title: "3. 同步标签",
                slug: "_3-同步标签",
                normalizedTitle: "3. 同步标签",
                charIndex: 254
            }],
            headersStr: "1. 表结构 2. 标签管理界面 3. 同步标签",
            content: "本章节，讲解公众号标签的相关内容，支持对标签进行创建、查询、修改、删除等操作，也可以对用户进行打标签、取消标签等操作，对应 《微信公众号官方文档 —— 用户标签管理》 文档。\n\n\n\n\n# 1. 表结构\n\n公众号粉丝对应 mp_tag 表，结构如下图所示：\n\n\n\n而给用户打上标签后，存储在 mp_user 表的 tag_ids 字段中（多个标签之间用 , 分隔），不单独存储关联表。\n\n\n# 2. 标签管理界面\n\n * 前端：/@views/mp/tag\n * 后端：MpTagController\n\n\n# 3. 同步标签\n\n点击标签管理界面的【同步】按钮，可以从公众号同步所有的标签信息，存储到 mp_tag 表中。\n\n对应后端的 MpTagServiceImpl 的 syncTag 方法。",
            normalizedContent: "本章节，讲解公众号标签的相关内容，支持对标签进行创建、查询、修改、删除等操作，也可以对用户进行打标签、取消标签等操作，对应 《微信公众号官方文档 —— 用户标签管理》 文档。\n\n\n\n\n# 1. 表结构\n\n公众号粉丝对应 mp_tag 表，结构如下图所示：\n\n\n\n而给用户打上标签后，存储在 mp_user 表的 tag_ids 字段中（多个标签之间用 , 分隔），不单独存储关联表。\n\n\n# 2. 标签管理界面\n\n * 前端：/@views/mp/tag\n * 后端：mptagcontroller\n\n\n# 3. 同步标签\n\n点击标签管理界面的【同步】按钮，可以从公众号同步所有的标签信息，存储到 mp_tag 表中。\n\n对应后端的 mptagserviceimpl 的 synctag 方法。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "自动回复",
            frontmatter: {
                title: "自动回复",
                date: "2023-01-29T21:38:12.000Z",
                permalink: "/mp/auto-reply"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/18.%E5%85%AC%E4%BC%97%E5%8F%B7%E6%89%8B%E5%86%8C/06.%E8%87%AA%E5%8A%A8%E5%9B%9E%E5%A4%8D.html",
            relativePath: "01.开发指南/18.公众号手册/06.自动回复.md",
            key: "v-96bcf192",
            path: "/mp/auto-reply/",
            headers: [{
                level: 2,
                title: "1. 表结构",
                slug: "_1-表结构",
                normalizedTitle: "1. 表结构",
                charIndex: 80
            }, {
                level: 2,
                title: "2. 自动回复界面",
                slug: "_2-自动回复界面",
                normalizedTitle: "2. 自动回复界面",
                charIndex: 221
            }, {
                level: 2,
                title: "3. 关注回复",
                slug: "_3-关注回复",
                normalizedTitle: "3. 关注回复",
                charIndex: 291
            }, {
                level: 2,
                title: "4. 消息回复 & 关键字回复",
                slug: "_4-消息回复-关键字回复",
                normalizedTitle: "4. 消息回复 &amp; 关键字回复",
                charIndex: null
            }],
            headersStr: "1. 表结构 2. 自动回复界面 3. 关注回复 4. 消息回复 & 关键字回复",
            content: "本章节，讲解自动回复的相关内容，对应 [公众号管理 -> 自动回复] 菜单。如下图所示：\n\n\n\n在用户关注、发送消息时，公众号可以自动回复消息给用户。\n\n\n# 1. 表结构\n\n自动回复对应 mp_auto_reply 表，结构如下图所示：\n\n\n\ntype 字段：回复类型，\n\n * 1 - 关注回复：用户关注公众号时\n * 3 - 关键字回复：消息类型为文本时，匹配到关键字\n * 2 - 消息回复：没有匹配到关键字时，根据消息类型\n\n\n# 2. 自动回复界面\n\n * 前端：/@views/mp/autoReply\n * 后端：MpAutoReplyController\n\n\n# 3. 关注回复\n\n用户关注公众号时，被动回复用户消息，由 MpAutoReplyServiceImpl 的 replyForSubscribe 方法来生成回复内容。如下图所示：\n\n\n\n\n# 4. 消息回复 & 关键字回复\n\n用户发送消息给公众号时，自动回复消息给用户，分为两种情况：\n\n * 关键字回复：消息类型为文本时，匹配到关键字，自动回复消息\n * 消息回复：没有匹配到关键字时，根据消息类型，自动回复消息\n\n这两种情况，由 MessageAutoReplyHandler 调用 MpAutoReplyServiceImpl 的 replyForMessage 方法来生成回复内容。如下图所示：\n\n",
            normalizedContent: "本章节，讲解自动回复的相关内容，对应 [公众号管理 -> 自动回复] 菜单。如下图所示：\n\n\n\n在用户关注、发送消息时，公众号可以自动回复消息给用户。\n\n\n# 1. 表结构\n\n自动回复对应 mp_auto_reply 表，结构如下图所示：\n\n\n\ntype 字段：回复类型，\n\n * 1 - 关注回复：用户关注公众号时\n * 3 - 关键字回复：消息类型为文本时，匹配到关键字\n * 2 - 消息回复：没有匹配到关键字时，根据消息类型\n\n\n# 2. 自动回复界面\n\n * 前端：/@views/mp/autoreply\n * 后端：mpautoreplycontroller\n\n\n# 3. 关注回复\n\n用户关注公众号时，被动回复用户消息，由 mpautoreplyserviceimpl 的 replyforsubscribe 方法来生成回复内容。如下图所示：\n\n\n\n\n# 4. 消息回复 & 关键字回复\n\n用户发送消息给公众号时，自动回复消息给用户，分为两种情况：\n\n * 关键字回复：消息类型为文本时，匹配到关键字，自动回复消息\n * 消息回复：没有匹配到关键字时，根据消息类型，自动回复消息\n\n这两种情况，由 messageautoreplyhandler 调用 mpautoreplyserviceimpl 的 replyformessage 方法来生成回复内容。如下图所示：\n\n",
            charsets: {
                cjk: !0
            }
        }, {
            title: "公众号粉丝",
            frontmatter: {
                title: "公众号粉丝",
                date: "2023-01-29T17:17:16.000Z",
                permalink: "/mp/user"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/18.%E5%85%AC%E4%BC%97%E5%8F%B7%E6%89%8B%E5%86%8C/03.%E5%85%AC%E4%BC%97%E5%8F%B7%E7%B2%89%E4%B8%9D.html",
            relativePath: "01.开发指南/18.公众号手册/03.公众号粉丝.md",
            key: "v-2718e9ea",
            path: "/mp/user/",
            headers: [{
                level: 2,
                title: "1. 表结构",
                slug: "_1-表结构",
                normalizedTitle: "1. 表结构",
                charIndex: 64
            }, {
                level: 2,
                title: "2. 粉丝管理界面",
                slug: "_2-粉丝管理界面",
                normalizedTitle: "2. 粉丝管理界面",
                charIndex: 192
            }, {
                level: 2,
                title: "3. 同步粉丝",
                slug: "_3-同步粉丝",
                normalizedTitle: "3. 同步粉丝",
                charIndex: 252
            }, {
                level: 2,
                title: "4. 关注 SubscribeHandler",
                slug: "_4-关注-subscribehandler",
                normalizedTitle: "4. 关注 subscribehandler",
                charIndex: 377
            }, {
                level: 2,
                title: "5. 取关 UnsubscribeHandler",
                slug: "_5-取关-unsubscribehandler",
                normalizedTitle: "5. 取关 unsubscribehandler",
                charIndex: 461
            }],
            headersStr: "1. 表结构 2. 粉丝管理界面 3. 同步粉丝 4. 关注 SubscribeHandler 5. 取关 UnsubscribeHandler",
            content: "本章节，讲解公众号粉丝的相关内容，包括关注、取消关注等等，对应 《微信公众号官方文档 —— 获取用户列表》 文档。\n\n\n\n\n# 1. 表结构\n\n公众号粉丝对应 mp_user 表，结构如下图所示：\n\n\n\n注意，自 2021-12-27 开始，公众号接口不再返回头像和昵称，只能通过微信公众号的网页登录获取。因此，表中的 avatar 和 nickname 字段，往往是空的。\n\n\n# 2. 粉丝管理界面\n\n * 前端：/@views/mp/user\n * 后端：MpUserController\n\n\n# 3. 同步粉丝\n\n点击粉丝管理界面的【同步】按钮，可以 异步 从公众号同步所有的粉丝信息，存储到 mp_user 表中。如果你的粉丝较多，可能需要等待一段时间。\n\n对应后端的 MpUserServiceImpl 的 syncUser 方法。\n\n\n# 4. 关注 SubscribeHandler\n\n用户关注公众号时，会触发 SubscribeHandler 处理器，新增或修改 mp_user 粉丝信息。\n\n\n\n\n# 5. 取关 UnsubscribeHandler\n\n用户取消关注公众号时，会触发 UnsubscribeHandler 处理器，标记 mp_user 粉丝信息为取消关注，设置 subscribe_status 字段为 0。\n\n",
            normalizedContent: "本章节，讲解公众号粉丝的相关内容，包括关注、取消关注等等，对应 《微信公众号官方文档 —— 获取用户列表》 文档。\n\n\n\n\n# 1. 表结构\n\n公众号粉丝对应 mp_user 表，结构如下图所示：\n\n\n\n注意，自 2021-12-27 开始，公众号接口不再返回头像和昵称，只能通过微信公众号的网页登录获取。因此，表中的 avatar 和 nickname 字段，往往是空的。\n\n\n# 2. 粉丝管理界面\n\n * 前端：/@views/mp/user\n * 后端：mpusercontroller\n\n\n# 3. 同步粉丝\n\n点击粉丝管理界面的【同步】按钮，可以 异步 从公众号同步所有的粉丝信息，存储到 mp_user 表中。如果你的粉丝较多，可能需要等待一段时间。\n\n对应后端的 mpuserserviceimpl 的 syncuser 方法。\n\n\n# 4. 关注 subscribehandler\n\n用户关注公众号时，会触发 subscribehandler 处理器，新增或修改 mp_user 粉丝信息。\n\n\n\n\n# 5. 取关 unsubscribehandler\n\n用户取消关注公众号时，会触发 unsubscribehandler 处理器，标记 mp_user 粉丝信息为取消关注，设置 subscribe_status 字段为 0。\n\n",
            charsets: {
                cjk: !0
            }
        }, {
            title: "公众号菜单",
            frontmatter: {
                title: "公众号菜单",
                date: "2023-01-29T22:17:03.000Z",
                permalink: "/mp/menu"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/18.%E5%85%AC%E4%BC%97%E5%8F%B7%E6%89%8B%E5%86%8C/07.%E5%85%AC%E4%BC%97%E5%8F%B7%E8%8F%9C%E5%8D%95.html",
            relativePath: "01.开发指南/18.公众号手册/07.公众号菜单.md",
            key: "v-33de6fc2",
            path: "/mp/menu/",
            headers: [{
                level: 2,
                title: "1. 表结构",
                slug: "_1-表结构",
                normalizedTitle: "1. 表结构",
                charIndex: 79
            }, {
                level: 2,
                title: "2. 菜单管理界面",
                slug: "_2-菜单管理界面",
                normalizedTitle: "2. 菜单管理界面",
                charIndex: 176
            }, {
                level: 2,
                title: "3. 点击回复",
                slug: "_3-点击回复",
                normalizedTitle: "3. 点击回复",
                charIndex: 236
            }],
            headersStr: "1. 表结构 2. 菜单管理界面 3. 点击回复",
            content: "本章节，讲解公众号菜单的相关内容，对应 [公众号管理 -> 菜单管理] 菜单，对应 《微信公众号官方文档 —— 自定义菜单》 文档。如下图所示：\n\n\n\n\n# 1. 表结构\n\n公众号菜单对应 mp_menu 表，结构如下图所示：\n\n\n\ntype 字段：按钮类型。如果类型为 CLICK 点击回复时，可进行文本、图片、语音、视频、图文、音乐消息。\n\n\n# 2. 菜单管理界面\n\n * 前端：/@views/mp/menu\n * 后端：MpMenuController\n\n\n# 3. 点击回复\n\n用户点击菜单按钮时，会接收事件消息，进而被 MenuHandler 处理。如果类型为 CLICK 点击回复时，自动回复对应的消息。如下图所示：\n\n",
            normalizedContent: "本章节，讲解公众号菜单的相关内容，对应 [公众号管理 -> 菜单管理] 菜单，对应 《微信公众号官方文档 —— 自定义菜单》 文档。如下图所示：\n\n\n\n\n# 1. 表结构\n\n公众号菜单对应 mp_menu 表，结构如下图所示：\n\n\n\ntype 字段：按钮类型。如果类型为 click 点击回复时，可进行文本、图片、语音、视频、图文、音乐消息。\n\n\n# 2. 菜单管理界面\n\n * 前端：/@views/mp/menu\n * 后端：mpmenucontroller\n\n\n# 3. 点击回复\n\n用户点击菜单按钮时，会接收事件消息，进而被 menuhandler 处理。如果类型为 click 点击回复时，自动回复对应的消息。如下图所示：\n\n",
            charsets: {
                cjk: !0
            }
        }, {
            title: "公众号统计",
            frontmatter: {
                title: "公众号统计",
                date: "2023-01-30T00:26:45.000Z",
                permalink: "/mp/statistics/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/18.%E5%85%AC%E4%BC%97%E5%8F%B7%E6%89%8B%E5%86%8C/10.%E5%85%AC%E4%BC%97%E5%8F%B7%E7%BB%9F%E8%AE%A1.html",
            relativePath: "01.开发指南/18.公众号手册/10.公众号统计.md",
            key: "v-76a0b199",
            path: "/mp/statistics/",
            headers: [{
                level: 2,
                title: "1. 表结构",
                slug: "_1-表结构",
                normalizedTitle: "1. 表结构",
                charIndex: 65
            }, {
                level: 2,
                title: "2. 数据统计界面",
                slug: "_2-数据统计界面",
                normalizedTitle: "2. 数据统计界面",
                charIndex: 201
            }],
            headersStr: "1. 表结构 2. 数据统计界面",
            content: "本章节，讲解公众号统计的相关内容，包括用户、消息、接口分析。对应 [公众号管理 -> 数据统计] 菜单，如下图所示：\n\n\n\n\n# 1. 表结构\n\n暂无，全部基于微信公众号提供的 API 接口。\n\n * 用户增减数据 + 累计用户数据：《微信公众号官方文档 —— 用户分析》\n * 消息概况数据：《微信公众号官方文档 —— 消息分析》\n * 接口分析数据：《微信公众号官方文档 —— 接口分析》\n\n\n# 2. 数据统计界面\n\n * 前端：/@views/mp/statistics\n * 后端：MpStatisticsController",
            normalizedContent: "本章节，讲解公众号统计的相关内容，包括用户、消息、接口分析。对应 [公众号管理 -> 数据统计] 菜单，如下图所示：\n\n\n\n\n# 1. 表结构\n\n暂无，全部基于微信公众号提供的 api 接口。\n\n * 用户增减数据 + 累计用户数据：《微信公众号官方文档 —— 用户分析》\n * 消息概况数据：《微信公众号官方文档 —— 消息分析》\n * 接口分析数据：《微信公众号官方文档 —— 接口分析》\n\n\n# 2. 数据统计界面\n\n * 前端：/@views/mp/statistics\n * 后端：mpstatisticscontroller",
            charsets: {
                cjk: !0
            }
        }, {
            title: "公众号素材",
            frontmatter: {
                title: "公众号素材",
                date: "2023-01-29T23:00:40.000Z",
                permalink: "/mp/material/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/18.%E5%85%AC%E4%BC%97%E5%8F%B7%E6%89%8B%E5%86%8C/08.%E5%85%AC%E4%BC%97%E5%8F%B7%E7%B4%A0%E6%9D%90.html",
            relativePath: "01.开发指南/18.公众号手册/08.公众号素材.md",
            key: "v-708f9059",
            path: "/mp/material/",
            headers: [{
                level: 2,
                title: "1. 表结构",
                slug: "_1-表结构",
                normalizedTitle: "1. 表结构",
                charIndex: 114
            }, {
                level: 2,
                title: "2. 素材管理界面",
                slug: "_2-素材管理界面",
                normalizedTitle: "2. 素材管理界面",
                charIndex: 434
            }, {
                level: 2,
                title: "3. 永久素材",
                slug: "_3-永久素材",
                normalizedTitle: "3. 永久素材",
                charIndex: 502
            }, {
                level: 2,
                title: "4. 临时素材",
                slug: "_4-临时素材",
                normalizedTitle: "4. 临时素材",
                charIndex: 625
            }],
            headersStr: "1. 表结构 2. 素材管理界面 3. 永久素材 4. 临时素材",
            content: "本章节，讲解公众号素材的相关内容，包括图片、语音、视频素材，不包括图文素材。对应 [公众号管理 -> 素材管理] 菜单，如下图所示：\n\n\n\n在配置公众号的自动回复、菜单的自动回复、主动给用户发送消息时，都可以使用素材。\n\n\n# 1. 表结构\n\n公众号素材对应 mp_material 表，结构如下图所示：\n\n\n\n① type 字段：素材类型。对应微信的素材类型，包括 image 图片、voice 语音、video 视频。\n\n② media_id 字段：素材的媒体编号，对应微信公众号的 media_id。\n\n③ permanent 字段：是否永久。true 代表 永久素材，false 代表 临时素材。\n\n④ mp_url 字段：公众号存储素材的 URL 地址，有且仅有永久素材才有。\n\n⑤ url 字段：存储在自己文件服务器上的 URL 地址，解决临时素材只在微信服务器上保存 3 天的问题，也解决图片素材的 mp_url 无法在自己管理后台显示的问题。\n\n\n# 2. 素材管理界面\n\n * 前端：/@views/mp/material\n * 后端：MpMaterialController\n\n\n# 3. 永久素材\n\n> 对应 《微信公众号官方文档 —— 永久素材》 文档。\n\nMpMaterialController 的 uploadPermanentMaterial 方法对应的接口，实现了上传【永久】素材到公众号。如下图所示：\n\n\n\n\n# 4. 临时素材\n\n> 对应 《微信公众号官方文档 —— 临时素材》 文档。\n\n① 来源一：主动发送客服消息给用户时，如果是图片、语音、视频素材，需要先上传到微信服务器，获得到 media_id 后，才能发送给用户。\n\n此时，可调用 MpMaterialController 的 uploadTemporaryMaterial 方法对应的接口，实现了上传【临时】素材到公众号。如下图所示：\n\n\n\n② 来源二：在接收到用户消息时，如果是图片、语音、视频素材，需要先下载到自己的文件服务器上，避免超过 3 天后无法访问的问题。如下图所示：\n\n",
            normalizedContent: "本章节，讲解公众号素材的相关内容，包括图片、语音、视频素材，不包括图文素材。对应 [公众号管理 -> 素材管理] 菜单，如下图所示：\n\n\n\n在配置公众号的自动回复、菜单的自动回复、主动给用户发送消息时，都可以使用素材。\n\n\n# 1. 表结构\n\n公众号素材对应 mp_material 表，结构如下图所示：\n\n\n\n① type 字段：素材类型。对应微信的素材类型，包括 image 图片、voice 语音、video 视频。\n\n② media_id 字段：素材的媒体编号，对应微信公众号的 media_id。\n\n③ permanent 字段：是否永久。true 代表 永久素材，false 代表 临时素材。\n\n④ mp_url 字段：公众号存储素材的 url 地址，有且仅有永久素材才有。\n\n⑤ url 字段：存储在自己文件服务器上的 url 地址，解决临时素材只在微信服务器上保存 3 天的问题，也解决图片素材的 mp_url 无法在自己管理后台显示的问题。\n\n\n# 2. 素材管理界面\n\n * 前端：/@views/mp/material\n * 后端：mpmaterialcontroller\n\n\n# 3. 永久素材\n\n> 对应 《微信公众号官方文档 —— 永久素材》 文档。\n\nmpmaterialcontroller 的 uploadpermanentmaterial 方法对应的接口，实现了上传【永久】素材到公众号。如下图所示：\n\n\n\n\n# 4. 临时素材\n\n> 对应 《微信公众号官方文档 —— 临时素材》 文档。\n\n① 来源一：主动发送客服消息给用户时，如果是图片、语音、视频素材，需要先上传到微信服务器，获得到 media_id 后，才能发送给用户。\n\n此时，可调用 mpmaterialcontroller 的 uploadtemporarymaterial 方法对应的接口，实现了上传【临时】素材到公众号。如下图所示：\n\n\n\n② 来源二：在接收到用户消息时，如果是图片、语音、视频素材，需要先下载到自己的文件服务器上，避免超过 3 天后无法访问的问题。如下图所示：\n\n",
            charsets: {
                cjk: !0
            }
        }, {
            title: "短信配置",
            frontmatter: {
                title: "短信配置",
                date: "2022-04-10T21:20:42.000Z",
                permalink: "/sms"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/19.%E7%B3%BB%E7%BB%9F%E6%89%8B%E5%86%8C/40.%E7%9F%AD%E4%BF%A1%E9%85%8D%E7%BD%AE.html",
            relativePath: "01.开发指南/19.系统手册/40.短信配置.md",
            key: "v-217c7a2a",
            path: "/sms/",
            headers: [{
                level: 2,
                title: "1. 表结构",
                slug: "_1-表结构",
                normalizedTitle: "1. 表结构",
                charIndex: 237
            }, {
                level: 2,
                title: "2. 短信配置",
                slug: "_2-短信配置",
                normalizedTitle: "2. 短信配置",
                charIndex: 250
            }, {
                level: 3,
                title: "2.1 新建短信渠道",
                slug: "_2-1-新建短信渠道",
                normalizedTitle: "2.1 新建短信渠道",
                charIndex: 371
            }, {
                level: 3,
                title: "2.2 新建短信模板",
                slug: "_2-2-新建短信模板",
                normalizedTitle: "2.2 新建短信模板",
                charIndex: 938
            }, {
                level: 3,
                title: "2.3 查看短信日志",
                slug: "_2-3-查看短信日志",
                normalizedTitle: "2.3 查看短信日志",
                charIndex: 1382
            }, {
                level: 2,
                title: "3. 短信发送",
                slug: "_3-短信发送",
                normalizedTitle: "3. 短信发送",
                charIndex: 1712
            }, {
                level: 3,
                title: "3.1 SmsSendApi",
                slug: "_3-1-smssendapi",
                normalizedTitle: "3.1 smssendapi",
                charIndex: 1724
            }, {
                level: 3,
                title: "3.2 实战案例",
                slug: "_3-2-实战案例",
                normalizedTitle: "3.2 实战案例",
                charIndex: 1785
            }, {
                level: 2,
                title: "4. 验证码发送",
                slug: "_4-验证码发送",
                normalizedTitle: "4. 验证码发送",
                charIndex: 1953
            }, {
                level: 3,
                title: "4.1 SmsCodeApi",
                slug: "_4-1-smscodeapi",
                normalizedTitle: "4.1 smscodeapi",
                charIndex: 1966
            }, {
                level: 3,
                title: "4.2 实战案例",
                slug: "_4-2-实战案例",
                normalizedTitle: "4.2 实战案例",
                charIndex: 2141
            }, {
                level: 2,
                title: "5. 短信客户端",
                slug: "_5-短信客户端",
                normalizedTitle: "5. 短信客户端",
                charIndex: 2359
            }, {
                level: 3,
                title: "5.1 SmsClient",
                slug: "_5-1-smsclient",
                normalizedTitle: "5.1 smsclient",
                charIndex: 2449
            }, {
                level: 3,
                title: "5.2 对接其它短信平台",
                slug: "_5-2-对接其它短信平台",
                normalizedTitle: "5.2 对接其它短信平台",
                charIndex: 2531
            }, {
                level: 2,
                title: "6. 短信平台附录",
                slug: "_6-短信平台附录",
                normalizedTitle: "6. 短信平台附录",
                charIndex: 919
            }, {
                level: 3,
                title: "6.1 阿里云",
                slug: "_6-1-阿里云",
                normalizedTitle: "6.1 阿里云",
                charIndex: 2739
            }, {
                level: 3,
                title: "6.2 腾讯云",
                slug: "_6-2-腾讯云",
                normalizedTitle: "6.2 腾讯云",
                charIndex: 2897
            }, {
                level: 3,
                title: "6.3 华为云",
                slug: "_6-3-华为云",
                normalizedTitle: "6.3 华为云",
                charIndex: 3225
            }, {
                level: 3,
                title: "6.4 七牛云",
                slug: "_6-4-七牛云",
                normalizedTitle: "6.4 七牛云",
                charIndex: 3613
            }, {
                level: 3,
                title: "6.5 更多短信平台",
                slug: "_6-5-更多短信平台",
                normalizedTitle: "6.5 更多短信平台",
                charIndex: 3762
            }],
            headersStr: "1. 表结构 2. 短信配置 2.1 新建短信渠道 2.2 新建短信模板 2.3 查看短信日志 3. 短信发送 3.1 SmsSendApi 3.2 实战案例 4. 验证码发送 4.1 SmsCodeApi 4.2 实战案例 5. 短信客户端 5.1 SmsClient 5.2 对接其它短信平台 6. 短信平台附录 6.1 阿里云 6.2 腾讯云 6.3 华为云 6.4 七牛云 6.5 更多短信平台",
            content: "本章节，介绍项目的短信功能。该功能提供统一的短信 API 给其它模块，使它们可以快速接入短信功能，无需关心不同短信平台的具体对接。\n\n短信采用异步发送，基于 消息队列，如下图所示：\n\n\n\n该功能由 yudao-module-system 模块实现，其中：\n\n * service/sms：短信【业务】，提供短信渠道、模板的配置，短信日志的查看，短信的发送等功能\n * frameowrk/sms：短信【组件】，封装阿里云、腾讯云、华为云、七牛云等短信平台的客户端。\n\n\n# 1. 表结构\n\n\n\n\n# 2. 短信配置\n\n本小节，讲解如何配置短信功能，整个过程如下：\n\n * 新建一个短信【渠道】，配置对应短信平台的账号\n * 新建一个短信【模版】，配置对应短信平台的模板\n * 测试该短信模板，查看对应的短信【日志】，确认是否发送成功\n\n\n# 2.1 新建短信渠道\n\n① 点击 [系统管理 -> 消息中心 -> 短信管理 -> 短信渠道] 菜单，查看短信渠道的列表。如下图所示：\n\n\n\n② 点击 [新增] 按钮，选择渠道编码为【调试（钉钉）】，并填写信息如下图：\n\n\n\n短信 API 的账号: 696b5d8ead48071237e4aa5861ff08dbadb2b4ded1c688a7b7c9afc615579859\n短信 API 的密钥: SEC5c4e5ff888bc8a9923ae47f59e7ccd30af1f14d93c55b4e2c9cb094e35aeed67\n\n\n疑问 1：为什么选择渠道编码为【调试（钉钉）】？\n\n该类型使用钉钉机器人来模拟短信发送，用于日常调试。\n\n * 短信 API 的账号，对应机器人的 Webhook 的 access_token 参数\n * 短信 API 的密钥，对应机器人的安全设置的加签\n\n上图使用的配置，是艿艿自己的钉钉机器人。正式使用时，必须参考 《钉钉开放平台 —— 自定义机器人接入 》 文档，申请自己的专属机器人。\n\n疑问 2：可以选择其它渠道编码吗？\n\n当然可以，这里主要考虑部分同学暂时没有申请短信平台，所以使用【调试（钉钉）】渠道编码。\n\n不同短信平台的配置，可见 「6. 短信平台附录」 小节。\n\n\n# 2.2 新建短信模板\n\n① 点击 [系统管理 -> 消息中心 -> 短信管理 -> 短信模板] 菜单，查看短信模板的列表。如下图所示：\n\n\n\n② 点击 [新增] 按钮，选择刚创建的短信渠道，并填写信息如下图：\n\n\n\n * 短信渠道编号：发送该短信模板时，使用的短信渠道，即使用哪个短信平台进行发送\n * 模板编号：短信模板的唯一标识，使用短信 API 时，通过它标识使用的短信模板\n * 模板内容：短信模板的内容，使用 {var} 作为占位符，例如说 {name}、{code} 等\n * 短信 API 模板编号：短信平台的短信模板的编号，需要保证该模板在短信平台已经审核通过\n * 开启状态：短信模板被禁用时，该短信模板将不发送短信，只记录短信日志\n\n疑问：为什么设计短信模板的功能？\n\n在一些场景下，需要修改短信模板所使用的短信平台。例如说：短信平台出现故障，或者切换短信平台等等。\n\n此时，只需要修改短信模板的两个属性：短信渠道编号、短信 API 模板编号，无需重启应用。\n\n\n# 2.3 查看短信日志\n\n① 使用钉钉，扫码 图片 加入机器人所在的【ruoyi-vue-pro 短信测试群】，查看测试短信的模拟发送。\n\n② 点击 [测试] 按钮，输入任一手机号，进行该短信模板的模拟发送。如下图所示：\n\n\n\n\n\n友情提示：如果使用的短信渠道是阿里云、腾讯云等正式的短信平台，则会发送到填写的手机号中。例如说：\n\n\n\n③ 点击 [系统管理 -> 消息中心 -> 短信管理 -> 短信日志] 采单，可以查看到每条短信的发送状态、接收状态。如下图所示：\n\n\n\n常见问题：为什么日志的接受状态，一直处理“等待结果”？\n\n因为你没配置短信回调 URL，导致短信平台无法回调我们的系统，所以一直等待结果。具体怎么配置，可见 短信平台附录 小节。\n\n\n# 3. 短信发送\n\n\n# 3.1 SmsSendApi\n\n使用 SmsSendApi 进行短信的发送，支持多种用户类型。它的方法如下：\n\n\n\n\n# 3.2 实战案例\n\n以工作流申请通过时，发送短信为例子，讲解 SmsSendApi 的使用。\n\n① 引入 yudao-module-system-api 依赖，如下图所示：\n\n\n\n② 新建对应的短信模板，如下图所示：\n\n\n\n③ 使用 Spring 注入 SmsSendApi Bean，调用对应的短信发送方法。如下图所示：\n\n\n\n\n# 4. 验证码发送\n\n\n# 4.1 SmsCodeApi\n\n使用 SmsCodeApi 进行【验证码】短信的发送，例如说：用户手机验证码登录、用户忘记密码等等。它的方法如下：\n\n\n\n验证码使用 system_sms_code 表进行存储，默认每天最多发送 10 条，每分钟发送 1 条，有效期为 10 分钟，可通过 yudao.sms-code 配置项进行自定义：\n\n\n\n\n# 4.2 实战案例\n\n以会员用户手机验证码登录为例子，讲解 SmsCodeApi 的使用。\n\n① 引入 yudao-module-system-api 依赖，如下图所示：\n\n\n\n② 新建对应的短信模板，如下图所示：\n\n\n\n③ 在 SmsSceneEnum 中，枚举会员用户的手机号登录的场景，如下图所示：\n\n\n\n④ 使用 Spring 注入 SmsCodeApi Bean，调用对应的短信验证码的发送与使用方法。如下图所示：\n\n\n\n\n# 5. 短信客户端\n\nframeowrk/sms 短信【组件】，对接阿里云、腾讯云等短信平台，提供统一的短信客户端，提供给 service/sms 短信【业务】模块来调用。\n\n\n# 5.1 SmsClient\n\nSmsClient 接口，定义短信客户端的方法。代码如下：\n\n\n\n每个短信平台，都对应一个 SmsClient 实现类。\n\n\n\n\n# 5.2 对接其它短信平台\n\n如果你想要对接其它短信平台，自定义一个 SmsClient 实现类，并使用 SmsClientFactoryImpl 进行创建。代码如下：\n\n\n\n\n# 6. 短信平台附录\n\n一般情况下，建议接入 2-3 个短信平台，避免某个短信平台故障时，影响业务的正常运行。\n\n例如说，手机验证码的短信平台 A 故障时，赶紧将短信验证码切换到短信平台 B 上，否则用户将无法正常登录或是注册。\n\n\n# 6.1 阿里云\n\n① 短信 API 的账号、密钥，可通过 阿里云 —— AccessKey 获取。\n\n② 短信发送回调 URL，可通过 阿里云 —— 短信服务 —— 通用设置 配置。它对应的是 SmsCallbackController 的 #receiveAliyunSmsStatus(...) 地址。\n\n\n# 6.2 腾讯云\n\n① 短信 API 的账号、密钥，可通过 腾讯云 —— API 密钥管理 获取。\n\n注意！！！\n\n腾讯云需要额外使用 SDKAppID 参数，它的账号需要采用 secretId SDKAppID 格式。\n\n例如说：在“API 密钥管理”获得了 SecretId 为 A，SecretKey 为 B，在“SDKAppID”获得了 SDKAppID 为 18，则配置短信 API 的账号为 A 18，短信 API 的密钥为 B。\n\n② 短信发送回调 URL，可通过 腾讯云 —— 短信 —— 基础配置 配置。它对应的是 SmsCallbackController 的 #receiveTencentSmsStatus(...) 地址。\n\n\n# 6.3 华为云\n\n① 短信 API 的账号、密钥，可通过 华为云 —— 访问密钥 获取。\n\n注意！！！\n\n华为云需要额外使用 sender 通道号，它的账号需要采用 AccessKeyId sender 格式。\n\n例如说：在“华为云访问密钥”获得了 AccessKeyId 为 A，SecretAccessKey 为 B，在“华为云签名”获得了 sender 为 8824060312575，则配置短信 API 的账号为 A 8824060312575，短信 API 的密钥为 B。\n\n② 短信发送回调 URL，可以通过我们项目的 [系统管理 -> 消息中心 -> 短信管理 -> 短信渠道] 菜单，配置它的“短信发送回调 URL”字段即可。它对应的是 SmsCallbackController 的 #receiveHuaweiSmsStatus(...) 地址。\n\n\n# 6.4 七牛云\n\n① 短信 API 的账号、密钥，可通过 七牛云 —— 密钥管理 获取。\n\n② 短信发送回调 URL，可通过 七牛云 —— 云短信 —— 设置 配置。它对应的是 SmsCallbackController 的 #receiveQiniuSmsStatus(...) 地址。\n\n\n# 6.5 更多短信平台\n\n短信平台非常的多，欢迎给我们 pull request 贡献。\n\n例如说：合一、云片、京东云、容联云、亿美软通、天翼云、网易云等等。\n\n如果你想参与，可以添加 wangwenbin-server 微信好，备注“短信”即可。",
            normalizedContent: "本章节，介绍项目的短信功能。该功能提供统一的短信 api 给其它模块，使它们可以快速接入短信功能，无需关心不同短信平台的具体对接。\n\n短信采用异步发送，基于 消息队列，如下图所示：\n\n\n\n该功能由 yudao-module-system 模块实现，其中：\n\n * service/sms：短信【业务】，提供短信渠道、模板的配置，短信日志的查看，短信的发送等功能\n * frameowrk/sms：短信【组件】，封装阿里云、腾讯云、华为云、七牛云等短信平台的客户端。\n\n\n# 1. 表结构\n\n\n\n\n# 2. 短信配置\n\n本小节，讲解如何配置短信功能，整个过程如下：\n\n * 新建一个短信【渠道】，配置对应短信平台的账号\n * 新建一个短信【模版】，配置对应短信平台的模板\n * 测试该短信模板，查看对应的短信【日志】，确认是否发送成功\n\n\n# 2.1 新建短信渠道\n\n① 点击 [系统管理 -> 消息中心 -> 短信管理 -> 短信渠道] 菜单，查看短信渠道的列表。如下图所示：\n\n\n\n② 点击 [新增] 按钮，选择渠道编码为【调试（钉钉）】，并填写信息如下图：\n\n\n\n短信 api 的账号: 696b5d8ead48071237e4aa5861ff08dbadb2b4ded1c688a7b7c9afc615579859\n短信 api 的密钥: sec5c4e5ff888bc8a9923ae47f59e7ccd30af1f14d93c55b4e2c9cb094e35aeed67\n\n\n疑问 1：为什么选择渠道编码为【调试（钉钉）】？\n\n该类型使用钉钉机器人来模拟短信发送，用于日常调试。\n\n * 短信 api 的账号，对应机器人的 webhook 的 access_token 参数\n * 短信 api 的密钥，对应机器人的安全设置的加签\n\n上图使用的配置，是艿艿自己的钉钉机器人。正式使用时，必须参考 《钉钉开放平台 —— 自定义机器人接入 》 文档，申请自己的专属机器人。\n\n疑问 2：可以选择其它渠道编码吗？\n\n当然可以，这里主要考虑部分同学暂时没有申请短信平台，所以使用【调试（钉钉）】渠道编码。\n\n不同短信平台的配置，可见 「6. 短信平台附录」 小节。\n\n\n# 2.2 新建短信模板\n\n① 点击 [系统管理 -> 消息中心 -> 短信管理 -> 短信模板] 菜单，查看短信模板的列表。如下图所示：\n\n\n\n② 点击 [新增] 按钮，选择刚创建的短信渠道，并填写信息如下图：\n\n\n\n * 短信渠道编号：发送该短信模板时，使用的短信渠道，即使用哪个短信平台进行发送\n * 模板编号：短信模板的唯一标识，使用短信 api 时，通过它标识使用的短信模板\n * 模板内容：短信模板的内容，使用 {var} 作为占位符，例如说 {name}、{code} 等\n * 短信 api 模板编号：短信平台的短信模板的编号，需要保证该模板在短信平台已经审核通过\n * 开启状态：短信模板被禁用时，该短信模板将不发送短信，只记录短信日志\n\n疑问：为什么设计短信模板的功能？\n\n在一些场景下，需要修改短信模板所使用的短信平台。例如说：短信平台出现故障，或者切换短信平台等等。\n\n此时，只需要修改短信模板的两个属性：短信渠道编号、短信 api 模板编号，无需重启应用。\n\n\n# 2.3 查看短信日志\n\n① 使用钉钉，扫码 图片 加入机器人所在的【ruoyi-vue-pro 短信测试群】，查看测试短信的模拟发送。\n\n② 点击 [测试] 按钮，输入任一手机号，进行该短信模板的模拟发送。如下图所示：\n\n\n\n\n\n友情提示：如果使用的短信渠道是阿里云、腾讯云等正式的短信平台，则会发送到填写的手机号中。例如说：\n\n\n\n③ 点击 [系统管理 -> 消息中心 -> 短信管理 -> 短信日志] 采单，可以查看到每条短信的发送状态、接收状态。如下图所示：\n\n\n\n常见问题：为什么日志的接受状态，一直处理“等待结果”？\n\n因为你没配置短信回调 url，导致短信平台无法回调我们的系统，所以一直等待结果。具体怎么配置，可见 短信平台附录 小节。\n\n\n# 3. 短信发送\n\n\n# 3.1 smssendapi\n\n使用 smssendapi 进行短信的发送，支持多种用户类型。它的方法如下：\n\n\n\n\n# 3.2 实战案例\n\n以工作流申请通过时，发送短信为例子，讲解 smssendapi 的使用。\n\n① 引入 yudao-module-system-api 依赖，如下图所示：\n\n\n\n② 新建对应的短信模板，如下图所示：\n\n\n\n③ 使用 spring 注入 smssendapi bean，调用对应的短信发送方法。如下图所示：\n\n\n\n\n# 4. 验证码发送\n\n\n# 4.1 smscodeapi\n\n使用 smscodeapi 进行【验证码】短信的发送，例如说：用户手机验证码登录、用户忘记密码等等。它的方法如下：\n\n\n\n验证码使用 system_sms_code 表进行存储，默认每天最多发送 10 条，每分钟发送 1 条，有效期为 10 分钟，可通过 yudao.sms-code 配置项进行自定义：\n\n\n\n\n# 4.2 实战案例\n\n以会员用户手机验证码登录为例子，讲解 smscodeapi 的使用。\n\n① 引入 yudao-module-system-api 依赖，如下图所示：\n\n\n\n② 新建对应的短信模板，如下图所示：\n\n\n\n③ 在 smssceneenum 中，枚举会员用户的手机号登录的场景，如下图所示：\n\n\n\n④ 使用 spring 注入 smscodeapi bean，调用对应的短信验证码的发送与使用方法。如下图所示：\n\n\n\n\n# 5. 短信客户端\n\nframeowrk/sms 短信【组件】，对接阿里云、腾讯云等短信平台，提供统一的短信客户端，提供给 service/sms 短信【业务】模块来调用。\n\n\n# 5.1 smsclient\n\nsmsclient 接口，定义短信客户端的方法。代码如下：\n\n\n\n每个短信平台，都对应一个 smsclient 实现类。\n\n\n\n\n# 5.2 对接其它短信平台\n\n如果你想要对接其它短信平台，自定义一个 smsclient 实现类，并使用 smsclientfactoryimpl 进行创建。代码如下：\n\n\n\n\n# 6. 短信平台附录\n\n一般情况下，建议接入 2-3 个短信平台，避免某个短信平台故障时，影响业务的正常运行。\n\n例如说，手机验证码的短信平台 a 故障时，赶紧将短信验证码切换到短信平台 b 上，否则用户将无法正常登录或是注册。\n\n\n# 6.1 阿里云\n\n① 短信 api 的账号、密钥，可通过 阿里云 —— accesskey 获取。\n\n② 短信发送回调 url，可通过 阿里云 —— 短信服务 —— 通用设置 配置。它对应的是 smscallbackcontroller 的 #receivealiyunsmsstatus(...) 地址。\n\n\n# 6.2 腾讯云\n\n① 短信 api 的账号、密钥，可通过 腾讯云 —— api 密钥管理 获取。\n\n注意！！！\n\n腾讯云需要额外使用 sdkappid 参数，它的账号需要采用 secretid sdkappid 格式。\n\n例如说：在“api 密钥管理”获得了 secretid 为 a，secretkey 为 b，在“sdkappid”获得了 sdkappid 为 18，则配置短信 api 的账号为 a 18，短信 api 的密钥为 b。\n\n② 短信发送回调 url，可通过 腾讯云 —— 短信 —— 基础配置 配置。它对应的是 smscallbackcontroller 的 #receivetencentsmsstatus(...) 地址。\n\n\n# 6.3 华为云\n\n① 短信 api 的账号、密钥，可通过 华为云 —— 访问密钥 获取。\n\n注意！！！\n\n华为云需要额外使用 sender 通道号，它的账号需要采用 accesskeyid sender 格式。\n\n例如说：在“华为云访问密钥”获得了 accesskeyid 为 a，secretaccesskey 为 b，在“华为云签名”获得了 sender 为 8824060312575，则配置短信 api 的账号为 a 8824060312575，短信 api 的密钥为 b。\n\n② 短信发送回调 url，可以通过我们项目的 [系统管理 -> 消息中心 -> 短信管理 -> 短信渠道] 菜单，配置它的“短信发送回调 url”字段即可。它对应的是 smscallbackcontroller 的 #receivehuaweismsstatus(...) 地址。\n\n\n# 6.4 七牛云\n\n① 短信 api 的账号、密钥，可通过 七牛云 —— 密钥管理 获取。\n\n② 短信发送回调 url，可通过 七牛云 —— 云短信 —— 设置 配置。它对应的是 smscallbackcontroller 的 #receiveqiniusmsstatus(...) 地址。\n\n\n# 6.5 更多短信平台\n\n短信平台非常的多，欢迎给我们 pull request 贡献。\n\n例如说：合一、云片、京东云、容联云、亿美软通、天翼云、网易云等等。\n\n如果你想参与，可以添加 wangwenbin-server 微信好，备注“短信”即可。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "公众号图文",
            frontmatter: {
                title: "公众号图文",
                date: "2023-01-30T00:11:58.000Z",
                permalink: "/mp/article/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/18.%E5%85%AC%E4%BC%97%E5%8F%B7%E6%89%8B%E5%86%8C/09.%E5%85%AC%E4%BC%97%E5%8F%B7%E5%9B%BE%E6%96%87.html",
            relativePath: "01.开发指南/18.公众号手册/09.公众号图文.md",
            key: "v-3e3c0a92",
            path: "/mp/article/",
            headers: [{
                level: 2,
                title: "1. 表结构",
                slug: "_1-表结构",
                normalizedTitle: "1. 表结构",
                charIndex: 140
            }, {
                level: 2,
                title: "2. 图文草稿箱界面",
                slug: "_2-图文草稿箱界面",
                normalizedTitle: "2. 图文草稿箱界面",
                charIndex: 235
            }, {
                level: 2,
                title: "3. 图文发表记录界面",
                slug: "_3-图文发表记录界面",
                normalizedTitle: "3. 图文发表记录界面",
                charIndex: 298
            }],
            headersStr: "1. 表结构 2. 图文草稿箱界面 3. 图文发表记录界面",
            content: "本章节，讲解公众号图文的相关内容，包括两部分：\n\n① 在 [公众号管理 -> 图文草稿箱] 菜单中，创建一个图文草稿。如下图所示：\n\n\n\n② 点击【发布】按钮，将图文草稿发布到公众号，成为一个图文记录，展示在 [公众号管理 -> 图文发表记录] 菜单中。如下图所示：\n\n\n\n\n# 1. 表结构\n\n暂无，全部基于微信公众号提供的 API 接口。\n\n * 图文草稿箱：《微信公众号官方文档 —— 草稿箱》\n * 图文发表记录：《微信公众号官方文档 —— 发布能力》\n\n\n# 2. 图文草稿箱界面\n\n * 前端：/@views/mp/draft\n * 后端：MpDraftController\n\n\n# 3. 图文发表记录界面\n\n * 前端：/@views/mp/freePublish\n * 后端：MpFreePublishController",
            normalizedContent: "本章节，讲解公众号图文的相关内容，包括两部分：\n\n① 在 [公众号管理 -> 图文草稿箱] 菜单中，创建一个图文草稿。如下图所示：\n\n\n\n② 点击【发布】按钮，将图文草稿发布到公众号，成为一个图文记录，展示在 [公众号管理 -> 图文发表记录] 菜单中。如下图所示：\n\n\n\n\n# 1. 表结构\n\n暂无，全部基于微信公众号提供的 api 接口。\n\n * 图文草稿箱：《微信公众号官方文档 —— 草稿箱》\n * 图文发表记录：《微信公众号官方文档 —— 发布能力》\n\n\n# 2. 图文草稿箱界面\n\n * 前端：/@views/mp/draft\n * 后端：mpdraftcontroller\n\n\n# 3. 图文发表记录界面\n\n * 前端：/@views/mp/freepublish\n * 后端：mpfreepublishcontroller",
            charsets: {
                cjk: !0
            }
        }, {
            title: "敏感词",
            frontmatter: {
                title: "敏感词",
                date: "2022-12-31T18:35:58.000Z",
                permalink: "/sensitive-word"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/19.%E7%B3%BB%E7%BB%9F%E6%89%8B%E5%86%8C/46.%E6%95%8F%E6%84%9F%E8%AF%8D.html",
            relativePath: "01.开发指南/19.系统手册/46.敏感词.md",
            key: "v-1d0606ec",
            path: "/sensitive-word/",
            headers: [{
                level: 2,
                title: "1. 实现原理",
                slug: "_1-实现原理",
                normalizedTitle: "1. 实现原理",
                charIndex: 189
            }, {
                level: 2,
                title: "2. 使用教程",
                slug: "_2-使用教程",
                normalizedTitle: "2. 使用教程",
                charIndex: 236
            }, {
                level: 3,
                title: "2.1 添加敏感词",
                slug: "_2-1-添加敏感词",
                normalizedTitle: "2.1 添加敏感词",
                charIndex: 361
            }, {
                level: 3,
                title: "2.2 测试敏感词",
                slug: "_2-2-测试敏感词",
                normalizedTitle: "2.2 测试敏感词",
                charIndex: 435
            }, {
                level: 2,
                title: "3. 敏感词的使用",
                slug: "_3-敏感词的使用",
                normalizedTitle: "3. 敏感词的使用",
                charIndex: 514
            }],
            headersStr: "1. 实现原理 2. 使用教程 2.1 添加敏感词 2.2 测试敏感词 3. 敏感词的使用",
            content: '友情提示：\n\n最新版本的代码，已经移除“敏感词”功能。原因是，该功能比较小众，可能只有极少数的用户需要~\n\n如果你系统里需要，可以参考 9a31613（后端）、0925253（前端） 把代码复制、粘贴回来。\n\n本章节，介绍项目的敏感词功能，可用于文本检测，高效过滤色情、广告、敏感、暴恐等违规内容。例如说，用户昵称、评论、私信等文本内容，都可以使用敏感词功能进行过滤。\n\n\n# 1. 实现原理\n\n敏感词采用 前缀树 算法，，核心代码见 SimpleTrie 类。\n\n\n# 2. 使用教程\n\n对应的管理后台，可以在 [系统管理 -> 敏感词] 菜单，进行敏感词的管理。如下图所示：\n\n\n\n * 前端实现：sensitiveWord/index.vue\n * 后端实现：SensitiveWordController\n\n\n# 2.1 添加敏感词\n\n\n\n * 标签：用于敏感词分组，不同的场景会需要使用不同的敏感词，通过标签进行分组。\n\n添加完敏感词后，刷新下界面。\n\n\n# 2.2 测试敏感词\n\n① 输入检测文本为“你是白痴么？”，选择标签为“测试”，检测到有敏感词：\n\n\n\n② 选择标签为“蔬菜”，检测到米有敏感词：\n\n\n\n\n# 3. 敏感词的使用\n\nSensitiveWordApi 提供了敏感词的 API 接口，可以在任意地方使用。方法如下：\n\npublic interface SensitiveWordApi {\n\n    /**\n     * 获得文本所包含的不合法的敏感词数组\n     *\n     * @param text 文本\n     * @param tags 标签数组\n     * @return 不合法的敏感词数组\n     */\n    List<String> validateText(String text, List<String> tags);\n\n    /**\n     * 判断文本是否包含敏感词\n     *\n     * @param text 文本\n     * @param tags 表述数组\n     * @return 是否包含\n     */\n    boolean isTextValid(String text, List<String> tags);\n\n}\n\n\n使用步骤如下：\n\n① 在需要使用的 yudao-module-*-biz 模块的 pom.xml 中，引入 yudao-module-system-api 依赖。代码如下：\n\n<dependency>\n    <groupId>cn.iocoder.boot</groupId>\n    <artifactId>yudao-module-system-api</artifactId>\n    <version>${revision}</version>\n</dependency>\n\n\n② 注入 SensitiveWordApi Bean，调用对应的方法即可。例如说：\n\n@Service\npublic class DemoService {\n\n    @Resource\n    private SensitiveWordApi sensitiveWordApi;\n\n    public void demo() {\n        sensitiveWordApi.validateText("你是白痴吗", Collections.singletonList("测试"));\n        sensitiveWordApi.isTextValid("你是白痴吗", Collections.singletonList("蔬菜"));\n    }\n\n}\n',
            normalizedContent: '友情提示：\n\n最新版本的代码，已经移除“敏感词”功能。原因是，该功能比较小众，可能只有极少数的用户需要~\n\n如果你系统里需要，可以参考 9a31613（后端）、0925253（前端） 把代码复制、粘贴回来。\n\n本章节，介绍项目的敏感词功能，可用于文本检测，高效过滤色情、广告、敏感、暴恐等违规内容。例如说，用户昵称、评论、私信等文本内容，都可以使用敏感词功能进行过滤。\n\n\n# 1. 实现原理\n\n敏感词采用 前缀树 算法，，核心代码见 simpletrie 类。\n\n\n# 2. 使用教程\n\n对应的管理后台，可以在 [系统管理 -> 敏感词] 菜单，进行敏感词的管理。如下图所示：\n\n\n\n * 前端实现：sensitiveword/index.vue\n * 后端实现：sensitivewordcontroller\n\n\n# 2.1 添加敏感词\n\n\n\n * 标签：用于敏感词分组，不同的场景会需要使用不同的敏感词，通过标签进行分组。\n\n添加完敏感词后，刷新下界面。\n\n\n# 2.2 测试敏感词\n\n① 输入检测文本为“你是白痴么？”，选择标签为“测试”，检测到有敏感词：\n\n\n\n② 选择标签为“蔬菜”，检测到米有敏感词：\n\n\n\n\n# 3. 敏感词的使用\n\nsensitivewordapi 提供了敏感词的 api 接口，可以在任意地方使用。方法如下：\n\npublic interface sensitivewordapi {\n\n    /**\n     * 获得文本所包含的不合法的敏感词数组\n     *\n     * @param text 文本\n     * @param tags 标签数组\n     * @return 不合法的敏感词数组\n     */\n    list<string> validatetext(string text, list<string> tags);\n\n    /**\n     * 判断文本是否包含敏感词\n     *\n     * @param text 文本\n     * @param tags 表述数组\n     * @return 是否包含\n     */\n    boolean istextvalid(string text, list<string> tags);\n\n}\n\n\n使用步骤如下：\n\n① 在需要使用的 yudao-module-*-biz 模块的 pom.xml 中，引入 yudao-module-system-api 依赖。代码如下：\n\n<dependency>\n    <groupid>cn.iocoder.boot</groupid>\n    <artifactid>yudao-module-system-api</artifactid>\n    <version>${revision}</version>\n</dependency>\n\n\n② 注入 sensitivewordapi bean，调用对应的方法即可。例如说：\n\n@service\npublic class demoservice {\n\n    @resource\n    private sensitivewordapi sensitivewordapi;\n\n    public void demo() {\n        sensitivewordapi.validatetext("你是白痴吗", collections.singletonlist("测试"));\n        sensitivewordapi.istextvalid("你是白痴吗", collections.singletonlist("蔬菜"));\n    }\n\n}\n',
            charsets: {
                cjk: !0
            }
        }, {
            title: "数据脱敏、字段权限",
            frontmatter: {
                title: "数据脱敏、字段权限",
                date: "2023-01-21T07:47:58.000Z",
                permalink: "/desensitize"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/19.%E7%B3%BB%E7%BB%9F%E6%89%8B%E5%86%8C/45.%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F.html",
            relativePath: "01.开发指南/19.系统手册/45.数据脱敏.md",
            key: "v-59619c72",
            path: "/desensitize/",
            headers: [{
                level: 2,
                title: "1. 脱敏组件",
                slug: "_1-脱敏组件",
                normalizedTitle: "1. 脱敏组件",
                charIndex: 216
            }, {
                level: 2,
                title: "2. 内置脱敏注解",
                slug: "_2-内置脱敏注解",
                normalizedTitle: "2. 内置脱敏注解",
                charIndex: 470
            }, {
                level: 3,
                title: "2.1 regex 正则脱敏",
                slug: "_2-1-regex-正则脱敏",
                normalizedTitle: "2.1 regex 正则脱敏",
                charIndex: 520
            }, {
                level: 3,
                title: "2.2 slider 滑块脱敏",
                slug: "_2-2-slider-滑块脱敏",
                normalizedTitle: "2.2 slider 滑块脱敏",
                charIndex: 1214
            }, {
                level: 2,
                title: "3. 自定义脱敏注解",
                slug: "_3-自定义脱敏注解",
                normalizedTitle: "3. 自定义脱敏注解",
                charIndex: 2094
            }, {
                level: 2,
                title: "4. 脱敏工具类",
                slug: "_4-脱敏工具类",
                normalizedTitle: "4. 脱敏工具类",
                charIndex: 3714
            }, {
                level: 2,
                title: "5. 字段权限",
                slug: "_5-字段权限",
                normalizedTitle: "5. 字段权限",
                charIndex: 4991
            }, {
                level: 3,
                title: "5.1 基于角色判断",
                slug: "_5-1-基于角色判断",
                normalizedTitle: "5.1 基于角色判断",
                charIndex: 5168
            }, {
                level: 3,
                title: "5.2 基于权限判断",
                slug: "_5-2-基于权限判断",
                normalizedTitle: "5.2 基于权限判断",
                charIndex: 5317
            }],
            headersStr: "1. 脱敏组件 2. 内置脱敏注解 2.1 regex 正则脱敏 2.2 slider 滑块脱敏 3. 自定义脱敏注解 4. 脱敏工具类 5. 字段权限 5.1 基于角色判断 5.2 基于权限判断",
            content: '接口在返回一些敏感或隐私数据时，是需要进行脱敏处理，通常的手段是使用 * 隐藏一部分数据。例如说：\n\n类型    原始数据                 脱敏数据\n手机    13248765917          132****5917\n身份证   530321199204074611   530321**********11\n银行卡   9988002866797031     998800********31\n\n\n# 1. 脱敏组件\n\n脱敏组件，由 yudao-spring-boot-starter-web 的 desensitize 包实现，基于 Jackson 拓展，只需要在字段上添加脱敏注解，即可实现对该字段进行脱敏。\n\n使用步骤如下：\n\n在字段上添加脱敏注解。如下所示：\n\n@Data\npublic static class DesensitizeDemo {\n\n    @MobileDesensitize // 手机号的脱敏注解\n    private String phoneNumber;\n\n}\n\n\n\n# 2. 内置脱敏注解\n\n根据不同的脱敏处理方式，项目内置了两类脱敏注解：正则脱敏、滑块脱敏。\n\n\n# 2.1 regex 正则脱敏\n\n# 2.1.1 @RegexDesensitize 注解\n\n正则脱敏注解 @RegexDesensitize：根据正则表达式，将原始数据进行替换处理。\n\npublic @interface RegexDesensitize {\n\n    /**\n     * 匹配的正则表达式（默认匹配所有）\n     */\n    String regex() default "^[\\\\s\\\\S]*$";\n\n    /**\n     * 替换规则，会将匹配到的字符串全部替换成 replacer\n     */\n    String replacer() default "******";\n\n}\n\n\n例如说：regex=123; replacer=****** 表示将 123 替换为 ******\n\n * 原始字符串 123456789\n * 脱敏后字符串 ******456789\n\n# 2.1.2 其它正则脱敏注解\n\n项目内置了其它基于正则脱敏的常用注解，无需手动填写 regex、replacer 属性，更加方便。例如说：\n\n@Data\npublic static class DesensitizeDemo {\n    \n    @EmailDesensitize\n    private String email;\n\n}\n\n\n所有注解如下：\n\n注解                  原始数据                脱敏数据\n@EmailDesensitize   example@gmail.com   e****@gmail.com\n\n\n# 2.2 slider 滑块脱敏\n\n# 2.2.1 @SliderDesensitize 注解\n\n滑块脱敏注解 @SliderDesensitize：根据设置的左右明文字符长度，中间部分全部替换为 *。\n\n例如说：prefixKeep=3; suffixKeep=4; replacer=* 表示前 3 后 4 保持明文，中间都替换成 *\n\n * 原始字符串 13248765917\n * 脱敏后字符串 132****5917\n\n# 2.2.2 其它滑块脱敏注解\n\n项目内置了其它基于滑块脱敏的常用注解，无需手动填写 prefixKeep、suffixKeep、replacer 属性，更加方便。例如说：\n\n@Data\npublic static class DesensitizeDemo {\n    \n    @MobileDesensitize\n    private String mobile;\n\n}\n\n\n所有注解如下：\n\n注解                        原始数据                 脱敏数据\n@MobileDesensitize        13248765917          132****5917\n@FixedPhoneDesensitize    01086551122          0108*****22\n@BankCardDesensitize      9988002866797031     998800********31\n@PasswordDesensitize      123456               ******\n@CarLicenseDesensitize    粤A66666              粤A6***6\n@ChineseNameDesensitize   刘子豪                  刘**\n@IdCardDesensitize        530321199204074611   530321**********11\n\n\n# 3. 自定义脱敏注解\n\n如果内置的注解无法满足你的需求，只需要自定义一个脱敏注解，并实现它的脱敏处理器即可。\n\n例如说，我们要实现一个新的脱敏处理方法，将编号使用 MD5 或 SHA256 计算后返回。步骤如下：\n\n① 创建 @DigestDesensitize 注解，使用 @DesensitizeBy 标记它使用的处理器。代码如下：\n\nimport cn.iocoder.yudao.framework.desensitize.core.base.annotation.DesensitizeBy;\nimport cn.iocoder.yudao.framework.desensitize.core.handler.DigestHandler;\nimport com.fasterxml.jackson.annotation.JacksonAnnotationsInside;\n\nimport java.lang.annotation.*;\n\n@Documented\n@Target({ElementType.FIELD})\n@Retention(RetentionPolicy.RUNTIME)\n@JacksonAnnotationsInside\n@DesensitizeBy(handler = DigestHandler.class) // 使用 @DesensitizeBy 设置它的处理器\npublic @interface DigestDesensitize {\n\n    /**\n     * 摘要算法，例如说：MD5、SHA256\n     */\n    String algorithm() default "md5";\n\n}\n\n\n② 创建 DigestHandler 类，实现 DesensitizationHandler 接口，将编号使用 MD5 或 SHA256 处理。代码如下：\n\nimport cn.hutool.crypto.digest.DigestUtil;\nimport cn.iocoder.yudao.framework.desensitize.core.annotation.DigestDesensitize;\nimport cn.iocoder.yudao.framework.desensitize.core.base.handler.DesensitizationHandler;\n\npublic class DigestHandler implements DesensitizationHandler<DigestDesensitize> {\n\n    @Override\n    public String desensitize(String origin, DigestDesensitize annotation) {\n        String algorithm = annotation.algorithm();\n        return DigestUtil.digester(algorithm).digestHex(origin);\n    }\n\n}\n\n\n友情提示：\n\n① 如果自定义的是基于正则脱敏的注解，可选择继承 AbstractRegexDesensitizationHandler 处理器。\n\n① 如果自定义的是基于滑块脱敏的注解，可选择继承 AbstractSliderDesensitizationHandler 处理器。\n\n③ 在需要使用的字段上，添加 @DigestDesensitize 注解。示例代码如下：\n\n@Data\npublic static class DesensitizeDemo {\n    \n    @DigestDesensitize\n    private String email;\n\n}\n\n\n完事~\n\n\n# 4. 脱敏工具类\n\nHutool 提供了 DesensitizedUtil 脱敏工具类，支持用户 ID、 中文名、身份证、座机号、手机号、 地址、电子邮件、 密码、车牌、银行卡号的脱敏处理。\n\n使用方式，代码如下：\n\nDesensitizedUtil.desensitized("100", DesensitizedUtils.DesensitizedType.USER_ID)) =  "0"\nDesensitizedUtil.desensitized("段正淳", DesensitizedUtils.DesensitizedType.CHINESE_NAME)) = "段**"\nDesensitizedUtil.desensitized("51343620000320711X", DesensitizedUtils.DesensitizedType.ID_CARD)) = "5***************1X"\nDesensitizedUtil.desensitized("09157518479", DesensitizedUtils.DesensitizedType.FIXED_PHONE)) = "0915*****79"\nDesensitizedUtil.desensitized("18049531999", DesensitizedUtils.DesensitizedType.MOBILE_PHONE)) = "180****1999"\nDesensitizedUtil.desensitized("北京市海淀区马连洼街道289号", DesensitizedUtils.DesensitizedType.ADDRESS)) = "北京市海淀区马********"\nDesensitizedUtil.desensitized("duandazhi-jack@gmail.com.cn", DesensitizedUtils.DesensitizedType.EMAIL)) = "d*************@gmail.com.cn"\nDesensitizedUtil.desensitized("1234567890", DesensitizedUtils.DesensitizedType.PASSWORD)) = "**********"\nDesensitizedUtil.desensitized("苏D40000", DesensitizedUtils.DesensitizedType.CAR_LICENSE)) = "苏D4***0"\nDesensitizedUtil.desensitized("11011111222233333256", DesensitizedUtils.DesensitizedType.BANK_CARD)) = "1101 **** **** **** 3256"\n\n\n适合场景，逻辑里需要直接对某个变量进行脱敏处理，然后打印 logger 日志，或者存储到数据库中。\n\n\n# 5. 字段权限\n\n通过数据脱敏，可以实现一定程度的字段权限，通过每个脱敏注解上的 disable 属性。例如说：\n\n// @MobileDesensitize.java\n\n/**\n * 是否禁用脱敏\n *\n * 支持 Spring EL 表达式，如果返回 true 则跳过脱敏\n */\nString disable() default "";\n\n\n\n# 5.1 基于角色判断\n\n例如说：只有超管可以查看完整手机号，其它用户只能查看脱敏后的手机号。\n\n// XXXVO.java\n\n@EmailDesensitize(disable = "@ss.hasRole(\'super_admin\')")\nprivate String mobile;\n\n\n\n# 5.2 基于权限判断\n\n再例如说：只有拥有 user:info:query-mobile 权限的用户，才能查看完整手机号。\n\n// XXXVO.java\n\n@EmailDesensitize(disable = "!@ss.hasPermission(\'user:info:query-mobile\')")\n',
            normalizedContent: '接口在返回一些敏感或隐私数据时，是需要进行脱敏处理，通常的手段是使用 * 隐藏一部分数据。例如说：\n\n类型    原始数据                 脱敏数据\n手机    13248765917          132****5917\n身份证   530321199204074611   530321**********11\n银行卡   9988002866797031     998800********31\n\n\n# 1. 脱敏组件\n\n脱敏组件，由 yudao-spring-boot-starter-web 的 desensitize 包实现，基于 jackson 拓展，只需要在字段上添加脱敏注解，即可实现对该字段进行脱敏。\n\n使用步骤如下：\n\n在字段上添加脱敏注解。如下所示：\n\n@data\npublic static class desensitizedemo {\n\n    @mobiledesensitize // 手机号的脱敏注解\n    private string phonenumber;\n\n}\n\n\n\n# 2. 内置脱敏注解\n\n根据不同的脱敏处理方式，项目内置了两类脱敏注解：正则脱敏、滑块脱敏。\n\n\n# 2.1 regex 正则脱敏\n\n# 2.1.1 @regexdesensitize 注解\n\n正则脱敏注解 @regexdesensitize：根据正则表达式，将原始数据进行替换处理。\n\npublic @interface regexdesensitize {\n\n    /**\n     * 匹配的正则表达式（默认匹配所有）\n     */\n    string regex() default "^[\\\\s\\\\s]*$";\n\n    /**\n     * 替换规则，会将匹配到的字符串全部替换成 replacer\n     */\n    string replacer() default "******";\n\n}\n\n\n例如说：regex=123; replacer=****** 表示将 123 替换为 ******\n\n * 原始字符串 123456789\n * 脱敏后字符串 ******456789\n\n# 2.1.2 其它正则脱敏注解\n\n项目内置了其它基于正则脱敏的常用注解，无需手动填写 regex、replacer 属性，更加方便。例如说：\n\n@data\npublic static class desensitizedemo {\n    \n    @emaildesensitize\n    private string email;\n\n}\n\n\n所有注解如下：\n\n注解                  原始数据                脱敏数据\n@emaildesensitize   example@gmail.com   e****@gmail.com\n\n\n# 2.2 slider 滑块脱敏\n\n# 2.2.1 @sliderdesensitize 注解\n\n滑块脱敏注解 @sliderdesensitize：根据设置的左右明文字符长度，中间部分全部替换为 *。\n\n例如说：prefixkeep=3; suffixkeep=4; replacer=* 表示前 3 后 4 保持明文，中间都替换成 *\n\n * 原始字符串 13248765917\n * 脱敏后字符串 132****5917\n\n# 2.2.2 其它滑块脱敏注解\n\n项目内置了其它基于滑块脱敏的常用注解，无需手动填写 prefixkeep、suffixkeep、replacer 属性，更加方便。例如说：\n\n@data\npublic static class desensitizedemo {\n    \n    @mobiledesensitize\n    private string mobile;\n\n}\n\n\n所有注解如下：\n\n注解                        原始数据                 脱敏数据\n@mobiledesensitize        13248765917          132****5917\n@fixedphonedesensitize    01086551122          0108*****22\n@bankcarddesensitize      9988002866797031     998800********31\n@passworddesensitize      123456               ******\n@carlicensedesensitize    粤a66666              粤a6***6\n@chinesenamedesensitize   刘子豪                  刘**\n@idcarddesensitize        530321199204074611   530321**********11\n\n\n# 3. 自定义脱敏注解\n\n如果内置的注解无法满足你的需求，只需要自定义一个脱敏注解，并实现它的脱敏处理器即可。\n\n例如说，我们要实现一个新的脱敏处理方法，将编号使用 md5 或 sha256 计算后返回。步骤如下：\n\n① 创建 @digestdesensitize 注解，使用 @desensitizeby 标记它使用的处理器。代码如下：\n\nimport cn.iocoder.yudao.framework.desensitize.core.base.annotation.desensitizeby;\nimport cn.iocoder.yudao.framework.desensitize.core.handler.digesthandler;\nimport com.fasterxml.jackson.annotation.jacksonannotationsinside;\n\nimport java.lang.annotation.*;\n\n@documented\n@target({elementtype.field})\n@retention(retentionpolicy.runtime)\n@jacksonannotationsinside\n@desensitizeby(handler = digesthandler.class) // 使用 @desensitizeby 设置它的处理器\npublic @interface digestdesensitize {\n\n    /**\n     * 摘要算法，例如说：md5、sha256\n     */\n    string algorithm() default "md5";\n\n}\n\n\n② 创建 digesthandler 类，实现 desensitizationhandler 接口，将编号使用 md5 或 sha256 处理。代码如下：\n\nimport cn.hutool.crypto.digest.digestutil;\nimport cn.iocoder.yudao.framework.desensitize.core.annotation.digestdesensitize;\nimport cn.iocoder.yudao.framework.desensitize.core.base.handler.desensitizationhandler;\n\npublic class digesthandler implements desensitizationhandler<digestdesensitize> {\n\n    @override\n    public string desensitize(string origin, digestdesensitize annotation) {\n        string algorithm = annotation.algorithm();\n        return digestutil.digester(algorithm).digesthex(origin);\n    }\n\n}\n\n\n友情提示：\n\n① 如果自定义的是基于正则脱敏的注解，可选择继承 abstractregexdesensitizationhandler 处理器。\n\n① 如果自定义的是基于滑块脱敏的注解，可选择继承 abstractsliderdesensitizationhandler 处理器。\n\n③ 在需要使用的字段上，添加 @digestdesensitize 注解。示例代码如下：\n\n@data\npublic static class desensitizedemo {\n    \n    @digestdesensitize\n    private string email;\n\n}\n\n\n完事~\n\n\n# 4. 脱敏工具类\n\nhutool 提供了 desensitizedutil 脱敏工具类，支持用户 id、 中文名、身份证、座机号、手机号、 地址、电子邮件、 密码、车牌、银行卡号的脱敏处理。\n\n使用方式，代码如下：\n\ndesensitizedutil.desensitized("100", desensitizedutils.desensitizedtype.user_id)) =  "0"\ndesensitizedutil.desensitized("段正淳", desensitizedutils.desensitizedtype.chinese_name)) = "段**"\ndesensitizedutil.desensitized("51343620000320711x", desensitizedutils.desensitizedtype.id_card)) = "5***************1x"\ndesensitizedutil.desensitized("09157518479", desensitizedutils.desensitizedtype.fixed_phone)) = "0915*****79"\ndesensitizedutil.desensitized("18049531999", desensitizedutils.desensitizedtype.mobile_phone)) = "180****1999"\ndesensitizedutil.desensitized("北京市海淀区马连洼街道289号", desensitizedutils.desensitizedtype.address)) = "北京市海淀区马********"\ndesensitizedutil.desensitized("duandazhi-jack@gmail.com.cn", desensitizedutils.desensitizedtype.email)) = "d*************@gmail.com.cn"\ndesensitizedutil.desensitized("1234567890", desensitizedutils.desensitizedtype.password)) = "**********"\ndesensitizedutil.desensitized("苏d40000", desensitizedutils.desensitizedtype.car_license)) = "苏d4***0"\ndesensitizedutil.desensitized("11011111222233333256", desensitizedutils.desensitizedtype.bank_card)) = "1101 **** **** **** 3256"\n\n\n适合场景，逻辑里需要直接对某个变量进行脱敏处理，然后打印 logger 日志，或者存储到数据库中。\n\n\n# 5. 字段权限\n\n通过数据脱敏，可以实现一定程度的字段权限，通过每个脱敏注解上的 disable 属性。例如说：\n\n// @mobiledesensitize.java\n\n/**\n * 是否禁用脱敏\n *\n * 支持 spring el 表达式，如果返回 true 则跳过脱敏\n */\nstring disable() default "";\n\n\n\n# 5.1 基于角色判断\n\n例如说：只有超管可以查看完整手机号，其它用户只能查看脱敏后的手机号。\n\n// xxxvo.java\n\n@emaildesensitize(disable = "@ss.hasrole(\'super_admin\')")\nprivate string mobile;\n\n\n\n# 5.2 基于权限判断\n\n再例如说：只有拥有 user:info:query-mobile 权限的用户，才能查看完整手机号。\n\n// xxxvo.java\n\n@emaildesensitize(disable = "!@ss.haspermission(\'user:info:query-mobile\')")\n',
            charsets: {
                cjk: !0
            }
        }, {
            title: "站内信配置",
            frontmatter: {
                title: "站内信配置",
                date: "2023-01-28T20:42:42.000Z",
                permalink: "/notify"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/19.%E7%B3%BB%E7%BB%9F%E6%89%8B%E5%86%8C/42.%E7%AB%99%E5%86%85%E4%BF%A1%E9%85%8D%E7%BD%AE.html",
            relativePath: "01.开发指南/19.系统手册/42.站内信配置.md",
            key: "v-1f164a08",
            path: "/notify/",
            headers: [{
                level: 2,
                title: "1. 表结构",
                slug: "_1-表结构",
                normalizedTitle: "1. 表结构",
                charIndex: 102
            }, {
                level: 2,
                title: "2. 实现代码",
                slug: "_2-实现代码",
                normalizedTitle: "2. 实现代码",
                charIndex: 115
            }, {
                level: 2,
                title: "3. 站内信配置",
                slug: "_3-站内信配置",
                normalizedTitle: "3. 站内信配置",
                charIndex: 188
            }, {
                level: 3,
                title: "3.1 新建站内信模版",
                slug: "_3-1-新建站内信模版",
                normalizedTitle: "3.1 新建站内信模版",
                charIndex: 289
            }, {
                level: 3,
                title: "3.2 测试站内信模版",
                slug: "_3-2-测试站内信模版",
                normalizedTitle: "3.2 测试站内信模版",
                charIndex: 688
            }, {
                level: 2,
                title: "4. 站内信发送",
                slug: "_4-站内信发送",
                normalizedTitle: "4. 站内信发送",
                charIndex: 858
            }, {
                level: 3,
                title: "4.1 NotifyMessageSendApi",
                slug: "_4-1-notifymessagesendapi",
                normalizedTitle: "4.1 notifymessagesendapi",
                charIndex: 871
            }, {
                level: 3,
                title: "4.2 接入示例",
                slug: "_4-2-接入示例",
                normalizedTitle: "4.2 接入示例",
                charIndex: 963
            }],
            headersStr: "1. 表结构 2. 实现代码 3. 站内信配置 3.1 新建站内信模版 3.2 测试站内信模版 4. 站内信发送 4.1 NotifyMessageSendApi 4.2 接入示例",
            content: '本章节，介绍项目的站内信功能。它在管理后台有三个菜单，分别是：\n\n① 站内信模版：管理站内信的内容模版\n\n\n\n② 站内信管理：查看站内信的发送记录\n\n\n\n③ 我的站内信：查看发送给我的站内信\n\n\n\n\n# 1. 表结构\n\n\n\n\n# 2. 实现代码\n\n * 前端代码：views/system/notify\n * 后端代码：controller/admin/notify\n\n\n# 3. 站内信配置\n\n本小节，讲解如何配置站内信功能，整个过程如下：\n\n 1. 新建一个站内信【模版】，配置站内信的内容模版\n 2. 测试该站内信模板，查看对应的站内信【记录】，确认是否发送成功\n\n\n# 3.1 新建站内信模版\n\n① 点击 [系统管理 -> 消息中心 -> 站内信管理 -> 模板管理] 菜单，查看站内信模板的列表。如下图所示：\n\n\n\n② 点击 [新增] 按钮，填写信息如下图：\n\n\n\n * 模版编号：站内信模板的唯一标识，使用站内信 API 时，通过它标识使用的站内信模板\n * 发件人名称：发送站内信显示的发件人名字\n * 模板内容：站内信模板的内容，使用 {var} 作为占位符，例如说 {name}、{code} 等\n * 模版类型：站内信的分类，可使用 system_notify_template_type 字典进行自定义\n * 开启状态：站内信模板被禁用时，该站内信模板将不发送站内信，只打印 logger 日志\n\n疑问：为什么设计站内信模板的功能？\n\n在一些场景下，产品会希望修改发送站内信的内容、发送人昵称，此时只需要修改站内信模版的对应属性，无需重启应用。\n\n\n# 3.2 测试站内信模版\n\n① 点击 [测试] 按钮，选择接收人为「芋道源码」，进行该站内信模板的模拟发送。如下图所示：\n\n\n\n② 点击 [系统管理 -> 消息中心 -> 站内信管理 -> 消息记录] 菜单，可以查看到刚发送的站内信。如下图所示：\n\n\n\n③ 点击右上角的 [消息] 图标，也可以查看到刚发送的站内信。如下图所示：\n\n\n\n\n# 4. 站内信发送\n\n\n# 4.1 NotifyMessageSendApi\n\n站内信配置完成后，可使用 NotifyMessageSendApi 进行站内信的发送，支持多种用户类型。它的方法如下：\n\n\n\n\n# 4.2 接入示例\n\n以 yudao-module-infra 模块，需要发站内信为例子，讲解 SmsCodeApi 的使用。\n\n① 在 yudao-module-infra-biz 模块的 pom.xml 引入 yudao-module-system-api 依赖，如所示：\n\n<dependency>\n    <groupId>cn.iocoder.boot</groupId>\n    <artifactId>yudao-module-system-api</artifactId>\n    <version>${revision}</version>\n</dependency>\n\n\n② 在代码中注入 NotifyMessageSendApi Bean，并调用发送站内信的方法。代码如下：\n\npublic class TestDemoServiceImpl implements TestDemoService {\n\n    // 0. 注入 NotifyMessageSendApi Bean\n    @Resource\n    private NotifyMessageSendApi notifySendApi;\n\n    public void sendDemo() {\n        // 1. 准备参数\n        Long userId = 1L; // 示例中写死，你可以改成你业务中的 userId 噢\n        String templateCode = "test_01"; // 站内信模版，记得在【站内信管理】中配置噢\n        Map<String, Object> templateParams = new HashMap<>();\n        templateParams.put("key1", "奥特曼");\n        templateParams.put("key2", "变身");\n\n        // 2. 发送站内信\n        notifySendApi.sendSingleNotifylToAdmin(new NotifySendSingleToUserReqDTO()\n                .setUserId(userId).setTemplateCode(templateCode).setTemplateParams(templateParams));\n    }\n    \n}\n',
            normalizedContent: '本章节，介绍项目的站内信功能。它在管理后台有三个菜单，分别是：\n\n① 站内信模版：管理站内信的内容模版\n\n\n\n② 站内信管理：查看站内信的发送记录\n\n\n\n③ 我的站内信：查看发送给我的站内信\n\n\n\n\n# 1. 表结构\n\n\n\n\n# 2. 实现代码\n\n * 前端代码：views/system/notify\n * 后端代码：controller/admin/notify\n\n\n# 3. 站内信配置\n\n本小节，讲解如何配置站内信功能，整个过程如下：\n\n 1. 新建一个站内信【模版】，配置站内信的内容模版\n 2. 测试该站内信模板，查看对应的站内信【记录】，确认是否发送成功\n\n\n# 3.1 新建站内信模版\n\n① 点击 [系统管理 -> 消息中心 -> 站内信管理 -> 模板管理] 菜单，查看站内信模板的列表。如下图所示：\n\n\n\n② 点击 [新增] 按钮，填写信息如下图：\n\n\n\n * 模版编号：站内信模板的唯一标识，使用站内信 api 时，通过它标识使用的站内信模板\n * 发件人名称：发送站内信显示的发件人名字\n * 模板内容：站内信模板的内容，使用 {var} 作为占位符，例如说 {name}、{code} 等\n * 模版类型：站内信的分类，可使用 system_notify_template_type 字典进行自定义\n * 开启状态：站内信模板被禁用时，该站内信模板将不发送站内信，只打印 logger 日志\n\n疑问：为什么设计站内信模板的功能？\n\n在一些场景下，产品会希望修改发送站内信的内容、发送人昵称，此时只需要修改站内信模版的对应属性，无需重启应用。\n\n\n# 3.2 测试站内信模版\n\n① 点击 [测试] 按钮，选择接收人为「芋道源码」，进行该站内信模板的模拟发送。如下图所示：\n\n\n\n② 点击 [系统管理 -> 消息中心 -> 站内信管理 -> 消息记录] 菜单，可以查看到刚发送的站内信。如下图所示：\n\n\n\n③ 点击右上角的 [消息] 图标，也可以查看到刚发送的站内信。如下图所示：\n\n\n\n\n# 4. 站内信发送\n\n\n# 4.1 notifymessagesendapi\n\n站内信配置完成后，可使用 notifymessagesendapi 进行站内信的发送，支持多种用户类型。它的方法如下：\n\n\n\n\n# 4.2 接入示例\n\n以 yudao-module-infra 模块，需要发站内信为例子，讲解 smscodeapi 的使用。\n\n① 在 yudao-module-infra-biz 模块的 pom.xml 引入 yudao-module-system-api 依赖，如所示：\n\n<dependency>\n    <groupid>cn.iocoder.boot</groupid>\n    <artifactid>yudao-module-system-api</artifactid>\n    <version>${revision}</version>\n</dependency>\n\n\n② 在代码中注入 notifymessagesendapi bean，并调用发送站内信的方法。代码如下：\n\npublic class testdemoserviceimpl implements testdemoservice {\n\n    // 0. 注入 notifymessagesendapi bean\n    @resource\n    private notifymessagesendapi notifysendapi;\n\n    public void senddemo() {\n        // 1. 准备参数\n        long userid = 1l; // 示例中写死，你可以改成你业务中的 userid 噢\n        string templatecode = "test_01"; // 站内信模版，记得在【站内信管理】中配置噢\n        map<string, object> templateparams = new hashmap<>();\n        templateparams.put("key1", "奥特曼");\n        templateparams.put("key2", "变身");\n\n        // 2. 发送站内信\n        notifysendapi.sendsinglenotifyltoadmin(new notifysendsingletouserreqdto()\n                .setuserid(userid).settemplatecode(templatecode).settemplateparams(templateparams));\n    }\n    \n}\n',
            charsets: {
                cjk: !0
            }
        }, {
            title: "地区 & IP 库",
            frontmatter: {
                title: "地区 & IP 库",
                date: "2022-12-29T22:04:57.000Z",
                permalink: "/area-and-ip/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/19.%E7%B3%BB%E7%BB%9F%E6%89%8B%E5%86%8C/48.%E5%9C%B0%E5%8C%BA%20&%20IP.html",
            relativePath: "01.开发指南/19.系统手册/48.地区 & IP.md",
            key: "v-1573c0d7",
            path: "/area-and-ip/",
            headers: [{
                level: 2,
                title: "1. 地区",
                slug: "_1-地区",
                normalizedTitle: "1. 地区",
                charIndex: 58
            }, {
                level: 2,
                title: "2. IP",
                slug: "_2-ip",
                normalizedTitle: "2. ip",
                charIndex: 1253
            }],
            headersStr: "1. 地区 2. IP",
            content: "yudao-spring-boot-starter-biz-ip 业务组件，提供地区 & IP 库的封装。\n\n\n# 1. 地区\n\nAreaUtils 是地区工具类，可以查询中国的省、市、区县，也可以查询国外的国家。\n\n它的数据来自 Administrative-divisions-of-China 项目，最终整理到项目的 area.csv 文件。每一行的数据，对应 Area 对象。代码所示：\n\npublic class Area {\n\n    /**\n     * 编号\n     */\n    private Integer id;\n    /**\n     * 名字\n     */\n    private String name;\n    /**\n     * 类型\n     *\n     * 枚举 {@link AreaTypeEnum}\n     * 1 - 国家\n     * 2 - 省份\n     * 3 - 城市\n     * 4 - 地区, 例如说县、镇、区等\n     */\n    private Integer type;\n\n    /**\n     * 父节点\n     */\n    private Area parent;\n    /**\n     * 子节点\n     */\n    private List<Area> children;\n    \n}\n\n\nAreaUtils 主要有如下两个方法：\n\n// AreaUtils.java\n\n/**\n * 获得指定编号对应的区域\n *\n * @param id 区域编号\n * @return 区域\n */\npublic static Area getArea(Integer id) {\n    // ... 省略具体实现\n}\n\n/**\n * 格式化区域\n *\n * 例如说：\n *      1. id = “静安区”时：上海 上海市 静安区\n *      2. id = “上海市”时：上海 上海市\n *      3. id = “上海”时：上海\n *      4. id = “美国”时：美国\n * 当区域在中国时，默认不显示中国\n *\n * @param id 区域编号\n * @param separator 分隔符\n * @return 格式化后的区域\n */\npublic static String format(Integer id, String separator) {\n    // ... 省略具体实现\n}\n\n\n * 具体的使用，可见 AreaUtilsTest 测试类。\n\n另外，管理后台提供了 [系统管理 -> 地区管理] 菜单，可以按照树形结构查看地区列表。如下图所示：\n\n\n\n * 后端代码，对应 AreaController 的 /admin-api/system/area/tree 接口\n * 前端代码，对应 system/area/index.vue 界面\n\n\n# 2. IP\n\nIPUtils 是 IP 工具类，可以查询 IP 对应的城市信息。\n\n它的数据来自 ip2region 项目，最终整理到项目的 ip2region.xdb 文件。\n\nIPUtils 主要有如下两个方法：\n\n// IPUtils.java\n/**\n * 查询 IP 对应的地区编号\n *\n * @param ip IP 地址，格式为 127.0.0.1\n * @return 地区id\n */\npublic static Integer getAreaId(String ip) {\n    // ... 省略具体实现\n}\n\n/**\n * 查询 IP 对应的地区\n *\n * @param ip IP 地址，格式为 127.0.0.1\n * @return 地区\n */\npublic static Area getArea(String ip) {\n        // ... 省略具体实现\n}\n\n\n * 具体的使用，可见 IPUtilsTest 测试类。\n\n另外，管理后台提供了 [系统管理 -> 地区管理] 菜单，也提供了 IP 查询城市的示例。如下图所示：\n\n\n\n * 后端代码，对应 AreaController 的 /admin-api/system/area/get-by-ip 接口",
            normalizedContent: "yudao-spring-boot-starter-biz-ip 业务组件，提供地区 & ip 库的封装。\n\n\n# 1. 地区\n\nareautils 是地区工具类，可以查询中国的省、市、区县，也可以查询国外的国家。\n\n它的数据来自 administrative-divisions-of-china 项目，最终整理到项目的 area.csv 文件。每一行的数据，对应 area 对象。代码所示：\n\npublic class area {\n\n    /**\n     * 编号\n     */\n    private integer id;\n    /**\n     * 名字\n     */\n    private string name;\n    /**\n     * 类型\n     *\n     * 枚举 {@link areatypeenum}\n     * 1 - 国家\n     * 2 - 省份\n     * 3 - 城市\n     * 4 - 地区, 例如说县、镇、区等\n     */\n    private integer type;\n\n    /**\n     * 父节点\n     */\n    private area parent;\n    /**\n     * 子节点\n     */\n    private list<area> children;\n    \n}\n\n\nareautils 主要有如下两个方法：\n\n// areautils.java\n\n/**\n * 获得指定编号对应的区域\n *\n * @param id 区域编号\n * @return 区域\n */\npublic static area getarea(integer id) {\n    // ... 省略具体实现\n}\n\n/**\n * 格式化区域\n *\n * 例如说：\n *      1. id = “静安区”时：上海 上海市 静安区\n *      2. id = “上海市”时：上海 上海市\n *      3. id = “上海”时：上海\n *      4. id = “美国”时：美国\n * 当区域在中国时，默认不显示中国\n *\n * @param id 区域编号\n * @param separator 分隔符\n * @return 格式化后的区域\n */\npublic static string format(integer id, string separator) {\n    // ... 省略具体实现\n}\n\n\n * 具体的使用，可见 areautilstest 测试类。\n\n另外，管理后台提供了 [系统管理 -> 地区管理] 菜单，可以按照树形结构查看地区列表。如下图所示：\n\n\n\n * 后端代码，对应 areacontroller 的 /admin-api/system/area/tree 接口\n * 前端代码，对应 system/area/index.vue 界面\n\n\n# 2. ip\n\niputils 是 ip 工具类，可以查询 ip 对应的城市信息。\n\n它的数据来自 ip2region 项目，最终整理到项目的 ip2region.xdb 文件。\n\niputils 主要有如下两个方法：\n\n// iputils.java\n/**\n * 查询 ip 对应的地区编号\n *\n * @param ip ip 地址，格式为 127.0.0.1\n * @return 地区id\n */\npublic static integer getareaid(string ip) {\n    // ... 省略具体实现\n}\n\n/**\n * 查询 ip 对应的地区\n *\n * @param ip ip 地址，格式为 127.0.0.1\n * @return 地区\n */\npublic static area getarea(string ip) {\n        // ... 省略具体实现\n}\n\n\n * 具体的使用，可见 iputilstest 测试类。\n\n另外，管理后台提供了 [系统管理 -> 地区管理] 菜单，也提供了 ip 查询城市的示例。如下图所示：\n\n\n\n * 后端代码，对应 areacontroller 的 /admin-api/system/area/get-by-ip 接口",
            charsets: {
                cjk: !0
            }
        }, {
            title: "邮件配置",
            frontmatter: {
                title: "邮件配置",
                date: "2023-01-26T20:53:42.000Z",
                permalink: "/mail"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/19.%E7%B3%BB%E7%BB%9F%E6%89%8B%E5%86%8C/41.%E9%82%AE%E4%BB%B6%E9%85%8D%E7%BD%AE.html",
            relativePath: "01.开发指南/19.系统手册/41.邮件配置.md",
            key: "v-7b1df228",
            path: "/mail/",
            headers: [{
                level: 2,
                title: "1. 表结构",
                slug: "_1-表结构",
                normalizedTitle: "1. 表结构",
                charIndex: 95
            }, {
                level: 2,
                title: "2. 实现原理",
                slug: "_2-实现原理",
                normalizedTitle: "2. 实现原理",
                charIndex: 108
            }, {
                level: 2,
                title: "3. 邮箱配置",
                slug: "_3-邮箱配置",
                normalizedTitle: "3. 邮箱配置",
                charIndex: 289
            }, {
                level: 3,
                title: "3.1 新建邮箱账号",
                slug: "_3-1-新建邮箱账号",
                normalizedTitle: "3.1 新建邮箱账号",
                charIndex: 409
            }, {
                level: 3,
                title: "3.2 新建邮箱模版",
                slug: "_3-2-新建邮箱模版",
                normalizedTitle: "3.2 新建邮箱模版",
                charIndex: 1213
            }, {
                level: 3,
                title: "3.3 查看邮件日志",
                slug: "_3-3-查看邮件日志",
                normalizedTitle: "3.3 查看邮件日志",
                charIndex: 1592
            }, {
                level: 2,
                title: "4. 邮件发送",
                slug: "_4-邮件发送",
                normalizedTitle: "4. 邮件发送",
                charIndex: 1749
            }, {
                level: 3,
                title: "4.1 MailSendApi",
                slug: "_4-1-mailsendapi",
                normalizedTitle: "4.1 mailsendapi",
                charIndex: 1761
            }, {
                level: 3,
                title: "4.2 接入示例",
                slug: "_4-2-接入示例",
                normalizedTitle: "4.2 接入示例",
                charIndex: 1833
            }, {
                level: 2,
                title: "5. 邮箱平台附录",
                slug: "_5-邮箱平台附录",
                normalizedTitle: "5. 邮箱平台附录",
                charIndex: 583
            }],
            headersStr: "1. 表结构 2. 实现原理 3. 邮箱配置 3.1 新建邮箱账号 3.2 新建邮箱模版 3.3 查看邮件日志 4. 邮件发送 4.1 MailSendApi 4.2 接入示例 5. 邮箱平台附录",
            content: '本章节，介绍项目的邮件功能。它在管理后台有三个菜单，分别是：\n\n① 邮箱账号：配置邮件的发送账号\n\n\n\n② 邮件模版：管理邮件的内容模版\n\n\n\n③ 邮件记录：查看邮件的发送记录\n\n\n\n\n# 1. 表结构\n\n\n\n\n# 2. 实现原理\n\n邮件功能提供统一的 API 给其它模块，使它们可以快速实现发送邮件的功能，无需关心不同邮件平台的具体对接。\n\n邮件采用异步发送，基于 消息队列，如下图所示：\n\n\n\n * 前端代码：views/system/mail\n * 后端代码：controller/admin/mail\n\n最终使用 Hutool 的 MailUtil 发送邮件。\n\n\n# 3. 邮箱配置\n\n本小节，讲解如何配置邮件功能，整个过程如下：\n\n 1. 新建一个邮箱【账号】，配置邮件的发送账号\n 2. 新建一个邮件【模版】，配置邮件的内容模版\n 3. 测试该邮件模板，查看对应的邮件【日志】，确认是否发送成功\n\n\n# 3.1 新建邮箱账号\n\n① 点击 [系统管理 -> 消息中心 -> 邮件管理 -> 邮箱账号] 菜单，查看邮箱账号的列表。如下图所示：\n\n\n\n② 点击 [新增] 按钮，添加一个邮箱账号，并填写信息如下图：\n\n\n\n友情提示：\n\n邮件发送基于 SMTP 协议实现，需要开通账号的 STMP 服务。例如说：\n\n\n\n不同邮件平台的 SMTP 配置，可见 「5. 邮箱平台附录」 小节。\n\n③ 新增完成后，确认你的邮箱账号是否可以发送邮件，可通过如下代码：\n\nimport cn.hutool.extra.mail.MailAccount;\nimport cn.hutool.extra.mail.MailUtil;\n\n@Test\npublic void testDemo() {\n    MailAccount mailAccount = new MailAccount()\n//                .setFrom("奥特曼 <ydym_test@163.com>")\n            .setFrom("ydym_test@163.com") // 邮箱地址\n            .setHost("smtp.163.com").setPort(465).setSslEnable(true) // SMTP 服务器\n            .setAuth(true).setUser("ydym_test@163.com").setPass("WBZTEINMIFVRYSOE"); // 登录账号密码\n    String messageId = MailUtil.send(mailAccount, "7685413@qq.com", "主题", "内容", false);\n    System.out.println("发送结果：" + messageId);\n}\n\n\n\n# 3.2 新建邮箱模版\n\n① 点击 [系统管理 -> 消息中心 -> 邮箱管理 -> 邮件模板] 菜单，查看邮件模板的列表。如下图所示：\n\n\n\n② 点击 [新增] 按钮，选择刚创建的邮箱账号，并填写信息如下图：\n\n\n\n * 邮箱账号：发送该邮件模板时，使用的邮件账号，即使用哪个邮箱进行发送邮件\n * 模版编号：邮件模板的唯一标识，使用邮件 API 时，通过它标识使用的邮件模板\n * 发件人名称：发送邮件显示的发件人名字\n * 模板内容：邮件模板的内容，使用 {var} 作为占位符，例如说 {name}、{code} 等\n * 开启状态：邮件模板被禁用时，该邮件模板将不发送邮件，只记录邮件日志\n\n疑问：为什么设计邮件模板的功能？\n\n在一些场景下，产品会希望修改发送邮件的标题、内容，甚至邮箱账号，此时只需要修改邮件模版的对应属性，无需重启应用。\n\n\n# 3.3 查看邮件日志\n\n① 点击 [测试] 按钮，输入测试的收件邮箱地址，进行该邮件模板的模拟发送。如下图所示：\n\n\n\n② 打开收件邮箱，查看邮件是否发送成功。如下图所示：\n\n\n\n③ 点击 [系统管理 -> 消息中心 -> 邮箱管理 -> 邮件日志] 采单，可以查看到每条邮件的发送状态。如下图所示：\n\n\n\n\n# 4. 邮件发送\n\n\n# 4.1 MailSendApi\n\n邮箱配置完成后，可使用 MailSendApi 进行邮件的发送，支持多种用户类型。它的方法如下：\n\n\n\n\n# 4.2 接入示例\n\n以 yudao-module-infra 模块，需要发邮件为例子，讲解 SmsCodeApi 的使用。\n\n① 在 yudao-module-infra-biz 模块的 pom.xml 引入 yudao-module-system-api 依赖，如所示：\n\n<dependency>\n    <groupId>cn.iocoder.boot</groupId>\n    <artifactId>yudao-module-system-api</artifactId>\n    <version>${revision}</version>\n</dependency>\n\n\n② 在代码中注入 SmsCodeApi Bean，并调用发送邮件的方法。代码如下：\n\npublic class TestDemoServiceImpl implements TestDemoService {\n\n    // 0. 注入 MailSendApi Bean\n    @Resource\n    private MailSendApi mailSendApi;\n\n    public void sendDemo() {\n        // 1. 准备参数\n        Long userId = 1L; // 示例中写死，你可以改成你业务中的 userId 噢\n        String templateCode = "test_01"; // 邮件模版，记得在【邮箱管理】中配置噢\n        Map<String, Object> templateParams = new HashMap<>();\n        templateParams.put("key1", "奥特曼");\n        templateParams.put("key2", "变身");\n\n        // 2. 发送邮件\n        mailSendApi.sendSingleMailToAdmin(new MailSendSingleToUserReqDTO()\n                .setUserId(userId).setTemplateCode(templateCode).setTemplateParams(templateParams));\n    }\n    \n}\n\n\n\n# 5. 邮箱平台附录\n\n * 《QQ 邮箱的 SMTP 设置》\n * 《网易 163 邮箱的 SMTP 设置》\n * 《QQ 邮箱、网易邮箱、腾讯企业邮箱、网易企业邮箱的 SMTP 设置》',
            normalizedContent: '本章节，介绍项目的邮件功能。它在管理后台有三个菜单，分别是：\n\n① 邮箱账号：配置邮件的发送账号\n\n\n\n② 邮件模版：管理邮件的内容模版\n\n\n\n③ 邮件记录：查看邮件的发送记录\n\n\n\n\n# 1. 表结构\n\n\n\n\n# 2. 实现原理\n\n邮件功能提供统一的 api 给其它模块，使它们可以快速实现发送邮件的功能，无需关心不同邮件平台的具体对接。\n\n邮件采用异步发送，基于 消息队列，如下图所示：\n\n\n\n * 前端代码：views/system/mail\n * 后端代码：controller/admin/mail\n\n最终使用 hutool 的 mailutil 发送邮件。\n\n\n# 3. 邮箱配置\n\n本小节，讲解如何配置邮件功能，整个过程如下：\n\n 1. 新建一个邮箱【账号】，配置邮件的发送账号\n 2. 新建一个邮件【模版】，配置邮件的内容模版\n 3. 测试该邮件模板，查看对应的邮件【日志】，确认是否发送成功\n\n\n# 3.1 新建邮箱账号\n\n① 点击 [系统管理 -> 消息中心 -> 邮件管理 -> 邮箱账号] 菜单，查看邮箱账号的列表。如下图所示：\n\n\n\n② 点击 [新增] 按钮，添加一个邮箱账号，并填写信息如下图：\n\n\n\n友情提示：\n\n邮件发送基于 smtp 协议实现，需要开通账号的 stmp 服务。例如说：\n\n\n\n不同邮件平台的 smtp 配置，可见 「5. 邮箱平台附录」 小节。\n\n③ 新增完成后，确认你的邮箱账号是否可以发送邮件，可通过如下代码：\n\nimport cn.hutool.extra.mail.mailaccount;\nimport cn.hutool.extra.mail.mailutil;\n\n@test\npublic void testdemo() {\n    mailaccount mailaccount = new mailaccount()\n//                .setfrom("奥特曼 <ydym_test@163.com>")\n            .setfrom("ydym_test@163.com") // 邮箱地址\n            .sethost("smtp.163.com").setport(465).setsslenable(true) // smtp 服务器\n            .setauth(true).setuser("ydym_test@163.com").setpass("wbzteinmifvrysoe"); // 登录账号密码\n    string messageid = mailutil.send(mailaccount, "7685413@qq.com", "主题", "内容", false);\n    system.out.println("发送结果：" + messageid);\n}\n\n\n\n# 3.2 新建邮箱模版\n\n① 点击 [系统管理 -> 消息中心 -> 邮箱管理 -> 邮件模板] 菜单，查看邮件模板的列表。如下图所示：\n\n\n\n② 点击 [新增] 按钮，选择刚创建的邮箱账号，并填写信息如下图：\n\n\n\n * 邮箱账号：发送该邮件模板时，使用的邮件账号，即使用哪个邮箱进行发送邮件\n * 模版编号：邮件模板的唯一标识，使用邮件 api 时，通过它标识使用的邮件模板\n * 发件人名称：发送邮件显示的发件人名字\n * 模板内容：邮件模板的内容，使用 {var} 作为占位符，例如说 {name}、{code} 等\n * 开启状态：邮件模板被禁用时，该邮件模板将不发送邮件，只记录邮件日志\n\n疑问：为什么设计邮件模板的功能？\n\n在一些场景下，产品会希望修改发送邮件的标题、内容，甚至邮箱账号，此时只需要修改邮件模版的对应属性，无需重启应用。\n\n\n# 3.3 查看邮件日志\n\n① 点击 [测试] 按钮，输入测试的收件邮箱地址，进行该邮件模板的模拟发送。如下图所示：\n\n\n\n② 打开收件邮箱，查看邮件是否发送成功。如下图所示：\n\n\n\n③ 点击 [系统管理 -> 消息中心 -> 邮箱管理 -> 邮件日志] 采单，可以查看到每条邮件的发送状态。如下图所示：\n\n\n\n\n# 4. 邮件发送\n\n\n# 4.1 mailsendapi\n\n邮箱配置完成后，可使用 mailsendapi 进行邮件的发送，支持多种用户类型。它的方法如下：\n\n\n\n\n# 4.2 接入示例\n\n以 yudao-module-infra 模块，需要发邮件为例子，讲解 smscodeapi 的使用。\n\n① 在 yudao-module-infra-biz 模块的 pom.xml 引入 yudao-module-system-api 依赖，如所示：\n\n<dependency>\n    <groupid>cn.iocoder.boot</groupid>\n    <artifactid>yudao-module-system-api</artifactid>\n    <version>${revision}</version>\n</dependency>\n\n\n② 在代码中注入 smscodeapi bean，并调用发送邮件的方法。代码如下：\n\npublic class testdemoserviceimpl implements testdemoservice {\n\n    // 0. 注入 mailsendapi bean\n    @resource\n    private mailsendapi mailsendapi;\n\n    public void senddemo() {\n        // 1. 准备参数\n        long userid = 1l; // 示例中写死，你可以改成你业务中的 userid 噢\n        string templatecode = "test_01"; // 邮件模版，记得在【邮箱管理】中配置噢\n        map<string, object> templateparams = new hashmap<>();\n        templateparams.put("key1", "奥特曼");\n        templateparams.put("key2", "变身");\n\n        // 2. 发送邮件\n        mailsendapi.sendsinglemailtoadmin(new mailsendsingletouserreqdto()\n                .setuserid(userid).settemplatecode(templatecode).settemplateparams(templateparams));\n    }\n    \n}\n\n\n\n# 5. 邮箱平台附录\n\n * 《qq 邮箱的 smtp 设置》\n * 《网易 163 邮箱的 smtp 设置》\n * 《qq 邮箱、网易邮箱、腾讯企业邮箱、网易企业邮箱的 smtp 设置》',
            charsets: {
                cjk: !0
            }
        }, {
            title: "Linux 部署",
            frontmatter: {
                title: "Linux 部署",
                date: "2022-04-12T19:07:52.000Z",
                permalink: "/deployment-linux"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/20.%E8%BF%90%E7%BB%B4%E6%89%8B%E5%86%8C/02.Linux%20%E9%83%A8%E7%BD%B2.html",
            relativePath: "01.开发指南/20.运维手册/02.Linux 部署.md",
            key: "v-5f199590",
            path: "/deployment-linux/",
            headers: [{
                level: 2,
                title: "1. 环境准备",
                slug: "_1-环境准备",
                normalizedTitle: "1. 环境准备",
                charIndex: 72
            }, {
                level: 3,
                title: "1.1 安装 MySQL",
                slug: "_1-1-安装-mysql",
                normalizedTitle: "1.1 安装 mysql",
                charIndex: 149
            }, {
                level: 3,
                title: "1.2 安装 Redis",
                slug: "_1-2-安装-redis",
                normalizedTitle: "1.2 安装 redis",
                charIndex: 1368
            }, {
                level: 3,
                title: "1.3 安装 JDK",
                slug: "_1-3-安装-jdk",
                normalizedTitle: "1.3 安装 jdk",
                charIndex: 1678
            }, {
                level: 3,
                title: "1.4 安装 Nginx",
                slug: "_1-4-安装-nginx",
                normalizedTitle: "1.4 安装 nginx",
                charIndex: 1797
            }, {
                level: 2,
                title: "2. 部署后端服务",
                slug: "_2-部署后端服务",
                normalizedTitle: "2. 部署后端服务",
                charIndex: 1984
            }, {
                level: 2,
                title: "3. 部署前端",
                slug: "_3-部署前端",
                normalizedTitle: "3. 部署前端",
                charIndex: 5619
            }, {
                level: 3,
                title: "3.1 yudao-ui-admin-vue3",
                slug: "_3-1-yudao-ui-admin-vue3",
                normalizedTitle: "3.1 yudao-ui-admin-vue3",
                charIndex: 5893
            }, {
                level: 3,
                title: "3.2 yudao-ui-admin-vben",
                slug: "_3-2-yudao-ui-admin-vben",
                normalizedTitle: "3.2 yudao-ui-admin-vben",
                charIndex: 7063
            }, {
                level: 3,
                title: "4.3 yudao-ui-admin-vue2",
                slug: "_4-3-yudao-ui-admin-vue2",
                normalizedTitle: "4.3 yudao-ui-admin-vue2",
                charIndex: 8086
            }, {
                level: 2,
                title: "4. 配置 Nginx 转发",
                slug: "_4-配置-nginx-转发",
                normalizedTitle: "4. 配置 nginx 转发",
                charIndex: 8847
            }, {
                level: 3,
                title: "4.1 方式一：服务器 IP 访问",
                slug: "_4-1-方式一-服务器-ip-访问",
                normalizedTitle: "4.1 方式一：服务器 ip 访问",
                charIndex: 8902
            }, {
                level: 3,
                title: "4.2 方式二：独立域名访问",
                slug: "_4-2-方式二-独立域名访问",
                normalizedTitle: "4.2 方式二：独立域名访问",
                charIndex: 10889
            }, {
                level: 2,
                title: "666. 更多说明",
                slug: "_666-更多说明",
                normalizedTitle: "666. 更多说明",
                charIndex: 13043
            }],
            headersStr: "1. 环境准备 1.1 安装 MySQL 1.2 安装 Redis 1.3 安装 JDK 1.4 安装 Nginx 2. 部署后端服务 3. 部署前端 3.1 yudao-ui-admin-vue3 3.2 yudao-ui-admin-vben 4.3 yudao-ui-admin-vue2 4. 配置 Nginx 转发 4.1 方式一：服务器 IP 访问 4.2 方式二：独立域名访问 666. 更多说明",
            content: '本小节，讲解如何将前端 + 后端项目，使用 Shell 脚本，部署到 dev 开发环境下的一台 Linux 服务器上。如下图所示：\n\n\n\n\n# 1. 环境准备\n\n需要安装如下环境：\n\n * MySQL：数据库\n * Redis：缓存\n * JDK：后端运行环境\n * Nginx：负载均衡\n\n\n# 1.1 安装 MySQL\n\n需要安装 MySQL，并导入 SQL 脚本。\n\n# 第一步，安装 MySQL（可选）\n\n友情提示：安装 MySQL 是可选步骤，也可以购买 MySQL 云服务。\n\n① 执行如下命令，进行 MySQL 的安装。\n\n## ① 在 CentOS 9 下，安装 MySQL 8.4 版本的软件源 https://dev.mysql.com/downloads/repo/yum/\nrpm -Uvh https://repo.mysql.com//mysql84-community-release-el9-1.noarch.rpm\n\n## ② 安装 MySQL Server 8.4 版本\nyum install mysql-server --nogpgcheck\n\n## ③ 查看 MySQL 的安装版本。结果是 /usr/sbin/mysqld  Ver 8.4.2 for Linux on x86_64 (MySQL Community Server - GPL)\nmysqld --version\n\n\n② 修改 /etc/my.cnf 文件，在文末加上 lower_case_table_names=1 配置，执行 systemctl restart mysqld 命令重启。\n\n踩坑提示：\n\n为什么 MySQL 启动后，后续无法修改 lower_case_table_names=1 呢？\n\n原因和解决，参考 https://www.cnblogs.com/niceyoo/p/11545196.html 博客！\n\n③ 执行 grep password /var/log/mysqld.log 命令，获得 MySQL 临时密码。\n\n2024-09-26T01:51:44.277843Z 6 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: iLXXg3.tje;8\n\n\n④ 执行如下命令，修改 MySQL 的密码，设置允许远程连接。\n\n## ① 连接 MySQL Server 服务，并输入临时密码\nmysql -uroot -p\n\n## ② 修改密码，3WLiVUBEwTbvAfsh. 可改成你想要的密码\nalter user \'root\'@\'localhost\' identified by \'3WLiVUBEwTbvAfsh.\';\n\n## ③ 设置允许远程连接\nuse mysql;\nupdate user set host = \'%\' where user = \'root\';\nFLUSH PRIVILEGES;\n\n\n# 第二步，导入 SQL 脚本\n\n创建一个名字为 ruoyi-vue-pro 数据库，执行数据库对应的 sql 目录下的 SQL 文件，进行初始化。\n\n\n\n\n# 1.2 安装 Redis\n\n友情提示：安装 Redis 是可选步骤，也可以购买 Redis 云服务。\n\n执行如下命令，进行 Redis 的安装。\n\n## ① 安装 Redis\nyum install redis \n\n## ② 查看 Redis 的安装版本。结果是 Redis server v=6.2.7 sha=00000000:0 malloc=jemalloc-5.1.0 bits=64 build=ec192bdd77ecd321\nredis-server --version\n\n## ④ 启动 Redis 服务\nsystemctl restart redis\n\n\n * 端口是 6379，密码未设置\n\n\n# 1.3 安装 JDK\n\n执行 yum install -y java-1.8.0-openjdk 命令，安装 OpenJDK 8。\n\n友情提示：如果已经安装 JDK，可不安装。建议使用的 JDK 版本为 8、11、17 这三个。\n\n\n# 1.4 安装 Nginx\n\n参考 Nginx 官方文档，安装 Nginx 服务。命令如下：\n\n## 添加 yum 源\nyum install epel-release\nyum update\n## 安装 nginx\nyum install nginx\n## 启动 nginx \nnginx\n\n\nNginx 默认配置文件是 /etc/nginx/nginx.conf。\n\n\n# 2. 部署后端服务\n\n# 第一步，修改配置\n\n后端 dev 开发环境对应的是 application-dev.yaml 配置文件，主要是修改 MySQL 和 Redis 为你的地址。如下图所示：\n\n\n\n# 第二步，编译后端\n\n在项目的根目录下，执行 mvn clean package -Dmaven.test.skip=true 命令，编译后端项目，构建出它的 Jar 包。如下图所示：\n\n\n\n疑问：-Dmaven.test.skip=true 是什么意思？\n\n跳过单元测试的执行。如果你项目的单元测试写的不错，建议使用 mvn clean package 命令，执行单元测试，保证交付的质量。\n\n# 第三步，上传 Jar 包\n\n在 Linux 服务器上创建 /work/projects/yudao-server 目录，使用 scp 命令或者 FTP 工具，将 yudao-server.jar 上传到该目录下。如下图所示：\n\n\n\n疑问：如果构建 War 包，部署到 Tomcat 下？\n\n并不推荐采用 War 包部署到 Tomcat 下。如果真的需要，可以参考 《Deploy a Spring Boot WAR into a Tomcat Server》 文章。\n\n# 第四步，编写脚本\n\n在 /work/projects/yudao-server 目录下，新建 Shell 脚本 deploy.sh，用于启动后端项目。编写内容如下：\n\n#!/bin/bash\nset -e\n\nDATE=$(date +%Y%m%d%H%M)\n# 基础路径\nBASE_PATH=/work/projects/yudao-server\n# 服务名称。同时约定部署服务的 jar 包名字也为它。\nSERVER_NAME=yudao-server\n# 环境\nPROFILES_ACTIVE=dev\n\n# heapError 存放路径\nHEAP_ERROR_PATH=$BASE_PATH/heapError\n# JVM 参数\nJAVA_OPS="-Xms512m -Xmx512m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=$HEAP_ERROR_PATH"\n\n# SkyWalking Agent 配置\n#export SW_AGENT_NAME=$SERVER_NAME\n#export SW_AGENT_COLLECTOR_BACKEND_SERVICES=192.168.0.84:11800\n#export SW_GRPC_LOG_SERVER_HOST=192.168.0.84\n#export SW_AGENT_TRACE_IGNORE_PATH="Redisson/PING,/actuator/**,/admin/**"\n#export JAVA_AGENT=-javaagent:/work/skywalking/apache-skywalking-apm-bin/agent/skywalking-agent.jar\n\n# 停止：优雅关闭之前已经启动的服务\nfunction stop() {\n    echo "[stop] 开始停止 $BASE_PATH/$SERVER_NAME"\n    PID=$(ps -ef | grep $BASE_PATH/$SERVER_NAME | grep -v "grep" | awk \'{print $2}\')\n    # 如果 Java 服务启动中，则进行关闭\n    if [ -n "$PID" ]; then\n        # 正常关闭\n        echo "[stop] $BASE_PATH/$SERVER_NAME 运行中，开始 kill [$PID]"\n        kill -15 $PID\n        # 等待最大 120 秒，直到关闭完成。\n        for ((i = 0; i < 120; i++))\n            do\n                sleep 1\n                PID=$(ps -ef | grep $BASE_PATH/$SERVER_NAME | grep -v "grep" | awk \'{print $2}\')\n                if [ -n "$PID" ]; then\n                    echo -e ".\\c"\n                else\n                    echo \'[stop] 停止 $BASE_PATH/$SERVER_NAME 成功\'\n                    break\n                fi\n\t\t    done\n\n        # 如果正常关闭失败，那么进行强制 kill -9 进行关闭\n        if [ -n "$PID" ]; then\n            echo "[stop] $BASE_PATH/$SERVER_NAME 失败，强制 kill -9 $PID"\n            kill -9 $PID\n        fi\n    # 如果 Java 服务未启动，则无需关闭\n    else\n        echo "[stop] $BASE_PATH/$SERVER_NAME 未启动，无需停止"\n    fi\n}\n\n# 启动：启动后端项目\nfunction start() {\n    # 开启启动前，打印启动参数\n    echo "[start] 开始启动 $BASE_PATH/$SERVER_NAME"\n    echo "[start] JAVA_OPS: $JAVA_OPS"\n    echo "[start] JAVA_AGENT: $JAVA_AGENT"\n    echo "[start] PROFILES: $PROFILES_ACTIVE"\n\n    # 开始启动\n    nohup java -server $JAVA_OPS $JAVA_AGENT -jar $BASE_PATH/$SERVER_NAME.jar --spring.profiles.active=$PROFILES_ACTIVE > nohup.out 2>&1 &\n    echo "[start] 启动 $BASE_PATH/$SERVER_NAME 完成"\n}\n\n# 部署\nfunction deploy() {\n    cd $BASE_PATH\n    # 第一步：停止 Java 服务\n    stop\n    # 第二步：启动 Java 服务\n    start\n}\n\ndeploy\n\n\n友情提示：\n\n脚本的详细讲解，可见 《芋道 Jenkins 极简入门 》 的「2.3 远程服务器配置 」小节。\n\n如果你想要修改脚本，主要关注 BASE_PATH、PROFILES_ACTIVE、JAVA_OPS 三个参数。如下图所示：\n\n\n\n# 第五步，启动后端\n\n① 执行 sh deploy.sh 命令，启动后端项目。日志如下：\n\n[stop] 开始停止 /work/projects/yudao-server/yudao-server\n[stop] /work/projects/yudao-server/yudao-server 未启动，无需停止\n[start] 开始启动 /work/projects/yudao-server/yudao-server\n[start] JAVA_OPS: -Xms512m -Xmx512m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/work/projects/yudao-server/heapError\n[start] JAVA_AGENT:\n[start] PROFILES: dev\n[start] 启动 /work/projects/yudao-server/yudao-server 完成\n\n\n② 执行 tail -f nohup.out 命令，查看启动日志。看到如下内容，说明启动完成：\n\n2022-04-13 00:06:20.049  INFO 1395 --- [main] [TID: N/A] c.i.yudao.server.YudaoServerApplication  : Started YudaoServerApplication in 35.315 seconds (JVM running for 36.282)\n\n\n\n# 3. 部署前端\n\n项目的管理后台有 3 个版本（只需要看你的版本即可）：\n\n * yudao-ui-admin-vue3：基于 Vue3 + element-plus\n * yudao-ui-admin-vben：基于 Vue3 + vben(ant-design-vue)\n * yudao-ui-admin-vue2：基于 Vue2 + element-ui\n\n注意，前端无法直接启动，而是需要通过 Nginx 转发读取前端构建出来的静态文件，最终都放在服务器上的 /work/projects/yudao-ui-admin 目录下。\n\n\n# 3.1 yudao-ui-admin-vue3\n\n基于 Vue3 + element-plus\n\n# 第一步，修改配置\n\n前端 dev 开发环境对应的是 .env.dev 配置文件，主要是修改 VITE_BASE_URL 为你的后端项目的访问地址。如下图所示：\n\n\n\n# 第二步，编译前端\n\n在前端项目的根目录下，执行 npm run build:dev 命令，编译前端项目，构建出它的 dist 文件，里面是 HTML、CSS、JavaScript 等静态文件。如下图所示：\n\n\n\n如下想要打包其它环境，可使用如下命令：\n\nnpm run build:prod ## 打包 prod 生产环境\nnpm run build:stage ## 打包 stage 预发布环境\n\n\n如果是在服务器上构建，并且出现卡死的情况，可以参考 https://gitee.com/yudaocode/yudao-ui-admin-vue3/issues/IAU0T3 解决\n\n其它高级参数说明【可暂时不看】：\n\n① VITE_PUBLIC_PATH：前端打包的路径（静态资源的基础路径），一般默认为 / 即可。目前有两种用法：\n\n第一种，可用于二级目录部署。例如说，VITE_PUBLIC_PATH 设置为 /demo 。然后 Nginx 配置时，需要特殊注意，如下所示：\n\n        location /demo { # 注意点 1：不需要 / 结尾\n            # 注意点 2：二级路由时需要使用别名 alias，不用 root\n            alias   /work/projects/yudao-ui-admin/; # 注意点 3：需要 / 结尾\n            index  index.html index.htm;\n            try_files $uri $uri/ /index.html;\n        }\n\n\n第二种，可用于七牛等 CDN 服务，读取前端的静态文件，提升访问速度，建议 prod 生产环境使用。例如说，我们演示环境的 VITE_PUBLIC_PATH 是 http://static-vue3.yudao.iocoder.cn/ 。\n\n具体操作，可参考文章的 《Vue 项目使用七牛云 CDN 存放静态资源》 的「二、实现方式 」部分，只是最终的“修改 index.html 中静态资源引用”，变成 PUBLIC_PATH 修改即可。\n\n# 第三步，上传 dist 文件\n\n在 Linux 服务器上创建 /work/projects/yudao-ui-admin 目录，使用 scp 命令或者 FTP 工具，将 dist 上传到该目录下。如下图所示：\n\n\n\n\n# 3.2 yudao-ui-admin-vben\n\n基于 Vue3 + vben(ant-design-vue)\n\n# 第一步，修改配置\n\n前端 production 开发环境对应的是 .env.production 配置文件，主要是修改 VITE_GLOB_BASE_URL、VITE_GLOB_API_URL 为你的后端项目的访问地址。如下图所示：\n\n\n\n其它高级参数说明【可暂时不看】：\n\n① VITE_PUBLIC_PATH：前端打包的路径（静态资源的基础路径），一般默认为 / 即可。目前有两种用法：\n\n第一种，可用于二级目录部署。例如说，VITE_PUBLIC_PATH 设置为 /demo 。然后 Nginx 配置时，需要特殊注意，如下所示：\n\n        location /demo { # 注意点 1：不需要 / 结尾\n            # 注意点 2：二级路由时需要使用别名 alias，不用 root\n            alias   /work/projects/yudao-ui-admin/; # 注意点 3：需要 / 结尾\n            index  index.html index.htm;\n            try_files $uri $uri/ /index.html;\n        }\n\n\n第二种，可用于七牛等 CDN 服务，读取前端的静态文件，提升访问速度，建议 prod 生产环境使用。例如说，我们演示环境的 VITE_PUBLIC_PATH 是 http://static-vue3.yudao.iocoder.cn/ 。\n\n具体操作，可参考文章的 《Vue 项目使用七牛云 CDN 存放静态资源》 的「二、实现方式 」部分，只是最终的“修改 index.html 中静态资源引用”，变成 PUBLIC_PATH 修改即可。\n\n# 第二步，编译前端\n\n在前端项目的根目录下，执行 npm run build 命令，编译前端项目，构建出它的 dist 文件，里面是 HTML、CSS、JavaScript 等静态文件。如下图所示：\n\n\n\n# 第三步，上传 dist 文件\n\n在 Linux 服务器上创建 /work/projects/yudao-ui-admin 目录，使用 scp 命令或者 FTP 工具，将 dist 上传到该目录下。如下图所示：\n\n\n\n\n# 4.3 yudao-ui-admin-vue2\n\n基于 Vue2 + element-ui\n\n# 第一步，修改配置\n\n前端 dev 开发环境对应的是 .env.dev 配置文件，主要是修改 VUE_APP_BASE_API 为你的后端项目的访问地址。如下图所示：\n\n\n\n# 第二步，编译前端\n\n在前端项目的根目录下，执行 npm run build:dev 命令，编译前端项目，构建出它的 dist 文件，里面是 HTML、CSS、JavaScript 等静态文件。如下图所示：\n\n\n\n如下想要打包其它环境，可使用如下命令：\n\nnpm run build:prod ## 打包 prod 生产环境\nnpm run build:stage ## 打包 stage 预发布环境\n\n\n其它高级参数说明【可暂时不看】：\n\n① PUBLIC_PATH：可用于七牛等 CDN 服务，读取前端的静态文件，提升访问速度，建议 prod 生产环境使用。示例如下：\n\n可参考文章的 《Vue 项目使用七牛云 CDN 存放静态资源》 的「二、实现方式 」部分，只是最终的“修改 index.html 中静态资源引用”，变成 PUBLIC_PATH 修改即可。\n\n② VUE_APP_APP_NAME：二级部署路径，默认为 / 根目录，一般不用修改。\n\n③ mode：前端路由的模式，默认采用 history 路由，一般不用修改。可以通过修改 router/index.js 来设置为 hash 路由，示例如下：\n\n\n\n# 第三步，上传 dist 文件\n\n在 Linux 服务器上创建 /work/projects/yudao-ui-admin 目录，使用 scp 命令或者 FTP 工具，将 dist 上传到该目录下。如下图所示：\n\n\n\n\n# 4. 配置 Nginx 转发\n\n两种 Nginx 的配置，分别满足服务器 IP、独立域名的不同场景。\n\n\n# 4.1 方式一：服务器 IP 访问\n\n① 修改 Nginx 配置，内容如下：\n\nworker_processes  1;\n\nevents {\n    worker_connections  1024;\n}\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n    sendfile        on;\n    keepalive_timeout  65;\n\n    gzip on;\n    gzip_min_length 1k;     # 设置允许压缩的页面最小字节数\n    gzip_buffers 4 16k;     # 用来存储 gzip 的压缩结果\n    gzip_http_version 1.1;  # 识别 HTTP 协议版本\n    gzip_comp_level 2;      # 设置 gzip 的压缩比 1-9。1 压缩比最小但最快，而 9 相反\n    gzip_types gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript; # 指定压缩类型\n    gzip_proxied any;       # 无论后端服务器的 headers 头返回什么信息，都无条件启用压缩\n\n    server {\n        listen       80;\n        server_name  192.168.225.2; ## 重要！！！修改成你的外网 IP/域名\n\n        location / { ## 前端项目\n            root   /work/projects/yudao-ui-admin;\n            index  index.html index.htm;\n            try_files $uri $uri/ /index.html;\n        }\n\n        location /admin-api/ { ## 后端项目 - 管理后台\n            proxy_pass http://localhost:48080/admin-api/; ## 重要！！！proxy_pass 需要设置为后端项目所在服务器的 IP\n            proxy_set_header Host $http_host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header REMOTE-HOST $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        }\n\n        location /app-api/ { ## 后端项目 - 用户 App\n            proxy_pass http://localhost:48080/app-api/; ## 重要！！！proxy_pass 需要设置为后端项目所在服务器的 IP\n            proxy_set_header Host $http_host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header REMOTE-HOST $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        }\n\n    }\n\n}\n\n\n② 执行 nginx -s reload 命令，重新加载 Nginx 配置。\n\n③ 请求 http://192.168.225.2/admin-api/ 地址，成功访问后端项目，返回结果如下：\n\n{"code":401,"data":null,"msg":"账号未登录"}\n\n\n④ 请求 http://192.168.225.2 地址，成功访问前端项目，返回前端界面如下：\n\n\n\n⑤ 如果你使用到 WebSocket 的话，需要额外对 /infra/ws 路径进行配置，具体可见 https://t.zsxq.com/LQEfC 链接。\n\n\n# 4.2 方式二：独立域名访问\n\n友情提示：在前端项目的编译时，需要把 `VUE_APP_BASE_API` 修改为后端项目对应的域名。\n\n例如说，这里使用的是 http://api.iocoder.cn\n\n① 修改 Nginx 配置，内容如下：\n\nworker_processes  1;\n\nevents {\n    worker_connections  1024;\n}\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n    sendfile        on;\n    keepalive_timeout  65;\n\n    gzip on;\n    gzip_min_length 1k;     # 设置允许压缩的页面最小字节数\n    gzip_buffers 4 16k;     # 用来存储 gzip 的压缩结果\n    gzip_http_version 1.1;  # 识别 HTTP 协议版本\n    gzip_comp_level 2;      # 设置 gzip 的压缩比 1-9。1 压缩比最小但最快，而 9 相反\n    gzip_types text/plain application/x-javascript text/css application/xml application/javascript; # 指定压缩类型\n    gzip_proxied any;       # 无论后端服务器的 headers 头返回什么信息，都无条件启用压缩\n\n    server { ## 前端项目\n        listen       80;\n        server_name  admin.iocoder.cn; ## 重要！！！修改成你的前端域名\n\n        location / { ## 前端项目\n            root   /work/projects/yudao-ui-admin;\n            index  index.html index.htm;\n            try_files $uri $uri/ /index.html;\n        }\n\n    }\n\n    server { ## 后端项目\n        listen       80;\n        server_name  api.iocoder.cn; ## 重要！！！修改成你的外网 IP/域名\n\n        ## 不要使用 location / 转发到后端项目，因为 druid、admin 等监控，不需要外网可访问。或者增加 Nginx IP 白名单限制也可以。\n\n        location /admin-api/ { ## 后端项目 - 管理后台\n            proxy_pass http://localhost:48080/admin-api/; ## 重要！！！proxy_pass 需要设置为后端项目所在服务器的 IP\n            proxy_set_header Host $http_host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header REMOTE-HOST $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        }\n\n        location /app-api/ { ## 后端项目 - 用户 App\n            proxy_pass http://localhost:48080/app-api/; ## 重要！！！proxy_pass 需要设置为后端项目所在服务器的 IP\n            proxy_set_header Host $http_host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header REMOTE-HOST $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        }\n\n    }\n}\n\n\n② 执行 nginx -s reload 命令，重新加载 Nginx 配置。\n\n③ 请求 http://api.iocoder.cn/admin-api/ 地址，成功访问后端项目，返回结果如下：\n\n{"code":401,"data":null,"msg":"账号未登录"}\n\n\n④ 请求 http://admin.iocoder.cn 地址，成功访问前端项目，返回前端界面如下：\n\n\n\n\n# 666. 更多说明\n\n① 积木报表菜单，无法访问。参考 https://t.zsxq.com/vBkup 解决。',
            normalizedContent: '本小节，讲解如何将前端 + 后端项目，使用 shell 脚本，部署到 dev 开发环境下的一台 linux 服务器上。如下图所示：\n\n\n\n\n# 1. 环境准备\n\n需要安装如下环境：\n\n * mysql：数据库\n * redis：缓存\n * jdk：后端运行环境\n * nginx：负载均衡\n\n\n# 1.1 安装 mysql\n\n需要安装 mysql，并导入 sql 脚本。\n\n# 第一步，安装 mysql（可选）\n\n友情提示：安装 mysql 是可选步骤，也可以购买 mysql 云服务。\n\n① 执行如下命令，进行 mysql 的安装。\n\n## ① 在 centos 9 下，安装 mysql 8.4 版本的软件源 https://dev.mysql.com/downloads/repo/yum/\nrpm -uvh https://repo.mysql.com//mysql84-community-release-el9-1.noarch.rpm\n\n## ② 安装 mysql server 8.4 版本\nyum install mysql-server --nogpgcheck\n\n## ③ 查看 mysql 的安装版本。结果是 /usr/sbin/mysqld  ver 8.4.2 for linux on x86_64 (mysql community server - gpl)\nmysqld --version\n\n\n② 修改 /etc/my.cnf 文件，在文末加上 lower_case_table_names=1 配置，执行 systemctl restart mysqld 命令重启。\n\n踩坑提示：\n\n为什么 mysql 启动后，后续无法修改 lower_case_table_names=1 呢？\n\n原因和解决，参考 https://www.cnblogs.com/niceyoo/p/11545196.html 博客！\n\n③ 执行 grep password /var/log/mysqld.log 命令，获得 mysql 临时密码。\n\n2024-09-26t01:51:44.277843z 6 [note] [my-010454] [server] a temporary password is generated for root@localhost: ilxxg3.tje;8\n\n\n④ 执行如下命令，修改 mysql 的密码，设置允许远程连接。\n\n## ① 连接 mysql server 服务，并输入临时密码\nmysql -uroot -p\n\n## ② 修改密码，3wlivubewtbvafsh. 可改成你想要的密码\nalter user \'root\'@\'localhost\' identified by \'3wlivubewtbvafsh.\';\n\n## ③ 设置允许远程连接\nuse mysql;\nupdate user set host = \'%\' where user = \'root\';\nflush privileges;\n\n\n# 第二步，导入 sql 脚本\n\n创建一个名字为 ruoyi-vue-pro 数据库，执行数据库对应的 sql 目录下的 sql 文件，进行初始化。\n\n\n\n\n# 1.2 安装 redis\n\n友情提示：安装 redis 是可选步骤，也可以购买 redis 云服务。\n\n执行如下命令，进行 redis 的安装。\n\n## ① 安装 redis\nyum install redis \n\n## ② 查看 redis 的安装版本。结果是 redis server v=6.2.7 sha=00000000:0 malloc=jemalloc-5.1.0 bits=64 build=ec192bdd77ecd321\nredis-server --version\n\n## ④ 启动 redis 服务\nsystemctl restart redis\n\n\n * 端口是 6379，密码未设置\n\n\n# 1.3 安装 jdk\n\n执行 yum install -y java-1.8.0-openjdk 命令，安装 openjdk 8。\n\n友情提示：如果已经安装 jdk，可不安装。建议使用的 jdk 版本为 8、11、17 这三个。\n\n\n# 1.4 安装 nginx\n\n参考 nginx 官方文档，安装 nginx 服务。命令如下：\n\n## 添加 yum 源\nyum install epel-release\nyum update\n## 安装 nginx\nyum install nginx\n## 启动 nginx \nnginx\n\n\nnginx 默认配置文件是 /etc/nginx/nginx.conf。\n\n\n# 2. 部署后端服务\n\n# 第一步，修改配置\n\n后端 dev 开发环境对应的是 application-dev.yaml 配置文件，主要是修改 mysql 和 redis 为你的地址。如下图所示：\n\n\n\n# 第二步，编译后端\n\n在项目的根目录下，执行 mvn clean package -dmaven.test.skip=true 命令，编译后端项目，构建出它的 jar 包。如下图所示：\n\n\n\n疑问：-dmaven.test.skip=true 是什么意思？\n\n跳过单元测试的执行。如果你项目的单元测试写的不错，建议使用 mvn clean package 命令，执行单元测试，保证交付的质量。\n\n# 第三步，上传 jar 包\n\n在 linux 服务器上创建 /work/projects/yudao-server 目录，使用 scp 命令或者 ftp 工具，将 yudao-server.jar 上传到该目录下。如下图所示：\n\n\n\n疑问：如果构建 war 包，部署到 tomcat 下？\n\n并不推荐采用 war 包部署到 tomcat 下。如果真的需要，可以参考 《deploy a spring boot war into a tomcat server》 文章。\n\n# 第四步，编写脚本\n\n在 /work/projects/yudao-server 目录下，新建 shell 脚本 deploy.sh，用于启动后端项目。编写内容如下：\n\n#!/bin/bash\nset -e\n\ndate=$(date +%y%m%d%h%m)\n# 基础路径\nbase_path=/work/projects/yudao-server\n# 服务名称。同时约定部署服务的 jar 包名字也为它。\nserver_name=yudao-server\n# 环境\nprofiles_active=dev\n\n# heaperror 存放路径\nheap_error_path=$base_path/heaperror\n# jvm 参数\njava_ops="-xms512m -xmx512m -xx:+heapdumponoutofmemoryerror -xx:heapdumppath=$heap_error_path"\n\n# skywalking agent 配置\n#export sw_agent_name=$server_name\n#export sw_agent_collector_backend_services=192.168.0.84:11800\n#export sw_grpc_log_server_host=192.168.0.84\n#export sw_agent_trace_ignore_path="redisson/ping,/actuator/**,/admin/**"\n#export java_agent=-javaagent:/work/skywalking/apache-skywalking-apm-bin/agent/skywalking-agent.jar\n\n# 停止：优雅关闭之前已经启动的服务\nfunction stop() {\n    echo "[stop] 开始停止 $base_path/$server_name"\n    pid=$(ps -ef | grep $base_path/$server_name | grep -v "grep" | awk \'{print $2}\')\n    # 如果 java 服务启动中，则进行关闭\n    if [ -n "$pid" ]; then\n        # 正常关闭\n        echo "[stop] $base_path/$server_name 运行中，开始 kill [$pid]"\n        kill -15 $pid\n        # 等待最大 120 秒，直到关闭完成。\n        for ((i = 0; i < 120; i++))\n            do\n                sleep 1\n                pid=$(ps -ef | grep $base_path/$server_name | grep -v "grep" | awk \'{print $2}\')\n                if [ -n "$pid" ]; then\n                    echo -e ".\\c"\n                else\n                    echo \'[stop] 停止 $base_path/$server_name 成功\'\n                    break\n                fi\n\t\t    done\n\n        # 如果正常关闭失败，那么进行强制 kill -9 进行关闭\n        if [ -n "$pid" ]; then\n            echo "[stop] $base_path/$server_name 失败，强制 kill -9 $pid"\n            kill -9 $pid\n        fi\n    # 如果 java 服务未启动，则无需关闭\n    else\n        echo "[stop] $base_path/$server_name 未启动，无需停止"\n    fi\n}\n\n# 启动：启动后端项目\nfunction start() {\n    # 开启启动前，打印启动参数\n    echo "[start] 开始启动 $base_path/$server_name"\n    echo "[start] java_ops: $java_ops"\n    echo "[start] java_agent: $java_agent"\n    echo "[start] profiles: $profiles_active"\n\n    # 开始启动\n    nohup java -server $java_ops $java_agent -jar $base_path/$server_name.jar --spring.profiles.active=$profiles_active > nohup.out 2>&1 &\n    echo "[start] 启动 $base_path/$server_name 完成"\n}\n\n# 部署\nfunction deploy() {\n    cd $base_path\n    # 第一步：停止 java 服务\n    stop\n    # 第二步：启动 java 服务\n    start\n}\n\ndeploy\n\n\n友情提示：\n\n脚本的详细讲解，可见 《芋道 jenkins 极简入门 》 的「2.3 远程服务器配置 」小节。\n\n如果你想要修改脚本，主要关注 base_path、profiles_active、java_ops 三个参数。如下图所示：\n\n\n\n# 第五步，启动后端\n\n① 执行 sh deploy.sh 命令，启动后端项目。日志如下：\n\n[stop] 开始停止 /work/projects/yudao-server/yudao-server\n[stop] /work/projects/yudao-server/yudao-server 未启动，无需停止\n[start] 开始启动 /work/projects/yudao-server/yudao-server\n[start] java_ops: -xms512m -xmx512m -xx:+heapdumponoutofmemoryerror -xx:heapdumppath=/work/projects/yudao-server/heaperror\n[start] java_agent:\n[start] profiles: dev\n[start] 启动 /work/projects/yudao-server/yudao-server 完成\n\n\n② 执行 tail -f nohup.out 命令，查看启动日志。看到如下内容，说明启动完成：\n\n2022-04-13 00:06:20.049  info 1395 --- [main] [tid: n/a] c.i.yudao.server.yudaoserverapplication  : started yudaoserverapplication in 35.315 seconds (jvm running for 36.282)\n\n\n\n# 3. 部署前端\n\n项目的管理后台有 3 个版本（只需要看你的版本即可）：\n\n * yudao-ui-admin-vue3：基于 vue3 + element-plus\n * yudao-ui-admin-vben：基于 vue3 + vben(ant-design-vue)\n * yudao-ui-admin-vue2：基于 vue2 + element-ui\n\n注意，前端无法直接启动，而是需要通过 nginx 转发读取前端构建出来的静态文件，最终都放在服务器上的 /work/projects/yudao-ui-admin 目录下。\n\n\n# 3.1 yudao-ui-admin-vue3\n\n基于 vue3 + element-plus\n\n# 第一步，修改配置\n\n前端 dev 开发环境对应的是 .env.dev 配置文件，主要是修改 vite_base_url 为你的后端项目的访问地址。如下图所示：\n\n\n\n# 第二步，编译前端\n\n在前端项目的根目录下，执行 npm run build:dev 命令，编译前端项目，构建出它的 dist 文件，里面是 html、css、javascript 等静态文件。如下图所示：\n\n\n\n如下想要打包其它环境，可使用如下命令：\n\nnpm run build:prod ## 打包 prod 生产环境\nnpm run build:stage ## 打包 stage 预发布环境\n\n\n如果是在服务器上构建，并且出现卡死的情况，可以参考 https://gitee.com/yudaocode/yudao-ui-admin-vue3/issues/iau0t3 解决\n\n其它高级参数说明【可暂时不看】：\n\n① vite_public_path：前端打包的路径（静态资源的基础路径），一般默认为 / 即可。目前有两种用法：\n\n第一种，可用于二级目录部署。例如说，vite_public_path 设置为 /demo 。然后 nginx 配置时，需要特殊注意，如下所示：\n\n        location /demo { # 注意点 1：不需要 / 结尾\n            # 注意点 2：二级路由时需要使用别名 alias，不用 root\n            alias   /work/projects/yudao-ui-admin/; # 注意点 3：需要 / 结尾\n            index  index.html index.htm;\n            try_files $uri $uri/ /index.html;\n        }\n\n\n第二种，可用于七牛等 cdn 服务，读取前端的静态文件，提升访问速度，建议 prod 生产环境使用。例如说，我们演示环境的 vite_public_path 是 http://static-vue3.yudao.iocoder.cn/ 。\n\n具体操作，可参考文章的 《vue 项目使用七牛云 cdn 存放静态资源》 的「二、实现方式 」部分，只是最终的“修改 index.html 中静态资源引用”，变成 public_path 修改即可。\n\n# 第三步，上传 dist 文件\n\n在 linux 服务器上创建 /work/projects/yudao-ui-admin 目录，使用 scp 命令或者 ftp 工具，将 dist 上传到该目录下。如下图所示：\n\n\n\n\n# 3.2 yudao-ui-admin-vben\n\n基于 vue3 + vben(ant-design-vue)\n\n# 第一步，修改配置\n\n前端 production 开发环境对应的是 .env.production 配置文件，主要是修改 vite_glob_base_url、vite_glob_api_url 为你的后端项目的访问地址。如下图所示：\n\n\n\n其它高级参数说明【可暂时不看】：\n\n① vite_public_path：前端打包的路径（静态资源的基础路径），一般默认为 / 即可。目前有两种用法：\n\n第一种，可用于二级目录部署。例如说，vite_public_path 设置为 /demo 。然后 nginx 配置时，需要特殊注意，如下所示：\n\n        location /demo { # 注意点 1：不需要 / 结尾\n            # 注意点 2：二级路由时需要使用别名 alias，不用 root\n            alias   /work/projects/yudao-ui-admin/; # 注意点 3：需要 / 结尾\n            index  index.html index.htm;\n            try_files $uri $uri/ /index.html;\n        }\n\n\n第二种，可用于七牛等 cdn 服务，读取前端的静态文件，提升访问速度，建议 prod 生产环境使用。例如说，我们演示环境的 vite_public_path 是 http://static-vue3.yudao.iocoder.cn/ 。\n\n具体操作，可参考文章的 《vue 项目使用七牛云 cdn 存放静态资源》 的「二、实现方式 」部分，只是最终的“修改 index.html 中静态资源引用”，变成 public_path 修改即可。\n\n# 第二步，编译前端\n\n在前端项目的根目录下，执行 npm run build 命令，编译前端项目，构建出它的 dist 文件，里面是 html、css、javascript 等静态文件。如下图所示：\n\n\n\n# 第三步，上传 dist 文件\n\n在 linux 服务器上创建 /work/projects/yudao-ui-admin 目录，使用 scp 命令或者 ftp 工具，将 dist 上传到该目录下。如下图所示：\n\n\n\n\n# 4.3 yudao-ui-admin-vue2\n\n基于 vue2 + element-ui\n\n# 第一步，修改配置\n\n前端 dev 开发环境对应的是 .env.dev 配置文件，主要是修改 vue_app_base_api 为你的后端项目的访问地址。如下图所示：\n\n\n\n# 第二步，编译前端\n\n在前端项目的根目录下，执行 npm run build:dev 命令，编译前端项目，构建出它的 dist 文件，里面是 html、css、javascript 等静态文件。如下图所示：\n\n\n\n如下想要打包其它环境，可使用如下命令：\n\nnpm run build:prod ## 打包 prod 生产环境\nnpm run build:stage ## 打包 stage 预发布环境\n\n\n其它高级参数说明【可暂时不看】：\n\n① public_path：可用于七牛等 cdn 服务，读取前端的静态文件，提升访问速度，建议 prod 生产环境使用。示例如下：\n\n可参考文章的 《vue 项目使用七牛云 cdn 存放静态资源》 的「二、实现方式 」部分，只是最终的“修改 index.html 中静态资源引用”，变成 public_path 修改即可。\n\n② vue_app_app_name：二级部署路径，默认为 / 根目录，一般不用修改。\n\n③ mode：前端路由的模式，默认采用 history 路由，一般不用修改。可以通过修改 router/index.js 来设置为 hash 路由，示例如下：\n\n\n\n# 第三步，上传 dist 文件\n\n在 linux 服务器上创建 /work/projects/yudao-ui-admin 目录，使用 scp 命令或者 ftp 工具，将 dist 上传到该目录下。如下图所示：\n\n\n\n\n# 4. 配置 nginx 转发\n\n两种 nginx 的配置，分别满足服务器 ip、独立域名的不同场景。\n\n\n# 4.1 方式一：服务器 ip 访问\n\n① 修改 nginx 配置，内容如下：\n\nworker_processes  1;\n\nevents {\n    worker_connections  1024;\n}\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n    sendfile        on;\n    keepalive_timeout  65;\n\n    gzip on;\n    gzip_min_length 1k;     # 设置允许压缩的页面最小字节数\n    gzip_buffers 4 16k;     # 用来存储 gzip 的压缩结果\n    gzip_http_version 1.1;  # 识别 http 协议版本\n    gzip_comp_level 2;      # 设置 gzip 的压缩比 1-9。1 压缩比最小但最快，而 9 相反\n    gzip_types gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript; # 指定压缩类型\n    gzip_proxied any;       # 无论后端服务器的 headers 头返回什么信息，都无条件启用压缩\n\n    server {\n        listen       80;\n        server_name  192.168.225.2; ## 重要！！！修改成你的外网 ip/域名\n\n        location / { ## 前端项目\n            root   /work/projects/yudao-ui-admin;\n            index  index.html index.htm;\n            try_files $uri $uri/ /index.html;\n        }\n\n        location /admin-api/ { ## 后端项目 - 管理后台\n            proxy_pass http://localhost:48080/admin-api/; ## 重要！！！proxy_pass 需要设置为后端项目所在服务器的 ip\n            proxy_set_header host $http_host;\n            proxy_set_header x-real-ip $remote_addr;\n            proxy_set_header remote-host $remote_addr;\n            proxy_set_header x-forwarded-for $proxy_add_x_forwarded_for;\n        }\n\n        location /app-api/ { ## 后端项目 - 用户 app\n            proxy_pass http://localhost:48080/app-api/; ## 重要！！！proxy_pass 需要设置为后端项目所在服务器的 ip\n            proxy_set_header host $http_host;\n            proxy_set_header x-real-ip $remote_addr;\n            proxy_set_header remote-host $remote_addr;\n            proxy_set_header x-forwarded-for $proxy_add_x_forwarded_for;\n        }\n\n    }\n\n}\n\n\n② 执行 nginx -s reload 命令，重新加载 nginx 配置。\n\n③ 请求 http://192.168.225.2/admin-api/ 地址，成功访问后端项目，返回结果如下：\n\n{"code":401,"data":null,"msg":"账号未登录"}\n\n\n④ 请求 http://192.168.225.2 地址，成功访问前端项目，返回前端界面如下：\n\n\n\n⑤ 如果你使用到 websocket 的话，需要额外对 /infra/ws 路径进行配置，具体可见 https://t.zsxq.com/lqefc 链接。\n\n\n# 4.2 方式二：独立域名访问\n\n友情提示：在前端项目的编译时，需要把 `vue_app_base_api` 修改为后端项目对应的域名。\n\n例如说，这里使用的是 http://api.iocoder.cn\n\n① 修改 nginx 配置，内容如下：\n\nworker_processes  1;\n\nevents {\n    worker_connections  1024;\n}\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n    sendfile        on;\n    keepalive_timeout  65;\n\n    gzip on;\n    gzip_min_length 1k;     # 设置允许压缩的页面最小字节数\n    gzip_buffers 4 16k;     # 用来存储 gzip 的压缩结果\n    gzip_http_version 1.1;  # 识别 http 协议版本\n    gzip_comp_level 2;      # 设置 gzip 的压缩比 1-9。1 压缩比最小但最快，而 9 相反\n    gzip_types text/plain application/x-javascript text/css application/xml application/javascript; # 指定压缩类型\n    gzip_proxied any;       # 无论后端服务器的 headers 头返回什么信息，都无条件启用压缩\n\n    server { ## 前端项目\n        listen       80;\n        server_name  admin.iocoder.cn; ## 重要！！！修改成你的前端域名\n\n        location / { ## 前端项目\n            root   /work/projects/yudao-ui-admin;\n            index  index.html index.htm;\n            try_files $uri $uri/ /index.html;\n        }\n\n    }\n\n    server { ## 后端项目\n        listen       80;\n        server_name  api.iocoder.cn; ## 重要！！！修改成你的外网 ip/域名\n\n        ## 不要使用 location / 转发到后端项目，因为 druid、admin 等监控，不需要外网可访问。或者增加 nginx ip 白名单限制也可以。\n\n        location /admin-api/ { ## 后端项目 - 管理后台\n            proxy_pass http://localhost:48080/admin-api/; ## 重要！！！proxy_pass 需要设置为后端项目所在服务器的 ip\n            proxy_set_header host $http_host;\n            proxy_set_header x-real-ip $remote_addr;\n            proxy_set_header remote-host $remote_addr;\n            proxy_set_header x-forwarded-for $proxy_add_x_forwarded_for;\n        }\n\n        location /app-api/ { ## 后端项目 - 用户 app\n            proxy_pass http://localhost:48080/app-api/; ## 重要！！！proxy_pass 需要设置为后端项目所在服务器的 ip\n            proxy_set_header host $http_host;\n            proxy_set_header x-real-ip $remote_addr;\n            proxy_set_header remote-host $remote_addr;\n            proxy_set_header x-forwarded-for $proxy_add_x_forwarded_for;\n        }\n\n    }\n}\n\n\n② 执行 nginx -s reload 命令，重新加载 nginx 配置。\n\n③ 请求 http://api.iocoder.cn/admin-api/ 地址，成功访问后端项目，返回结果如下：\n\n{"code":401,"data":null,"msg":"账号未登录"}\n\n\n④ 请求 http://admin.iocoder.cn 地址，成功访问前端项目，返回前端界面如下：\n\n\n\n\n# 666. 更多说明\n\n① 积木报表菜单，无法访问。参考 https://t.zsxq.com/vbkup 解决。',
            charsets: {
                cjk: !0
            }
        }, {
            title: "开发环境",
            frontmatter: {
                title: "开发环境",
                date: "2022-04-11T20:31:26.000Z",
                permalink: "/dev-env"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/20.%E8%BF%90%E7%BB%B4%E6%89%8B%E5%86%8C/01.%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.html",
            relativePath: "01.开发指南/20.运维手册/01.开发环境.md",
            key: "v-34a0a5ca",
            path: "/dev-env/",
            headers: [{
                level: 2,
                title: "1. 本地环境",
                slug: "_1-本地环境",
                normalizedTitle: "1. 本地环境",
                charIndex: 336
            }, {
                level: 2,
                title: "2. 开发环境",
                slug: "_2-开发环境",
                normalizedTitle: "2. 开发环境",
                charIndex: 565
            }, {
                level: 2,
                title: "3. 测试环境",
                slug: "_3-测试环境",
                normalizedTitle: "3. 测试环境",
                charIndex: 898
            }, {
                level: 2,
                title: "4. 预发布环境",
                slug: "_4-预发布环境",
                normalizedTitle: "4. 预发布环境",
                charIndex: 1078
            }, {
                level: 2,
                title: "5. 生产环境",
                slug: "_5-生产环境",
                normalizedTitle: "5. 生产环境",
                charIndex: 1307
            }],
            headersStr: "1. 本地环境 2. 开发环境 3. 测试环境 4. 预发布环境 5. 生产环境",
            content: "在系统开发的经典模型，一般会分成 2 类 5 种环境：\n\n * 【线下】本地环境(local)、开发环境(dev)、测试环境(test)\n * 【线上】预发布环境(stage)、生产环境(prod)\n\n\n\n * 每个环境、每个项目使用独立的二级域名\n * 线下、线上各一套 MySQL 数据库，多个环境共享使用\n * 每个环境对应一个配置文件，后端使用 application-{env}.yaml 文件，前端使用 .env.{env} 文件\n\n友情提示：项目中暂时没有 test、stage、production 等环境的配置，需要自己创建。\n\n另外，本文的 MySQL 数据库是基础设施的“泛指”，包括 Redis 缓存、MQ 消息队列，都需要线上线下独立。\n\n\n# 1. 本地环境\n\n后端工程师使用 application-local.yaml 配置文件，在本地电脑启动后端服务，连接线下 MySQL 数据库。考虑到不影响 dev、test 环境，会配置禁用定时任务、MQ 集群消费的执行。\n\n前端工程师也会在本地电脑启动前端服务，一般不使用 .env.local 配置文件，而是使用 .env.dev 配置文件，访问 dev 环境的后端服务。如果需要和后端进行本地联调，可以使用 .env.local 配置文件。\n\n\n# 2. 开发环境\n\ndev 环境的用户是前端工程师、后端工程师，主要用于前后端的联调、又或者功能开发完后的自测。\n\n一些公司可能不提供 dev 环境，直接使用 test 环境，适合团队规模较小的团队，可以降低服务器的成本。\n\n不过，测试工程师可能比较反感 dev 和 test 环境不隔离，因为他们是按照测试用例，一轮一轮的进行验收。这个时候，如果前端或者后端工程师部署了 test 环境，“破坏”了他当前轮次的验收。\n\n疑问：开发环境可以使用独立的 MySQL 数据库吗？\n\n当然是可以的，提供更好的环境隔离性，避免开发阶段产生过多的脏数据，影响 test 环境的验收。\n\n不过呢，这也带来额外的成本，部署程序到 test 环境时，需要做一次数据库的同步。\n\n\n# 3. 测试环境\n\ntest 环境的用户是产品经理、测试工程师，主要用于他们的功能验收。\n\n考虑到 test 环境的稳定性，一般建议由测试工程师使用 Jenkins 等工具，完成该环境的部署。具体的原因，上面 dev 环境已经解释了。\n\n疑问：如果需要并行验收多个功能，怎么办？\n\n并行验收多个功能时候，对应不同的 Git 分支，需要搭建多套测试环境。\n\n\n# 4. 预发布环境\n\nstage 环境的用户是产品经理、测试工程师，连接线上 MySQL 数据库，基于真实的数据，进行功能的全回归测试。\n\n因为数据更加真实，且更具多样性，所以往往也会测试出较多的 Bug。比较好的解决方案，是将线上数据库定期脱敏，导入线下数据库。\n\n考虑到 stage 环境的安全性，一般由技术经理、运维工程师进行部署。\n\n一些公司可能不提供 stage 环境，直接上线到 production 环境，风险非常高，容易产生较多报错。\n\n\n# 5. 生产环境\n\nproduction 环境的用户是真实用户，即线上环境。一般发布上线时，会进行核心功能的快速测试，避免主流程存在问题。\n\n考虑到 production 环境的问题排查效率，会给技术核心开放 MySQL 数据库的读权限。",
            normalizedContent: "在系统开发的经典模型，一般会分成 2 类 5 种环境：\n\n * 【线下】本地环境(local)、开发环境(dev)、测试环境(test)\n * 【线上】预发布环境(stage)、生产环境(prod)\n\n\n\n * 每个环境、每个项目使用独立的二级域名\n * 线下、线上各一套 mysql 数据库，多个环境共享使用\n * 每个环境对应一个配置文件，后端使用 application-{env}.yaml 文件，前端使用 .env.{env} 文件\n\n友情提示：项目中暂时没有 test、stage、production 等环境的配置，需要自己创建。\n\n另外，本文的 mysql 数据库是基础设施的“泛指”，包括 redis 缓存、mq 消息队列，都需要线上线下独立。\n\n\n# 1. 本地环境\n\n后端工程师使用 application-local.yaml 配置文件，在本地电脑启动后端服务，连接线下 mysql 数据库。考虑到不影响 dev、test 环境，会配置禁用定时任务、mq 集群消费的执行。\n\n前端工程师也会在本地电脑启动前端服务，一般不使用 .env.local 配置文件，而是使用 .env.dev 配置文件，访问 dev 环境的后端服务。如果需要和后端进行本地联调，可以使用 .env.local 配置文件。\n\n\n# 2. 开发环境\n\ndev 环境的用户是前端工程师、后端工程师，主要用于前后端的联调、又或者功能开发完后的自测。\n\n一些公司可能不提供 dev 环境，直接使用 test 环境，适合团队规模较小的团队，可以降低服务器的成本。\n\n不过，测试工程师可能比较反感 dev 和 test 环境不隔离，因为他们是按照测试用例，一轮一轮的进行验收。这个时候，如果前端或者后端工程师部署了 test 环境，“破坏”了他当前轮次的验收。\n\n疑问：开发环境可以使用独立的 mysql 数据库吗？\n\n当然是可以的，提供更好的环境隔离性，避免开发阶段产生过多的脏数据，影响 test 环境的验收。\n\n不过呢，这也带来额外的成本，部署程序到 test 环境时，需要做一次数据库的同步。\n\n\n# 3. 测试环境\n\ntest 环境的用户是产品经理、测试工程师，主要用于他们的功能验收。\n\n考虑到 test 环境的稳定性，一般建议由测试工程师使用 jenkins 等工具，完成该环境的部署。具体的原因，上面 dev 环境已经解释了。\n\n疑问：如果需要并行验收多个功能，怎么办？\n\n并行验收多个功能时候，对应不同的 git 分支，需要搭建多套测试环境。\n\n\n# 4. 预发布环境\n\nstage 环境的用户是产品经理、测试工程师，连接线上 mysql 数据库，基于真实的数据，进行功能的全回归测试。\n\n因为数据更加真实，且更具多样性，所以往往也会测试出较多的 bug。比较好的解决方案，是将线上数据库定期脱敏，导入线下数据库。\n\n考虑到 stage 环境的安全性，一般由技术经理、运维工程师进行部署。\n\n一些公司可能不提供 stage 环境，直接上线到 production 环境，风险非常高，容易产生较多报错。\n\n\n# 5. 生产环境\n\nproduction 环境的用户是真实用户，即线上环境。一般发布上线时，会进行核心功能的快速测试，避免主流程存在问题。\n\n考虑到 production 环境的问题排查效率，会给技术核心开放 mysql 数据库的读权限。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "Docker 部署",
            frontmatter: {
                title: "Docker 部署",
                date: "2022-04-13T19:07:52.000Z",
                permalink: "/deployment-docker"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/20.%E8%BF%90%E7%BB%B4%E6%89%8B%E5%86%8C/03.Docker%20%E9%83%A8%E7%BD%B2.html",
            relativePath: "01.开发指南/20.运维手册/03.Docker 部署.md",
            key: "v-017c0fde",
            path: "/deployment-docker/",
            headers: [{
                level: 2,
                title: "1. 环境准备",
                slug: "_1-环境准备",
                normalizedTitle: "1. 环境准备",
                charIndex: 195
            }, {
                level: 3,
                title: "1.1 安装 Docker",
                slug: "_1-1-安装-docker",
                normalizedTitle: "1.1 安装 docker",
                charIndex: 271
            }, {
                level: 3,
                title: "1.2 安装 MySQL",
                slug: "_1-2-安装-mysql",
                normalizedTitle: "1.2 安装 mysql",
                charIndex: 998
            }, {
                level: 3,
                title: "1.3 安装 Redis",
                slug: "_1-3-安装-redis",
                normalizedTitle: "1.3 安装 redis",
                charIndex: 1472
            }, {
                level: 3,
                title: "1.4 安装 Nginx",
                slug: "_1-4-安装-nginx",
                normalizedTitle: "1.4 安装 nginx",
                charIndex: 1689
            }, {
                level: 2,
                title: "2. 部署后端服务",
                slug: "_2-部署后端服务",
                normalizedTitle: "2. 部署后端服务",
                charIndex: 3358
            }, {
                level: 2,
                title: "3. 部署前端",
                slug: "_3-部署前端",
                normalizedTitle: "3. 部署前端",
                charIndex: 5614
            }, {
                level: 3,
                title: "3.1 yudao-ui-admin-vue3",
                slug: "_3-1-yudao-ui-admin-vue3",
                normalizedTitle: "3.1 yudao-ui-admin-vue3",
                charIndex: 5888
            }, {
                level: 3,
                title: "3.2 yudao-ui-admin-vben",
                slug: "_3-2-yudao-ui-admin-vben",
                normalizedTitle: "3.2 yudao-ui-admin-vben",
                charIndex: 7058
            }, {
                level: 3,
                title: "4.3 yudao-ui-admin-vue2",
                slug: "_4-3-yudao-ui-admin-vue2",
                normalizedTitle: "4.3 yudao-ui-admin-vue2",
                charIndex: 8081
            }, {
                level: 2,
                title: "4. 配置 Nginx 转发",
                slug: "_4-配置-nginx-转发",
                normalizedTitle: "4. 配置 nginx 转发",
                charIndex: 8842
            }, {
                level: 3,
                title: "4.1 方式一：服务器 IP 访问",
                slug: "_4-1-方式一-服务器-ip-访问",
                normalizedTitle: "4.1 方式一：服务器 ip 访问",
                charIndex: 8897
            }, {
                level: 3,
                title: "4.2 方式二：独立域名访问",
                slug: "_4-2-方式二-独立域名访问",
                normalizedTitle: "4.2 方式二：独立域名访问",
                charIndex: 10481
            }, {
                level: 2,
                title: "666. 更多说明",
                slug: "_666-更多说明",
                normalizedTitle: "666. 更多说明",
                charIndex: 12007
            }],
            headersStr: "1. 环境准备 1.1 安装 Docker 1.2 安装 MySQL 1.3 安装 Redis 1.4 安装 Nginx 2. 部署后端服务 3. 部署前端 3.1 yudao-ui-admin-vue3 3.2 yudao-ui-admin-vben 4.3 yudao-ui-admin-vue2 4. 配置 Nginx 转发 4.1 方式一：服务器 IP 访问 4.2 方式二：独立域名访问 666. 更多说明",
            content: '本小节，讲解如何将前端 + 后端项目，使用 Docker 容器，部署到 dev 开发环境下的一台 Linux 服务器上。如下图所示：\n\n\n\n注意：服务器的 IP 地址。\n\n * 外网 IP：139.9.196.247 或 8.154.33.209\n * 内网 IP：192.168.0.213 或 172.26.126.182\n\n下属所有涉及到 IP 的配置，需要替换成你自己的。\n\n\n# 1. 环境准备\n\n需要安装如下环境：\n\n * Docker：容器\n * MySQL：数据库\n * Redis：缓存\n * Nginx：负载均衡\n\n\n# 1.1 安装 Docker\n\n执行如下命令，进行 Docker 的安装。参考自 https://help.aliyun.com/zh/ecs/use-cases/install-and-use-docker-on-a-linux-ecs-instance 文档。\n\n# ① 运行以下命令，安装 Docker 存储驱动的依赖包\ndnf install -y device-mapper-persistent-data lvm2\n\n# ② 添加稳定的 Docker 软件源\ndnf config-manager --add-repo=https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n\n# ③ 检查 Docker 软件源是否已添加\ndnf list docker-ce\n\n# ④ 安装 Docker\ndnf install -y docker-ce --nobest\n\n# ⑤ 查看 docker 版本信息：返回 Docker version 27.3.1, build ce12230\ndocker -v\n\n# ⑥ 启动 Docker 守护进程，并设置开机自启动\nsystemctl start docker\nsystemctl enable docker\n\n\n补充说明：由于访问 Docker 镜像不稳定，一般建议加速访问！！！\n\n问题反馈：\n\n * https://t.zsxq.com/sfdMJ\n\n可参考加速方式：\n\n * DaoCloud / public-image-mirror\n * kubesre / docker-registry-mirrors\n\n\n# 1.2 安装 MySQL\n\n# 第一步，安装 MySQL（可选）\n\n友情提示：使用 Docker 安装 MySQL 是可选步骤，也可以直接安装 MySQL，或者购买 MySQL 云服务。\n\n① 执行如下命令，使用 Docker 启动 MySQL 容器。\n\ndocker run -v /work/mysql/:/var/lib/mysql \\\n-p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 \\\n--restart=always --name mysql -d m.daocloud.io/docker.io/mysql\n\n\n * 数据库文件，挂载到服务器的的 /work/mysql/ 目录下\n * 端口是 3306，密码是 123456\n\n② 执行 ls /work/mysql 命令，查看 /work/mysql/ 目录的数据库文件。\n\n\n\n# 第二步，导入 SQL 脚本\n\n创建一个名字为 ruoyi-vue-pro 数据库，执行数据库对应的 sql 目录下的 SQL 文件，进行初始化。\n\n\n\n\n# 1.3 安装 Redis\n\n友情提示：使用 Docker 安装 Redis 是可选步骤，也可以直接安装 Redis，或者购买 Redis 云服务。\n\n执行如下命令，使用 Docker 启动 Redis 容器。\n\ndocker run -d --name redis --restart=always -p 6379:6379 m.daocloud.io/docker.io/redis\n\n\n * 端口是 6379，密码未设置\n\n\n# 1.4 安装 Nginx\n\n# 第一步，创建挂载目录\n\nNginx 挂载到服务器的目录：\n\n * /work/nginx/conf.d 用于存放配置文件\n * /work/nginx/html 用于存放网页文件\n * /work/nginx/logs 用于存放日志\n * /work/nginx/cert 用于存放 HTTPS 证书\n\n创建 /work/nginx 目录，并在该目录下新建 nginx.conf 文件，避免稍后安装 Nginx 报错。内容如下：\n\nuser  nginx;\nworker_processes  1;\n\nevents {\n    worker_connections  1024;\n}\n\nerror_log  /var/log/nginx/error.log warn;\npid        /var/run/nginx.pid;\n\nhttp {\n    include       /etc/nginx/mime.types;\n    default_type  application/octet-stream;\n    sendfile        on;\n    keepalive_timeout  65;\n\n    log_format  main  \'$remote_addr - $remote_user [$time_local] "$request" \'\n                      \'$status $body_bytes_sent "$http_referer" \'\n                      \'"$http_user_agent" "$http_x_forwarded_for"\';\n#    access_log  /var/log/nginx/access.log  main;\n\n    gzip on;\n    gzip_min_length 1k;     # 设置允许压缩的页面最小字节数\n    gzip_buffers 4 16k;     # 用来存储 gzip 的压缩结果\n    gzip_http_version 1.1;  # 识别 HTTP 协议版本\n    gzip_comp_level 2;      # 设置 gzip 的压缩比 1-9。1 压缩比最小但最快，而 9 相反\n    gzip_types text/plain application/x-javascript text/css application/xml application/javascript; # 指定压缩类型\n    gzip_proxied any;       # 无论后端服务器的 headers 头返回什么信息，都无条件启用压缩\n\n    include /etc/nginx/conf.d/*.conf; ## 加载该目录下的其它 Nginx 配置文件\n}\n\n\n# 启动 Nginx\n\n① 执行如下命令，使用 Docker 启动 Nginx 容器。\n\ndocker run -d \\\n--name nginx --restart always \\\n-p 80:80 -p 443:443 \\\n-e "TZ=Asia/Shanghai" \\\n-v /work/nginx/nginx.conf:/etc/nginx/nginx.conf \\\n-v /work/nginx/conf.d:/etc/nginx/conf.d \\\n-v /work/nginx/logs:/var/log/nginx \\\n-v /work/nginx/cert:/etc/nginx/cert \\\n-v /work/nginx/html:/usr/share/nginx/html \\\nm.daocloud.io/docker.io/nginx\n\n\n② 执行 docker ps 命令，查看到 Nginx 容器的状态是 UP 的。\n\n\n# 2. 部署后端服务\n\n# 第一步，修改配置\n\n后端 dev 开发环境对应的是 application-dev.yaml 配置文件，主要是修改 MySQL 和 Redis 为你的地址。如下图所示：\n\n\n\n# 第二步，编译后端\n\n在项目的根目录下，执行 mvn clean package -Dmaven.test.skip=true 命令，编译后端项目，构建出它的 Jar 包。如下图所示：\n\n\n\n疑问：-Dmaven.test.skip=true 是什么意思？\n\n跳过单元测试的执行。如果你项目的单元测试写的不错，建议使用 mvn clean package 命令，执行单元测试，保证交付的质量。\n\n# 第三步，上传 Jar 包\n\n在 Linux 服务器上创建 /work/projects/yudao-server 目录，使用 scp 命令或者 FTP 工具，将 yudao-server.jar 上传到该目录下。如下图所示：\n\n\n\n# 第四步，构建镜像\n\n① 在 /work/projects/yudao-server 目录下，新建 Dockerfile 文件，用于制作后端项目的 Docker 镜像。编写内容如下：\n\n## AdoptOpenJDK 停止发布 OpenJDK 二进制，而 Eclipse Temurin 是它的延伸，提供更好的稳定性\n## 感谢复旦核博士的建议！灰子哥，牛皮！\nFROM m.daocloud.io/docker.io/eclipse-temurin:8-jre\n\n## 创建目录，并使用它作为工作目录\nRUN mkdir -p /yudao-server\nWORKDIR /yudao-server\n## 将后端项目的 Jar 文件，复制到镜像中\nCOPY yudao-server.jar app.jar\n\n## 设置 TZ 时区\n## 设置 JAVA_OPTS 环境变量，可通过 docker run -e "JAVA_OPTS=" 进行覆盖\nENV TZ=Asia/Shanghai JAVA_OPTS="-Xms512m -Xmx512m"\n\n## 暴露后端项目的 48080 端口\nEXPOSE 48080\n\n## 启动后端项目\nENTRYPOINT java ${JAVA_OPTS} -Djava.security.egd=file:/dev/./urandom -jar app.jar\n\n\n② 执行如下命令，构建名字为 yudao-server 的 Docker 镜像。\n\ncd /work/projects/yudao-server\ndocker build -t yudao-server .\n\n\n③ 在 /work/projects/yudao-server 目录下，新建 Shell 脚本 deploy.sh，使用 Docker 启动后端项目。编写内容如下：\n\n#!/bin/bash\nset -e\n\n## 第一步：删除可能启动的老 yudao-server 容器\necho "开始删除 yudao-server 容器"\ndocker stop yudao-server || true\ndocker rm yudao-server || true\necho "完成删除 yudao-server 容器"\n\n## 第二步：启动新的 yudao-server 容器 \\\necho "开始启动 yudao-server 容器"\ndocker run -d \\\n--name yudao-server \\\n-p 48080:48080 \\\n-e "SPRING_PROFILES_ACTIVE=dev" \\\n-v /work/projects/yudao-server:/root/logs/ \\\nyudao-server\necho "正在启动 yudao-server 容器中，需要等待 60 秒左右"\n\n\n * 应用日志文件，挂载到服务器的的 /work/projects/yudao-server 目录下\n * 通过 SPRING_PROFILES_ACTIVE 设置为 dev 开发环境\n\n# 第五步，启动后端\n\n① 执行 sh deploy.sh 命令，使用 Docker 启动后端项目。日志如下：\n\n开始删除 yudao-server 容器\nyudao-server\nyudao-server\n完成删除 yudao-server 容器\n开始启动 yudao-server 容器\n0dfd3dc409a53ae6b5e7c5662602cf5dcb52fd4d7f673bd74af7d21da8ead9d5\n正在启动 yudao-server 容器中，需要等待 60 秒左右\n\n\n② 执行 docker logs yudao-server 命令，查看启动日志。看到如下内容，说明启动完成：\n\n友情提示：如果日志比较多，可以使用 grep 进行过滤。\n\n例如说：使用 docker logs yudao-server | grep 48080\n\n2022-04-15 00:34:19.647  INFO 8 --- [main] [TID: N/A] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 48080 (http)\n\n\n\n# 3. 部署前端\n\n项目的管理后台有 3 个版本（只需要看你的版本即可）：\n\n * yudao-ui-admin-vue3：基于 Vue3 + element-plus\n * yudao-ui-admin-vben：基于 Vue3 + vben(ant-design-vue)\n * yudao-ui-admin-vue2：基于 Vue2 + element-ui\n\n注意，前端无法直接启动，而是需要通过 Nginx 转发读取前端构建出来的静态文件，最终都放在服务器上的 /work/projects/yudao-ui-admin 目录下。\n\n\n# 3.1 yudao-ui-admin-vue3\n\n基于 Vue3 + element-plus\n\n# 第一步，修改配置\n\n前端 dev 开发环境对应的是 .env.dev 配置文件，主要是修改 VITE_BASE_URL 为你的后端项目的访问地址。如下图所示：\n\n\n\n# 第二步，编译前端\n\n在前端项目的根目录下，执行 npm run build:dev 命令，编译前端项目，构建出它的 dist 文件，里面是 HTML、CSS、JavaScript 等静态文件。如下图所示：\n\n\n\n如下想要打包其它环境，可使用如下命令：\n\nnpm run build:prod ## 打包 prod 生产环境\nnpm run build:stage ## 打包 stage 预发布环境\n\n\n如果是在服务器上构建，并且出现卡死的情况，可以参考 https://gitee.com/yudaocode/yudao-ui-admin-vue3/issues/IAU0T3 解决\n\n其它高级参数说明【可暂时不看】：\n\n① VITE_PUBLIC_PATH：前端打包的路径（静态资源的基础路径），一般默认为 / 即可。目前有两种用法：\n\n第一种，可用于二级目录部署。例如说，VITE_PUBLIC_PATH 设置为 /demo 。然后 Nginx 配置时，需要特殊注意，如下所示：\n\n        location /demo { # 注意点 1：不需要 / 结尾\n            # 注意点 2：二级路由时需要使用别名 alias，不用 root\n            alias   /work/projects/yudao-ui-admin/; # 注意点 3：需要 / 结尾\n            index  index.html index.htm;\n            try_files $uri $uri/ /index.html;\n        }\n\n\n第二种，可用于七牛等 CDN 服务，读取前端的静态文件，提升访问速度，建议 prod 生产环境使用。例如说，我们演示环境的 VITE_PUBLIC_PATH 是 http://static-vue3.yudao.iocoder.cn/ 。\n\n具体操作，可参考文章的 《Vue 项目使用七牛云 CDN 存放静态资源》 的「二、实现方式 」部分，只是最终的“修改 index.html 中静态资源引用”，变成 PUBLIC_PATH 修改即可。\n\n# 第三步，上传 dist 文件\n\n在 Linux 服务器上创建 /work/projects/yudao-ui-admin 目录，使用 scp 命令或者 FTP 工具，将 dist 上传到该目录下。如下图所示：\n\n\n\n\n# 3.2 yudao-ui-admin-vben\n\n基于 Vue3 + vben(ant-design-vue)\n\n# 第一步，修改配置\n\n前端 production 开发环境对应的是 .env.production 配置文件，主要是修改 VITE_GLOB_BASE_URL、VITE_GLOB_API_URL 为你的后端项目的访问地址。如下图所示：\n\n\n\n其它高级参数说明【可暂时不看】：\n\n① VITE_PUBLIC_PATH：前端打包的路径（静态资源的基础路径），一般默认为 / 即可。目前有两种用法：\n\n第一种，可用于二级目录部署。例如说，VITE_PUBLIC_PATH 设置为 /demo 。然后 Nginx 配置时，需要特殊注意，如下所示：\n\n        location /demo { # 注意点 1：不需要 / 结尾\n            # 注意点 2：二级路由时需要使用别名 alias，不用 root\n            alias   /work/projects/yudao-ui-admin/; # 注意点 3：需要 / 结尾\n            index  index.html index.htm;\n            try_files $uri $uri/ /index.html;\n        }\n\n\n第二种，可用于七牛等 CDN 服务，读取前端的静态文件，提升访问速度，建议 prod 生产环境使用。例如说，我们演示环境的 VITE_PUBLIC_PATH 是 http://static-vue3.yudao.iocoder.cn/ 。\n\n具体操作，可参考文章的 《Vue 项目使用七牛云 CDN 存放静态资源》 的「二、实现方式 」部分，只是最终的“修改 index.html 中静态资源引用”，变成 PUBLIC_PATH 修改即可。\n\n# 第二步，编译前端\n\n在前端项目的根目录下，执行 npm run build 命令，编译前端项目，构建出它的 dist 文件，里面是 HTML、CSS、JavaScript 等静态文件。如下图所示：\n\n\n\n# 第三步，上传 dist 文件\n\n在 Linux 服务器上创建 /work/projects/yudao-ui-admin 目录，使用 scp 命令或者 FTP 工具，将 dist 上传到该目录下。如下图所示：\n\n\n\n\n# 4.3 yudao-ui-admin-vue2\n\n基于 Vue2 + element-ui\n\n# 第一步，修改配置\n\n前端 dev 开发环境对应的是 .env.dev 配置文件，主要是修改 VUE_APP_BASE_API 为你的后端项目的访问地址。如下图所示：\n\n\n\n# 第二步，编译前端\n\n在前端项目的根目录下，执行 npm run build:dev 命令，编译前端项目，构建出它的 dist 文件，里面是 HTML、CSS、JavaScript 等静态文件。如下图所示：\n\n\n\n如下想要打包其它环境，可使用如下命令：\n\nnpm run build:prod ## 打包 prod 生产环境\nnpm run build:stage ## 打包 stage 预发布环境\n\n\n其它高级参数说明【可暂时不看】：\n\n① PUBLIC_PATH：可用于七牛等 CDN 服务，读取前端的静态文件，提升访问速度，建议 prod 生产环境使用。示例如下：\n\n可参考文章的 《Vue 项目使用七牛云 CDN 存放静态资源》 的「二、实现方式 」部分，只是最终的“修改 index.html 中静态资源引用”，变成 PUBLIC_PATH 修改即可。\n\n② VUE_APP_APP_NAME：二级部署路径，默认为 / 根目录，一般不用修改。\n\n③ mode：前端路由的模式，默认采用 history 路由，一般不用修改。可以通过修改 router/index.js 来设置为 hash 路由，示例如下：\n\n\n\n# 第三步，上传 dist 文件\n\n在 Linux 服务器上创建 /work/projects/yudao-ui-admin 目录，使用 scp 命令或者 FTP 工具，将 dist 上传到该目录下。如下图所示：\n\n\n\n\n# 4. 配置 Nginx 转发\n\n两种 Nginx 的配置，分别满足服务器 IP、独立域名的不同场景。\n\n\n# 4.1 方式一：服务器 IP 访问\n\n① 在 /work/nginx/conf.d 目录下，创建 ruoyi-vue-pro.conf，内容如下：\n\nserver {\n    listen       80;\n    server_name  139.9.196.247; ## 重要！！！修改成你的外网 IP/域名\n\n    location / { ## 前端项目\n        root   /usr/share/nginx/html/yudao-admin-ui;\n        index  index.html index.htm;\n        try_files $uri $uri/ /index.html;\n    }\n\n    location /admin-api/ { ## 后端项目 - 管理后台\n        proxy_pass http://192.168.0.213:48080/admin-api/; ## 重要！！！proxy_pass 需要设置为后端项目所在服务器的 IP\n        proxy_set_header Host $http_host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header REMOTE-HOST $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    }\n\n    location /app-api/ { ## 后端项目 - 用户 App\n        proxy_pass http://192.168.0.213:48080/app-api/; ## 重要！！！proxy_pass 需要设置为后端项目所在服务器的 IP\n        proxy_set_header Host $http_host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header REMOTE-HOST $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    }\n\n}\n\n\n友情提示：\n\n[root] 指令在本地文件时，要使用 Nginx Docker 容器内的路径，即 /usr/share/nginx/html/yudao-admin-ui，否则会报 404 的错误。\n\n② 执行 docker exec nginx nginx -s reload 命令，重新加载 Nginx 配置。\n\n友情提示：如果你担心 Nginx 配置不正确，可以执行 docker exec nginx nginx -t 命令。\n\n③ 执行 curl http://192.168.0.213/admin-api/ 命令，成功访问后端项目的内网地址，返回结果如下：\n\n{"code":401,"data":null,"msg":"账号未登录"}\n\n\n执行 curl http://139.9.196.247:48080/admin-api/ 命令，成功访问后端项目的外网地址，返回结果一致。\n\n④ 请求 http://139.9.196.247:48080 地址，成功访问前端项目的外网地址，，返回前端界面如下：\n\n\n\n⑤ 如果你使用到 WebSocket 的话，需要额外对 /infra/ws 路径进行配置，具体可见 https://t.zsxq.com/LQEfC 链接。\n\n\n# 4.2 方式二：独立域名访问\n\n友情提示：在前端项目的编译时，需要把 `VUE_APP_BASE_API` 修改为后端项目对应的域名。\n\n例如说，这里使用的是 http://api.iocoder.cn\n\n① 在 /work/nginx/conf.d 目录下，创建 ruoyi-vue-pro2.conf，内容如下：\n\nserver { ## 前端项目\n    listen       80;\n    server_name  admin.iocoder.cn; ## 重要！！！修改成你的前端域名\n\n    location / { ## 前端项目\n        root   /usr/share/nginx/html/yudao-admin-ui;\n        index  index.html index.htm;\n        try_files $uri $uri/ /index.html;\n    }\n\n}\n\nserver { ## 后端项目\n    listen       80;\n    server_name  api.iocoder.cn; ## 重要！！！修改成你的外网 IP/域名\n\n    ## 不要使用 location / 转发到后端项目，因为 druid、admin 等监控，不需要外网可访问。或者增加 Nginx IP 白名单限制也可以。\n\n    location /admin-api/ { ## 后端项目 - 管理后台\n        proxy_pass http://192.168.0.213:48080/admin-api/; ## 重要！！！proxy_pass 需要设置为后端项目所在服务器的 IP\n        proxy_set_header Host $http_host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header REMOTE-HOST $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    }\n\n    location /app-api/ { ## 后端项目 - 用户 App\n        proxy_pass http://192.168.0.213:48080/app-api/; ## 重要！！！proxy_pass 需要设置为后端项目所在服务器的 IP\n        proxy_set_header Host $http_host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header REMOTE-HOST $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    }\n\n}\n\n\n② 执行 docker exec nginx nginx -s reload 命令，重新加载 Nginx 配置。\n\n③ 请求 http://api.iocoder.cn/admin-api/ 地址，成功访问后端项目，返回结果如下：\n\n{"code":401,"data":null,"msg":"账号未登录"}\n\n\n④ 请求 http://admin.iocoder.cn 地址，成功访问前端项目，返回前端界面如下：\n\n\n\n\n# 666. 更多说明\n\n① 积木报表菜单，无法访问。参考 https://t.zsxq.com/vBkup 解决。',
            normalizedContent: '本小节，讲解如何将前端 + 后端项目，使用 docker 容器，部署到 dev 开发环境下的一台 linux 服务器上。如下图所示：\n\n\n\n注意：服务器的 ip 地址。\n\n * 外网 ip：139.9.196.247 或 8.154.33.209\n * 内网 ip：192.168.0.213 或 172.26.126.182\n\n下属所有涉及到 ip 的配置，需要替换成你自己的。\n\n\n# 1. 环境准备\n\n需要安装如下环境：\n\n * docker：容器\n * mysql：数据库\n * redis：缓存\n * nginx：负载均衡\n\n\n# 1.1 安装 docker\n\n执行如下命令，进行 docker 的安装。参考自 https://help.aliyun.com/zh/ecs/use-cases/install-and-use-docker-on-a-linux-ecs-instance 文档。\n\n# ① 运行以下命令，安装 docker 存储驱动的依赖包\ndnf install -y device-mapper-persistent-data lvm2\n\n# ② 添加稳定的 docker 软件源\ndnf config-manager --add-repo=https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n\n# ③ 检查 docker 软件源是否已添加\ndnf list docker-ce\n\n# ④ 安装 docker\ndnf install -y docker-ce --nobest\n\n# ⑤ 查看 docker 版本信息：返回 docker version 27.3.1, build ce12230\ndocker -v\n\n# ⑥ 启动 docker 守护进程，并设置开机自启动\nsystemctl start docker\nsystemctl enable docker\n\n\n补充说明：由于访问 docker 镜像不稳定，一般建议加速访问！！！\n\n问题反馈：\n\n * https://t.zsxq.com/sfdmj\n\n可参考加速方式：\n\n * daocloud / public-image-mirror\n * kubesre / docker-registry-mirrors\n\n\n# 1.2 安装 mysql\n\n# 第一步，安装 mysql（可选）\n\n友情提示：使用 docker 安装 mysql 是可选步骤，也可以直接安装 mysql，或者购买 mysql 云服务。\n\n① 执行如下命令，使用 docker 启动 mysql 容器。\n\ndocker run -v /work/mysql/:/var/lib/mysql \\\n-p 3306:3306 -e mysql_root_password=123456 \\\n--restart=always --name mysql -d m.daocloud.io/docker.io/mysql\n\n\n * 数据库文件，挂载到服务器的的 /work/mysql/ 目录下\n * 端口是 3306，密码是 123456\n\n② 执行 ls /work/mysql 命令，查看 /work/mysql/ 目录的数据库文件。\n\n\n\n# 第二步，导入 sql 脚本\n\n创建一个名字为 ruoyi-vue-pro 数据库，执行数据库对应的 sql 目录下的 sql 文件，进行初始化。\n\n\n\n\n# 1.3 安装 redis\n\n友情提示：使用 docker 安装 redis 是可选步骤，也可以直接安装 redis，或者购买 redis 云服务。\n\n执行如下命令，使用 docker 启动 redis 容器。\n\ndocker run -d --name redis --restart=always -p 6379:6379 m.daocloud.io/docker.io/redis\n\n\n * 端口是 6379，密码未设置\n\n\n# 1.4 安装 nginx\n\n# 第一步，创建挂载目录\n\nnginx 挂载到服务器的目录：\n\n * /work/nginx/conf.d 用于存放配置文件\n * /work/nginx/html 用于存放网页文件\n * /work/nginx/logs 用于存放日志\n * /work/nginx/cert 用于存放 https 证书\n\n创建 /work/nginx 目录，并在该目录下新建 nginx.conf 文件，避免稍后安装 nginx 报错。内容如下：\n\nuser  nginx;\nworker_processes  1;\n\nevents {\n    worker_connections  1024;\n}\n\nerror_log  /var/log/nginx/error.log warn;\npid        /var/run/nginx.pid;\n\nhttp {\n    include       /etc/nginx/mime.types;\n    default_type  application/octet-stream;\n    sendfile        on;\n    keepalive_timeout  65;\n\n    log_format  main  \'$remote_addr - $remote_user [$time_local] "$request" \'\n                      \'$status $body_bytes_sent "$http_referer" \'\n                      \'"$http_user_agent" "$http_x_forwarded_for"\';\n#    access_log  /var/log/nginx/access.log  main;\n\n    gzip on;\n    gzip_min_length 1k;     # 设置允许压缩的页面最小字节数\n    gzip_buffers 4 16k;     # 用来存储 gzip 的压缩结果\n    gzip_http_version 1.1;  # 识别 http 协议版本\n    gzip_comp_level 2;      # 设置 gzip 的压缩比 1-9。1 压缩比最小但最快，而 9 相反\n    gzip_types text/plain application/x-javascript text/css application/xml application/javascript; # 指定压缩类型\n    gzip_proxied any;       # 无论后端服务器的 headers 头返回什么信息，都无条件启用压缩\n\n    include /etc/nginx/conf.d/*.conf; ## 加载该目录下的其它 nginx 配置文件\n}\n\n\n# 启动 nginx\n\n① 执行如下命令，使用 docker 启动 nginx 容器。\n\ndocker run -d \\\n--name nginx --restart always \\\n-p 80:80 -p 443:443 \\\n-e "tz=asia/shanghai" \\\n-v /work/nginx/nginx.conf:/etc/nginx/nginx.conf \\\n-v /work/nginx/conf.d:/etc/nginx/conf.d \\\n-v /work/nginx/logs:/var/log/nginx \\\n-v /work/nginx/cert:/etc/nginx/cert \\\n-v /work/nginx/html:/usr/share/nginx/html \\\nm.daocloud.io/docker.io/nginx\n\n\n② 执行 docker ps 命令，查看到 nginx 容器的状态是 up 的。\n\n\n# 2. 部署后端服务\n\n# 第一步，修改配置\n\n后端 dev 开发环境对应的是 application-dev.yaml 配置文件，主要是修改 mysql 和 redis 为你的地址。如下图所示：\n\n\n\n# 第二步，编译后端\n\n在项目的根目录下，执行 mvn clean package -dmaven.test.skip=true 命令，编译后端项目，构建出它的 jar 包。如下图所示：\n\n\n\n疑问：-dmaven.test.skip=true 是什么意思？\n\n跳过单元测试的执行。如果你项目的单元测试写的不错，建议使用 mvn clean package 命令，执行单元测试，保证交付的质量。\n\n# 第三步，上传 jar 包\n\n在 linux 服务器上创建 /work/projects/yudao-server 目录，使用 scp 命令或者 ftp 工具，将 yudao-server.jar 上传到该目录下。如下图所示：\n\n\n\n# 第四步，构建镜像\n\n① 在 /work/projects/yudao-server 目录下，新建 dockerfile 文件，用于制作后端项目的 docker 镜像。编写内容如下：\n\n## adoptopenjdk 停止发布 openjdk 二进制，而 eclipse temurin 是它的延伸，提供更好的稳定性\n## 感谢复旦核博士的建议！灰子哥，牛皮！\nfrom m.daocloud.io/docker.io/eclipse-temurin:8-jre\n\n## 创建目录，并使用它作为工作目录\nrun mkdir -p /yudao-server\nworkdir /yudao-server\n## 将后端项目的 jar 文件，复制到镜像中\ncopy yudao-server.jar app.jar\n\n## 设置 tz 时区\n## 设置 java_opts 环境变量，可通过 docker run -e "java_opts=" 进行覆盖\nenv tz=asia/shanghai java_opts="-xms512m -xmx512m"\n\n## 暴露后端项目的 48080 端口\nexpose 48080\n\n## 启动后端项目\nentrypoint java ${java_opts} -djava.security.egd=file:/dev/./urandom -jar app.jar\n\n\n② 执行如下命令，构建名字为 yudao-server 的 docker 镜像。\n\ncd /work/projects/yudao-server\ndocker build -t yudao-server .\n\n\n③ 在 /work/projects/yudao-server 目录下，新建 shell 脚本 deploy.sh，使用 docker 启动后端项目。编写内容如下：\n\n#!/bin/bash\nset -e\n\n## 第一步：删除可能启动的老 yudao-server 容器\necho "开始删除 yudao-server 容器"\ndocker stop yudao-server || true\ndocker rm yudao-server || true\necho "完成删除 yudao-server 容器"\n\n## 第二步：启动新的 yudao-server 容器 \\\necho "开始启动 yudao-server 容器"\ndocker run -d \\\n--name yudao-server \\\n-p 48080:48080 \\\n-e "spring_profiles_active=dev" \\\n-v /work/projects/yudao-server:/root/logs/ \\\nyudao-server\necho "正在启动 yudao-server 容器中，需要等待 60 秒左右"\n\n\n * 应用日志文件，挂载到服务器的的 /work/projects/yudao-server 目录下\n * 通过 spring_profiles_active 设置为 dev 开发环境\n\n# 第五步，启动后端\n\n① 执行 sh deploy.sh 命令，使用 docker 启动后端项目。日志如下：\n\n开始删除 yudao-server 容器\nyudao-server\nyudao-server\n完成删除 yudao-server 容器\n开始启动 yudao-server 容器\n0dfd3dc409a53ae6b5e7c5662602cf5dcb52fd4d7f673bd74af7d21da8ead9d5\n正在启动 yudao-server 容器中，需要等待 60 秒左右\n\n\n② 执行 docker logs yudao-server 命令，查看启动日志。看到如下内容，说明启动完成：\n\n友情提示：如果日志比较多，可以使用 grep 进行过滤。\n\n例如说：使用 docker logs yudao-server | grep 48080\n\n2022-04-15 00:34:19.647  info 8 --- [main] [tid: n/a] o.s.b.w.embedded.tomcat.tomcatwebserver  : tomcat initialized with port(s): 48080 (http)\n\n\n\n# 3. 部署前端\n\n项目的管理后台有 3 个版本（只需要看你的版本即可）：\n\n * yudao-ui-admin-vue3：基于 vue3 + element-plus\n * yudao-ui-admin-vben：基于 vue3 + vben(ant-design-vue)\n * yudao-ui-admin-vue2：基于 vue2 + element-ui\n\n注意，前端无法直接启动，而是需要通过 nginx 转发读取前端构建出来的静态文件，最终都放在服务器上的 /work/projects/yudao-ui-admin 目录下。\n\n\n# 3.1 yudao-ui-admin-vue3\n\n基于 vue3 + element-plus\n\n# 第一步，修改配置\n\n前端 dev 开发环境对应的是 .env.dev 配置文件，主要是修改 vite_base_url 为你的后端项目的访问地址。如下图所示：\n\n\n\n# 第二步，编译前端\n\n在前端项目的根目录下，执行 npm run build:dev 命令，编译前端项目，构建出它的 dist 文件，里面是 html、css、javascript 等静态文件。如下图所示：\n\n\n\n如下想要打包其它环境，可使用如下命令：\n\nnpm run build:prod ## 打包 prod 生产环境\nnpm run build:stage ## 打包 stage 预发布环境\n\n\n如果是在服务器上构建，并且出现卡死的情况，可以参考 https://gitee.com/yudaocode/yudao-ui-admin-vue3/issues/iau0t3 解决\n\n其它高级参数说明【可暂时不看】：\n\n① vite_public_path：前端打包的路径（静态资源的基础路径），一般默认为 / 即可。目前有两种用法：\n\n第一种，可用于二级目录部署。例如说，vite_public_path 设置为 /demo 。然后 nginx 配置时，需要特殊注意，如下所示：\n\n        location /demo { # 注意点 1：不需要 / 结尾\n            # 注意点 2：二级路由时需要使用别名 alias，不用 root\n            alias   /work/projects/yudao-ui-admin/; # 注意点 3：需要 / 结尾\n            index  index.html index.htm;\n            try_files $uri $uri/ /index.html;\n        }\n\n\n第二种，可用于七牛等 cdn 服务，读取前端的静态文件，提升访问速度，建议 prod 生产环境使用。例如说，我们演示环境的 vite_public_path 是 http://static-vue3.yudao.iocoder.cn/ 。\n\n具体操作，可参考文章的 《vue 项目使用七牛云 cdn 存放静态资源》 的「二、实现方式 」部分，只是最终的“修改 index.html 中静态资源引用”，变成 public_path 修改即可。\n\n# 第三步，上传 dist 文件\n\n在 linux 服务器上创建 /work/projects/yudao-ui-admin 目录，使用 scp 命令或者 ftp 工具，将 dist 上传到该目录下。如下图所示：\n\n\n\n\n# 3.2 yudao-ui-admin-vben\n\n基于 vue3 + vben(ant-design-vue)\n\n# 第一步，修改配置\n\n前端 production 开发环境对应的是 .env.production 配置文件，主要是修改 vite_glob_base_url、vite_glob_api_url 为你的后端项目的访问地址。如下图所示：\n\n\n\n其它高级参数说明【可暂时不看】：\n\n① vite_public_path：前端打包的路径（静态资源的基础路径），一般默认为 / 即可。目前有两种用法：\n\n第一种，可用于二级目录部署。例如说，vite_public_path 设置为 /demo 。然后 nginx 配置时，需要特殊注意，如下所示：\n\n        location /demo { # 注意点 1：不需要 / 结尾\n            # 注意点 2：二级路由时需要使用别名 alias，不用 root\n            alias   /work/projects/yudao-ui-admin/; # 注意点 3：需要 / 结尾\n            index  index.html index.htm;\n            try_files $uri $uri/ /index.html;\n        }\n\n\n第二种，可用于七牛等 cdn 服务，读取前端的静态文件，提升访问速度，建议 prod 生产环境使用。例如说，我们演示环境的 vite_public_path 是 http://static-vue3.yudao.iocoder.cn/ 。\n\n具体操作，可参考文章的 《vue 项目使用七牛云 cdn 存放静态资源》 的「二、实现方式 」部分，只是最终的“修改 index.html 中静态资源引用”，变成 public_path 修改即可。\n\n# 第二步，编译前端\n\n在前端项目的根目录下，执行 npm run build 命令，编译前端项目，构建出它的 dist 文件，里面是 html、css、javascript 等静态文件。如下图所示：\n\n\n\n# 第三步，上传 dist 文件\n\n在 linux 服务器上创建 /work/projects/yudao-ui-admin 目录，使用 scp 命令或者 ftp 工具，将 dist 上传到该目录下。如下图所示：\n\n\n\n\n# 4.3 yudao-ui-admin-vue2\n\n基于 vue2 + element-ui\n\n# 第一步，修改配置\n\n前端 dev 开发环境对应的是 .env.dev 配置文件，主要是修改 vue_app_base_api 为你的后端项目的访问地址。如下图所示：\n\n\n\n# 第二步，编译前端\n\n在前端项目的根目录下，执行 npm run build:dev 命令，编译前端项目，构建出它的 dist 文件，里面是 html、css、javascript 等静态文件。如下图所示：\n\n\n\n如下想要打包其它环境，可使用如下命令：\n\nnpm run build:prod ## 打包 prod 生产环境\nnpm run build:stage ## 打包 stage 预发布环境\n\n\n其它高级参数说明【可暂时不看】：\n\n① public_path：可用于七牛等 cdn 服务，读取前端的静态文件，提升访问速度，建议 prod 生产环境使用。示例如下：\n\n可参考文章的 《vue 项目使用七牛云 cdn 存放静态资源》 的「二、实现方式 」部分，只是最终的“修改 index.html 中静态资源引用”，变成 public_path 修改即可。\n\n② vue_app_app_name：二级部署路径，默认为 / 根目录，一般不用修改。\n\n③ mode：前端路由的模式，默认采用 history 路由，一般不用修改。可以通过修改 router/index.js 来设置为 hash 路由，示例如下：\n\n\n\n# 第三步，上传 dist 文件\n\n在 linux 服务器上创建 /work/projects/yudao-ui-admin 目录，使用 scp 命令或者 ftp 工具，将 dist 上传到该目录下。如下图所示：\n\n\n\n\n# 4. 配置 nginx 转发\n\n两种 nginx 的配置，分别满足服务器 ip、独立域名的不同场景。\n\n\n# 4.1 方式一：服务器 ip 访问\n\n① 在 /work/nginx/conf.d 目录下，创建 ruoyi-vue-pro.conf，内容如下：\n\nserver {\n    listen       80;\n    server_name  139.9.196.247; ## 重要！！！修改成你的外网 ip/域名\n\n    location / { ## 前端项目\n        root   /usr/share/nginx/html/yudao-admin-ui;\n        index  index.html index.htm;\n        try_files $uri $uri/ /index.html;\n    }\n\n    location /admin-api/ { ## 后端项目 - 管理后台\n        proxy_pass http://192.168.0.213:48080/admin-api/; ## 重要！！！proxy_pass 需要设置为后端项目所在服务器的 ip\n        proxy_set_header host $http_host;\n        proxy_set_header x-real-ip $remote_addr;\n        proxy_set_header remote-host $remote_addr;\n        proxy_set_header x-forwarded-for $proxy_add_x_forwarded_for;\n    }\n\n    location /app-api/ { ## 后端项目 - 用户 app\n        proxy_pass http://192.168.0.213:48080/app-api/; ## 重要！！！proxy_pass 需要设置为后端项目所在服务器的 ip\n        proxy_set_header host $http_host;\n        proxy_set_header x-real-ip $remote_addr;\n        proxy_set_header remote-host $remote_addr;\n        proxy_set_header x-forwarded-for $proxy_add_x_forwarded_for;\n    }\n\n}\n\n\n友情提示：\n\n[root] 指令在本地文件时，要使用 nginx docker 容器内的路径，即 /usr/share/nginx/html/yudao-admin-ui，否则会报 404 的错误。\n\n② 执行 docker exec nginx nginx -s reload 命令，重新加载 nginx 配置。\n\n友情提示：如果你担心 nginx 配置不正确，可以执行 docker exec nginx nginx -t 命令。\n\n③ 执行 curl http://192.168.0.213/admin-api/ 命令，成功访问后端项目的内网地址，返回结果如下：\n\n{"code":401,"data":null,"msg":"账号未登录"}\n\n\n执行 curl http://139.9.196.247:48080/admin-api/ 命令，成功访问后端项目的外网地址，返回结果一致。\n\n④ 请求 http://139.9.196.247:48080 地址，成功访问前端项目的外网地址，，返回前端界面如下：\n\n\n\n⑤ 如果你使用到 websocket 的话，需要额外对 /infra/ws 路径进行配置，具体可见 https://t.zsxq.com/lqefc 链接。\n\n\n# 4.2 方式二：独立域名访问\n\n友情提示：在前端项目的编译时，需要把 `vue_app_base_api` 修改为后端项目对应的域名。\n\n例如说，这里使用的是 http://api.iocoder.cn\n\n① 在 /work/nginx/conf.d 目录下，创建 ruoyi-vue-pro2.conf，内容如下：\n\nserver { ## 前端项目\n    listen       80;\n    server_name  admin.iocoder.cn; ## 重要！！！修改成你的前端域名\n\n    location / { ## 前端项目\n        root   /usr/share/nginx/html/yudao-admin-ui;\n        index  index.html index.htm;\n        try_files $uri $uri/ /index.html;\n    }\n\n}\n\nserver { ## 后端项目\n    listen       80;\n    server_name  api.iocoder.cn; ## 重要！！！修改成你的外网 ip/域名\n\n    ## 不要使用 location / 转发到后端项目，因为 druid、admin 等监控，不需要外网可访问。或者增加 nginx ip 白名单限制也可以。\n\n    location /admin-api/ { ## 后端项目 - 管理后台\n        proxy_pass http://192.168.0.213:48080/admin-api/; ## 重要！！！proxy_pass 需要设置为后端项目所在服务器的 ip\n        proxy_set_header host $http_host;\n        proxy_set_header x-real-ip $remote_addr;\n        proxy_set_header remote-host $remote_addr;\n        proxy_set_header x-forwarded-for $proxy_add_x_forwarded_for;\n    }\n\n    location /app-api/ { ## 后端项目 - 用户 app\n        proxy_pass http://192.168.0.213:48080/app-api/; ## 重要！！！proxy_pass 需要设置为后端项目所在服务器的 ip\n        proxy_set_header host $http_host;\n        proxy_set_header x-real-ip $remote_addr;\n        proxy_set_header remote-host $remote_addr;\n        proxy_set_header x-forwarded-for $proxy_add_x_forwarded_for;\n    }\n\n}\n\n\n② 执行 docker exec nginx nginx -s reload 命令，重新加载 nginx 配置。\n\n③ 请求 http://api.iocoder.cn/admin-api/ 地址，成功访问后端项目，返回结果如下：\n\n{"code":401,"data":null,"msg":"账号未登录"}\n\n\n④ 请求 http://admin.iocoder.cn 地址，成功访问前端项目，返回前端界面如下：\n\n\n\n\n# 666. 更多说明\n\n① 积木报表菜单，无法访问。参考 https://t.zsxq.com/vbkup 解决。',
            charsets: {
                cjk: !0
            }
        }, {
            title: "Jenkins 部署",
            frontmatter: {
                title: "Jenkins 部署",
                date: "2022-04-15T20:09:52.000Z",
                permalink: "/deployment-jenkins"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/20.%E8%BF%90%E7%BB%B4%E6%89%8B%E5%86%8C/04.Jenkins%20%E9%83%A8%E7%BD%B2.html",
            relativePath: "01.开发指南/20.运维手册/04.Jenkins 部署.md",
            key: "v-604907e0",
            path: "/deployment-jenkins/",
            headers: [{
                level: 2,
                title: "1. 安装 Jenkins",
                slug: "_1-安装-jenkins",
                normalizedTitle: "1. 安装 jenkins",
                charIndex: 129
            }, {
                level: 2,
                title: "2. 部署后端",
                slug: "_2-部署后端",
                normalizedTitle: "2. 部署后端",
                charIndex: 189
            }, {
                level: 2,
                title: "3. 部署前端",
                slug: "_3-部署前端",
                normalizedTitle: "3. 部署前端",
                charIndex: 274
            }],
            headersStr: "1. 安装 Jenkins 2. 部署后端 3. 部署前端",
            content: "本小节，讲解如何将前端 + 后端项目，使用 Jenkins 工具，部署到 dev 开发环境下的一台 Linux 服务器上。如下图所示：\n\n\n\n友情提示：\n\n本文是 《开发指南 —— Linux 部署》 的加强版，差别在于使用 Jenkins 部署。\n\n\n# 1. 安装 Jenkins\n\n阅读 《芋道 Jenkins 极简入门 》 文章，进行 Jenkins 的安装。\n\n\n# 2. 部署后端\n\n阅读 《芋道 Spring Boot 持续交付 Jenkins 入门 》 文章，进行后端的部署。\n\n可参考 Jenkins 配置如下：\n\n\n\n\n\n\n# 3. 部署前端\n\n可参考 Jenkins 配置如下：\n\n\n\n",
            normalizedContent: "本小节，讲解如何将前端 + 后端项目，使用 jenkins 工具，部署到 dev 开发环境下的一台 linux 服务器上。如下图所示：\n\n\n\n友情提示：\n\n本文是 《开发指南 —— linux 部署》 的加强版，差别在于使用 jenkins 部署。\n\n\n# 1. 安装 jenkins\n\n阅读 《芋道 jenkins 极简入门 》 文章，进行 jenkins 的安装。\n\n\n# 2. 部署后端\n\n阅读 《芋道 spring boot 持续交付 jenkins 入门 》 文章，进行后端的部署。\n\n可参考 jenkins 配置如下：\n\n\n\n\n\n\n# 3. 部署前端\n\n可参考 jenkins 配置如下：\n\n\n\n",
            charsets: {
                cjk: !0
            }
        }, {
            title: "宝塔部署",
            frontmatter: {
                title: "宝塔部署",
                date: "2024-09-03T09:21:06.000Z",
                permalink: "/deployment-baota"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/20.%E8%BF%90%E7%BB%B4%E6%89%8B%E5%86%8C/05.%E5%AE%9D%E5%A1%94%E9%83%A8%E7%BD%B2.html",
            relativePath: "01.开发指南/20.运维手册/05.宝塔部署.md",
            key: "v-41a4a526",
            path: "/deployment-baota/",
            headers: [{
                level: 2,
                title: "1. 环境准备",
                slug: "_1-环境准备",
                normalizedTitle: "1. 环境准备",
                charIndex: 202
            }, {
                level: 3,
                title: "1.0 安装宝塔",
                slug: "_1-0-安装宝塔",
                normalizedTitle: "1.0 安装宝塔",
                charIndex: 290
            }, {
                level: 3,
                title: "1.1 安装 MySQL",
                slug: "_1-1-安装-mysql",
                normalizedTitle: "1.1 安装 mysql",
                charIndex: 900
            }, {
                level: 3,
                title: "1.2 安装 Redis",
                slug: "_1-2-安装-redis",
                normalizedTitle: "1.2 安装 redis",
                charIndex: 1352
            }, {
                level: 3,
                title: "1.3 安装 JDK",
                slug: "_1-3-安装-jdk",
                normalizedTitle: "1.3 安装 jdk",
                charIndex: 1511
            }, {
                level: 3,
                title: "1.4 安装 Nginx",
                slug: "_1-4-安装-nginx",
                normalizedTitle: "1.4 安装 nginx",
                charIndex: 1678
            }, {
                level: 2,
                title: "2. 部署后端服务",
                slug: "_2-部署后端服务",
                normalizedTitle: "2. 部署后端服务",
                charIndex: 1796
            }, {
                level: 2,
                title: "3. 部署前端",
                slug: "_3-部署前端",
                normalizedTitle: "3. 部署前端",
                charIndex: 2548
            }, {
                level: 3,
                title: "3.1 yudao-ui-admin-vue3",
                slug: "_3-1-yudao-ui-admin-vue3",
                normalizedTitle: "3.1 yudao-ui-admin-vue3",
                charIndex: 2820
            }, {
                level: 3,
                title: "3.2 yudao-ui-admin-vben",
                slug: "_3-2-yudao-ui-admin-vben",
                normalizedTitle: "3.2 yudao-ui-admin-vben",
                charIndex: 4069
            }, {
                level: 3,
                title: "3.3 yudao-ui-admin-vue2",
                slug: "_3-3-yudao-ui-admin-vue2",
                normalizedTitle: "3.3 yudao-ui-admin-vue2",
                charIndex: 5171
            }, {
                level: 2,
                title: "4. 部署 Nginx 转发",
                slug: "_4-部署-nginx-转发",
                normalizedTitle: "4. 部署 nginx 转发",
                charIndex: 6011
            }, {
                level: 3,
                title: "4.1 服务器 IP 场景",
                slug: "_4-1-服务器-ip-场景",
                normalizedTitle: "4.1 服务器 ip 场景",
                charIndex: 6066
            }, {
                level: 3,
                title: "4.2 独立域名场景",
                slug: "_4-2-独立域名场景",
                normalizedTitle: "4.2 独立域名场景",
                charIndex: 7440
            }, {
                level: 2,
                title: "666. 更多说明",
                slug: "_666-更多说明",
                normalizedTitle: "666. 更多说明",
                charIndex: 8863
            }],
            headersStr: "1. 环境准备 1.0 安装宝塔 1.1 安装 MySQL 1.2 安装 Redis 1.3 安装 JDK 1.4 安装 Nginx 2. 部署后端服务 3. 部署前端 3.1 yudao-ui-admin-vue3 3.2 yudao-ui-admin-vben 3.3 yudao-ui-admin-vue2 4. 部署 Nginx 转发 4.1 服务器 IP 场景 4.2 独立域名场景 666. 更多说明",
            content: '本小节，讲解如何将前端 + 后端项目，使用 宝塔，部署到 dev 开发环境下的一台 Linux 服务器上。如下图所示：\n\n\n\n友情提示：\n\n本文的部署过程，本质和 Linux 部署 一样，只是使用了宝塔面板，简化了一些操作。\n\n另外，如果你在部署过程中碰到问题，也可以参考 https://articles.zsxq.com/id_xu72z2zjekbx.html 文章，来自球友的宝塔部署。\n\n\n# 1. 环境准备\n\n需要安装如下环境：\n\n * 宝塔：运维面板\n * MySQL：数据库\n * Redis：缓存\n * JDK：后端运行环境\n * Nginx：负载均衡\n\n\n# 1.0 安装宝塔\n\n① 访问 宝塔 官网，注册账号。因为登录后，需要绑定宝塔账号。\n\n② 访问 https://www.bt.cn/new/download.html 地址，选择你的系统版本，下载对应的安装包。\n\n这里，我们使用 Centos 9，所以只需要执行如下命令：\n\nurl=https://download.bt.cn/install/install_lts.sh;if [ -f /usr/bin/curl ];then curl -sSO $url;else wget -O install_lts.sh $url;fi;bash install_lts.sh ed8484bec\n\n\n整个安装过程预计需要 5 分钟左右，成功后可见如下日志：\n\n========================面板账户登录信息==========================\n\n 【云服务器】请在安全组放行 23471 端口\n 外网面板地址: https://8.149.143.162:23471/06777072\n 内网面板地址: https://172.26.126.181:23471/06777072\n username: pru5q1ad\n password: 6fc718b8\n\n\n③ 访问面板地址，使用上面的 username、password 登录。注意，第一次登录，需要绑定宝塔账号。\n\n\n\n\n# 1.1 安装 MySQL\n\n需要安装 MySQL，并导入 SQL 脚本。\n\n# 第一步，安装 MySQL\n\n友情提示：安装 MySQL 是可选步骤，也可以购买 MySQL 云服务。\n\n在宝塔首页，点击左侧的 [数据库] 菜单，选择 [MySQL] 选项，之后点击 [安装mysql环境] 选项。\n\n再之后，选择 [mysql 8.4.0] 版本，点击 [极速安装] 按钮。如下图所示：\n\n\n\n# 第二步，导入 SQL 脚本\n\n① 点击 [添加数据库] 按钮，创建一个名字为 ruoyi-vue-pro 数据库，。如下图所示：\n\n\n\n② 点击 [导入] 按钮，再点击 [从本地上传] 按钮，执行数据库对应的 sql 目录下的 SQL 文件，进行初始化。如下图所示：\n\n\n\n疑问：如何使用本地 Navicat 连接该 MySQL？\n\n参考 https://www.bt.cn/bbs/thread-179-1-1.html 文档。\n\n当然，如果使用阿里云等云服务，相关的 3306 端口也需要放行。\n\n\n# 1.2 安装 Redis\n\n友情提示：安装 Redis 是可选步骤，也可以购买 Redis 云服务。\n\n在宝塔首页，点击左侧的 [数据库] 菜单，选择 [Redis] 选项，之后点击 [安装Redis环境] 选项。\n\n再之后，选择 [redis 7.2.4] 版本，点击 [立即安装] 按钮。如下图所示：\n\n\n\n\n# 1.3 安装 JDK\n\n在宝塔首页，点击左侧的 [网站] 菜单，之后选择 [Java 项目] 选项。\n\n再之后，点击 [Java环境管理] 按钮，选择 [jdk1.8.0_371] 版本，点击 [安装] 按钮。如下图所示：\n\n\n\n友情提示：如果已经安装 JDK，可不安装。建议使用的 JDK 版本为 8、11、17 这三个。\n\n\n# 1.4 安装 Nginx\n\n在宝塔首页，点击左侧的 [网站] 菜单，之后选择 [反向代理] 选项。\n\n再之后，点击 [安装Nginx] 按钮，选择 [nginx 1.24.0] 版本，点击 [极速安装] 按钮。如下图所示：\n\n\n\n\n# 2. 部署后端服务\n\n# 第一步，修改配置\n\n后端 dev 开发环境对应的是 application-dev.yaml 配置文件，主要是修改 MySQL 和 Redis 为你的地址。如下图所示：\n\n\n\n# 第二步，编译后端\n\n在项目的根目录下，执行 mvn clean package -Dmaven.test.skip=true 命令，编译后端项目，构建出它的 Jar 包。如下图所示：\n\n\n\n疑问：-Dmaven.test.skip=true 是什么意思？\n\n跳过单元测试的执行。如果你项目的单元测试写的不错，建议使用 mvn clean package 命令，执行单元测试，保证交付的质量。\n\n# 第三步，上传 Jar 包\n\n在宝塔首页，点击左侧的 [文件] 菜单， 在 /www/wwwroot 目录下，创建一个名字为 yudao-server 的目录。\n\n之后，将 yudao-server.jar 上传到该目录下。如下图所示：\n\n\n\n疑问：如果构建 War 包，部署到 Tomcat 下？\n\n并不推荐采用 War 包部署到 Tomcat 下。如果真的需要，可以参考 《Deploy a Spring Boot WAR into a Tomcat Server》 文章。\n\n# 第四步，启动后端\n\n① 在宝塔首页，点击左侧的 [网站] 菜单，之后选择 [Java项目] 选项。\n\n再之后，点击 [添加Java项目] 按钮，选择该上传的 yudao-server 包，并在“项目启动命令”补充 --spring.profiles.active=dev 参数。如下图所示：\n\n\n\n② 后续，可以点击该项目的 [设置] 按钮，进行日志管理、性能监控、负载状态、配置文件等等。如下图所示：\n\n\n\n\n# 3. 部署前端\n\n项目的管理后台有 3 个版本（只需要看你的版本即可）：\n\n * yudao-ui-admin-vue3：基于 Vue3 + element-plus\n * yudao-ui-admin-vben：基于 Vue3 + vben(ant-design-vue)\n * yudao-ui-admin-vue2：基于 Vue2 + element-ui\n\n注意，前端无法直接启动，而是需要通过 Nginx 转发读取前端构建出来的静态文件，最终都放在服务器上的 /www/wwwroot/yudao-ui-admin 目录下。\n\n\n# 3.1 yudao-ui-admin-vue3\n\n基于 Vue3 + element-plus\n\n# 第一步，修改配置\n\n前端 dev 开发环境对应的是 .env.dev 配置文件，主要是修改 VITE_BASE_URL 为你的后端项目的访问地址。如下图所示：\n\n\n\n# 第二步，编译前端\n\n在前端项目的根目录下，执行 npm run build:dev 命令，编译前端项目，构建出它的 dist 文件，里面是 HTML、CSS、JavaScript 等静态文件。如下图所示：\n\n\n\n如下想要打包其它环境，可使用如下命令：\n\nnpm run build:prod ## 打包 prod 生产环境\nnpm run build:stage ## 打包 stage 预发布环境\n\n\n如果是在服务器上构建，并且出现卡死的情况，可以参考 https://gitee.com/yudaocode/yudao-ui-admin-vue3/issues/IAU0T3 解决\n\n其它高级参数说明【可暂时不看】：\n\n① VITE_PUBLIC_PATH：前端打包的路径（静态资源的基础路径），一般默认为 / 即可。目前有两种用法：\n\n第一种，可用于二级目录部署。例如说，VITE_PUBLIC_PATH 设置为 /demo 。然后 Nginx 配置时，需要特殊注意，如下所示：\n\n        location /demo { # 注意点 1：不需要 / 结尾\n            # 注意点 2：二级路由时需要使用别名 alias，不用 root\n            alias   /work/projects/yudao-ui-admin/; # 注意点 3：需要 / 结尾\n            index  index.html index.htm;\n            try_files $uri $uri/ /index.html;\n        }\n\n\n第二种，可用于七牛等 CDN 服务，读取前端的静态文件，提升访问速度，建议 prod 生产环境使用。例如说，我们演示环境的 VITE_PUBLIC_PATH 是 http://static-vue3.yudao.iocoder.cn/ 。\n\n具体操作，可参考文章的 《Vue 项目使用七牛云 CDN 存放静态资源》 的「二、实现方式 」部分，只是最终的“修改 index.html 中静态资源引用”，变成 PUBLIC_PATH 修改即可。\n\n# 第三步，上传 dist 文件\n\n① 选中本地的 dist 内的所有文件，进行压缩。（注意，不是压缩 dist 文件夹，而是选中它里面所有的内容！！！）\n\n② 在宝塔首页，点击左侧的 [文件] 菜单， 在 /www/wwwroot 目录下，创建一个名字为 yudao-ui-admin 的目录。\n\n之后，上传 dist.zip 到该目录下，并进行解压。最终如下图所示：\n\n\n\n\n# 3.2 yudao-ui-admin-vben\n\n基于 Vue3 + vben(ant-design-vue)\n\n# 第一步，修改配置\n\n前端 production 开发环境对应的是 .env.production 配置文件，主要是修改 VITE_GLOB_BASE_URL、VITE_GLOB_API_URL 为你的后端项目的访问地址。如下图所示：\n\n\n\n其它高级参数说明【可暂时不看】：\n\n① VITE_PUBLIC_PATH：前端打包的路径（静态资源的基础路径），一般默认为 / 即可。目前有两种用法：\n\n第一种，可用于二级目录部署。例如说，VITE_PUBLIC_PATH 设置为 /demo 。然后 Nginx 配置时，需要特殊注意，如下所示：\n\n        location /demo { # 注意点 1：不需要 / 结尾\n            # 注意点 2：二级路由时需要使用别名 alias，不用 root\n            alias   /work/projects/yudao-ui-admin/; # 注意点 3：需要 / 结尾\n            index  index.html index.htm;\n            try_files $uri $uri/ /index.html;\n        }\n\n\n第二种，可用于七牛等 CDN 服务，读取前端的静态文件，提升访问速度，建议 prod 生产环境使用。例如说，我们演示环境的 VITE_PUBLIC_PATH 是 http://static-vue3.yudao.iocoder.cn/ 。\n\n具体操作，可参考文章的 《Vue 项目使用七牛云 CDN 存放静态资源》 的「二、实现方式 」部分，只是最终的“修改 index.html 中静态资源引用”，变成 PUBLIC_PATH 修改即可。\n\n# 第二步，编译前端\n\n在前端项目的根目录下，执行 npm run build 命令，编译前端项目，构建出它的 dist 文件，里面是 HTML、CSS、JavaScript 等静态文件。如下图所示：\n\n\n\n# 第三步，上传 dist 文件\n\n① 选中本地的 dist 内的所有文件，进行压缩。（注意，不是压缩 dist 文件夹，而是选中它里面所有的内容！！！）\n\n② 在宝塔首页，点击左侧的 [文件] 菜单， 在 /www/wwwroot 目录下，创建一个名字为 yudao-ui-admin 的目录。\n\n之后，上传 dist.zip 到该目录下，并进行解压。最终如下图所示：\n\n\n\n\n# 3.3 yudao-ui-admin-vue2\n\n基于 Vue2 + element-ui\n\n# 第一步，修改配置\n\n前端 dev 开发环境对应的是 .env.dev 配置文件，主要是修改 VUE_APP_BASE_API 为你的后端项目的访问地址。如下图所示：\n\n\n\n# 第二步，编译前端\n\n在前端项目的根目录下，执行 npm run build:dev 命令，编译前端项目，构建出它的 dist 文件，里面是 HTML、CSS、JavaScript 等静态文件。如下图所示：\n\n\n\n如下想要打包其它环境，可使用如下命令：\n\nnpm run build:prod ## 打包 prod 生产环境\nnpm run build:stage ## 打包 stage 预发布环境\n\n\n其它高级参数说明【可暂时不看】：\n\n① PUBLIC_PATH：可用于七牛等 CDN 服务，读取前端的静态文件，提升访问速度，建议 prod 生产环境使用。示例如下：\n\n可参考文章的 《Vue 项目使用七牛云 CDN 存放静态资源》 的「二、实现方式 」部分，只是最终的“修改 index.html 中静态资源引用”，变成 PUBLIC_PATH 修改即可。\n\n② VUE_APP_APP_NAME：二级部署路径，默认为 / 根目录，一般不用修改。\n\n③ mode：前端路由的模式，默认采用 history 路由，一般不用修改。可以通过修改 router/index.js 来设置为 hash 路由，示例如下：\n\n\n\n# 第三步，上传 dist 文件\n\n① 选中本地的 dist 内的所有文件，进行压缩。（注意，不是压缩 dist 文件夹，而是选中它里面所有的内容！！！）\n\n② 在宝塔首页，点击左侧的 [文件] 菜单， 在 /www/wwwroot 目录下，创建一个名字为 yudao-ui-admin 的目录。\n\n之后，上传 dist.zip 到该目录下，并进行解压。最终如下图所示：\n\n\n\n\n# 4. 部署 Nginx 转发\n\n两种 Nginx 的配置，分别满足服务器 IP、独立域名的不同场景。\n\n\n# 4.1 服务器 IP 场景\n\n# 第一步，配置前端转发\n\n在宝塔首页，点击左侧的 [网站] 菜单，之后选择 [HTML项目] 选项。\n\n之后，点击 [添加HTML项目] 按钮，填写备注为 yudao-ui-admin，并在“根目录”选择 /www/wwwroot/yudao-ui-admin 目录。如下图所示：\n\n\n\n# 第二步，配置后端转发\n\n点击该项目的 [设置] 按钮，选中 [伪静态] 选项，进行后端的转发配置。如下图所示：\n\n疑问：为什么要在 HTML 项目下配置后端转发？\n\n因为前端和后端共享了同一个 IP 地址，导致它在宝塔进行 Nginx 配置转发时，server_name 冲突了！！！\n\n另外，下面有个 try_files 配置，是为了解决前端刷新 404 问题，参考自 《Vue 项目使用宝塔面板部署刷新 404 问题》 文章。\n\n\n\n# 请将伪静态规则或自定义NGINX配置填写到此处\nlocation / { \n  try_files $uri $uri/ /index.html; ## 重要！！！解决前端刷新 404 问题\n}\n\nlocation /admin-api/ { ## 后端项目 - 管理后台\n    proxy_pass http://localhost:48080/admin-api/; ## 重要！！！proxy_pass 需要设置为后端项目所在服务器的 IP\n    proxy_set_header Host $http_host;\n    proxy_set_header X-Real-IP $remote_addr;\n    proxy_set_header REMOTE-HOST $remote_addr;\n    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n}\n\nlocation /app-api/ { ## 后端项目 - 用户 App\n    proxy_pass http://localhost:48080/app-api/; ## 重要！！！proxy_pass 需要设置为后端项目所在服务器的 IP\n    proxy_set_header Host $http_host;\n    proxy_set_header X-Real-IP $remote_addr;\n    proxy_set_header REMOTE-HOST $remote_addr;\n    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n}\n\n\n# 第三步，简单测试\n\n① 请求 http://192.168.225.2/admin-api/ 地址，成功访问后端项目，返回结果如下：\n\n{"code":401,"data":null,"msg":"账号未登录"}\n\n\n② 请求 http://192.168.225.2 地址，成功访问前端项目，返回前端界面如下：\n\n\n\n③ 如果你使用到 WebSocket 的话，需要额外对 /infra/ws 路径进行配置，具体可见 https://t.zsxq.com/LQEfC 链接。\n\n\n# 4.2 独立域名场景\n\n友情提示：在前端项目的编译时，需要把 `VUE_APP_BASE_API` 修改为后端项目对应的域名。\n\n例如说，这里使用的是 http://api.iocoder.cn\n\n# 第一步，配置前端转发\n\n① 在宝塔首页，点击左侧的 [网站] 菜单，之后选择 [HTML项目] 选项。\n\n之后，点击 [添加HTML项目] 按钮，填写备注为 yudao-ui-admin，并在“根目录”选择 /www/wwwroot/yudao-ui-admin 目录。如下图所示：\n\n\n\n② 点击该项目的 [设置] 按钮，选中 [伪静态] 选项，进行 try_files 的转发配置。如下图所示：\n\n# 请将伪静态规则或自定义NGINX配置填写到此处\nlocation / { \n  try_files $uri $uri/ /index.html; ## 重要！！！解决前端刷新 404 问题\n}\n\n\n\n\n# 第二步，配置后端转发\n\n① 点击 Java 项目的 [设置] 按钮，选中 [域名管理] 选项，在“域名”输入后端的域名，如 api.iocoder.cn。如下图所示：\n\n\n\n② 选中 [外网访问] 选项，把“外网映射”选上。如下图所示：\n\n\n\n③ 选中 [配置文件] 选项，选择 [伪静态配置文件] 选项，进行后端的转发配置。如下图所示：\n\n\n\n# 请将伪静态规则或自定义NGINX配置填写到此处\nlocation /admin-api/ { ## 后端项目 - 管理后台\n    proxy_pass http://127.0.0.1:48080/admin-api/; ## 重要！！！proxy_pass 需要设置为后端项目所在服务器的 IP\n    proxy_set_header Host $http_host;\n    proxy_set_header X-Real-IP $remote_addr;\n    proxy_set_header REMOTE-HOST $remote_addr;\n    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n}\n\nlocation /app-api/ { ## 后端项目 - 用户 App\n    proxy_pass http://127.0.0.1:48080/app-api/; ## 重要！！！proxy_pass 需要设置为后端项目所在服务器的 IP\n    proxy_set_header Host $http_host;\n    proxy_set_header X-Real-IP $remote_addr;\n    proxy_set_header REMOTE-HOST $remote_addr;\n    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n}\n\n\n# 第三步，简单测试\n\n① 请求 http://api.iocoder.cn/admin-api/ 地址，成功访问后端项目，返回结果如下：\n\n{"code":401,"data":null,"msg":"账号未登录"}\n\n\n② 请求 http://admin.iocoder.cn 地址，成功访问前端项目，返回前端界面如下：\n\n\n\n\n# 666. 更多说明\n\n① 积木报表菜单，无法访问。参考 https://t.zsxq.com/vBkup 解决。',
            normalizedContent: '本小节，讲解如何将前端 + 后端项目，使用 宝塔，部署到 dev 开发环境下的一台 linux 服务器上。如下图所示：\n\n\n\n友情提示：\n\n本文的部署过程，本质和 linux 部署 一样，只是使用了宝塔面板，简化了一些操作。\n\n另外，如果你在部署过程中碰到问题，也可以参考 https://articles.zsxq.com/id_xu72z2zjekbx.html 文章，来自球友的宝塔部署。\n\n\n# 1. 环境准备\n\n需要安装如下环境：\n\n * 宝塔：运维面板\n * mysql：数据库\n * redis：缓存\n * jdk：后端运行环境\n * nginx：负载均衡\n\n\n# 1.0 安装宝塔\n\n① 访问 宝塔 官网，注册账号。因为登录后，需要绑定宝塔账号。\n\n② 访问 https://www.bt.cn/new/download.html 地址，选择你的系统版本，下载对应的安装包。\n\n这里，我们使用 centos 9，所以只需要执行如下命令：\n\nurl=https://download.bt.cn/install/install_lts.sh;if [ -f /usr/bin/curl ];then curl -sso $url;else wget -o install_lts.sh $url;fi;bash install_lts.sh ed8484bec\n\n\n整个安装过程预计需要 5 分钟左右，成功后可见如下日志：\n\n========================面板账户登录信息==========================\n\n 【云服务器】请在安全组放行 23471 端口\n 外网面板地址: https://8.149.143.162:23471/06777072\n 内网面板地址: https://172.26.126.181:23471/06777072\n username: pru5q1ad\n password: 6fc718b8\n\n\n③ 访问面板地址，使用上面的 username、password 登录。注意，第一次登录，需要绑定宝塔账号。\n\n\n\n\n# 1.1 安装 mysql\n\n需要安装 mysql，并导入 sql 脚本。\n\n# 第一步，安装 mysql\n\n友情提示：安装 mysql 是可选步骤，也可以购买 mysql 云服务。\n\n在宝塔首页，点击左侧的 [数据库] 菜单，选择 [mysql] 选项，之后点击 [安装mysql环境] 选项。\n\n再之后，选择 [mysql 8.4.0] 版本，点击 [极速安装] 按钮。如下图所示：\n\n\n\n# 第二步，导入 sql 脚本\n\n① 点击 [添加数据库] 按钮，创建一个名字为 ruoyi-vue-pro 数据库，。如下图所示：\n\n\n\n② 点击 [导入] 按钮，再点击 [从本地上传] 按钮，执行数据库对应的 sql 目录下的 sql 文件，进行初始化。如下图所示：\n\n\n\n疑问：如何使用本地 navicat 连接该 mysql？\n\n参考 https://www.bt.cn/bbs/thread-179-1-1.html 文档。\n\n当然，如果使用阿里云等云服务，相关的 3306 端口也需要放行。\n\n\n# 1.2 安装 redis\n\n友情提示：安装 redis 是可选步骤，也可以购买 redis 云服务。\n\n在宝塔首页，点击左侧的 [数据库] 菜单，选择 [redis] 选项，之后点击 [安装redis环境] 选项。\n\n再之后，选择 [redis 7.2.4] 版本，点击 [立即安装] 按钮。如下图所示：\n\n\n\n\n# 1.3 安装 jdk\n\n在宝塔首页，点击左侧的 [网站] 菜单，之后选择 [java 项目] 选项。\n\n再之后，点击 [java环境管理] 按钮，选择 [jdk1.8.0_371] 版本，点击 [安装] 按钮。如下图所示：\n\n\n\n友情提示：如果已经安装 jdk，可不安装。建议使用的 jdk 版本为 8、11、17 这三个。\n\n\n# 1.4 安装 nginx\n\n在宝塔首页，点击左侧的 [网站] 菜单，之后选择 [反向代理] 选项。\n\n再之后，点击 [安装nginx] 按钮，选择 [nginx 1.24.0] 版本，点击 [极速安装] 按钮。如下图所示：\n\n\n\n\n# 2. 部署后端服务\n\n# 第一步，修改配置\n\n后端 dev 开发环境对应的是 application-dev.yaml 配置文件，主要是修改 mysql 和 redis 为你的地址。如下图所示：\n\n\n\n# 第二步，编译后端\n\n在项目的根目录下，执行 mvn clean package -dmaven.test.skip=true 命令，编译后端项目，构建出它的 jar 包。如下图所示：\n\n\n\n疑问：-dmaven.test.skip=true 是什么意思？\n\n跳过单元测试的执行。如果你项目的单元测试写的不错，建议使用 mvn clean package 命令，执行单元测试，保证交付的质量。\n\n# 第三步，上传 jar 包\n\n在宝塔首页，点击左侧的 [文件] 菜单， 在 /www/wwwroot 目录下，创建一个名字为 yudao-server 的目录。\n\n之后，将 yudao-server.jar 上传到该目录下。如下图所示：\n\n\n\n疑问：如果构建 war 包，部署到 tomcat 下？\n\n并不推荐采用 war 包部署到 tomcat 下。如果真的需要，可以参考 《deploy a spring boot war into a tomcat server》 文章。\n\n# 第四步，启动后端\n\n① 在宝塔首页，点击左侧的 [网站] 菜单，之后选择 [java项目] 选项。\n\n再之后，点击 [添加java项目] 按钮，选择该上传的 yudao-server 包，并在“项目启动命令”补充 --spring.profiles.active=dev 参数。如下图所示：\n\n\n\n② 后续，可以点击该项目的 [设置] 按钮，进行日志管理、性能监控、负载状态、配置文件等等。如下图所示：\n\n\n\n\n# 3. 部署前端\n\n项目的管理后台有 3 个版本（只需要看你的版本即可）：\n\n * yudao-ui-admin-vue3：基于 vue3 + element-plus\n * yudao-ui-admin-vben：基于 vue3 + vben(ant-design-vue)\n * yudao-ui-admin-vue2：基于 vue2 + element-ui\n\n注意，前端无法直接启动，而是需要通过 nginx 转发读取前端构建出来的静态文件，最终都放在服务器上的 /www/wwwroot/yudao-ui-admin 目录下。\n\n\n# 3.1 yudao-ui-admin-vue3\n\n基于 vue3 + element-plus\n\n# 第一步，修改配置\n\n前端 dev 开发环境对应的是 .env.dev 配置文件，主要是修改 vite_base_url 为你的后端项目的访问地址。如下图所示：\n\n\n\n# 第二步，编译前端\n\n在前端项目的根目录下，执行 npm run build:dev 命令，编译前端项目，构建出它的 dist 文件，里面是 html、css、javascript 等静态文件。如下图所示：\n\n\n\n如下想要打包其它环境，可使用如下命令：\n\nnpm run build:prod ## 打包 prod 生产环境\nnpm run build:stage ## 打包 stage 预发布环境\n\n\n如果是在服务器上构建，并且出现卡死的情况，可以参考 https://gitee.com/yudaocode/yudao-ui-admin-vue3/issues/iau0t3 解决\n\n其它高级参数说明【可暂时不看】：\n\n① vite_public_path：前端打包的路径（静态资源的基础路径），一般默认为 / 即可。目前有两种用法：\n\n第一种，可用于二级目录部署。例如说，vite_public_path 设置为 /demo 。然后 nginx 配置时，需要特殊注意，如下所示：\n\n        location /demo { # 注意点 1：不需要 / 结尾\n            # 注意点 2：二级路由时需要使用别名 alias，不用 root\n            alias   /work/projects/yudao-ui-admin/; # 注意点 3：需要 / 结尾\n            index  index.html index.htm;\n            try_files $uri $uri/ /index.html;\n        }\n\n\n第二种，可用于七牛等 cdn 服务，读取前端的静态文件，提升访问速度，建议 prod 生产环境使用。例如说，我们演示环境的 vite_public_path 是 http://static-vue3.yudao.iocoder.cn/ 。\n\n具体操作，可参考文章的 《vue 项目使用七牛云 cdn 存放静态资源》 的「二、实现方式 」部分，只是最终的“修改 index.html 中静态资源引用”，变成 public_path 修改即可。\n\n# 第三步，上传 dist 文件\n\n① 选中本地的 dist 内的所有文件，进行压缩。（注意，不是压缩 dist 文件夹，而是选中它里面所有的内容！！！）\n\n② 在宝塔首页，点击左侧的 [文件] 菜单， 在 /www/wwwroot 目录下，创建一个名字为 yudao-ui-admin 的目录。\n\n之后，上传 dist.zip 到该目录下，并进行解压。最终如下图所示：\n\n\n\n\n# 3.2 yudao-ui-admin-vben\n\n基于 vue3 + vben(ant-design-vue)\n\n# 第一步，修改配置\n\n前端 production 开发环境对应的是 .env.production 配置文件，主要是修改 vite_glob_base_url、vite_glob_api_url 为你的后端项目的访问地址。如下图所示：\n\n\n\n其它高级参数说明【可暂时不看】：\n\n① vite_public_path：前端打包的路径（静态资源的基础路径），一般默认为 / 即可。目前有两种用法：\n\n第一种，可用于二级目录部署。例如说，vite_public_path 设置为 /demo 。然后 nginx 配置时，需要特殊注意，如下所示：\n\n        location /demo { # 注意点 1：不需要 / 结尾\n            # 注意点 2：二级路由时需要使用别名 alias，不用 root\n            alias   /work/projects/yudao-ui-admin/; # 注意点 3：需要 / 结尾\n            index  index.html index.htm;\n            try_files $uri $uri/ /index.html;\n        }\n\n\n第二种，可用于七牛等 cdn 服务，读取前端的静态文件，提升访问速度，建议 prod 生产环境使用。例如说，我们演示环境的 vite_public_path 是 http://static-vue3.yudao.iocoder.cn/ 。\n\n具体操作，可参考文章的 《vue 项目使用七牛云 cdn 存放静态资源》 的「二、实现方式 」部分，只是最终的“修改 index.html 中静态资源引用”，变成 public_path 修改即可。\n\n# 第二步，编译前端\n\n在前端项目的根目录下，执行 npm run build 命令，编译前端项目，构建出它的 dist 文件，里面是 html、css、javascript 等静态文件。如下图所示：\n\n\n\n# 第三步，上传 dist 文件\n\n① 选中本地的 dist 内的所有文件，进行压缩。（注意，不是压缩 dist 文件夹，而是选中它里面所有的内容！！！）\n\n② 在宝塔首页，点击左侧的 [文件] 菜单， 在 /www/wwwroot 目录下，创建一个名字为 yudao-ui-admin 的目录。\n\n之后，上传 dist.zip 到该目录下，并进行解压。最终如下图所示：\n\n\n\n\n# 3.3 yudao-ui-admin-vue2\n\n基于 vue2 + element-ui\n\n# 第一步，修改配置\n\n前端 dev 开发环境对应的是 .env.dev 配置文件，主要是修改 vue_app_base_api 为你的后端项目的访问地址。如下图所示：\n\n\n\n# 第二步，编译前端\n\n在前端项目的根目录下，执行 npm run build:dev 命令，编译前端项目，构建出它的 dist 文件，里面是 html、css、javascript 等静态文件。如下图所示：\n\n\n\n如下想要打包其它环境，可使用如下命令：\n\nnpm run build:prod ## 打包 prod 生产环境\nnpm run build:stage ## 打包 stage 预发布环境\n\n\n其它高级参数说明【可暂时不看】：\n\n① public_path：可用于七牛等 cdn 服务，读取前端的静态文件，提升访问速度，建议 prod 生产环境使用。示例如下：\n\n可参考文章的 《vue 项目使用七牛云 cdn 存放静态资源》 的「二、实现方式 」部分，只是最终的“修改 index.html 中静态资源引用”，变成 public_path 修改即可。\n\n② vue_app_app_name：二级部署路径，默认为 / 根目录，一般不用修改。\n\n③ mode：前端路由的模式，默认采用 history 路由，一般不用修改。可以通过修改 router/index.js 来设置为 hash 路由，示例如下：\n\n\n\n# 第三步，上传 dist 文件\n\n① 选中本地的 dist 内的所有文件，进行压缩。（注意，不是压缩 dist 文件夹，而是选中它里面所有的内容！！！）\n\n② 在宝塔首页，点击左侧的 [文件] 菜单， 在 /www/wwwroot 目录下，创建一个名字为 yudao-ui-admin 的目录。\n\n之后，上传 dist.zip 到该目录下，并进行解压。最终如下图所示：\n\n\n\n\n# 4. 部署 nginx 转发\n\n两种 nginx 的配置，分别满足服务器 ip、独立域名的不同场景。\n\n\n# 4.1 服务器 ip 场景\n\n# 第一步，配置前端转发\n\n在宝塔首页，点击左侧的 [网站] 菜单，之后选择 [html项目] 选项。\n\n之后，点击 [添加html项目] 按钮，填写备注为 yudao-ui-admin，并在“根目录”选择 /www/wwwroot/yudao-ui-admin 目录。如下图所示：\n\n\n\n# 第二步，配置后端转发\n\n点击该项目的 [设置] 按钮，选中 [伪静态] 选项，进行后端的转发配置。如下图所示：\n\n疑问：为什么要在 html 项目下配置后端转发？\n\n因为前端和后端共享了同一个 ip 地址，导致它在宝塔进行 nginx 配置转发时，server_name 冲突了！！！\n\n另外，下面有个 try_files 配置，是为了解决前端刷新 404 问题，参考自 《vue 项目使用宝塔面板部署刷新 404 问题》 文章。\n\n\n\n# 请将伪静态规则或自定义nginx配置填写到此处\nlocation / { \n  try_files $uri $uri/ /index.html; ## 重要！！！解决前端刷新 404 问题\n}\n\nlocation /admin-api/ { ## 后端项目 - 管理后台\n    proxy_pass http://localhost:48080/admin-api/; ## 重要！！！proxy_pass 需要设置为后端项目所在服务器的 ip\n    proxy_set_header host $http_host;\n    proxy_set_header x-real-ip $remote_addr;\n    proxy_set_header remote-host $remote_addr;\n    proxy_set_header x-forwarded-for $proxy_add_x_forwarded_for;\n}\n\nlocation /app-api/ { ## 后端项目 - 用户 app\n    proxy_pass http://localhost:48080/app-api/; ## 重要！！！proxy_pass 需要设置为后端项目所在服务器的 ip\n    proxy_set_header host $http_host;\n    proxy_set_header x-real-ip $remote_addr;\n    proxy_set_header remote-host $remote_addr;\n    proxy_set_header x-forwarded-for $proxy_add_x_forwarded_for;\n}\n\n\n# 第三步，简单测试\n\n① 请求 http://192.168.225.2/admin-api/ 地址，成功访问后端项目，返回结果如下：\n\n{"code":401,"data":null,"msg":"账号未登录"}\n\n\n② 请求 http://192.168.225.2 地址，成功访问前端项目，返回前端界面如下：\n\n\n\n③ 如果你使用到 websocket 的话，需要额外对 /infra/ws 路径进行配置，具体可见 https://t.zsxq.com/lqefc 链接。\n\n\n# 4.2 独立域名场景\n\n友情提示：在前端项目的编译时，需要把 `vue_app_base_api` 修改为后端项目对应的域名。\n\n例如说，这里使用的是 http://api.iocoder.cn\n\n# 第一步，配置前端转发\n\n① 在宝塔首页，点击左侧的 [网站] 菜单，之后选择 [html项目] 选项。\n\n之后，点击 [添加html项目] 按钮，填写备注为 yudao-ui-admin，并在“根目录”选择 /www/wwwroot/yudao-ui-admin 目录。如下图所示：\n\n\n\n② 点击该项目的 [设置] 按钮，选中 [伪静态] 选项，进行 try_files 的转发配置。如下图所示：\n\n# 请将伪静态规则或自定义nginx配置填写到此处\nlocation / { \n  try_files $uri $uri/ /index.html; ## 重要！！！解决前端刷新 404 问题\n}\n\n\n\n\n# 第二步，配置后端转发\n\n① 点击 java 项目的 [设置] 按钮，选中 [域名管理] 选项，在“域名”输入后端的域名，如 api.iocoder.cn。如下图所示：\n\n\n\n② 选中 [外网访问] 选项，把“外网映射”选上。如下图所示：\n\n\n\n③ 选中 [配置文件] 选项，选择 [伪静态配置文件] 选项，进行后端的转发配置。如下图所示：\n\n\n\n# 请将伪静态规则或自定义nginx配置填写到此处\nlocation /admin-api/ { ## 后端项目 - 管理后台\n    proxy_pass http://127.0.0.1:48080/admin-api/; ## 重要！！！proxy_pass 需要设置为后端项目所在服务器的 ip\n    proxy_set_header host $http_host;\n    proxy_set_header x-real-ip $remote_addr;\n    proxy_set_header remote-host $remote_addr;\n    proxy_set_header x-forwarded-for $proxy_add_x_forwarded_for;\n}\n\nlocation /app-api/ { ## 后端项目 - 用户 app\n    proxy_pass http://127.0.0.1:48080/app-api/; ## 重要！！！proxy_pass 需要设置为后端项目所在服务器的 ip\n    proxy_set_header host $http_host;\n    proxy_set_header x-real-ip $remote_addr;\n    proxy_set_header remote-host $remote_addr;\n    proxy_set_header x-forwarded-for $proxy_add_x_forwarded_for;\n}\n\n\n# 第三步，简单测试\n\n① 请求 http://api.iocoder.cn/admin-api/ 地址，成功访问后端项目，返回结果如下：\n\n{"code":401,"data":null,"msg":"账号未登录"}\n\n\n② 请求 http://admin.iocoder.cn 地址，成功访问前端项目，返回前端界面如下：\n\n\n\n\n# 666. 更多说明\n\n① 积木报表菜单，无法访问。参考 https://t.zsxq.com/vbkup 解决。',
            charsets: {
                cjk: !0
            }
        }, {
            title: "开发规范",
            frontmatter: {
                title: "开发规范",
                date: "2022-04-17T19:21:32.000Z",
                permalink: "/vue3/dev-spec"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/21.%E5%89%8D%E7%AB%AF%E6%89%8B%E5%86%8C%20Vue%203.x/01.%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83.html",
            relativePath: "01.开发指南/21.前端手册 Vue 3.x/01.开发规范.md",
            key: "v-455bbf33",
            path: "/vue3/dev-spec/",
            headers: [{
                level: 2,
                title: "0. 实战案例",
                slug: "_0-实战案例",
                normalizedTitle: "0. 实战案例",
                charIndex: 2
            }, {
                level: 3,
                title: "0.1 普通列表",
                slug: "_0-1-普通列表",
                normalizedTitle: "0.1 普通列表",
                charIndex: 72
            }, {
                level: 3,
                title: "0.2 树形列表",
                slug: "_0-2-树形列表",
                normalizedTitle: "0.2 树形列表",
                charIndex: 301
            }, {
                level: 3,
                title: "0.3 高性能列表",
                slug: "_0-3-高性能列表",
                normalizedTitle: "0.3 高性能列表",
                charIndex: 464
            }, {
                level: 3,
                title: "0.4 详情弹窗",
                slug: "_0-4-详情弹窗",
                normalizedTitle: "0.4 详情弹窗",
                charIndex: 606
            }, {
                level: 2,
                title: "1. view 页面",
                slug: "_1-view-页面",
                normalizedTitle: "1. view 页面",
                charIndex: 713
            }, {
                level: 2,
                title: "2. api 请求",
                slug: "_2-api-请求",
                normalizedTitle: "2. api 请求",
                charIndex: 806
            }, {
                level: 3,
                title: "2.1 请求封装",
                slug: "_2-1-请求封装",
                normalizedTitle: "2.1 请求封装",
                charIndex: 961
            }, {
                level: 3,
                title: "2.2 交互流程",
                slug: "_2-2-交互流程",
                normalizedTitle: "2.2 交互流程",
                charIndex: 9919
            }, {
                level: 2,
                title: "3. component 组件",
                slug: "_3-component-组件",
                normalizedTitle: "3. component 组件",
                charIndex: 10756
            }, {
                level: 3,
                title: "3.1 全局组件",
                slug: "_3-1-全局组件",
                normalizedTitle: "3.1 全局组件",
                charIndex: 10776
            }, {
                level: 3,
                title: "3.2 模块内组件",
                slug: "_3-2-模块内组件",
                normalizedTitle: "3.2 模块内组件",
                charIndex: 10859
            }, {
                level: 2,
                title: "4. style 样式",
                slug: "_4-style-样式",
                normalizedTitle: "4. style 样式",
                charIndex: 10989
            }, {
                level: 2,
                title: "5. 项目规范",
                slug: "_5-项目规范",
                normalizedTitle: "5. 项目规范",
                charIndex: 11211
            }],
            headersStr: "0. 实战案例 0.1 普通列表 0.2 树形列表 0.3 高性能列表 0.4 详情弹窗 1. view 页面 2. api 请求 2.1 请求封装 2.2 交互流程 3. component 组件 3.1 全局组件 3.2 模块内组件 4. style 样式 5. 项目规范",
            content: "# 0. 实战案例\n\n本小节，提供大家开发管理后台的功能时，最常用的普通列表、树形列表、新增与修改的表单弹窗、详情表单弹窗的实战案例。\n\n\n# 0.1 普通列表\n\n可参考 [系统管理 -> 岗位管理] 菜单：\n\n * API 接口：/src/api/system/post/index.ts\n * 列表界面：/src/views/system/post/index.vue\n * 表单界面：/src/views/system/post/PostForm.vue\n\n为什么界面拆成列表和表单两个 Vue 文件？\n\n每个 Vue 文件，只实现一个功能，更简洁，维护性更好，Git 代码冲突概率低。\n\n\n# 0.2 树形列表\n\n可参考 [系统管理 -> 部门管理] 菜单：\n\n * API 接口：/src/api/system/dept/index.ts\n * 列表界面：/src/views/system/dept/index.vue\n * 表单界面：/src/views/system/dept/DeptForm.vue\n\n\n# 0.3 高性能列表\n\n可参考 [系统管理 -> 地区管理] 菜单，对应 /src/views/system/area/index.vue 列表界面\n\n基于 Virtualized Table 虚拟化表格 实现，解决一屏里超过 1000 条数据记录时，就会出现卡顿等性能问题。\n\n\n# 0.4 详情弹窗\n\n可参考 [基础设施 -> API 日志 -> 访问日志] 菜单，对应 /src/views/infra/apiAccessLog/ApiAccessLogDetail.vue 详情弹窗\n\n\n# 1. view 页面\n\n在 @views 目录下，每个模块对应一个目录，它的所有功能的 .vue 都放在该目录里。\n\n\n\n一般来说，一个路由对应一个 index.vue 文件。\n\n\n# 2. api 请求\n\n在 @/api 目录下，每个模块对应一个 index.ts API 文件。\n\n\n\n * API 方法：会调用 request 方法，发起对后端 RESTful API 的调用。\n * interface 类型：定义了 API 的请求参数和返回结果的类型，对应后端的 VO 类型。\n\n\n# 2.1 请求封装\n\n/src/config/axios/index.ts 基于 axios 封装，统一处理 GET、POST 方法的请求参数、请求头，以及错误提示信息等。\n\n\n\n# 2.1.1 创建 axios 实例\n\n * baseURL 基础路径\n * timeout 超时时间，默认为 30000 毫秒\n\n实现代码 /src/config/axios/service.ts\n\nimport axios from 'axios'\n\nconst { result_code, base_url, request_timeout } = config\n\n// 创建 axios 实例\nconst service: AxiosInstance = axios.create({\n    baseURL: base_url, // api 的 base_url\n    timeout: request_timeout, // 请求超时时间\n    withCredentials: false // 禁用 Cookie 等信息\n})\n\n\n# 2.1.2 Request 拦截器\n\n * 【重点】Authorization、tenant-id 请求头\n * GET 请求参数的拼接\n\n实现代码 /src/config/axios/service.ts\n\nimport axios, {\n    AxiosInstance,\n    AxiosRequestHeaders,\n    AxiosResponse,\n    AxiosError,\n    InternalAxiosRequestConfig\n} from 'axios'\n\nimport { getAccessToken, getTenantId } from '@/utils/auth'\n\nconst tenantEnable = import.meta.env.VITE_APP_TENANT_ENABLE\n\nservice.interceptors.request.use(\n    (config: InternalAxiosRequestConfig) => {\n        // 是否需要设置 token\n        let isToken = (config!.headers || {}).isToken === false\n        whiteList.some((v) => {\n            if (config.url) {\n                config.url.indexOf(v) > -1\n                return (isToken = false)\n            }\n        })\n        if (getAccessToken() && !isToken) {\n            (config as Recordable).headers.Authorization = 'Bearer ' + getAccessToken() // 让每个请求携带自定义token\n        }\n        // 设置租户\n        if (tenantEnable && tenantEnable === 'true') {\n            const tenantId = getTenantId()\n            if (tenantId) (config as Recordable).headers['tenant-id'] = tenantId\n        }\n        const params = config.params || {}\n        const data = config.data || false\n        if (\n            config.method?.toUpperCase() === 'POST' &&\n            (config.headers as AxiosRequestHeaders)['Content-Type'] ===\n        'application/x-www-form-urlencoded'\n    ) {\n            config.data = qs.stringify(data)\n        }\n        // get参数编码\n        if (config.method?.toUpperCase() === 'GET' && params) {\n            let url = config.url + '?'\n            for (const propName of Object.keys(params)) {\n                const value = params[propName]\n                if (value !== void 0 && value !== null && typeof value !== 'undefined') {\n                    if (typeof value === 'object') {\n                        for (const val of Object.keys(value)) {\n                            const params = propName + '[' + val + ']'\n                            const subPart = encodeURIComponent(params) + '='\n                            url += subPart + encodeURIComponent(value[val]) + '&'\n                        }\n                    } else {\n                        url += `${propName}=${encodeURIComponent(value)}&`\n                    }\n                }\n            }\n            // 给 get 请求加上时间戳参数，避免从缓存中拿数据\n            // const now = new Date().getTime()\n            // params = params.substring(0, url.length - 1) + `?_t=${now}`\n            url = url.slice(0, -1)\n            config.params = {}\n            config.url = url\n        }\n        return config\n    },\n    (error: AxiosError) => {\n        // Do something with request error\n        console.log(error) // for debug\n        Promise.reject(error)\n    }\n)\n\n\n# 2.1.3 Response 拦截器\n\n * 访问令牌 AccessToken 过期时，使用刷新令牌 RefreshToken 刷新，获得新的访问令牌\n * 刷新令牌失败（过期）时，跳回首页进行登录\n * 请求失败，Message 错误提示\n\n实现代码 /src/config/axios/service.ts\n\nimport axios, {\n    AxiosInstance,\n    AxiosRequestHeaders,\n    AxiosResponse,\n    AxiosError,\n    InternalAxiosRequestConfig\n} from 'axios'\nimport { ElMessage, ElMessageBox, ElNotification } from 'element-plus'\n\nimport { getAccessToken, getRefreshToken, removeToken, setToken } from '@/utils/auth'\n\n// 需要忽略的提示。忽略后，自动 Promise.reject('error')\nconst ignoreMsgs = [\n    '无效的刷新令牌', // 刷新令牌被删除时，不用提示\n    '刷新令牌已过期' // 使用刷新令牌，刷新获取新的访问令牌时，结果因为过期失败，此时需要忽略。否则，会导致继续 401，无法跳转到登出界面\n]\n// 是否显示重新登录\nexport const isRelogin = { show: false }\nimport errorCode from './errorCode'\n\nimport { resetRouter } from '@/router'\nimport { useCache } from '@/hooks/web/useCache'\n\nservice.interceptors.response.use(\n    async (response: AxiosResponse<any>) => {\n        const { data } = response\n        const config = response.config\n        if (!data) {\n            // 返回“[HTTP]请求没有返回值”;\n            throw new Error()\n        }\n        const { t } = useI18n()\n        // 未设置状态码则默认成功状态\n        const code = data.code || result_code\n        // 二进制数据则直接返回\n        if (\n            response.request.responseType === 'blob' ||\n            response.request.responseType === 'arraybuffer'\n        ) {\n            return response.data\n        }\n        // 获取错误信息\n        const msg = data.msg || errorCode[code] || errorCode['default']\n        if (ignoreMsgs.indexOf(msg) !== -1) {\n            // 如果是忽略的错误码，直接返回 msg 异常\n            return Promise.reject(msg)\n        } else if (code === 401) {\n            // 如果未认证，并且未进行刷新令牌，说明可能是访问令牌过期了\n            if (!isRefreshToken) {\n                isRefreshToken = true\n                // 1. 如果获取不到刷新令牌，则只能执行登出操作\n                if (!getRefreshToken()) {\n                    return handleAuthorized()\n                }\n                // 2. 进行刷新访问令牌\n                try {\n                    const refreshTokenRes = await refreshToken()\n                    // 2.1 刷新成功，则回放队列的请求 + 当前请求\n                    setToken((await refreshTokenRes).data.data)\n                    config.headers!.Authorization = 'Bearer ' + getAccessToken()\n                    requestList.forEach((cb: any) => {\n                        cb()\n                    })\n                    requestList = []\n                    return service(config)\n                } catch (e) {\n                    // 为什么需要 catch 异常呢？刷新失败时，请求因为 Promise.reject 触发异常。\n                    // 2.2 刷新失败，只回放队列的请求\n                    requestList.forEach((cb: any) => {\n                        cb()\n                    })\n                    // 提示是否要登出。即不回放当前请求！不然会形成递归\n                    return handleAuthorized()\n                } finally {\n                    requestList = []\n                    isRefreshToken = false\n                }\n            } else {\n                // 添加到队列，等待刷新获取到新的令牌\n                return new Promise((resolve) => {\n                    requestList.push(() => {\n                        config.headers!.Authorization = 'Bearer ' + getAccessToken() // 让每个请求携带自定义token 请根据实际情况自行修改\n                        resolve(service(config))\n                    })\n                })\n            }\n        } else if (code === 500) {\n            ElMessage.error(t('sys.api.errMsg500'))\n            return Promise.reject(new Error(msg))\n        } else if (code === 901) {\n            ElMessage.error({\n                offset: 300,\n                dangerouslyUseHTMLString: true,\n                message:\n                    '<div>' +\n                    t('sys.api.errMsg901') +\n                    '</div>' +\n                    '<div> &nbsp; </div>' +\n                    '<div>参考 https://doc.iocoder.cn/ 教程</div>' +\n                    '<div> &nbsp; </div>' +\n                    '<div>5 分钟搭建本地环境</div>'\n            })\n            return Promise.reject(new Error(msg))\n        } else if (code !== 200) {\n            if (msg === '无效的刷新令牌') {\n                // hard coding：忽略这个提示，直接登出\n                console.log(msg)\n            } else {\n                ElNotification.error({ title: msg })\n            }\n            return Promise.reject('error')\n        } else {\n            return data\n        }\n    },\n    (error: AxiosError) => {\n        console.log('err' + error) // for debug\n        let { message } = error\n        const { t } = useI18n()\n        if (message === 'Network Error') {\n            message = t('sys.api.errorMessage')\n        } else if (message.includes('timeout')) {\n            message = t('sys.api.apiTimeoutMessage')\n        } else if (message.includes('Request failed with status code')) {\n            message = t('sys.api.apiRequestFailed') + message.substr(message.length - 3)\n        }\n        ElMessage.error(message)\n        return Promise.reject(error)\n    }\n)\n\nconst refreshToken = async () => {\n    axios.defaults.headers.common['tenant-id'] = getTenantId()\n    return await axios.post(base_url + '/system/auth/refresh-token?refreshToken=' + getRefreshToken())\n}\nconst handleAuthorized = () => {\n    const { t } = useI18n()\n    if (!isRelogin.show) {\n        isRelogin.show = true\n        ElMessageBox.confirm(t('sys.api.timeoutMessage'), t('common.confirmTitle'), {\n            confirmButtonText: t('login.relogin'),\n            cancelButtonText: t('common.cancel'),\n            type: 'warning'\n        })\n            .then(() => {\n                const { wsCache } = useCache()\n                resetRouter() // 重置静态路由表\n                wsCache.clear()\n                removeToken()\n                isRelogin.show = false\n                window.location.href = '/'\n            })\n            .catch(() => {\n                isRelogin.show = false\n            })\n    }\n    return Promise.reject(t('sys.api.timeoutMessage'))\n}\n\n\n\n# 2.2 交互流程\n\n一个完整的前端 UI 交互到服务端处理流程，如下图所示：\n\n\n\n继续以 [系统管理 -> 岗位管理] 菜单为例，查看它是如何读取岗位列表的。代码如下：\n\n// ① api/system/post/index.ts\nimport request from '@/config/axios'\n\n// 查询岗位列表\nexport const getPostPage = async (params: PageParam) => {\n  return await request.get({ url: '/system/post/page', params })\n}\n\n// ② views/system/post/index.vue\n<script setup lang=\"tsx\">\nconst loading = ref(true) // 列表的加载中\nconst total = ref(0) // 列表的总页数\nconst list = ref([]) // 列表的数据\nconst queryParams = reactive({\n    pageNo: 1,\n    pageSize: 10,\n    code: '',\n    name: '',\n    status: undefined\n})\n\n/** 查询岗位列表 */\nconst getList = async () => {\n    loading.value = true\n    try {\n        const data = await PostApi.getPostPage(queryParams)\n        list.value = data.list\n        total.value = data.total\n    } finally {\n        loading.value = false\n    }\n}\n<\/script>\n\n\n\n# 3. component 组件\n\n\n# 3.1 全局组件\n\n在 @/components 目录下，实现全局组件，被所有模块所公用。\n\n例如说，富文本编辑器、各种各搜索组件、封装的分页组件等等。\n\n\n\n\n# 3.2 模块内组件\n\n每个模块的业务组件，可实现在 views 目录下，自己模块的目录的 components 目录下，避免单个 .vue 文件过大，降低维护成功。\n\n例如说，@/views/pay/app/components/xxx.vue：\n\n\n\n\n# 4. style 样式\n\n① 在 @/styles 目录下，实现全局样式，被所有页面所公用。\n\n\n\n② 每个 .vue 页面，可在 <style /> 标签中添加样式，注意需要添加 scoped 表示只作用在当前页面里，避免造成全局的样式污染。\n\n\n\n更多也可以看看如下两篇文档：\n\n * 《vue-element-plus-admin —— 项目配置「样式配置」》\n * 《vue-element-plus-admin —— 样式》\n\n\n# 5. 项目规范\n\n可参考 《vue-element-plus-admin —— 项目规范》 文档。",
            normalizedContent: "# 0. 实战案例\n\n本小节，提供大家开发管理后台的功能时，最常用的普通列表、树形列表、新增与修改的表单弹窗、详情表单弹窗的实战案例。\n\n\n# 0.1 普通列表\n\n可参考 [系统管理 -> 岗位管理] 菜单：\n\n * api 接口：/src/api/system/post/index.ts\n * 列表界面：/src/views/system/post/index.vue\n * 表单界面：/src/views/system/post/postform.vue\n\n为什么界面拆成列表和表单两个 vue 文件？\n\n每个 vue 文件，只实现一个功能，更简洁，维护性更好，git 代码冲突概率低。\n\n\n# 0.2 树形列表\n\n可参考 [系统管理 -> 部门管理] 菜单：\n\n * api 接口：/src/api/system/dept/index.ts\n * 列表界面：/src/views/system/dept/index.vue\n * 表单界面：/src/views/system/dept/deptform.vue\n\n\n# 0.3 高性能列表\n\n可参考 [系统管理 -> 地区管理] 菜单，对应 /src/views/system/area/index.vue 列表界面\n\n基于 virtualized table 虚拟化表格 实现，解决一屏里超过 1000 条数据记录时，就会出现卡顿等性能问题。\n\n\n# 0.4 详情弹窗\n\n可参考 [基础设施 -> api 日志 -> 访问日志] 菜单，对应 /src/views/infra/apiaccesslog/apiaccesslogdetail.vue 详情弹窗\n\n\n# 1. view 页面\n\n在 @views 目录下，每个模块对应一个目录，它的所有功能的 .vue 都放在该目录里。\n\n\n\n一般来说，一个路由对应一个 index.vue 文件。\n\n\n# 2. api 请求\n\n在 @/api 目录下，每个模块对应一个 index.ts api 文件。\n\n\n\n * api 方法：会调用 request 方法，发起对后端 restful api 的调用。\n * interface 类型：定义了 api 的请求参数和返回结果的类型，对应后端的 vo 类型。\n\n\n# 2.1 请求封装\n\n/src/config/axios/index.ts 基于 axios 封装，统一处理 get、post 方法的请求参数、请求头，以及错误提示信息等。\n\n\n\n# 2.1.1 创建 axios 实例\n\n * baseurl 基础路径\n * timeout 超时时间，默认为 30000 毫秒\n\n实现代码 /src/config/axios/service.ts\n\nimport axios from 'axios'\n\nconst { result_code, base_url, request_timeout } = config\n\n// 创建 axios 实例\nconst service: axiosinstance = axios.create({\n    baseurl: base_url, // api 的 base_url\n    timeout: request_timeout, // 请求超时时间\n    withcredentials: false // 禁用 cookie 等信息\n})\n\n\n# 2.1.2 request 拦截器\n\n * 【重点】authorization、tenant-id 请求头\n * get 请求参数的拼接\n\n实现代码 /src/config/axios/service.ts\n\nimport axios, {\n    axiosinstance,\n    axiosrequestheaders,\n    axiosresponse,\n    axioserror,\n    internalaxiosrequestconfig\n} from 'axios'\n\nimport { getaccesstoken, gettenantid } from '@/utils/auth'\n\nconst tenantenable = import.meta.env.vite_app_tenant_enable\n\nservice.interceptors.request.use(\n    (config: internalaxiosrequestconfig) => {\n        // 是否需要设置 token\n        let istoken = (config!.headers || {}).istoken === false\n        whitelist.some((v) => {\n            if (config.url) {\n                config.url.indexof(v) > -1\n                return (istoken = false)\n            }\n        })\n        if (getaccesstoken() && !istoken) {\n            (config as recordable).headers.authorization = 'bearer ' + getaccesstoken() // 让每个请求携带自定义token\n        }\n        // 设置租户\n        if (tenantenable && tenantenable === 'true') {\n            const tenantid = gettenantid()\n            if (tenantid) (config as recordable).headers['tenant-id'] = tenantid\n        }\n        const params = config.params || {}\n        const data = config.data || false\n        if (\n            config.method?.touppercase() === 'post' &&\n            (config.headers as axiosrequestheaders)['content-type'] ===\n        'application/x-www-form-urlencoded'\n    ) {\n            config.data = qs.stringify(data)\n        }\n        // get参数编码\n        if (config.method?.touppercase() === 'get' && params) {\n            let url = config.url + '?'\n            for (const propname of object.keys(params)) {\n                const value = params[propname]\n                if (value !== void 0 && value !== null && typeof value !== 'undefined') {\n                    if (typeof value === 'object') {\n                        for (const val of object.keys(value)) {\n                            const params = propname + '[' + val + ']'\n                            const subpart = encodeuricomponent(params) + '='\n                            url += subpart + encodeuricomponent(value[val]) + '&'\n                        }\n                    } else {\n                        url += `${propname}=${encodeuricomponent(value)}&`\n                    }\n                }\n            }\n            // 给 get 请求加上时间戳参数，避免从缓存中拿数据\n            // const now = new date().gettime()\n            // params = params.substring(0, url.length - 1) + `?_t=${now}`\n            url = url.slice(0, -1)\n            config.params = {}\n            config.url = url\n        }\n        return config\n    },\n    (error: axioserror) => {\n        // do something with request error\n        console.log(error) // for debug\n        promise.reject(error)\n    }\n)\n\n\n# 2.1.3 response 拦截器\n\n * 访问令牌 accesstoken 过期时，使用刷新令牌 refreshtoken 刷新，获得新的访问令牌\n * 刷新令牌失败（过期）时，跳回首页进行登录\n * 请求失败，message 错误提示\n\n实现代码 /src/config/axios/service.ts\n\nimport axios, {\n    axiosinstance,\n    axiosrequestheaders,\n    axiosresponse,\n    axioserror,\n    internalaxiosrequestconfig\n} from 'axios'\nimport { elmessage, elmessagebox, elnotification } from 'element-plus'\n\nimport { getaccesstoken, getrefreshtoken, removetoken, settoken } from '@/utils/auth'\n\n// 需要忽略的提示。忽略后，自动 promise.reject('error')\nconst ignoremsgs = [\n    '无效的刷新令牌', // 刷新令牌被删除时，不用提示\n    '刷新令牌已过期' // 使用刷新令牌，刷新获取新的访问令牌时，结果因为过期失败，此时需要忽略。否则，会导致继续 401，无法跳转到登出界面\n]\n// 是否显示重新登录\nexport const isrelogin = { show: false }\nimport errorcode from './errorcode'\n\nimport { resetrouter } from '@/router'\nimport { usecache } from '@/hooks/web/usecache'\n\nservice.interceptors.response.use(\n    async (response: axiosresponse<any>) => {\n        const { data } = response\n        const config = response.config\n        if (!data) {\n            // 返回“[http]请求没有返回值”;\n            throw new error()\n        }\n        const { t } = usei18n()\n        // 未设置状态码则默认成功状态\n        const code = data.code || result_code\n        // 二进制数据则直接返回\n        if (\n            response.request.responsetype === 'blob' ||\n            response.request.responsetype === 'arraybuffer'\n        ) {\n            return response.data\n        }\n        // 获取错误信息\n        const msg = data.msg || errorcode[code] || errorcode['default']\n        if (ignoremsgs.indexof(msg) !== -1) {\n            // 如果是忽略的错误码，直接返回 msg 异常\n            return promise.reject(msg)\n        } else if (code === 401) {\n            // 如果未认证，并且未进行刷新令牌，说明可能是访问令牌过期了\n            if (!isrefreshtoken) {\n                isrefreshtoken = true\n                // 1. 如果获取不到刷新令牌，则只能执行登出操作\n                if (!getrefreshtoken()) {\n                    return handleauthorized()\n                }\n                // 2. 进行刷新访问令牌\n                try {\n                    const refreshtokenres = await refreshtoken()\n                    // 2.1 刷新成功，则回放队列的请求 + 当前请求\n                    settoken((await refreshtokenres).data.data)\n                    config.headers!.authorization = 'bearer ' + getaccesstoken()\n                    requestlist.foreach((cb: any) => {\n                        cb()\n                    })\n                    requestlist = []\n                    return service(config)\n                } catch (e) {\n                    // 为什么需要 catch 异常呢？刷新失败时，请求因为 promise.reject 触发异常。\n                    // 2.2 刷新失败，只回放队列的请求\n                    requestlist.foreach((cb: any) => {\n                        cb()\n                    })\n                    // 提示是否要登出。即不回放当前请求！不然会形成递归\n                    return handleauthorized()\n                } finally {\n                    requestlist = []\n                    isrefreshtoken = false\n                }\n            } else {\n                // 添加到队列，等待刷新获取到新的令牌\n                return new promise((resolve) => {\n                    requestlist.push(() => {\n                        config.headers!.authorization = 'bearer ' + getaccesstoken() // 让每个请求携带自定义token 请根据实际情况自行修改\n                        resolve(service(config))\n                    })\n                })\n            }\n        } else if (code === 500) {\n            elmessage.error(t('sys.api.errmsg500'))\n            return promise.reject(new error(msg))\n        } else if (code === 901) {\n            elmessage.error({\n                offset: 300,\n                dangerouslyusehtmlstring: true,\n                message:\n                    '<div>' +\n                    t('sys.api.errmsg901') +\n                    '</div>' +\n                    '<div> &nbsp; </div>' +\n                    '<div>参考 https://doc.iocoder.cn/ 教程</div>' +\n                    '<div> &nbsp; </div>' +\n                    '<div>5 分钟搭建本地环境</div>'\n            })\n            return promise.reject(new error(msg))\n        } else if (code !== 200) {\n            if (msg === '无效的刷新令牌') {\n                // hard coding：忽略这个提示，直接登出\n                console.log(msg)\n            } else {\n                elnotification.error({ title: msg })\n            }\n            return promise.reject('error')\n        } else {\n            return data\n        }\n    },\n    (error: axioserror) => {\n        console.log('err' + error) // for debug\n        let { message } = error\n        const { t } = usei18n()\n        if (message === 'network error') {\n            message = t('sys.api.errormessage')\n        } else if (message.includes('timeout')) {\n            message = t('sys.api.apitimeoutmessage')\n        } else if (message.includes('request failed with status code')) {\n            message = t('sys.api.apirequestfailed') + message.substr(message.length - 3)\n        }\n        elmessage.error(message)\n        return promise.reject(error)\n    }\n)\n\nconst refreshtoken = async () => {\n    axios.defaults.headers.common['tenant-id'] = gettenantid()\n    return await axios.post(base_url + '/system/auth/refresh-token?refreshtoken=' + getrefreshtoken())\n}\nconst handleauthorized = () => {\n    const { t } = usei18n()\n    if (!isrelogin.show) {\n        isrelogin.show = true\n        elmessagebox.confirm(t('sys.api.timeoutmessage'), t('common.confirmtitle'), {\n            confirmbuttontext: t('login.relogin'),\n            cancelbuttontext: t('common.cancel'),\n            type: 'warning'\n        })\n            .then(() => {\n                const { wscache } = usecache()\n                resetrouter() // 重置静态路由表\n                wscache.clear()\n                removetoken()\n                isrelogin.show = false\n                window.location.href = '/'\n            })\n            .catch(() => {\n                isrelogin.show = false\n            })\n    }\n    return promise.reject(t('sys.api.timeoutmessage'))\n}\n\n\n\n# 2.2 交互流程\n\n一个完整的前端 ui 交互到服务端处理流程，如下图所示：\n\n\n\n继续以 [系统管理 -> 岗位管理] 菜单为例，查看它是如何读取岗位列表的。代码如下：\n\n// ① api/system/post/index.ts\nimport request from '@/config/axios'\n\n// 查询岗位列表\nexport const getpostpage = async (params: pageparam) => {\n  return await request.get({ url: '/system/post/page', params })\n}\n\n// ② views/system/post/index.vue\n<script setup lang=\"tsx\">\nconst loading = ref(true) // 列表的加载中\nconst total = ref(0) // 列表的总页数\nconst list = ref([]) // 列表的数据\nconst queryparams = reactive({\n    pageno: 1,\n    pagesize: 10,\n    code: '',\n    name: '',\n    status: undefined\n})\n\n/** 查询岗位列表 */\nconst getlist = async () => {\n    loading.value = true\n    try {\n        const data = await postapi.getpostpage(queryparams)\n        list.value = data.list\n        total.value = data.total\n    } finally {\n        loading.value = false\n    }\n}\n<\/script>\n\n\n\n# 3. component 组件\n\n\n# 3.1 全局组件\n\n在 @/components 目录下，实现全局组件，被所有模块所公用。\n\n例如说，富文本编辑器、各种各搜索组件、封装的分页组件等等。\n\n\n\n\n# 3.2 模块内组件\n\n每个模块的业务组件，可实现在 views 目录下，自己模块的目录的 components 目录下，避免单个 .vue 文件过大，降低维护成功。\n\n例如说，@/views/pay/app/components/xxx.vue：\n\n\n\n\n# 4. style 样式\n\n① 在 @/styles 目录下，实现全局样式，被所有页面所公用。\n\n\n\n② 每个 .vue 页面，可在 <style /> 标签中添加样式，注意需要添加 scoped 表示只作用在当前页面里，避免造成全局的样式污染。\n\n\n\n更多也可以看看如下两篇文档：\n\n * 《vue-element-plus-admin —— 项目配置「样式配置」》\n * 《vue-element-plus-admin —— 样式》\n\n\n# 5. 项目规范\n\n可参考 《vue-element-plus-admin —— 项目规范》 文档。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "HTTPS 证书",
            frontmatter: {
                title: "HTTPS 证书",
                date: "2022-04-16T01:58:41.000Z",
                permalink: "/https"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/20.%E8%BF%90%E7%BB%B4%E6%89%8B%E5%86%8C/10.HTTPS%20%E8%AF%81%E4%B9%A6.html",
            relativePath: "01.开发指南/20.运维手册/10.HTTPS 证书.md",
            key: "v-5979c815",
            path: "/https/",
            headers: [{
                level: 2,
                title: "1. 阿里云 SSL【最常用】",
                slug: "_1-阿里云-ssl【最常用】",
                normalizedTitle: "1. 阿里云 ssl【最常用】",
                charIndex: 275
            }, {
                level: 2,
                title: "2. FreeSSL【最便宜】",
                slug: "_2-freessl【最便宜】",
                normalizedTitle: "2. freessl【最便宜】",
                charIndex: 370
            }, {
                level: 2,
                title: "3. 腾讯云 SSL",
                slug: "_3-腾讯云-ssl",
                normalizedTitle: "3. 腾讯云 ssl",
                charIndex: 524
            }, {
                level: 2,
                title: "4. 华为云 SSL",
                slug: "_4-华为云-ssl",
                normalizedTitle: "4. 华为云 ssl",
                charIndex: 613
            }],
            headersStr: "1. 阿里云 SSL【最常用】 2. FreeSSL【最便宜】 3. 腾讯云 SSL 4. 华为云 SSL",
            content: "本小节，讲解如何在 Nginx 配置 SSL 证书，实现前端和后端使用 HTTPS 安全访问的功能。\n\n考虑到各大云服务厂商的文档写的比较齐全，这里更多做汇总与整理。\n\n😜 如果想要免费的 SSL 证书，请申请 DV 单域名证书。如果要配置多个域名，可以申请多个 DV 单域名证书。\n\n友情提示：HTTPS 的学习资料？\n\n * 《HTTPS 的工作原理》\n * 《面试官：你连 HTTPS 原理没搞懂，还给我讲“中间人攻击”？》\n\n重要！有个球友共享了 https://t.zsxq.com/th7np 了他的配置过程，大家可以借鉴下！\n\n\n# 1. 阿里云 SSL【最常用】\n\n阿里云 SSL 证书\n\n * 第一步，免费证书申购流程\n * 第二步，在 Nginx 或 Tengine 服务器上安装证书\n\n\n\n↑ 点击观看 ↑\n\n\n# 2. FreeSSL【最便宜】\n\nFreeSSL.cn，一个提供免费 HTTPS 证书申请的网站。\n\n《如何在 Nginx/Apache/Tomcat/IIS 自动部署证书？》\n\n疑问：有没其它类似的平台？\n\n * OHTTPS：免费提供 HTTPS 证书，支持一键申请、自动更新、自动部署的功能。\n\n\n# 3. 腾讯云 SSL\n\n腾讯云 SSL 证书\n\n * 第一步，免费 SSL 证书申请流程\n * 第二步，Nginx 服务器 SSL 证书安装部署\n\n\n\n↑ 点击观看 ↑\n\n\n# 4. 华为云 SSL\n\n云证书管理服务 CCM\n\n * 第一步，SSL 证书申购流程\n * 第二步，下载与安装 SSL 证书",
            normalizedContent: "本小节，讲解如何在 nginx 配置 ssl 证书，实现前端和后端使用 https 安全访问的功能。\n\n考虑到各大云服务厂商的文档写的比较齐全，这里更多做汇总与整理。\n\n😜 如果想要免费的 ssl 证书，请申请 dv 单域名证书。如果要配置多个域名，可以申请多个 dv 单域名证书。\n\n友情提示：https 的学习资料？\n\n * 《https 的工作原理》\n * 《面试官：你连 https 原理没搞懂，还给我讲“中间人攻击”？》\n\n重要！有个球友共享了 https://t.zsxq.com/th7np 了他的配置过程，大家可以借鉴下！\n\n\n# 1. 阿里云 ssl【最常用】\n\n阿里云 ssl 证书\n\n * 第一步，免费证书申购流程\n * 第二步，在 nginx 或 tengine 服务器上安装证书\n\n\n\n↑ 点击观看 ↑\n\n\n# 2. freessl【最便宜】\n\nfreessl.cn，一个提供免费 https 证书申请的网站。\n\n《如何在 nginx/apache/tomcat/iis 自动部署证书？》\n\n疑问：有没其它类似的平台？\n\n * ohttps：免费提供 https 证书，支持一键申请、自动更新、自动部署的功能。\n\n\n# 3. 腾讯云 ssl\n\n腾讯云 ssl 证书\n\n * 第一步，免费 ssl 证书申请流程\n * 第二步，nginx 服务器 ssl 证书安装部署\n\n\n\n↑ 点击观看 ↑\n\n\n# 4. 华为云 ssl\n\n云证书管理服务 ccm\n\n * 第一步，ssl 证书申购流程\n * 第二步，下载与安装 ssl 证书",
            charsets: {
                cjk: !0
            }
        }, {
            title: "菜单路由",
            frontmatter: {
                title: "菜单路由",
                date: "2022-12-31T22:35:06.000Z",
                permalink: "/vue3/route"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/21.%E5%89%8D%E7%AB%AF%E6%89%8B%E5%86%8C%20Vue%203.x/02.%E8%8F%9C%E5%8D%95%E8%B7%AF%E7%94%B1.html",
            relativePath: "01.开发指南/21.前端手册 Vue 3.x/02.菜单路由.md",
            key: "v-6fec2647",
            path: "/vue3/route/",
            headers: [{
                level: 2,
                title: "1. 路由配置",
                slug: "_1-路由配置",
                normalizedTitle: "1. 路由配置",
                charIndex: 175
            }, {
                level: 2,
                title: "1.1 普通示例",
                slug: "_1-1-普通示例",
                normalizedTitle: "1.1 普通示例",
                charIndex: 1282
            }, {
                level: 3,
                title: "1.2 外链示例",
                slug: "_1-2-外链示例",
                normalizedTitle: "1.2 外链示例",
                charIndex: 2752
            }, {
                level: 2,
                title: "2. 路由",
                slug: "_2-路由",
                normalizedTitle: "2. 路由",
                charIndex: 3001
            }, {
                level: 3,
                title: "2.1 静态路由",
                slug: "_2-1-静态路由",
                normalizedTitle: "2.1 静态路由",
                charIndex: 3033
            }, {
                level: 3,
                title: "2.2 动态路由",
                slug: "_2-2-动态路由",
                normalizedTitle: "2.2 动态路由",
                charIndex: 3161
            }, {
                level: 3,
                title: "2.3 路由跳转",
                slug: "_2-3-路由跳转",
                normalizedTitle: "2.3 路由跳转",
                charIndex: 3565
            }, {
                level: 2,
                title: "3. 菜单管理",
                slug: "_3-菜单管理",
                normalizedTitle: "3. 菜单管理",
                charIndex: 3769
            }, {
                level: 3,
                title: "3.1 新增目录",
                slug: "_3-1-新增目录",
                normalizedTitle: "3.1 新增目录",
                charIndex: 3877
            }, {
                level: 3,
                title: "3.2 新增菜单",
                slug: "_3-2-新增菜单",
                normalizedTitle: "3.2 新增菜单",
                charIndex: 3937
            }, {
                level: 3,
                title: "3.3 新增按钮",
                slug: "_3-3-新增按钮",
                normalizedTitle: "3.3 新增按钮",
                charIndex: 3952
            }, {
                level: 2,
                title: "4. 权限控制",
                slug: "_4-权限控制",
                normalizedTitle: "4. 权限控制",
                charIndex: 3967
            }, {
                level: 3,
                title: "4.1 v-hasPermi 指令",
                slug: "_4-1-v-haspermi-指令",
                normalizedTitle: "4.1 v-haspermi 指令",
                charIndex: 4075
            }, {
                level: 3,
                title: "4.2 v-hasRole 指令",
                slug: "_4-2-v-hasrole-指令",
                normalizedTitle: "4.2 v-hasrole 指令",
                charIndex: 4328
            }, {
                level: 3,
                title: "4.3 结合 v-if 指令",
                slug: "_4-3-结合-v-if-指令",
                normalizedTitle: "4.3 结合 v-if 指令",
                charIndex: 4530
            }, {
                level: 2,
                title: "5. 页面缓存",
                slug: "_5-页面缓存",
                normalizedTitle: "5. 页面缓存",
                charIndex: 5261
            }, {
                level: 3,
                title: "5.1 静态路由的示例",
                slug: "_5-1-静态路由的示例",
                normalizedTitle: "5.1 静态路由的示例",
                charIndex: 5423
            }, {
                level: 3,
                title: "5.2 动态路由的示例",
                slug: "_5-2-动态路由的示例",
                normalizedTitle: "5.2 动态路由的示例",
                charIndex: 5820
            }],
            headersStr: "1. 路由配置 1.1 普通示例 1.2 外链示例 2. 路由 2.1 静态路由 2.2 动态路由 2.3 路由跳转 3. 菜单管理 3.1 新增目录 3.2 新增菜单 3.3 新增按钮 4. 权限控制 4.1 v-hasPermi 指令 4.2 v-hasRole 指令 4.3 结合 v-if 指令 5. 页面缓存 5.1 静态路由的示例 5.2 动态路由的示例",
            content: "前端项目基于 vue-element-plus-admin 实现，它的 路由和侧边栏 是组织起一个后台应用的关键骨架。\n\n侧边栏和路由是绑定在一起的，所以你只有在 @/router/index.js 下面配置对应的路由，侧边栏就能动态的生成了，大大减轻了手动重复编辑侧边栏的工作量。\n\n当然，这样就需要在配置路由的时候，遵循一些约定的规则。\n\n\n# 1. 路由配置\n\n首先，我们了解一下本项目配置路由时，提供了哪些配置项：\n\n/**\n* redirect: noredirect        当设置 noredirect 的时候该路由在面包屑导航中不可被点击\n* name:'router-name'          设定路由的名字，一定要填写不然使用<keep-alive>时会出现各种问题\n* meta : {\n    hidden: true              当设置 true 的时候该路由不会再侧边栏出现 如404，login等页面(默认 false)\n\n    alwaysShow: true          当你一个路由下面的 children 声明的路由大于1个时，自动会变成嵌套的模式，\n                              只有一个时，会将那个子路由当做根路由显示在侧边栏，\n                              若你想不管路由下面的 children 声明的个数都显示你的根路由，\n                              你可以设置 alwaysShow: true，这样它就会忽略之前定义的规则，\n                              一直显示根路由(默认 false)\n\n    title: 'title'            设置该路由在侧边栏和面包屑中展示的名字\n\n    icon: 'svg-name'          设置该路由的图标\n\n    noCache: true             如果设置为true，则不会被 <keep-alive> 缓存(默认 false)\n\n    breadcrumb: false         如果设置为false，则不会在breadcrumb面包屑中显示(默认 true)\n\n    affix: true               如果设置为true，则会一直固定在tag项中(默认 false)\n\n    noTagsView: true          如果设置为true，则不会出现在tag中(默认 false)\n\n    activeMenu: '/dashboard'  显示高亮的路由路径\n\n    followAuth: '/dashboard'  跟随哪个路由进行权限过滤\n\n    canTo: true               设置为true即使hidden为true，也依然可以进行路由跳转(默认 false)\n  }\n**/\n\n\n\n# 1.1 普通示例\n\n注意事项：\n\n * 整个项目所有路由 name 不能重复\n * 所有的多级路由最终都会转成二级路由，所以不能内嵌子路由\n * 除了 layout 对应的 path 前面需要加 /，其余子路由都不要以 / 开头\n\n{\n  path: '/level',\n  component: Layout,\n  redirect: '/level/menu1/menu1-1/menu1-1-1',\n  name: 'Level',\n  meta: {\n    title: t('router.level'),\n    icon: 'carbon:skill-level-advanced'\n  },\n  children: [\n    {\n      path: 'menu1',\n      name: 'Menu1',\n      component: getParentLayout(),\n      redirect: '/level/menu1/menu1-1/menu1-1-1',\n      meta: {\n        title: t('router.menu1')\n      },\n      children: [\n        {\n          path: 'menu1-1',\n          name: 'Menu11',\n          component: getParentLayout(),\n          redirect: '/level/menu1/menu1-1/menu1-1-1',\n          meta: {\n            title: t('router.menu11'),\n            alwaysShow: true\n          },\n          children: [\n            {\n              path: 'menu1-1-1',\n              name: 'Menu111',\n              component: () => import('@/views/Level/Menu111.vue'),\n              meta: {\n                title: t('router.menu111')\n              }\n            }\n          ]\n        },\n        {\n          path: 'menu1-2',\n          name: 'Menu12',\n          component: () => import('@/views/Level/Menu12.vue'),\n          meta: {\n            title: t('router.menu12')\n          }\n        }\n      ]\n    },\n    {\n      path: 'menu2',\n      name: 'Menu2Demo',\n      component: () => import('@/views/Level/Menu2.vue'),\n      meta: {\n        title: t('router.menu2')\n      }\n    }\n  ]\n}\n\n\n\n# 1.2 外链示例\n\n只需要将 path 设置为需要跳转的 HTTP 地址即可。\n\n{\n  path: '/external-link',\n  component: Layout,\n  meta: {\n    name: 'ExternalLink'\n  },\n  children: [\n    {\n      path: 'https://www.iocoder.cn',\n      meta: { name: 'Link', title: '芋道源码' }\n    }\n  ]\n}\n\n\n\n# 2. 路由\n\n项目的路由分为两种：静态路由、动态路由。\n\n\n# 2.1 静态路由\n\n静态路由，代表那些不需要动态判断权限的路由，如登录页、404、个人中心等通用页面。\n\n在 @/router/modules/remaining.ts 的 remainingRouter，就是配置对应的公共路由。如下图所示：\n\n\n\n\n# 2.2 动态路由\n\n动态路由，代表那些需要根据用户动态判断权限，并通过 addRoutes 动态添加的页面，如用户管理、角色管理等功能页面。\n\n在用户登录成功后，会触发 @/store/modules/permission.ts 请求后端的菜单 RESTful API 接口，获取用户有权限的菜单列表，并转化添加到路由中。如下图所示：\n\n\n\n友情提示：\n\n 1. 动态路由可以在 [系统管理 -> 菜单管理] 进行新增和修改操作，请求的后端 RESTful API 接口是 /admin-api/system/auth/get-permission-info\n 2. 动态路由在生产环境下会默认使用路由懒加载，实现方式参考 import.meta.glob('../views/**/*.{vue,tsx}') 方法的判断\n\n补充说明：\n\n最新的代码，部分逻辑重构到 @/permission.ts\n\n\n# 2.3 路由跳转\n\n使用 router.push 方法，可以实现跳转到不同的页面。\n\nconst { push } = useRouter()\n\n// 简单跳转\npush('/job/job-log');\n\n// 跳转页面并设置请求参数，使用 `query` 属性\npush('/bpm/process-instance/detail?id=' + row.processInstance.id)\n\n\n\n# 3. 菜单管理\n\n项目的菜单在 [系统管理 -> 菜单管理] 进行管理，支持无限层级，提供目录、菜单、按钮三种类型。如下图所示：\n\n\n\n菜单可在 [系统管理 -> 角色管理] 被分配给角色。如下图所示：\n\n\n\n\n# 3.1 新增目录\n\n① 大多数情况下，目录是作为菜单的【分类】：\n\n\n\n② 目录也提供实现【外链】的能力：\n\n\n\n\n# 3.2 新增菜单\n\n\n\n\n# 3.3 新增按钮\n\n\n\n\n# 4. 权限控制\n\n前端通过权限控制，隐藏用户没有权限的按钮等，实现功能级别的权限。\n\n友情提示：前端的权限控制，主要是提升用户体验，避免操作后发现没有权限。\n\n最终在请求到后端时，还是会进行一次权限的校验。\n\n\n# 4.1 v-hasPermi 指令\n\nv-hasPermi 指令，基于权限字符，进行权限的控制。\n\n\x3c!-- 单个 --\x3e\n<el-button v-hasPermi=\"['system:user:create']\">存在权限字符串才能看到</el-button>\n\n\x3c!-- 多个，满足任一一个即可 --\x3e\n<el-button v-hasPermi=\"['system:user:create', 'system:user:update']\">包含权限字符串才能看到</el-button>\n\n\n\n# 4.2 v-hasRole 指令\n\nv-hasRole 指令，基于角色标识，机进行的控制。\n\n\x3c!-- 单个 --\x3e\n<el-button v-hasRole=\"['admin']\">管理员才能看到</el-button>\n\n\x3c!-- 多个，满足任一一个即可 --\x3e\n<el-button v-hasRole=\"['role1', 'role2']\">包含角色才能看到</el-button>\n\n\n\n# 4.3 结合 v-if 指令\n\n在某些情况下，它是不适合使用 v-hasPermi 或 v-hasRole 指令，如元素标签组件。此时，只能通过手动设置 v-if，通过使用全局权限判断函数，用法是基本一致的。\n\n<template>\n  <el-tabs>\n    <el-tab-pane v-if=\"checkPermi(['system:user:create'])\" label=\"用户管理\" name=\"user\">用户管理</el-tab-pane>\n    <el-tab-pane v-if=\"checkPermi(['system:user:create', 'system:user:update'])\" label=\"参数管理\" name=\"menu\">参数管理</el-tab-pane>\n    <el-tab-pane v-if=\"checkRole(['admin'])\" label=\"角色管理\" name=\"role\">角色管理</el-tab-pane>\n    <el-tab-pane v-if=\"checkRole(['admin','common'])\" label=\"定时任务\" name=\"job\">定时任务</el-tab-pane>\n   </el-tabs>\n</template>\n\n<script>\nimport { checkPermi, checkRole } from \"@/utils/permission\"; // 权限判断函数\n\nexport default{\n   methods: {\n    checkPermi,\n    checkRole\n  }\n}\n<\/script>\n\n\n\n# 5. 页面缓存\n\n开启缓存有 2 个条件\n\n * 路由设置 name，且不能重复\n * 路由对应的组件加上 name，与路由设置的 name 保持一致\n\n友情提示：页面缓存是什么？\n\n简单来说，Tab 切换时，开启页面缓存的 Tab 保持原本的状态，不进行刷新。\n\n详细可见 Vue 文档 —— KeepAlive\n\n\n# 5.1 静态路由的示例\n\n① router 路由的 name 声明如下：\n\n{\n    path: 'menu2',\n    name: 'Menu2',\n    component: () => import('@/views/Level/Menu2.vue'),\n    meta: {\n        title: t('router.menu2')\n    }\n}\n\n\n② view component 的 name 声明如下：\n\n<script setup lang=\"ts\">\n    defineOptions({\n    name: 'Menu2'\n})\n<\/script>\n\n\n注意：\n\nkeep-alive 生效的前提是：需要将路由的 name 属性及对应的页面的 name 设置成一样。\n\n因为：include - 字符串或正则表达式，只有名称匹配的组件会被缓存\n\n\n# 5.2 动态路由的示例\n\n",
            normalizedContent: "前端项目基于 vue-element-plus-admin 实现，它的 路由和侧边栏 是组织起一个后台应用的关键骨架。\n\n侧边栏和路由是绑定在一起的，所以你只有在 @/router/index.js 下面配置对应的路由，侧边栏就能动态的生成了，大大减轻了手动重复编辑侧边栏的工作量。\n\n当然，这样就需要在配置路由的时候，遵循一些约定的规则。\n\n\n# 1. 路由配置\n\n首先，我们了解一下本项目配置路由时，提供了哪些配置项：\n\n/**\n* redirect: noredirect        当设置 noredirect 的时候该路由在面包屑导航中不可被点击\n* name:'router-name'          设定路由的名字，一定要填写不然使用<keep-alive>时会出现各种问题\n* meta : {\n    hidden: true              当设置 true 的时候该路由不会再侧边栏出现 如404，login等页面(默认 false)\n\n    alwaysshow: true          当你一个路由下面的 children 声明的路由大于1个时，自动会变成嵌套的模式，\n                              只有一个时，会将那个子路由当做根路由显示在侧边栏，\n                              若你想不管路由下面的 children 声明的个数都显示你的根路由，\n                              你可以设置 alwaysshow: true，这样它就会忽略之前定义的规则，\n                              一直显示根路由(默认 false)\n\n    title: 'title'            设置该路由在侧边栏和面包屑中展示的名字\n\n    icon: 'svg-name'          设置该路由的图标\n\n    nocache: true             如果设置为true，则不会被 <keep-alive> 缓存(默认 false)\n\n    breadcrumb: false         如果设置为false，则不会在breadcrumb面包屑中显示(默认 true)\n\n    affix: true               如果设置为true，则会一直固定在tag项中(默认 false)\n\n    notagsview: true          如果设置为true，则不会出现在tag中(默认 false)\n\n    activemenu: '/dashboard'  显示高亮的路由路径\n\n    followauth: '/dashboard'  跟随哪个路由进行权限过滤\n\n    canto: true               设置为true即使hidden为true，也依然可以进行路由跳转(默认 false)\n  }\n**/\n\n\n\n# 1.1 普通示例\n\n注意事项：\n\n * 整个项目所有路由 name 不能重复\n * 所有的多级路由最终都会转成二级路由，所以不能内嵌子路由\n * 除了 layout 对应的 path 前面需要加 /，其余子路由都不要以 / 开头\n\n{\n  path: '/level',\n  component: layout,\n  redirect: '/level/menu1/menu1-1/menu1-1-1',\n  name: 'level',\n  meta: {\n    title: t('router.level'),\n    icon: 'carbon:skill-level-advanced'\n  },\n  children: [\n    {\n      path: 'menu1',\n      name: 'menu1',\n      component: getparentlayout(),\n      redirect: '/level/menu1/menu1-1/menu1-1-1',\n      meta: {\n        title: t('router.menu1')\n      },\n      children: [\n        {\n          path: 'menu1-1',\n          name: 'menu11',\n          component: getparentlayout(),\n          redirect: '/level/menu1/menu1-1/menu1-1-1',\n          meta: {\n            title: t('router.menu11'),\n            alwaysshow: true\n          },\n          children: [\n            {\n              path: 'menu1-1-1',\n              name: 'menu111',\n              component: () => import('@/views/level/menu111.vue'),\n              meta: {\n                title: t('router.menu111')\n              }\n            }\n          ]\n        },\n        {\n          path: 'menu1-2',\n          name: 'menu12',\n          component: () => import('@/views/level/menu12.vue'),\n          meta: {\n            title: t('router.menu12')\n          }\n        }\n      ]\n    },\n    {\n      path: 'menu2',\n      name: 'menu2demo',\n      component: () => import('@/views/level/menu2.vue'),\n      meta: {\n        title: t('router.menu2')\n      }\n    }\n  ]\n}\n\n\n\n# 1.2 外链示例\n\n只需要将 path 设置为需要跳转的 http 地址即可。\n\n{\n  path: '/external-link',\n  component: layout,\n  meta: {\n    name: 'externallink'\n  },\n  children: [\n    {\n      path: 'https://www.iocoder.cn',\n      meta: { name: 'link', title: '芋道源码' }\n    }\n  ]\n}\n\n\n\n# 2. 路由\n\n项目的路由分为两种：静态路由、动态路由。\n\n\n# 2.1 静态路由\n\n静态路由，代表那些不需要动态判断权限的路由，如登录页、404、个人中心等通用页面。\n\n在 @/router/modules/remaining.ts 的 remainingrouter，就是配置对应的公共路由。如下图所示：\n\n\n\n\n# 2.2 动态路由\n\n动态路由，代表那些需要根据用户动态判断权限，并通过 addroutes 动态添加的页面，如用户管理、角色管理等功能页面。\n\n在用户登录成功后，会触发 @/store/modules/permission.ts 请求后端的菜单 restful api 接口，获取用户有权限的菜单列表，并转化添加到路由中。如下图所示：\n\n\n\n友情提示：\n\n 1. 动态路由可以在 [系统管理 -> 菜单管理] 进行新增和修改操作，请求的后端 restful api 接口是 /admin-api/system/auth/get-permission-info\n 2. 动态路由在生产环境下会默认使用路由懒加载，实现方式参考 import.meta.glob('../views/**/*.{vue,tsx}') 方法的判断\n\n补充说明：\n\n最新的代码，部分逻辑重构到 @/permission.ts\n\n\n# 2.3 路由跳转\n\n使用 router.push 方法，可以实现跳转到不同的页面。\n\nconst { push } = userouter()\n\n// 简单跳转\npush('/job/job-log');\n\n// 跳转页面并设置请求参数，使用 `query` 属性\npush('/bpm/process-instance/detail?id=' + row.processinstance.id)\n\n\n\n# 3. 菜单管理\n\n项目的菜单在 [系统管理 -> 菜单管理] 进行管理，支持无限层级，提供目录、菜单、按钮三种类型。如下图所示：\n\n\n\n菜单可在 [系统管理 -> 角色管理] 被分配给角色。如下图所示：\n\n\n\n\n# 3.1 新增目录\n\n① 大多数情况下，目录是作为菜单的【分类】：\n\n\n\n② 目录也提供实现【外链】的能力：\n\n\n\n\n# 3.2 新增菜单\n\n\n\n\n# 3.3 新增按钮\n\n\n\n\n# 4. 权限控制\n\n前端通过权限控制，隐藏用户没有权限的按钮等，实现功能级别的权限。\n\n友情提示：前端的权限控制，主要是提升用户体验，避免操作后发现没有权限。\n\n最终在请求到后端时，还是会进行一次权限的校验。\n\n\n# 4.1 v-haspermi 指令\n\nv-haspermi 指令，基于权限字符，进行权限的控制。\n\n\x3c!-- 单个 --\x3e\n<el-button v-haspermi=\"['system:user:create']\">存在权限字符串才能看到</el-button>\n\n\x3c!-- 多个，满足任一一个即可 --\x3e\n<el-button v-haspermi=\"['system:user:create', 'system:user:update']\">包含权限字符串才能看到</el-button>\n\n\n\n# 4.2 v-hasrole 指令\n\nv-hasrole 指令，基于角色标识，机进行的控制。\n\n\x3c!-- 单个 --\x3e\n<el-button v-hasrole=\"['admin']\">管理员才能看到</el-button>\n\n\x3c!-- 多个，满足任一一个即可 --\x3e\n<el-button v-hasrole=\"['role1', 'role2']\">包含角色才能看到</el-button>\n\n\n\n# 4.3 结合 v-if 指令\n\n在某些情况下，它是不适合使用 v-haspermi 或 v-hasrole 指令，如元素标签组件。此时，只能通过手动设置 v-if，通过使用全局权限判断函数，用法是基本一致的。\n\n<template>\n  <el-tabs>\n    <el-tab-pane v-if=\"checkpermi(['system:user:create'])\" label=\"用户管理\" name=\"user\">用户管理</el-tab-pane>\n    <el-tab-pane v-if=\"checkpermi(['system:user:create', 'system:user:update'])\" label=\"参数管理\" name=\"menu\">参数管理</el-tab-pane>\n    <el-tab-pane v-if=\"checkrole(['admin'])\" label=\"角色管理\" name=\"role\">角色管理</el-tab-pane>\n    <el-tab-pane v-if=\"checkrole(['admin','common'])\" label=\"定时任务\" name=\"job\">定时任务</el-tab-pane>\n   </el-tabs>\n</template>\n\n<script>\nimport { checkpermi, checkrole } from \"@/utils/permission\"; // 权限判断函数\n\nexport default{\n   methods: {\n    checkpermi,\n    checkrole\n  }\n}\n<\/script>\n\n\n\n# 5. 页面缓存\n\n开启缓存有 2 个条件\n\n * 路由设置 name，且不能重复\n * 路由对应的组件加上 name，与路由设置的 name 保持一致\n\n友情提示：页面缓存是什么？\n\n简单来说，tab 切换时，开启页面缓存的 tab 保持原本的状态，不进行刷新。\n\n详细可见 vue 文档 —— keepalive\n\n\n# 5.1 静态路由的示例\n\n① router 路由的 name 声明如下：\n\n{\n    path: 'menu2',\n    name: 'menu2',\n    component: () => import('@/views/level/menu2.vue'),\n    meta: {\n        title: t('router.menu2')\n    }\n}\n\n\n② view component 的 name 声明如下：\n\n<script setup lang=\"ts\">\n    defineoptions({\n    name: 'menu2'\n})\n<\/script>\n\n\n注意：\n\nkeep-alive 生效的前提是：需要将路由的 name 属性及对应的页面的 name 设置成一样。\n\n因为：include - 字符串或正则表达式，只有名称匹配的组件会被缓存\n\n\n# 5.2 动态路由的示例\n\n",
            charsets: {
                cjk: !0
            }
        }, {
            title: "服务监控",
            frontmatter: {
                title: "服务监控",
                date: "2022-04-16T19:12:14.000Z",
                permalink: "/server-monitor"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/20.%E8%BF%90%E7%BB%B4%E6%89%8B%E5%86%8C/11.%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A7.html",
            relativePath: "01.开发指南/20.运维手册/11.服务监控.md",
            key: "v-f698ea34",
            path: "/server-monitor/",
            headers: [{
                level: 2,
                title: "1. Spring Boot Admin",
                slug: "_1-spring-boot-admin",
                normalizedTitle: "1. spring boot admin",
                charIndex: 51
            }, {
                level: 3,
                title: "1.1 如何配置？",
                slug: "_1-1-如何配置",
                normalizedTitle: "1.1 如何配置？",
                charIndex: 190
            }, {
                level: 3,
                title: "1.2 如何使用？",
                slug: "_1-2-如何使用",
                normalizedTitle: "1.2 如何使用？",
                charIndex: 593
            }, {
                level: 3,
                title: "1.3 如何开启登录？",
                slug: "_1-3-如何开启登录",
                normalizedTitle: "1.3 如何开启登录？",
                charIndex: 1045
            }, {
                level: 2,
                title: "2. SkyWalking",
                slug: "_2-skywalking",
                normalizedTitle: "2. skywalking",
                charIndex: 1313
            }, {
                level: 3,
                title: "2.1 如何配置？",
                slug: "_2-1-如何配置",
                normalizedTitle: "2.1 如何配置？",
                charIndex: 1415
            }, {
                level: 3,
                title: "2.2 如何使用？",
                slug: "_2-2-如何使用",
                normalizedTitle: "2.2 如何使用？",
                charIndex: 1605
            }, {
                level: 2,
                title: "3. 更多监控系统",
                slug: "_3-更多监控系统",
                normalizedTitle: "3. 更多监控系统",
                charIndex: 1872
            }, {
                level: 3,
                title: "3.1 Prometheus",
                slug: "_3-1-prometheus",
                normalizedTitle: "3.1 prometheus",
                charIndex: 1886
            }, {
                level: 3,
                title: "3.2 ELK",
                slug: "_3-2-elk",
                normalizedTitle: "3.2 elk",
                charIndex: 1960
            }, {
                level: 3,
                title: "3.3 Sentry",
                slug: "_3-3-sentry",
                normalizedTitle: "3.3 sentry",
                charIndex: 2027
            }],
            headersStr: "1. Spring Boot Admin 1.1 如何配置？ 1.2 如何使用？ 1.3 如何开启登录？ 2. SkyWalking 2.1 如何配置？ 2.2 如何使用？ 3. 更多监控系统 3.1 Prometheus 3.2 ELK 3.3 Sentry",
            content: "系统使用 Spring Boot Admin 和 SkyWalking 实现后端服务的监控。\n\n\n# 1. Spring Boot Admin\n\n阅读 《芋道 Spring Boot 监控工具 Admin 入门》 文章，入门 Spring Boot Admin。\n\n注意，Spring Boot Admin 是内嵌在 yudao-server 后端项目中，无需单独启动。\n\n\n# 1.1 如何配置？\n\n在 application-local.yaml 配置文件中，通过 spring.boot.admin 配置项，设置 Spring Boot Admin 的配置。如下图所示：\n\n\n\n疑问：prod 生产环境下，后端部署多个 JVM 进程时，spring.boot.admin.client.url 填写哪个 IP？\n\n * 第一步，在 Nginx 中配置 /admin 路径，转发到多个 JVM 的 IP 上，使用 backup 参数实现主备。注意，该转发只允许内网访问，避免安全问题！！！\n * 第二步，设置 spring.boot.admin.client.url 配置项，为 Nginx 的 内置 IP/admin 地址。\n\n重要！！！考虑到项目的启动速度，local 本地开发环境下，默认禁用了 Spring Boot Admin 的启动，可以参考下图进行开启：\n\n\n\n\n# 1.2 如何使用？\n\n① 访问 http://127.0.0.1:48080/admin/applications 地址，可以在 Spring Boot Admin 中，查看到应用与实例的列表。如下图所示：\n\n\n\n② 点击 yudao-server 应用，再点击实例，可以查看到该实例的细节信息。如下图所示：\n\n\n\n③ 点击 [日志 -> 日志文件] 菜单，查看该示例的日志内容。如下图所示：\n\n\n\n点击 [日志 -> 日志文件] 菜单，可动态修改 Logger 的日志级别，方便排查线上的某些 BUG。如下图所示：\n\n\n\n补充说明：也可以通过前端的 [基础设施 -> 监控中心 -> Java 监控] 菜单。\n\n前端 [基础设施 -> 监控中心 -> Java 监控] 菜单，通过 iframe 内嵌后端 /admin/applications 路径。\n\n如果你想自定义地址，可以前往 [基础设置 -> 配置管理] 菜单，设置 key 为 url.spring-boot-admin 配置项。\n\n\n# 1.3 如何开启登录？\n\n生产环境下，建议 Spring Boot Admin 开启“安全认证”的功能，避免出现安全事故。\n\n由于项目本身已经使用 Spring Security 做安全认证，再额外配置 Spring Boot Admin 的“安全认证”有点麻烦。我自己是拓展 Spring Security 解决，预计需要改 2-3 个类，不是很建议。\n\n那么怎么办呢？可以参考 《芋道 Spring Boot 监控工具 Admin 入门》 文档，额外搭建一个 Spring Boot Admin 进程，然后项目接入它使用！\n\n\n# 2. SkyWalking\n\n阅读 《芋道 SkyWalking 极简入门》 文章，入门 SkyWalking。\n\n注意，SkyWalking 需要单独启动，预计需要 4 核 8G 的硬件资源。\n\n\n# 2.1 如何配置？\n\n① 在 logback-spring.xml 配置文件中，添加 SkyWalking 收集日志的 appender 配置。如下图所示：\n\n\n\n② 修改 SkyWalking 在前端项目的 [基础设施 -> 监控中心 -> 链路追踪] 对应的 skywaling/index.vue 文件，调整为你 SkyWalking 的访问地址。如下图所示：\n\n\n\n\n# 2.2 如何使用？\n\n① 点击 [基础设施 -> 监控中心 -> 链路追踪] 菜单，可以看到 SkyWalking 提供的链路追踪。如下图所示：\n\n\n\n② 点击 yudao-server 服务，查看该服务的监控信息。如下图所示：\n\n\n\n补充说明：\n\n前端 [基础设施 -> 监控中心 -> 链路追踪] 菜单，通过 iframe 内嵌 http://skywalking.iocoder.cn 路径。\n\n如果你想自定义地址，可以前往 [基础设置 -> 配置管理] 菜单，设置 key 为 url.skywalking 配置项。\n\n\n# 3. 更多监控系统\n\n\n# 3.1 Prometheus\n\n参见 《芋道 Prometheus + Grafana + Alertmanager 极简入门 》 文章。\n\n\n# 3.2 ELK\n\n参见 芋道 ELK(Elasticsearch + Logstash + Kibana) 极简入门 文章。\n\n\n# 3.3 Sentry\n\n参见 《Sentry 极简入门 》 文章。",
            normalizedContent: "系统使用 spring boot admin 和 skywalking 实现后端服务的监控。\n\n\n# 1. spring boot admin\n\n阅读 《芋道 spring boot 监控工具 admin 入门》 文章，入门 spring boot admin。\n\n注意，spring boot admin 是内嵌在 yudao-server 后端项目中，无需单独启动。\n\n\n# 1.1 如何配置？\n\n在 application-local.yaml 配置文件中，通过 spring.boot.admin 配置项，设置 spring boot admin 的配置。如下图所示：\n\n\n\n疑问：prod 生产环境下，后端部署多个 jvm 进程时，spring.boot.admin.client.url 填写哪个 ip？\n\n * 第一步，在 nginx 中配置 /admin 路径，转发到多个 jvm 的 ip 上，使用 backup 参数实现主备。注意，该转发只允许内网访问，避免安全问题！！！\n * 第二步，设置 spring.boot.admin.client.url 配置项，为 nginx 的 内置 ip/admin 地址。\n\n重要！！！考虑到项目的启动速度，local 本地开发环境下，默认禁用了 spring boot admin 的启动，可以参考下图进行开启：\n\n\n\n\n# 1.2 如何使用？\n\n① 访问 http://127.0.0.1:48080/admin/applications 地址，可以在 spring boot admin 中，查看到应用与实例的列表。如下图所示：\n\n\n\n② 点击 yudao-server 应用，再点击实例，可以查看到该实例的细节信息。如下图所示：\n\n\n\n③ 点击 [日志 -> 日志文件] 菜单，查看该示例的日志内容。如下图所示：\n\n\n\n点击 [日志 -> 日志文件] 菜单，可动态修改 logger 的日志级别，方便排查线上的某些 bug。如下图所示：\n\n\n\n补充说明：也可以通过前端的 [基础设施 -> 监控中心 -> java 监控] 菜单。\n\n前端 [基础设施 -> 监控中心 -> java 监控] 菜单，通过 iframe 内嵌后端 /admin/applications 路径。\n\n如果你想自定义地址，可以前往 [基础设置 -> 配置管理] 菜单，设置 key 为 url.spring-boot-admin 配置项。\n\n\n# 1.3 如何开启登录？\n\n生产环境下，建议 spring boot admin 开启“安全认证”的功能，避免出现安全事故。\n\n由于项目本身已经使用 spring security 做安全认证，再额外配置 spring boot admin 的“安全认证”有点麻烦。我自己是拓展 spring security 解决，预计需要改 2-3 个类，不是很建议。\n\n那么怎么办呢？可以参考 《芋道 spring boot 监控工具 admin 入门》 文档，额外搭建一个 spring boot admin 进程，然后项目接入它使用！\n\n\n# 2. skywalking\n\n阅读 《芋道 skywalking 极简入门》 文章，入门 skywalking。\n\n注意，skywalking 需要单独启动，预计需要 4 核 8g 的硬件资源。\n\n\n# 2.1 如何配置？\n\n① 在 logback-spring.xml 配置文件中，添加 skywalking 收集日志的 appender 配置。如下图所示：\n\n\n\n② 修改 skywalking 在前端项目的 [基础设施 -> 监控中心 -> 链路追踪] 对应的 skywaling/index.vue 文件，调整为你 skywalking 的访问地址。如下图所示：\n\n\n\n\n# 2.2 如何使用？\n\n① 点击 [基础设施 -> 监控中心 -> 链路追踪] 菜单，可以看到 skywalking 提供的链路追踪。如下图所示：\n\n\n\n② 点击 yudao-server 服务，查看该服务的监控信息。如下图所示：\n\n\n\n补充说明：\n\n前端 [基础设施 -> 监控中心 -> 链路追踪] 菜单，通过 iframe 内嵌 http://skywalking.iocoder.cn 路径。\n\n如果你想自定义地址，可以前往 [基础设置 -> 配置管理] 菜单，设置 key 为 url.skywalking 配置项。\n\n\n# 3. 更多监控系统\n\n\n# 3.1 prometheus\n\n参见 《芋道 prometheus + grafana + alertmanager 极简入门 》 文章。\n\n\n# 3.2 elk\n\n参见 芋道 elk(elasticsearch + logstash + kibana) 极简入门 文章。\n\n\n# 3.3 sentry\n\n参见 《sentry 极简入门 》 文章。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "Icon 图标",
            frontmatter: {
                title: "Icon 图标",
                date: "2023-01-01T00:02:05.000Z",
                permalink: "/vue3/icon"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/21.%E5%89%8D%E7%AB%AF%E6%89%8B%E5%86%8C%20Vue%203.x/03.Icon%20%E5%9B%BE%E6%A0%87.html",
            relativePath: "01.开发指南/21.前端手册 Vue 3.x/03.Icon 图标.md",
            key: "v-191f91c3",
            path: "/vue3/icon/",
            headers: [{
                level: 2,
                title: "1. Icon 图标组件",
                slug: "_1-icon-图标组件",
                normalizedTitle: "1. icon 图标组件",
                charIndex: 134
            }, {
                level: 3,
                title: "1.1 基本用法",
                slug: "_1-1-基本用法",
                normalizedTitle: "1.1 基本用法",
                charIndex: 369
            }, {
                level: 3,
                title: "1.2 useIcon",
                slug: "_1-2-useicon",
                normalizedTitle: "1.2 useicon",
                charIndex: 571
            }, {
                level: 2,
                title: "2. 自定义图标",
                slug: "_2-自定义图标",
                normalizedTitle: "2. 自定义图标",
                charIndex: 1035
            }],
            headersStr: "1. Icon 图标组件 1.1 基本用法 1.2 useIcon 2. 自定义图标",
            content: 'Element Plus 内置多种 Icon 图标，可参考 Element Plus —— Icon 图标 的文档。\n\n在项目的 /src/assets/svgs 目录下，自定义了 Icon 图标，默认注册到全局中，可以在项目中任意地方使用。如下图所示：\n\n\n\n\n# 1. Icon 图标组件\n\n友情提示：\n\n该小节，基于 《vue element plus admin —— Icon 图标组件 》 的内容修改。\n\nIcon 组件位于 src/components/Icon 内，用于项目内组件的展示，基本支持所有图标库（支持按需加载，只打包所用到的图标），支持使用本地 svg 和 Iconify 图标。\n\n提示\n\n在 Iconify 上，你可以查询到你想要的所有图标并使用，不管是不是 element-plus 的图标库。\n\n\n# 1.1 基本用法\n\n如果以 svg-icon: 开头，则会在本地中找到该 svg 图标，否则，会加载 Iconify 图标。代码如下：\n\n<template>\n  \x3c!-- 加载本地 svg --\x3e\n  <Icon icon="svg-icon:peoples" />\n  \n  \x3c!-- 加载 Iconify --\x3e\n  <Icon icon="ep:aim" />\n</template>\n\n\n\n# 1.2 useIcon\n\n如果需要在其他组件中如 ElButton 传入 icon 属性，可以使用 useIcon。代码如下：\n\n<script setup lang="ts">\nimport { useIcon } from \'@/hooks/web/useIcon\'\nimport { ElButton } from \'element-plus\'\n\nconst icon = useIcon({ icon: \'svg-icon:save\' })\n<\/script>\n\n<template>\n  <ElButton :icon="icon"> button </ElButton>\n</template>\n\n\nuseIcon 的 props 属性如下：\n\n属性      说明     类型       可选值   默认值\nicon    图标名    string   -     -\ncolor   图标颜色   string   -     -\nsize    图标大小   number   -     16\n\n\n# 2. 自定义图标\n\n① 访问 https://www.iconfont.cn/ 地址，搜索你想要的图标，下载 SVG 格式。如下图所示：\n\n友情提示：其它 SVG 图标网站也可以。\n\n\n\n② 将 SVG 图标添加到 /src/assets/svgs 目录下，然后进行使用。\n\n<Icon icon="svg-icon:helpless" />\n',
            normalizedContent: 'element plus 内置多种 icon 图标，可参考 element plus —— icon 图标 的文档。\n\n在项目的 /src/assets/svgs 目录下，自定义了 icon 图标，默认注册到全局中，可以在项目中任意地方使用。如下图所示：\n\n\n\n\n# 1. icon 图标组件\n\n友情提示：\n\n该小节，基于 《vue element plus admin —— icon 图标组件 》 的内容修改。\n\nicon 组件位于 src/components/icon 内，用于项目内组件的展示，基本支持所有图标库（支持按需加载，只打包所用到的图标），支持使用本地 svg 和 iconify 图标。\n\n提示\n\n在 iconify 上，你可以查询到你想要的所有图标并使用，不管是不是 element-plus 的图标库。\n\n\n# 1.1 基本用法\n\n如果以 svg-icon: 开头，则会在本地中找到该 svg 图标，否则，会加载 iconify 图标。代码如下：\n\n<template>\n  \x3c!-- 加载本地 svg --\x3e\n  <icon icon="svg-icon:peoples" />\n  \n  \x3c!-- 加载 iconify --\x3e\n  <icon icon="ep:aim" />\n</template>\n\n\n\n# 1.2 useicon\n\n如果需要在其他组件中如 elbutton 传入 icon 属性，可以使用 useicon。代码如下：\n\n<script setup lang="ts">\nimport { useicon } from \'@/hooks/web/useicon\'\nimport { elbutton } from \'element-plus\'\n\nconst icon = useicon({ icon: \'svg-icon:save\' })\n<\/script>\n\n<template>\n  <elbutton :icon="icon"> button </elbutton>\n</template>\n\n\nuseicon 的 props 属性如下：\n\n属性      说明     类型       可选值   默认值\nicon    图标名    string   -     -\ncolor   图标颜色   string   -     -\nsize    图标大小   number   -     16\n\n\n# 2. 自定义图标\n\n① 访问 https://www.iconfont.cn/ 地址，搜索你想要的图标，下载 svg 格式。如下图所示：\n\n友情提示：其它 svg 图标网站也可以。\n\n\n\n② 将 svg 图标添加到 /src/assets/svgs 目录下，然后进行使用。\n\n<icon icon="svg-icon:helpless" />\n',
            charsets: {
                cjk: !0
            }
        }, {
            title: "通用方法",
            frontmatter: {
                title: "通用方法",
                date: "2023-01-01T10:07:50.000Z",
                permalink: "/vue3/util"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/21.%E5%89%8D%E7%AB%AF%E6%89%8B%E5%86%8C%20Vue%203.x/06.%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95.html",
            relativePath: "01.开发指南/21.前端手册 Vue 3.x/06.通用方法.md",
            key: "v-6f969d4f",
            path: "/vue3/util/",
            headers: [{
                level: 2,
                title: "1. 缓存配置",
                slug: "_1-缓存配置",
                normalizedTitle: "1. 缓存配置",
                charIndex: 21
            }, {
                level: 3,
                title: "1.1 说明",
                slug: "_1-1-说明",
                normalizedTitle: "1.1 说明",
                charIndex: 95
            }, {
                level: 3,
                title: "1.2 示例",
                slug: "_1-2-示例",
                normalizedTitle: "1.2 示例",
                charIndex: 569
            }, {
                level: 2,
                title: "2. message 对象",
                slug: "_2-message-对象",
                normalizedTitle: "2. message 对象",
                charIndex: 582
            }, {
                level: 3,
                title: "2.1 说明",
                slug: "_2-1-说明",
                normalizedTitle: "2.1 说明",
                charIndex: 600
            }, {
                level: 3,
                title: "2.2 示例",
                slug: "_2-2-示例",
                normalizedTitle: "2.2 示例",
                charIndex: 726
            }, {
                level: 2,
                title: "3. download 对象",
                slug: "_3-download-对象",
                normalizedTitle: "3. download 对象",
                charIndex: 739
            }, {
                level: 3,
                title: "3.1 说明",
                slug: "_3-1-说明",
                normalizedTitle: "3.1 说明",
                charIndex: 758
            }, {
                level: 3,
                title: "3.2 示例",
                slug: "_3-2-示例",
                normalizedTitle: "3.2 示例",
                charIndex: 838
            }],
            headersStr: "1. 缓存配置 1.1 说明 1.2 示例 2. message 对象 2.1 说明 2.2 示例 3. download 对象 3.1 说明 3.2 示例",
            content: "本小节，分享前端项目的常用方法。\n\n\n# 1. 缓存配置\n\n友情提示：\n\n该小节，基于 《vue element plus admin —— 项目配置「缓存配置 」》 的内容修改。\n\n\n# 1.1 说明\n\n在项目中，你可以看到很多地方都使用了 wsCache.set 或者 wsCache.get，这是基于 web-storage-cache 进行封装，采用 hook 的形式。\n\n该插件对HTML5 localStorage 和 sessionStorage 进行了扩展，添加了超时时间，序列化方法。可以直接存储 json 对象，同时可以非常简单的进行超时时间的设置。\n\n本项目默认是采用 sessionStorage 的存储方式，如果更改，可以直接在 useCache.ts 中把 type: CacheType = 'sessionStorage' 改为 type: CacheType = 'localStorage'，这样项目中的所有用到的地方，都会变成该方式进行数据存储。\n\n如果只想单个更改，可以传入存储类型 const { wsCache } = useCache('localStorage')，既可只适用当前存储对象。\n\n注意：\n\n更改完默认存储方式后，需要清除浏览器缓存并重新登录，以免造成不可描述的问题。\n\n\n# 1.2 示例\n\n\n\n\n# 2. message 对象\n\n\n# 2.1 说明\n\nmessage 对象，由 src/hooks/web/useMessage.ts 实现，基于 ElMessage、ElMessageBox、ElNotification 封装，用于做消息提示、通知提示、对话框提醒、二次确认等。\n\n\n# 2.2 示例\n\n\n\n\n# 3. download 对象\n\n\n# 3.1 说明\n\n$download 对象，由 util/download.ts 实现，用于 Excel、Word、Zip、HTML 等类型的文件下载。\n\n\n# 3.2 示例\n\n",
            normalizedContent: "本小节，分享前端项目的常用方法。\n\n\n# 1. 缓存配置\n\n友情提示：\n\n该小节，基于 《vue element plus admin —— 项目配置「缓存配置 」》 的内容修改。\n\n\n# 1.1 说明\n\n在项目中，你可以看到很多地方都使用了 wscache.set 或者 wscache.get，这是基于 web-storage-cache 进行封装，采用 hook 的形式。\n\n该插件对html5 localstorage 和 sessionstorage 进行了扩展，添加了超时时间，序列化方法。可以直接存储 json 对象，同时可以非常简单的进行超时时间的设置。\n\n本项目默认是采用 sessionstorage 的存储方式，如果更改，可以直接在 usecache.ts 中把 type: cachetype = 'sessionstorage' 改为 type: cachetype = 'localstorage'，这样项目中的所有用到的地方，都会变成该方式进行数据存储。\n\n如果只想单个更改，可以传入存储类型 const { wscache } = usecache('localstorage')，既可只适用当前存储对象。\n\n注意：\n\n更改完默认存储方式后，需要清除浏览器缓存并重新登录，以免造成不可描述的问题。\n\n\n# 1.2 示例\n\n\n\n\n# 2. message 对象\n\n\n# 2.1 说明\n\nmessage 对象，由 src/hooks/web/usemessage.ts 实现，基于 elmessage、elmessagebox、elnotification 封装，用于做消息提示、通知提示、对话框提醒、二次确认等。\n\n\n# 2.2 示例\n\n\n\n\n# 3. download 对象\n\n\n# 3.1 说明\n\n$download 对象，由 util/download.ts 实现，用于 excel、word、zip、html 等类型的文件下载。\n\n\n# 3.2 示例\n\n",
            charsets: {
                cjk: !0
            }
        }, {
            title: "字典数据",
            frontmatter: {
                title: "字典数据",
                date: "2022-04-17T22:48:10.000Z",
                permalink: "/vue3/dict"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/21.%E5%89%8D%E7%AB%AF%E6%89%8B%E5%86%8C%20Vue%203.x/04.%E5%AD%97%E5%85%B8%E6%95%B0%E6%8D%AE.html",
            relativePath: "01.开发指南/21.前端手册 Vue 3.x/04.字典数据.md",
            key: "v-6707f78a",
            path: "/vue3/dict/",
            headers: [{
                level: 2,
                title: "1. 全局缓存",
                slug: "_1-全局缓存",
                normalizedTitle: "1. 全局缓存",
                charIndex: 72
            }, {
                level: 2,
                title: "2. DICT_TYPE",
                slug: "_2-dict-type",
                normalizedTitle: "2. dict_type",
                charIndex: 209
            }, {
                level: 2,
                title: "3. DictTag 字典标签",
                slug: "_3-dicttag-字典标签",
                normalizedTitle: "3. dicttag 字典标签",
                charIndex: 300
            }, {
                level: 2,
                title: "4. 字典工具类",
                slug: "_4-字典工具类",
                normalizedTitle: "4. 字典工具类",
                charIndex: 605
            }],
            headersStr: "1. 全局缓存 2. DICT_TYPE 3. DictTag 字典标签 4. 字典工具类",
            content: '本小节，讲解前端如何使用 [系统管理 -> 字典管理] 菜单的字典数据，例如说字典数据的下拉框、单选 / 多选按钮、高亮展示等等。\n\n\n\n\n# 1. 全局缓存\n\n用户登录成功后，前端会从后端获取到全量的字典数据，缓存在 store 中。如下图所示：\n\n\n\n这样，前端在使用到字典数据时，无需重复请求后端，提升用户体验。\n\n不过，缓存暂时未提供刷新，所以在字典数据发生变化时，需要用户刷新浏览器，进行重新加载。\n\n\n# 2. DICT_TYPE\n\n在 dict.ts 文件中，使用 DICT_TYPE 枚举了字典的 KEY。如下图所示：\n\n\n\n后续如果有新的字典 KEY，需要你自己进行添加。\n\n\n# 3. DictTag 字典标签\n\n<dict-tag /> 组件，翻译字段对应的字典展示文本，并根据 colorType、cssClass 进行高亮。使用示例如下：\n\n\x3c!--\n    type: 字典 KEY\n    value: 字典值\n--\x3e\n<dict-tag :type="DICT_TYPE.SYSTEM_LOGIN_TYPE" :value="row.logType" />\n\n\n\n\n【推荐】注意，一般情况下使用 CRUD schemas 方式，不需要直接使用 <dict-tag />，而是通过 columns 的 dictType 和 dictClass 属性即可。如下图所示：\n\n\n\n\n# 4. 字典工具类\n\n在 dict.ts 文件中，提供了字典工具类，方法如下：\n\n// 获取 dictType 对应的数据字典数组【object】\nexport const getDictOptions = (dictType: string) => {{ /** 省略代码 */ }\n\n// 获取 dictType 对应的数据字典数组【int】\nexport const getIntDictOptions = (dictType: string) => { /** 省略代码 */ }\n\n// 获取 dictType 对应的数据字典数组【string】\nexport const getStrDictOptions = (dictType: string) => { /** 省略代码 */ }\n\n// 获取 dictType 对应的数据字典数组【boolean】\nexport const getBoolDictOptions = (dictType: string) => { /** 省略代码 */ }\n\n// 获取 dictType 对应的数据字典数组【object】\nexport const getDictObj = (dictType: string, value: any) => { /** 省略代码 */ }\n\n\n结合 Element Plus 的表单组件，使用示例如下：\n\n<template>\n  \x3c!-- radio 单选框 --\x3e\n  <el-radio \n    v-for="dict in getIntDictOptions(DICT_TYPE.COMMON_STATUS)"\n    :key="dict.value" \n    :label="parseInt(dict.value)"\n  >\n    {{dict.label}}\n  </el-radio>\n    \n  \x3c!-- select 下拉框 --\x3e\n  <el-select v-model="form.code" placeholder="请选择渠道编码" clearable>\n    <el-option \n      v-for="dict in getStrDictOptions(DICT_TYPE.SYSTEM_SMS_CHANNEL_CODE)"\n      :key="dict.value" \n      :label="dict.label" \n      :value="dict.value"\n    />\n  </el-select>\n</template>\n<script setup lang="tsx">\nimport { DICT_TYPE, getIntDictOptions, getStrDictOptions } from \'@/utils/dict\'\n<\/script>\n',
            normalizedContent: '本小节，讲解前端如何使用 [系统管理 -> 字典管理] 菜单的字典数据，例如说字典数据的下拉框、单选 / 多选按钮、高亮展示等等。\n\n\n\n\n# 1. 全局缓存\n\n用户登录成功后，前端会从后端获取到全量的字典数据，缓存在 store 中。如下图所示：\n\n\n\n这样，前端在使用到字典数据时，无需重复请求后端，提升用户体验。\n\n不过，缓存暂时未提供刷新，所以在字典数据发生变化时，需要用户刷新浏览器，进行重新加载。\n\n\n# 2. dict_type\n\n在 dict.ts 文件中，使用 dict_type 枚举了字典的 key。如下图所示：\n\n\n\n后续如果有新的字典 key，需要你自己进行添加。\n\n\n# 3. dicttag 字典标签\n\n<dict-tag /> 组件，翻译字段对应的字典展示文本，并根据 colortype、cssclass 进行高亮。使用示例如下：\n\n\x3c!--\n    type: 字典 key\n    value: 字典值\n--\x3e\n<dict-tag :type="dict_type.system_login_type" :value="row.logtype" />\n\n\n\n\n【推荐】注意，一般情况下使用 crud schemas 方式，不需要直接使用 <dict-tag />，而是通过 columns 的 dicttype 和 dictclass 属性即可。如下图所示：\n\n\n\n\n# 4. 字典工具类\n\n在 dict.ts 文件中，提供了字典工具类，方法如下：\n\n// 获取 dicttype 对应的数据字典数组【object】\nexport const getdictoptions = (dicttype: string) => {{ /** 省略代码 */ }\n\n// 获取 dicttype 对应的数据字典数组【int】\nexport const getintdictoptions = (dicttype: string) => { /** 省略代码 */ }\n\n// 获取 dicttype 对应的数据字典数组【string】\nexport const getstrdictoptions = (dicttype: string) => { /** 省略代码 */ }\n\n// 获取 dicttype 对应的数据字典数组【boolean】\nexport const getbooldictoptions = (dicttype: string) => { /** 省略代码 */ }\n\n// 获取 dicttype 对应的数据字典数组【object】\nexport const getdictobj = (dicttype: string, value: any) => { /** 省略代码 */ }\n\n\n结合 element plus 的表单组件，使用示例如下：\n\n<template>\n  \x3c!-- radio 单选框 --\x3e\n  <el-radio \n    v-for="dict in getintdictoptions(dict_type.common_status)"\n    :key="dict.value" \n    :label="parseint(dict.value)"\n  >\n    {{dict.label}}\n  </el-radio>\n    \n  \x3c!-- select 下拉框 --\x3e\n  <el-select v-model="form.code" placeholder="请选择渠道编码" clearable>\n    <el-option \n      v-for="dict in getstrdictoptions(dict_type.system_sms_channel_code)"\n      :key="dict.value" \n      :label="dict.label" \n      :value="dict.value"\n    />\n  </el-select>\n</template>\n<script setup lang="tsx">\nimport { dict_type, getintdictoptions, getstrdictoptions } from \'@/utils/dict\'\n<\/script>\n',
            charsets: {
                cjk: !0
            }
        }, {
            title: "系统组件",
            frontmatter: {
                title: "系统组件",
                date: "2022-12-31T22:18:12.000Z",
                permalink: "/vue3/components"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/21.%E5%89%8D%E7%AB%AF%E6%89%8B%E5%86%8C%20Vue%203.x/05.%E7%B3%BB%E7%BB%9F%E7%BB%84%E4%BB%B6.html",
            relativePath: "01.开发指南/21.前端手册 Vue 3.x/05.系统组件.md",
            key: "v-63425dba",
            path: "/vue3/components/",
            headers: [{
                level: 2,
                title: "1. 常用组件",
                slug: "_1-常用组件",
                normalizedTitle: "1. 常用组件",
                charIndex: 2
            }, {
                level: 3,
                title: "1.1 Editor 富文本组件",
                slug: "_1-1-editor-富文本组件",
                normalizedTitle: "1.1 editor 富文本组件",
                charIndex: 14
            }, {
                level: 3,
                title: "1.2 Dialog 弹窗组件",
                slug: "_1-2-dialog-弹窗组件",
                normalizedTitle: "1.2 dialog 弹窗组件",
                charIndex: 195
            }, {
                level: 3,
                title: "1.3 ContentWrap 包裹组件",
                slug: "_1-3-contentwrap-包裹组件",
                normalizedTitle: "1.3 contentwrap 包裹组件",
                charIndex: 405
            }, {
                level: 3,
                title: "1.4 Pagination 分页组件",
                slug: "_1-4-pagination-分页组件",
                normalizedTitle: "1.4 pagination 分页组件",
                charIndex: 563
            }, {
                level: 3,
                title: "1.5 UploadFile 上传文件组件",
                slug: "_1-5-uploadfile-上传文件组件",
                normalizedTitle: "1.5 uploadfile 上传文件组件",
                charIndex: 714
            }, {
                level: 3,
                title: "1.6 UploadImg 上传图片组件",
                slug: "_1-6-uploadimg-上传图片组件",
                normalizedTitle: "1.6 uploadimg 上传图片组件",
                charIndex: 861
            }, {
                level: 2,
                title: "2. 不常用组件",
                slug: "_2-不常用组件",
                normalizedTitle: "2. 不常用组件",
                charIndex: 1050
            }, {
                level: 3,
                title: "2.1 EChart 图表组件",
                slug: "_2-1-echart-图表组件",
                normalizedTitle: "2.1 echart 图表组件",
                charIndex: 1063
            }, {
                level: 3,
                title: "2.2 InputPassword 密码输入框",
                slug: "_2-2-inputpassword-密码输入框",
                normalizedTitle: "2.2 inputpassword 密码输入框",
                charIndex: 1256
            }, {
                level: 3,
                title: "2.3 ContentDetailWrap 详情包裹组件",
                slug: "_2-3-contentdetailwrap-详情包裹组件",
                normalizedTitle: "2.3 contentdetailwrap 详情包裹组件",
                charIndex: 1486
            }, {
                level: 3,
                title: "2.4 ImageViewer 图片预览组件",
                slug: "_2-4-imageviewer-图片预览组件",
                normalizedTitle: "2.4 imageviewer 图片预览组件",
                charIndex: 1680
            }, {
                level: 3,
                title: "2.5 Qrcode 二维码组件",
                slug: "_2-5-qrcode-二维码组件",
                normalizedTitle: "2.5 qrcode 二维码组件",
                charIndex: 1880
            }, {
                level: 3,
                title: "2.6 Highlight 高亮组件",
                slug: "_2-6-highlight-高亮组件",
                normalizedTitle: "2.6 highlight 高亮组件",
                charIndex: 2027
            }, {
                level: 3,
                title: "2.7 Error 缺省组件",
                slug: "_2-7-error-缺省组件",
                normalizedTitle: "2.7 error 缺省组件",
                charIndex: 2329
            }, {
                level: 3,
                title: "2.8 Sticky 黏性组件",
                slug: "_2-8-sticky-黏性组件",
                normalizedTitle: "2.8 sticky 黏性组件",
                charIndex: 2508
            }, {
                level: 3,
                title: "2.9 CountTo 数字动画组件",
                slug: "_2-9-countto-数字动画组件",
                normalizedTitle: "2.9 countto 数字动画组件",
                charIndex: 2640
            }, {
                level: 3,
                title: "2.10 useWatermark 水印组件",
                slug: "_2-10-usewatermark-水印组件",
                normalizedTitle: "2.10 usewatermark 水印组件",
                charIndex: 2777
            }, {
                level: 3,
                title: "2.11 form-create 动态表单生成器",
                slug: "_2-11-form-create-动态表单生成器",
                normalizedTitle: "2.11 form-create 动态表单生成器",
                charIndex: 2940
            }, {
                level: 3,
                title: "2.12 bpmn-js 工作流组件",
                slug: "_2-12-bpmn-js-工作流组件",
                normalizedTitle: "2.12 bpmn-js 工作流组件",
                charIndex: 3116
            }, {
                level: 2,
                title: "3. 组件注册",
                slug: "_3-组件注册",
                normalizedTitle: "3. 组件注册",
                charIndex: 3586
            }, {
                level: 3,
                title: "3.1 按需引入",
                slug: "_3-1-按需引入",
                normalizedTitle: "3.1 按需引入",
                charIndex: 3679
            }, {
                level: 3,
                title: "3.2 全局注册",
                slug: "_3-2-全局注册",
                normalizedTitle: "3.2 全局注册",
                charIndex: 4163
            }],
            headersStr: "1. 常用组件 1.1 Editor 富文本组件 1.2 Dialog 弹窗组件 1.3 ContentWrap 包裹组件 1.4 Pagination 分页组件 1.5 UploadFile 上传文件组件 1.6 UploadImg 上传图片组件 2. 不常用组件 2.1 EChart 图表组件 2.2 InputPassword 密码输入框 2.3 ContentDetailWrap 详情包裹组件 2.4 ImageViewer 图片预览组件 2.5 Qrcode 二维码组件 2.6 Highlight 高亮组件 2.7 Error 缺省组件 2.8 Sticky 黏性组件 2.9 CountTo 数字动画组件 2.10 useWatermark 水印组件 2.11 form-create 动态表单生成器 2.12 bpmn-js 工作流组件 3. 组件注册 3.1 按需引入 3.2 全局注册",
            content: "# 1. 常用组件\n\n\n# 1.1 Editor 富文本组件\n\n基于 wangEditor 封装\n\n * Editor 组件：位于 src/components/Editor 内\n * 详细文档：vue-element-plus-admin-doc/components/editor.html\n * 实战案例：src/views/system/notice/form.vue\n\n\n\n\n# 1.2 Dialog 弹窗组件\n\n对 Element Plus 的 Dialog 组件进行封装，支持最大化、最大高度等特性\n\n * Dialog 组件：位于 src/components/Dialog 内\n * 详细文档：vue-element-plus-admin-doc/components/dialog.html\n * 实战案例：src/views/system/dept/DeptForm.vue\n\n\n\n\n# 1.3 ContentWrap 包裹组件\n\n对 Element Plus 的 ElCard 组件进行封装，自带标题、边距\n\n * ContentWrap 组件：位于 src/components/ContentWrap 内\n * 实战案例：src/views/system/post/index.vue\n\n\n\n\n# 1.4 Pagination 分页组件\n\n对 Element Plus 的 Pagination 组件进行封装\n\n * Pagination 组件：位于 src/components/Pagination 内\n * 实战案例：src/views/system/post/index.vue\n\n\n\n\n# 1.5 UploadFile 上传文件组件\n\n对 Element Plus 的 Upload 组件进行封装，上传文件到文件服务\n\n * UploadFile 组件：位于 src/components/UploadFile/src/UploadFile.vue 内\n * 实战案例：暂无\n\n\n# 1.6 UploadImg 上传图片组件\n\n对 Element Plus 的 Upload 组件进行封装，上传图片到文件服务\n\n * UploadImg 组件：位于 src/components/UploadFile/src/UploadImg.vue 内\n * 实战案例：src/views/system/oauth2/client/ClientForm.vue\n\n\n\n\n# 2. 不常用组件\n\n\n# 2.1 EChart 图表组件\n\n基于 Apache ECharts 封装，自适应窗口大小\n\n * EChart 组件：位于 src/components/EChart 内\n * 详细文档：vue-element-plus-admin-doc/components/echart.html\n * 实战案例：src/views/mp/statistics/index.vue\n\n\n\n\n# 2.2 InputPassword 密码输入框\n\n对 Element Plus 的 Input 组件进行封装\n\n * InputPassword 组件：位于 src/components/InputPassword 内\n * 详细文档：vue-element-plus-admin-doc/components/input-password.html\n * 实战案例：src/views/Profile/components/ResetPwd.vue\n\n\n# 2.3 ContentDetailWrap 详情包裹组件\n\n用于展示详情，自带返回按钮。\n\n * ContentDetailWrap 组件：位于 src/components/ContentDetailWrap 内\n * 详细文档：vue-element-plus-admin-doc/components/content-detail-wrap.html\n * 实战案例：暂无\n\n\n# 2.4 ImageViewer 图片预览组件\n\n将 Element Plus 的 ImageViewer 组件函数化，通过函数方便创建组件\n\n * ImageViewer 组件：位于 src/components/ImageViewer 内\n * 详细文档：vue-element-plus-admin-doc/components/image-viewer.html\n * 实战案例：暂无\n\n\n# 2.5 Qrcode 二维码组件\n\n基于 qrcode 封装\n\n * Qrcode 组件：位于 src/components/Qrcode 内\n * 详细文档：vue-element-plus-admin-doc/components/qrcode.html\n * 实战案例：暂无\n\n\n\n\n# 2.6 Highlight 高亮组件\n\n * Highlight 组件：位于 src/components/Highlight 内\n * 详细文档：vue-element-plus-admin-doc/components/highlight.html\n * 实战案例：暂无\n\n\n\n# 2.6.1 Infotip 信息提示组件\n\n基于 Highlight 组件封装\n\n * Infotip 组件：位于 src/components/Infotip 内\n * 详细文档：vue-element-plus-admin-doc/components/infotip.html\n * 实战案例：暂无\n\n\n\n\n# 2.7 Error 缺省组件\n\n用于各种占位图组件，如 404、403、500 等错误页面。\n\n * Error 组件：位于 src/components/Error 内\n * 详细文档：vue-element-plus-admin-doc/components/error.html\n * 实战案例：403.vue、404.vue、500.vue\n\n\n# 2.8 Sticky 黏性组件\n\n * Sticky 组件：位于 src/components/Sticky 内\n * 详细文档：vue-element-plus-admin-doc/components/sticky.html\n * 实战案例：暂无\n\n\n\n\n# 2.9 CountTo 数字动画组件\n\n * CountTo 组件：位于 src/components/CountTo 内\n * 详细文档：vue-element-plus-admin-doc/components/count-to.html\n * 实战案例：暂无\n\n\n# 2.10 useWatermark 水印组件\n\n为元素设置水印\n\n * useWatermark 组件：位于 src/hooks/web/useWatermark.ts 内\n * 详细文档：vue-element-plus-admin-doc/hooks/useWatermark.html\n * 实战案例：暂无\n\n\n\n\n# 2.11 form-create 动态表单生成器\n\n详细文档：http://www.form-create.com/\n\n① 实战案例 - 表单设计：src/views/infra/build/index.vue\n\n\n\n② 实战案例 - 表单展示：src/views/bpm/processInstance/detail/index.vue\n\n\n\n\n# 2.12 bpmn-js 工作流组件\n\n核心是基于 bpmn-js 封装\n\n# 2.12.1 MyProcessDesigner 流程设计组件\n\n * MyProcessDesigner 组件：位于 src/components/bpmnProcessDesigner/package/designer/index.ts 内，基于 https://gitee.com/MiyueSC/bpmn-process-designer 项目适配\n * 实战案例：src/views/bpm/model/editor/index.vue\n\n\n\n# 2.12.2 MyProcessViewer 流程展示组件\n\n * MyProcessViewer 组件：位于 src/components/bpmnProcessDesigner/package/designer/index2.ts 内\n * 实战案例：src/views/bpm/processInstance/detail/ProcessInstanceBpmnViewer.vue\n\n\n\n\n# 3. 组件注册\n\n友情提示：\n\n该小节，基于 《vue element plus admin —— 组件注册 》 的内容修改。\n\n组件注册可以分成两种类型：按需引入、全局注册。\n\n\n# 3.1 按需引入\n\n项目目前的组件注册机制是按需注册，是在需要用到的页面才引入。\n\n<script setup lang=\"ts\">\nimport { ElBacktop } from 'element-plus'\nimport { useDesign } from '@/hooks/web/useDesign'\n\nconst { getPrefixCls, variables } = useDesign()\n\nconst prefixCls = getPrefixCls('backtop')\n<\/script>\n\n<template>\n  <ElBacktop\n    :class=\"`${prefixCls}-backtop`\"\n    :target=\"`.${variables.namespace}-layout-content-scrollbar .${variables.elNamespace}-scrollbar__wrap`\"\n  />\n</template>\n\n\n注意：tsx 文件内不能使用全局注册组件，需要手动引入组件使用。\n\n\n# 3.2 全局注册\n\n如果觉得按需引入太麻烦，可以进行全局注册，在 src/components/index.ts，添加需要注册的组件。\n\n以 Icon 组件进行了全局注册，举个例子：\n\nimport type { App } from 'vue'\nimport { Icon } from './Icon'\n\nexport const setupGlobCom = (app: App<Element>): void => {\n  app.component('Icon', Icon)\n}\n\n\n如果 Element Plus 的组件需要全局注册，在 src/plugins/elementPlus/index.ts 添加需要注册的组件。\n\n以 Element Plus 中只有 ElLoading 与 ElScrollbar 进行全局注册，举个例子：\n\nimport type { App } from 'vue'\n\n// 需要全局引入一些组件，如 ElScrollbar，不然一些下拉项样式有问题\nimport { ElLoading, ElScrollbar } from 'element-plus'\n\nconst plugins = [ElLoading]\n\nconst components = [ElScrollbar]\n\nexport const setupElementPlus = (app: App) => {\n  plugins.forEach((plugin) => {\n    app.use(plugin)\n  })\n\n  components.forEach((component) => {\n    app.component(component.name, component)\n  })\n}\n",
            normalizedContent: "# 1. 常用组件\n\n\n# 1.1 editor 富文本组件\n\n基于 wangeditor 封装\n\n * editor 组件：位于 src/components/editor 内\n * 详细文档：vue-element-plus-admin-doc/components/editor.html\n * 实战案例：src/views/system/notice/form.vue\n\n\n\n\n# 1.2 dialog 弹窗组件\n\n对 element plus 的 dialog 组件进行封装，支持最大化、最大高度等特性\n\n * dialog 组件：位于 src/components/dialog 内\n * 详细文档：vue-element-plus-admin-doc/components/dialog.html\n * 实战案例：src/views/system/dept/deptform.vue\n\n\n\n\n# 1.3 contentwrap 包裹组件\n\n对 element plus 的 elcard 组件进行封装，自带标题、边距\n\n * contentwrap 组件：位于 src/components/contentwrap 内\n * 实战案例：src/views/system/post/index.vue\n\n\n\n\n# 1.4 pagination 分页组件\n\n对 element plus 的 pagination 组件进行封装\n\n * pagination 组件：位于 src/components/pagination 内\n * 实战案例：src/views/system/post/index.vue\n\n\n\n\n# 1.5 uploadfile 上传文件组件\n\n对 element plus 的 upload 组件进行封装，上传文件到文件服务\n\n * uploadfile 组件：位于 src/components/uploadfile/src/uploadfile.vue 内\n * 实战案例：暂无\n\n\n# 1.6 uploadimg 上传图片组件\n\n对 element plus 的 upload 组件进行封装，上传图片到文件服务\n\n * uploadimg 组件：位于 src/components/uploadfile/src/uploadimg.vue 内\n * 实战案例：src/views/system/oauth2/client/clientform.vue\n\n\n\n\n# 2. 不常用组件\n\n\n# 2.1 echart 图表组件\n\n基于 apache echarts 封装，自适应窗口大小\n\n * echart 组件：位于 src/components/echart 内\n * 详细文档：vue-element-plus-admin-doc/components/echart.html\n * 实战案例：src/views/mp/statistics/index.vue\n\n\n\n\n# 2.2 inputpassword 密码输入框\n\n对 element plus 的 input 组件进行封装\n\n * inputpassword 组件：位于 src/components/inputpassword 内\n * 详细文档：vue-element-plus-admin-doc/components/input-password.html\n * 实战案例：src/views/profile/components/resetpwd.vue\n\n\n# 2.3 contentdetailwrap 详情包裹组件\n\n用于展示详情，自带返回按钮。\n\n * contentdetailwrap 组件：位于 src/components/contentdetailwrap 内\n * 详细文档：vue-element-plus-admin-doc/components/content-detail-wrap.html\n * 实战案例：暂无\n\n\n# 2.4 imageviewer 图片预览组件\n\n将 element plus 的 imageviewer 组件函数化，通过函数方便创建组件\n\n * imageviewer 组件：位于 src/components/imageviewer 内\n * 详细文档：vue-element-plus-admin-doc/components/image-viewer.html\n * 实战案例：暂无\n\n\n# 2.5 qrcode 二维码组件\n\n基于 qrcode 封装\n\n * qrcode 组件：位于 src/components/qrcode 内\n * 详细文档：vue-element-plus-admin-doc/components/qrcode.html\n * 实战案例：暂无\n\n\n\n\n# 2.6 highlight 高亮组件\n\n * highlight 组件：位于 src/components/highlight 内\n * 详细文档：vue-element-plus-admin-doc/components/highlight.html\n * 实战案例：暂无\n\n\n\n# 2.6.1 infotip 信息提示组件\n\n基于 highlight 组件封装\n\n * infotip 组件：位于 src/components/infotip 内\n * 详细文档：vue-element-plus-admin-doc/components/infotip.html\n * 实战案例：暂无\n\n\n\n\n# 2.7 error 缺省组件\n\n用于各种占位图组件，如 404、403、500 等错误页面。\n\n * error 组件：位于 src/components/error 内\n * 详细文档：vue-element-plus-admin-doc/components/error.html\n * 实战案例：403.vue、404.vue、500.vue\n\n\n# 2.8 sticky 黏性组件\n\n * sticky 组件：位于 src/components/sticky 内\n * 详细文档：vue-element-plus-admin-doc/components/sticky.html\n * 实战案例：暂无\n\n\n\n\n# 2.9 countto 数字动画组件\n\n * countto 组件：位于 src/components/countto 内\n * 详细文档：vue-element-plus-admin-doc/components/count-to.html\n * 实战案例：暂无\n\n\n# 2.10 usewatermark 水印组件\n\n为元素设置水印\n\n * usewatermark 组件：位于 src/hooks/web/usewatermark.ts 内\n * 详细文档：vue-element-plus-admin-doc/hooks/usewatermark.html\n * 实战案例：暂无\n\n\n\n\n# 2.11 form-create 动态表单生成器\n\n详细文档：http://www.form-create.com/\n\n① 实战案例 - 表单设计：src/views/infra/build/index.vue\n\n\n\n② 实战案例 - 表单展示：src/views/bpm/processinstance/detail/index.vue\n\n\n\n\n# 2.12 bpmn-js 工作流组件\n\n核心是基于 bpmn-js 封装\n\n# 2.12.1 myprocessdesigner 流程设计组件\n\n * myprocessdesigner 组件：位于 src/components/bpmnprocessdesigner/package/designer/index.ts 内，基于 https://gitee.com/miyuesc/bpmn-process-designer 项目适配\n * 实战案例：src/views/bpm/model/editor/index.vue\n\n\n\n# 2.12.2 myprocessviewer 流程展示组件\n\n * myprocessviewer 组件：位于 src/components/bpmnprocessdesigner/package/designer/index2.ts 内\n * 实战案例：src/views/bpm/processinstance/detail/processinstancebpmnviewer.vue\n\n\n\n\n# 3. 组件注册\n\n友情提示：\n\n该小节，基于 《vue element plus admin —— 组件注册 》 的内容修改。\n\n组件注册可以分成两种类型：按需引入、全局注册。\n\n\n# 3.1 按需引入\n\n项目目前的组件注册机制是按需注册，是在需要用到的页面才引入。\n\n<script setup lang=\"ts\">\nimport { elbacktop } from 'element-plus'\nimport { usedesign } from '@/hooks/web/usedesign'\n\nconst { getprefixcls, variables } = usedesign()\n\nconst prefixcls = getprefixcls('backtop')\n<\/script>\n\n<template>\n  <elbacktop\n    :class=\"`${prefixcls}-backtop`\"\n    :target=\"`.${variables.namespace}-layout-content-scrollbar .${variables.elnamespace}-scrollbar__wrap`\"\n  />\n</template>\n\n\n注意：tsx 文件内不能使用全局注册组件，需要手动引入组件使用。\n\n\n# 3.2 全局注册\n\n如果觉得按需引入太麻烦，可以进行全局注册，在 src/components/index.ts，添加需要注册的组件。\n\n以 icon 组件进行了全局注册，举个例子：\n\nimport type { app } from 'vue'\nimport { icon } from './icon'\n\nexport const setupglobcom = (app: app<element>): void => {\n  app.component('icon', icon)\n}\n\n\n如果 element plus 的组件需要全局注册，在 src/plugins/elementplus/index.ts 添加需要注册的组件。\n\n以 element plus 中只有 elloading 与 elscrollbar 进行全局注册，举个例子：\n\nimport type { app } from 'vue'\n\n// 需要全局引入一些组件，如 elscrollbar，不然一些下拉项样式有问题\nimport { elloading, elscrollbar } from 'element-plus'\n\nconst plugins = [elloading]\n\nconst components = [elscrollbar]\n\nexport const setupelementplus = (app: app) => {\n  plugins.foreach((plugin) => {\n    app.use(plugin)\n  })\n\n  components.foreach((component) => {\n    app.component(component.name, component)\n  })\n}\n",
            charsets: {
                cjk: !0
            }
        }, {
            title: "配置读取",
            frontmatter: {
                title: "配置读取",
                date: "2023-04-07T23:52:23.000Z",
                permalink: "/vue3/config-center"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/21.%E5%89%8D%E7%AB%AF%E6%89%8B%E5%86%8C%20Vue%203.x/07.%E9%85%8D%E7%BD%AE%E8%AF%BB%E5%8F%96.html",
            relativePath: "01.开发指南/21.前端手册 Vue 3.x/07.配置读取.md",
            key: "v-b7a0fe8c",
            path: "/vue3/config-center/",
            headers: [{
                level: 2,
                title: "1. 读取配置",
                slug: "_1-读取配置",
                normalizedTitle: "1. 读取配置",
                charIndex: 75
            }, {
                level: 2,
                title: "2. 实战案例",
                slug: "_2-实战案例",
                normalizedTitle: "2. 实战案例",
                charIndex: 329
            }],
            headersStr: "1. 读取配置 2. 实战案例",
            content: "在 [基础设施 -> 配置管理] 菜单，可以动态修改配置，无需重启服务器即可生效。\n\n\n\n提示\n\n对应 《后端手册 —— 配置中心》 文档。\n\n\n# 1. 读取配置\n\n前端调用 /@api/infra/config/index.ts 的 #getConfigKey(configKey) 方法，获取指定 key 对应的配置的值。代码如下：\n\n// 根据参数键名查询参数值\nexport const getConfigKey = (configKey: string) => {\n    return request.get({ url: '/infra/config/get-value-by-key?key=' + configKey })\n}\n\n\n\n# 2. 实战案例\n\n在 src/views/infra/server/index.vue 页面中，获取 key 为 \"url.skywalking\" 的配置的值。代码如下：\n\n",
            normalizedContent: "在 [基础设施 -> 配置管理] 菜单，可以动态修改配置，无需重启服务器即可生效。\n\n\n\n提示\n\n对应 《后端手册 —— 配置中心》 文档。\n\n\n# 1. 读取配置\n\n前端调用 /@api/infra/config/index.ts 的 #getconfigkey(configkey) 方法，获取指定 key 对应的配置的值。代码如下：\n\n// 根据参数键名查询参数值\nexport const getconfigkey = (configkey: string) => {\n    return request.get({ url: '/infra/config/get-value-by-key?key=' + configkey })\n}\n\n\n\n# 2. 实战案例\n\n在 src/views/infra/server/index.vue 页面中，获取 key 为 \"url.skywalking\" 的配置的值。代码如下：\n\n",
            charsets: {
                cjk: !0
            }
        }, {
            title: "国际化",
            frontmatter: {
                title: "国际化",
                date: "2023-01-01T10:26:23.000Z",
                permalink: "/vue3/i18n"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/21.%E5%89%8D%E7%AB%AF%E6%89%8B%E5%86%8C%20Vue%203.x/09.%E5%9B%BD%E9%99%85%E5%8C%96.html",
            relativePath: "01.开发指南/21.前端手册 Vue 3.x/09.国际化.md",
            key: "v-f3732e0a",
            path: "/vue3/i18n/",
            headers: [{
                level: 2,
                title: "1. I18n-ally 插件",
                slug: "_1-i18n-ally-插件",
                normalizedTitle: "1. i18n-ally 插件",
                charIndex: 98
            }, {
                level: 2,
                title: "2. 配置默认语言",
                slug: "_2-配置默认语言",
                normalizedTitle: "2. 配置默认语言",
                charIndex: 148
            }, {
                level: 2,
                title: "3. 语言文件",
                slug: "_3-语言文件",
                normalizedTitle: "3. 语言文件",
                charIndex: 1700
            }, {
                level: 2,
                title: "4. 语言导入逻辑说明",
                slug: "_4-语言导入逻辑说明",
                normalizedTitle: "4. 语言导入逻辑说明",
                charIndex: 1778
            }, {
                level: 2,
                title: "5. 使用",
                slug: "_5-使用",
                normalizedTitle: "5. 使用",
                charIndex: 1928
            }, {
                level: 2,
                title: "6. 切换语言",
                slug: "_6-切换语言",
                normalizedTitle: "6. 切换语言",
                charIndex: 2088
            }, {
                level: 2,
                title: "7. 新增新语言",
                slug: "_7-新增新语言",
                normalizedTitle: "7. 新增新语言",
                charIndex: 2246
            }, {
                level: 3,
                title: "7.1 语言文件",
                slug: "_7-1-语言文件",
                normalizedTitle: "7.1 语言文件",
                charIndex: 2259
            }, {
                level: 3,
                title: "7.2 新增语言",
                slug: "_7-2-新增语言",
                normalizedTitle: "7.2 新增语言",
                charIndex: 2299
            }, {
                level: 2,
                title: "8. 远程读取语言数据",
                slug: "_8-远程读取语言数据",
                normalizedTitle: "8. 远程读取语言数据",
                charIndex: 2477
            }, {
                level: 3,
                title: "8.1 useLocale",
                slug: "_8-1-uselocale",
                normalizedTitle: "8.1 uselocale",
                charIndex: 3366
            }],
            headersStr: "1. I18n-ally 插件 2. 配置默认语言 3. 语言文件 4. 语言导入逻辑说明 5. 使用 6. 切换语言 7. 新增新语言 7.1 语言文件 7.2 新增语言 8. 远程读取语言数据 8.1 useLocale",
            content: "友情提示：\n\n该章节，基于 《vue element plus admin —— 国际化》 的内容修改。\n\n如果你使用的 vscode 开发工具，则推荐安装 I18n-ally 这个插件\n\n\n# 1. I18n-ally 插件\n\n安装了该插件后，你的代码内可以实时看到对应的语言内容\n\n\n\n\n# 2. 配置默认语言\n\n在 src/store/modules/locale.ts 内配置 currentLocale 为其他语言。\n\n查看代码\n\nimport { defineStore } from 'pinia'\nimport { store } from '../index'\nimport zhCn from 'element-plus/es/locale/lang/zh-cn'\nimport en from 'element-plus/es/locale/lang/en'\nimport { CACHE_KEY, useCache } from '@/hooks/web/useCache'\nimport { LocaleDropdownType } from '@/types/localeDropdown'\n\nconst { wsCache } = useCache()\n\nconst elLocaleMap = {\n  'zh-CN': zhCn,\n  en: en\n}\ninterface LocaleState {\n  currentLocale: LocaleDropdownType\n  localeMap: LocaleDropdownType[]\n}\n\nexport const useLocaleStore = defineStore('locales', {\n  state: (): LocaleState => {\n    return {\n      currentLocale: {\n        lang: wsCache.get(CACHE_KEY.LANG) || 'zh-CN',\n        elLocale: elLocaleMap[wsCache.get(CACHE_KEY.LANG) || 'zh-CN']\n      },\n      // 多语言\n      localeMap: [\n        {\n          lang: 'zh-CN',\n          name: '简体中文'\n        },\n        {\n          lang: 'en',\n          name: 'English'\n        }\n      ]\n    }\n  },\n  getters: {\n    getCurrentLocale(): LocaleDropdownType {\n      return this.currentLocale\n    },\n    getLocaleMap(): LocaleDropdownType[] {\n      return this.localeMap\n    }\n  },\n  actions: {\n    setCurrentLocale(localeMap: LocaleDropdownType) {\n      // this.locale = Object.assign(this.locale, localeMap)\n      this.currentLocale.lang = localeMap?.lang\n      this.currentLocale.elLocale = elLocaleMap[localeMap?.lang]\n      wsCache.set(CACHE_KEY.LANG, localeMap?.lang)\n    }\n  }\n})\n\nexport const useLocaleStoreWithOut = () => {\n  return useLocaleStore(store)\n}\n\n\n\n# 3. 语言文件\n\n在 src/locales 可以配置具体的语言。\n\n目前项目中的语言都是没有拆分的，全部放一起，后续会考虑拆分出来，比较好维护。\n\n\n# 4. 语言导入逻辑说明\n\n在 src/plugins/vueI18n/index.ts 内可以看到\n\nconst defaultLocal = await import(`../../locales/${locale.lang}.ts`)\n\n\n这会导入 src/locales 文件语言包。\n\n\n# 5. 使用\n\n引入项目自带的 useI18n\n\n注意不要引入 vue-i18n 的 useI18n\n\nimport { useI18n } from '/@/hooks/web/useI18n'\n\nconst { t } = useI18n()\n\nconst title = t('common.menu')\n\n\n\n# 6. 切换语言\n\n切换语言需要使用 src/hooks/web/useLocale.ts\n\nimport { useLocale } from '@/hooks/web/useLocale'\nconst { changeLocale } = useLocale()\n\nchangeLocale('en')\n\n\n\n# 7. 新增新语言\n\n\n# 7.1 语言文件\n\n在 src/locales 增加对应语言的文件即可\n\n\n# 7.2 新增语言\n\n目前项目自带的语言只有 zh_CN 和 en 两种\n\n如果需要新增，按以下操作即可\n\n 1. 在 src/locales 下语言文件\n 2. 在 types/global.d.ts 给 LocaleType 添加对应的类型\n 3. 在 src/store/modules/locale.ts localeMap 中添加对应语言\n\n\n# 8. 远程读取语言数据\n\n目前项目会在 src/main.ts 内等待 setupI18n 这个函数执行完之后才会渲染界面，所以只需在 setupI18n 内的 createI18nOptions 发送 ajax 请求，将对应的数据设置到 i18n 实例上即可。\n\nconst createI18nOptions = async (): Promise<I18nOptions> => {\n  const localeStore = useLocaleStoreWithOut()\n  const locale = localeStore.getCurrentLocale\n  const localeMap = localeStore.getLocaleMap\n  // 这里改为远程请求即可。\n  const defaultLocal = await import(`../../locales/${locale.lang}.ts`)\n  const message = defaultLocal.default ?? {}\n\n  setHtmlPageLang(locale.lang)\n\n  localeStore.setCurrentLocale({\n    lang: locale.lang\n    // elLocale: elLocal\n  })\n\n  return {\n    legacy: false,\n    locale: locale.lang,\n    fallbackLocale: locale.lang,\n    messages: {\n      [locale.lang]: message\n    },\n    availableLocales: localeMap.map((v) => v.lang),\n    sync: true,\n    silentTranslationWarn: true,\n    missingWarn: false,\n    silentFallbackWarn: true\n  }\n}\n\n\n\n# 8.1 useLocale\n\n代码: src/hooks/web/useLocale.ts\n\n当手动切换语言的时候会触发 useLocale 函数，useLocale 也是异步函数，只需等待接口返回响应的数据后，再进行设置即可\n\nexport const useLocale = () => {\n  // Switching the language will change the locale of useI18n\n  // And submit to configuration modification\n  const changeLocale = async (locale: LocaleType) => {\n    const globalI18n = i18n.global\n    \n    // 改为远程获取\n    const langModule = await import(`../../locales/${locale}.ts`)\n\n    globalI18n.setLocaleMessage(locale, langModule.default)\n\n    setI18nLanguage(locale)\n  }\n\n  return {\n    changeLocale\n  }\n}\n",
            normalizedContent: "友情提示：\n\n该章节，基于 《vue element plus admin —— 国际化》 的内容修改。\n\n如果你使用的 vscode 开发工具，则推荐安装 i18n-ally 这个插件\n\n\n# 1. i18n-ally 插件\n\n安装了该插件后，你的代码内可以实时看到对应的语言内容\n\n\n\n\n# 2. 配置默认语言\n\n在 src/store/modules/locale.ts 内配置 currentlocale 为其他语言。\n\n查看代码\n\nimport { definestore } from 'pinia'\nimport { store } from '../index'\nimport zhcn from 'element-plus/es/locale/lang/zh-cn'\nimport en from 'element-plus/es/locale/lang/en'\nimport { cache_key, usecache } from '@/hooks/web/usecache'\nimport { localedropdowntype } from '@/types/localedropdown'\n\nconst { wscache } = usecache()\n\nconst ellocalemap = {\n  'zh-cn': zhcn,\n  en: en\n}\ninterface localestate {\n  currentlocale: localedropdowntype\n  localemap: localedropdowntype[]\n}\n\nexport const uselocalestore = definestore('locales', {\n  state: (): localestate => {\n    return {\n      currentlocale: {\n        lang: wscache.get(cache_key.lang) || 'zh-cn',\n        ellocale: ellocalemap[wscache.get(cache_key.lang) || 'zh-cn']\n      },\n      // 多语言\n      localemap: [\n        {\n          lang: 'zh-cn',\n          name: '简体中文'\n        },\n        {\n          lang: 'en',\n          name: 'english'\n        }\n      ]\n    }\n  },\n  getters: {\n    getcurrentlocale(): localedropdowntype {\n      return this.currentlocale\n    },\n    getlocalemap(): localedropdowntype[] {\n      return this.localemap\n    }\n  },\n  actions: {\n    setcurrentlocale(localemap: localedropdowntype) {\n      // this.locale = object.assign(this.locale, localemap)\n      this.currentlocale.lang = localemap?.lang\n      this.currentlocale.ellocale = ellocalemap[localemap?.lang]\n      wscache.set(cache_key.lang, localemap?.lang)\n    }\n  }\n})\n\nexport const uselocalestorewithout = () => {\n  return uselocalestore(store)\n}\n\n\n\n# 3. 语言文件\n\n在 src/locales 可以配置具体的语言。\n\n目前项目中的语言都是没有拆分的，全部放一起，后续会考虑拆分出来，比较好维护。\n\n\n# 4. 语言导入逻辑说明\n\n在 src/plugins/vuei18n/index.ts 内可以看到\n\nconst defaultlocal = await import(`../../locales/${locale.lang}.ts`)\n\n\n这会导入 src/locales 文件语言包。\n\n\n# 5. 使用\n\n引入项目自带的 usei18n\n\n注意不要引入 vue-i18n 的 usei18n\n\nimport { usei18n } from '/@/hooks/web/usei18n'\n\nconst { t } = usei18n()\n\nconst title = t('common.menu')\n\n\n\n# 6. 切换语言\n\n切换语言需要使用 src/hooks/web/uselocale.ts\n\nimport { uselocale } from '@/hooks/web/uselocale'\nconst { changelocale } = uselocale()\n\nchangelocale('en')\n\n\n\n# 7. 新增新语言\n\n\n# 7.1 语言文件\n\n在 src/locales 增加对应语言的文件即可\n\n\n# 7.2 新增语言\n\n目前项目自带的语言只有 zh_cn 和 en 两种\n\n如果需要新增，按以下操作即可\n\n 1. 在 src/locales 下语言文件\n 2. 在 types/global.d.ts 给 localetype 添加对应的类型\n 3. 在 src/store/modules/locale.ts localemap 中添加对应语言\n\n\n# 8. 远程读取语言数据\n\n目前项目会在 src/main.ts 内等待 setupi18n 这个函数执行完之后才会渲染界面，所以只需在 setupi18n 内的 createi18noptions 发送 ajax 请求，将对应的数据设置到 i18n 实例上即可。\n\nconst createi18noptions = async (): promise<i18noptions> => {\n  const localestore = uselocalestorewithout()\n  const locale = localestore.getcurrentlocale\n  const localemap = localestore.getlocalemap\n  // 这里改为远程请求即可。\n  const defaultlocal = await import(`../../locales/${locale.lang}.ts`)\n  const message = defaultlocal.default ?? {}\n\n  sethtmlpagelang(locale.lang)\n\n  localestore.setcurrentlocale({\n    lang: locale.lang\n    // ellocale: ellocal\n  })\n\n  return {\n    legacy: false,\n    locale: locale.lang,\n    fallbacklocale: locale.lang,\n    messages: {\n      [locale.lang]: message\n    },\n    availablelocales: localemap.map((v) => v.lang),\n    sync: true,\n    silenttranslationwarn: true,\n    missingwarn: false,\n    silentfallbackwarn: true\n  }\n}\n\n\n\n# 8.1 uselocale\n\n代码: src/hooks/web/uselocale.ts\n\n当手动切换语言的时候会触发 uselocale 函数，uselocale 也是异步函数，只需等待接口返回响应的数据后，再进行设置即可\n\nexport const uselocale = () => {\n  // switching the language will change the locale of usei18n\n  // and submit to configuration modification\n  const changelocale = async (locale: localetype) => {\n    const globali18n = i18n.global\n    \n    // 改为远程获取\n    const langmodule = await import(`../../locales/${locale}.ts`)\n\n    globali18n.setlocalemessage(locale, langmodule.default)\n\n    seti18nlanguage(locale)\n  }\n\n  return {\n    changelocale\n  }\n}\n",
            charsets: {
                cjk: !0
            }
        }, {
            title: "CRUD 组件",
            frontmatter: {
                title: "CRUD 组件",
                date: "2023-04-05T21:15:45.000Z",
                permalink: "/vue3/crud-schema"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/21.%E5%89%8D%E7%AB%AF%E6%89%8B%E5%86%8C%20Vue%203.x/08.CRUD%20%E7%BB%84%E4%BB%B6.html",
            relativePath: "01.开发指南/21.前端手册 Vue 3.x/08.CRUD 组件.md",
            key: "v-26f5609c",
            path: "/vue3/crud-schema/",
            headers: [{
                level: 2,
                title: "1. 基础组件",
                slug: "_1-基础组件",
                normalizedTitle: "1. 基础组件",
                charIndex: 268
            }, {
                level: 2,
                title: "2. CRUD 组件",
                slug: "_2-crud-组件",
                normalizedTitle: "2. crud 组件",
                charIndex: 400
            }, {
                level: 2,
                title: "3. 实战案例",
                slug: "_3-实战案例",
                normalizedTitle: "3. 实战案例",
                charIndex: 3465
            }, {
                level: 2,
                title: "4. 常见问题",
                slug: "_4-常见问题",
                normalizedTitle: "4. 常见问题",
                charIndex: 3644
            }, {
                level: 3,
                title: "4.1 如何隐藏某个字段？",
                slug: "_4-1-如何隐藏某个字段",
                normalizedTitle: "4.1 如何隐藏某个字段？",
                charIndex: 3656
            }, {
                level: 3,
                title: "4.2 如何使用数据字典？",
                slug: "_4-2-如何使用数据字典",
                normalizedTitle: "4.2 如何使用数据字典？",
                charIndex: 3773
            }, {
                level: 3,
                title: "4.3 如何使用 API 获取数据？",
                slug: "_4-3-如何使用-api-获取数据",
                normalizedTitle: "4.3 如何使用 api 获取数据？",
                charIndex: 3833
            }, {
                level: 3,
                title: "4.4 如何结合 Slot 自定义？",
                slug: "_4-4-如何结合-slot-自定义",
                normalizedTitle: "4.4 如何结合 slot 自定义？",
                charIndex: 3890
            }],
            headersStr: "1. 基础组件 2. CRUD 组件 3. 实战案例 4. 常见问题 4.1 如何隐藏某个字段？ 4.2 如何使用数据字典？ 4.3 如何使用 API 获取数据？ 4.4 如何结合 Slot 自定义？",
            content: "友情提示：\n\nCRUD 组件，比较适合开发简单的 CRUD 功能。如果是复杂的功能，使用起来会比较困难。所以一般情况下，我们还是建议使用 Element Plus 的原生组件。\n\n管理后台的功能，一般就是 CRUD 增删改查，可以拆分 3 个部分：“列表”、“新增/修改”、“详情”，如下图所示：\n\n部分        组件               示例\n列表        Search + Table   \n新增 / 修改   Form             \n详情        Descriptions     \n\n\n# 1. 基础组件\n\n涉及到 4 个前端基础组件，如下所示：\n\n组件             文档\nSearch         查询组件\nTable          表格组件\nForm           表单组件\nDescriptions   描述组件\n\n\n# 2. CRUD 组件\n\n由于以上 4 个组件都需要 Schema 或者 columns 的字段，如果每个组件都写一遍的话，会造成大量重复代码，所以提供 useCrudSchemas 来进行统一的数据生成。\n\n① useCrudSchemas：位于 src/hooks/web/useCrudSchemas.ts 内\n\n② useCrudSchemas 可以理解成一个 JSON 配置，示例如下：\n\nuseCrudSchemas 示例\n\n<script setup lang=\"ts\">\nimport { CrudSchema, useCrudSchemas } from '@/hooks/web/useCrudSchemas'\n\nconst crudSchemas = reactive<CrudSchema[]>([\n    {\n        field: 'index',\n        label: t('tableDemo.index'),\n        type: 'index',\n        form: {\n            show: false\n        },\n        detail: {\n            show: false\n        }\n    },\n    {\n        field: 'title',\n        label: t('tableDemo.title'),\n        search: {\n            show: true\n        },\n        form: {\n            colProps: {\n                span: 24\n            }\n        },\n        detail: {\n            span: 24\n        }\n    },\n    {\n        field: 'author',\n        label: t('tableDemo.author')\n    },\n    {\n        field: 'display_time',\n        label: t('tableDemo.displayTime'),\n        form: {\n            component: 'DatePicker',\n            componentProps: {\n                type: 'datetime',\n                valueFormat: 'YYYY-MM-DD HH:mm:ss'\n            }\n        }\n    },\n    {\n        field: 'importance',\n        label: t('tableDemo.importance'),\n        formatter: (_: Recordable, __: TableColumn, cellValue: number) => {\n            return h(\n                ElTag,\n                {\n                    type: cellValue === 1 ? 'success' : cellValue === 2 ? 'warning' : 'danger'\n                },\n                () =>\n                    cellValue === 1\n                        ? t('tableDemo.important')\n                        : cellValue === 2\n                            ? t('tableDemo.good')\n                            : t('tableDemo.commonly')\n            )\n        },\n        form: {\n            component: 'Select',\n            componentProps: {\n                options: [\n                    {\n                        label: '重要',\n                        value: 3\n                    },\n                    {\n                        label: '良好',\n                        value: 2\n                    },\n                    {\n                        label: '一般',\n                        value: 1\n                    }\n                ]\n            }\n        }\n    },\n    {\n        field: 'pageviews',\n        label: t('tableDemo.pageviews'),\n        form: {\n            component: 'InputNumber',\n            value: 0\n        }\n    },\n    {\n        field: 'content',\n        label: t('exampleDemo.content'),\n        table: {\n            show: false\n        },\n        form: {\n            component: 'Editor',\n            colProps: {\n                span: 24\n            }\n        },\n        detail: {\n            span: 24\n        }\n    },\n    {\n        field: 'action',\n        width: '260px',\n        label: t('tableDemo.action'),\n        form: {\n            show: false\n        },\n        detail: {\n            show: false\n        }\n    }\n])\n\nconst { allSchemas } = useCrudSchemas(crudSchemas)\n<\/script>\n\n\n③ 字段的详细说明，可见 useCrudSchemas 文档。\n\n\n# 3. 实战案例\n\n项目的 [系统管理 -> 邮箱管理] 相关的功能，都使用 CRUD 实现，你可以自己去学习。\n\n功能     代码\n邮箱账号   src/views/system/mail/account\n邮箱模版   src/views/system/mail/template\n邮箱记录   src/views/system/mail/log\n\n\n# 4. 常见问题\n\n\n# 4.1 如何隐藏某个字段？\n\n如 formSchema 不需要 field 为 createTime 的字段，可以使用 form: { show: false } 或 isForm: false 进行过滤，其他组件同理。\n\n\n\n\n# 4.2 如何使用数据字典？\n\n设置 dictType 字典的类型，和 dictClass 字典的数据类型。\n\n\n\n\n# 4.3 如何使用 API 获取数据？\n\n使用 api 来获取接口数据，需要主动 return 数据。\n\n\n\n\n# 4.4 如何结合 Slot 自定义？\n\n如果想要自定义，可以结合 Slot 来实现。具体有哪些 Slot，阅读对应基础组件的文档。\n\n",
            normalizedContent: "友情提示：\n\ncrud 组件，比较适合开发简单的 crud 功能。如果是复杂的功能，使用起来会比较困难。所以一般情况下，我们还是建议使用 element plus 的原生组件。\n\n管理后台的功能，一般就是 crud 增删改查，可以拆分 3 个部分：“列表”、“新增/修改”、“详情”，如下图所示：\n\n部分        组件               示例\n列表        search + table   \n新增 / 修改   form             \n详情        descriptions     \n\n\n# 1. 基础组件\n\n涉及到 4 个前端基础组件，如下所示：\n\n组件             文档\nsearch         查询组件\ntable          表格组件\nform           表单组件\ndescriptions   描述组件\n\n\n# 2. crud 组件\n\n由于以上 4 个组件都需要 schema 或者 columns 的字段，如果每个组件都写一遍的话，会造成大量重复代码，所以提供 usecrudschemas 来进行统一的数据生成。\n\n① usecrudschemas：位于 src/hooks/web/usecrudschemas.ts 内\n\n② usecrudschemas 可以理解成一个 json 配置，示例如下：\n\nusecrudschemas 示例\n\n<script setup lang=\"ts\">\nimport { crudschema, usecrudschemas } from '@/hooks/web/usecrudschemas'\n\nconst crudschemas = reactive<crudschema[]>([\n    {\n        field: 'index',\n        label: t('tabledemo.index'),\n        type: 'index',\n        form: {\n            show: false\n        },\n        detail: {\n            show: false\n        }\n    },\n    {\n        field: 'title',\n        label: t('tabledemo.title'),\n        search: {\n            show: true\n        },\n        form: {\n            colprops: {\n                span: 24\n            }\n        },\n        detail: {\n            span: 24\n        }\n    },\n    {\n        field: 'author',\n        label: t('tabledemo.author')\n    },\n    {\n        field: 'display_time',\n        label: t('tabledemo.displaytime'),\n        form: {\n            component: 'datepicker',\n            componentprops: {\n                type: 'datetime',\n                valueformat: 'yyyy-mm-dd hh:mm:ss'\n            }\n        }\n    },\n    {\n        field: 'importance',\n        label: t('tabledemo.importance'),\n        formatter: (_: recordable, __: tablecolumn, cellvalue: number) => {\n            return h(\n                eltag,\n                {\n                    type: cellvalue === 1 ? 'success' : cellvalue === 2 ? 'warning' : 'danger'\n                },\n                () =>\n                    cellvalue === 1\n                        ? t('tabledemo.important')\n                        : cellvalue === 2\n                            ? t('tabledemo.good')\n                            : t('tabledemo.commonly')\n            )\n        },\n        form: {\n            component: 'select',\n            componentprops: {\n                options: [\n                    {\n                        label: '重要',\n                        value: 3\n                    },\n                    {\n                        label: '良好',\n                        value: 2\n                    },\n                    {\n                        label: '一般',\n                        value: 1\n                    }\n                ]\n            }\n        }\n    },\n    {\n        field: 'pageviews',\n        label: t('tabledemo.pageviews'),\n        form: {\n            component: 'inputnumber',\n            value: 0\n        }\n    },\n    {\n        field: 'content',\n        label: t('exampledemo.content'),\n        table: {\n            show: false\n        },\n        form: {\n            component: 'editor',\n            colprops: {\n                span: 24\n            }\n        },\n        detail: {\n            span: 24\n        }\n    },\n    {\n        field: 'action',\n        width: '260px',\n        label: t('tabledemo.action'),\n        form: {\n            show: false\n        },\n        detail: {\n            show: false\n        }\n    }\n])\n\nconst { allschemas } = usecrudschemas(crudschemas)\n<\/script>\n\n\n③ 字段的详细说明，可见 usecrudschemas 文档。\n\n\n# 3. 实战案例\n\n项目的 [系统管理 -> 邮箱管理] 相关的功能，都使用 crud 实现，你可以自己去学习。\n\n功能     代码\n邮箱账号   src/views/system/mail/account\n邮箱模版   src/views/system/mail/template\n邮箱记录   src/views/system/mail/log\n\n\n# 4. 常见问题\n\n\n# 4.1 如何隐藏某个字段？\n\n如 formschema 不需要 field 为 createtime 的字段，可以使用 form: { show: false } 或 isform: false 进行过滤，其他组件同理。\n\n\n\n\n# 4.2 如何使用数据字典？\n\n设置 dicttype 字典的类型，和 dictclass 字典的数据类型。\n\n\n\n\n# 4.3 如何使用 api 获取数据？\n\n使用 api 来获取接口数据，需要主动 return 数据。\n\n\n\n\n# 4.4 如何结合 slot 自定义？\n\n如果想要自定义，可以结合 slot 来实现。具体有哪些 slot，阅读对应基础组件的文档。\n\n",
            charsets: {
                cjk: !0
            }
        }, {
            title: "代码格式化",
            frontmatter: {
                title: "代码格式化",
                date: "2023-11-17T18:30:42.000Z",
                permalink: "/vue3/format"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/21.%E5%89%8D%E7%AB%AF%E6%89%8B%E5%86%8C%20Vue%203.x/11.%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%8C%96.html",
            relativePath: "01.开发指南/21.前端手册 Vue 3.x/11.代码格式化.md",
            key: "v-1ff35d63",
            path: "/vue3/format/",
            headers: [{
                level: 2,
                title: "1. 如何开启？",
                slug: "_1-如何开启",
                normalizedTitle: "1. 如何开启？",
                charIndex: 52
            }, {
                level: 2,
                title: "2. 自动格式化",
                slug: "_2-自动格式化",
                normalizedTitle: "2. 自动格式化",
                charIndex: 184
            }, {
                level: 3,
                title: "2.1 JetBrains 端",
                slug: "_2-1-jetbrains-端",
                normalizedTitle: "2.1 jetbrains 端",
                charIndex: 293
            }, {
                level: 2,
                title: "2.2 VS Code 端",
                slug: "_2-2-vs-code-端",
                normalizedTitle: "2.2 vs code 端",
                charIndex: 431
            }],
            headersStr: "1. 如何开启？ 2. 自动格式化 2.1 JetBrains 端 2.2 VS Code 端",
            content: "项目使用 Prettier 进行代码格式化，配置文件在 prettier.config.js。\n\n\n# 1. 如何开启？\n\n考虑到 Prettier 在检测到格式不正确时，会弹窗错误提示，影响大家开发效率，所以目前 默认关闭 。\n\n如果想要开启，只修改修改 .eslintrc.js 文件，将 'prettier/prettier': 'off' 删除即可。\n\n\n# 2. 自动格式化\n\nJetBrains 和 VS Code 可以通过安装 Prettier 插件，实现按照 Prettier 自动格式化。这样，无论 Prettier 无论是否开启，都可以保证格式化的一致性。\n\n\n# 2.1 JetBrains 端\n\n① 安装 Prettier 插件。默认 IDEA 和 WebStorm 已经安装，所以这步可以省略。\n\n② 打开 Prettier 配置，勾选上 Run on save 选项。如下图所示：\n\n\n\n之后，保存页面，页面代码自动格式化。\n\n\n# 2.2 VS Code 端\n\n① 安装 Prettier 插件。需要手动安装！\n\n② 打开 VS Code 配置，搜索 save 后，勾选上 Format On Save 选项。如下图所示：\n\n\n\n③ 随便打开一个 Vue 文件，右键选择 Format Document 或者 格式化文档，然后选择 Prettier 即可。如下图所示：\n\n\n\n之后，保存页面，页面代码自动格式化。",
            normalizedContent: "项目使用 prettier 进行代码格式化，配置文件在 prettier.config.js。\n\n\n# 1. 如何开启？\n\n考虑到 prettier 在检测到格式不正确时，会弹窗错误提示，影响大家开发效率，所以目前 默认关闭 。\n\n如果想要开启，只修改修改 .eslintrc.js 文件，将 'prettier/prettier': 'off' 删除即可。\n\n\n# 2. 自动格式化\n\njetbrains 和 vs code 可以通过安装 prettier 插件，实现按照 prettier 自动格式化。这样，无论 prettier 无论是否开启，都可以保证格式化的一致性。\n\n\n# 2.1 jetbrains 端\n\n① 安装 prettier 插件。默认 idea 和 webstorm 已经安装，所以这步可以省略。\n\n② 打开 prettier 配置，勾选上 run on save 选项。如下图所示：\n\n\n\n之后，保存页面，页面代码自动格式化。\n\n\n# 2.2 vs code 端\n\n① 安装 prettier 插件。需要手动安装！\n\n② 打开 vs code 配置，搜索 save 后，勾选上 format on save 选项。如下图所示：\n\n\n\n③ 随便打开一个 vue 文件，右键选择 format document 或者 格式化文档，然后选择 prettier 即可。如下图所示：\n\n\n\n之后，保存页面，页面代码自动格式化。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "IDE 调试",
            frontmatter: {
                title: "IDE 调试",
                date: "2023-04-13T22:32:13.000Z",
                permalink: "/vue3/debugger"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/21.%E5%89%8D%E7%AB%AF%E6%89%8B%E5%86%8C%20Vue%203.x/10.IDE%20%E8%B0%83%E8%AF%95.html",
            relativePath: "01.开发指南/21.前端手册 Vue 3.x/10.IDE 调试.md",
            key: "v-1f7300c5",
            path: "/vue3/debugger/",
            headers: [{
                level: 2,
                title: "1. IDEA 调试",
                slug: "_1-idea-调试",
                normalizedTitle: "1. idea 调试",
                charIndex: 69
            }, {
                level: 2,
                title: "2. VS Code 调试",
                slug: "_2-vs-code-调试",
                normalizedTitle: "2. vs code 调试",
                charIndex: 357
            }],
            headersStr: "1. IDEA 调试 2. VS Code 调试",
            content: "除了使用 Chrome 调试 JS 代码外，我们也可以使用 IDEA / WebStorm 或 VS Code 进行代码的调试。\n\n\n# 1. IDEA 调试\n\n友情提示：WebStorm 也支持。\n\n① 使用 npm 命令将前端项目运行起来，例如说 npm run dev。耐心等待项目启动成功~\n\n② 点击链接，Windows 需按住 Ctrl + Shift + 鼠标左键，MacOS 需要按住 Shift + Command + 鼠标左键。如下图所示：\n\n\n\n③ 点击后，会跳出一个独立的 Chrome 窗口。如下图所示：\n\n\n\n④ 打个断点，例如说 /src/api/login/index.ts 的登录接口。如下图所示：\n\n\n\n⑤ 使用管理后台进行登录，可以看到成功进入断点。如下图所示：\n\n\n\n\n# 2. VS Code 调试\n\n① 使用 npm 命令将前端项目运行起来，例如说 npm run dev。耐心等待项目启动成功~\n\n② 点击 VS Code 左侧的运行和调试，然后启动 Launch，之后会跳出一个独立的 Edge 窗口。如下图所示：\n\n\n\n③ 打个断点，例如说 /src/api/login/index.ts 的登录接口。如下图所示：\n\n\n\n④ 使用管理后台进行登录，可以看到成功进入断点。如下图所示：\n\n",
            normalizedContent: "除了使用 chrome 调试 js 代码外，我们也可以使用 idea / webstorm 或 vs code 进行代码的调试。\n\n\n# 1. idea 调试\n\n友情提示：webstorm 也支持。\n\n① 使用 npm 命令将前端项目运行起来，例如说 npm run dev。耐心等待项目启动成功~\n\n② 点击链接，windows 需按住 ctrl + shift + 鼠标左键，macos 需要按住 shift + command + 鼠标左键。如下图所示：\n\n\n\n③ 点击后，会跳出一个独立的 chrome 窗口。如下图所示：\n\n\n\n④ 打个断点，例如说 /src/api/login/index.ts 的登录接口。如下图所示：\n\n\n\n⑤ 使用管理后台进行登录，可以看到成功进入断点。如下图所示：\n\n\n\n\n# 2. vs code 调试\n\n① 使用 npm 命令将前端项目运行起来，例如说 npm run dev。耐心等待项目启动成功~\n\n② 点击 vs code 左侧的运行和调试，然后启动 launch，之后会跳出一个独立的 edge 窗口。如下图所示：\n\n\n\n③ 打个断点，例如说 /src/api/login/index.ts 的登录接口。如下图所示：\n\n\n\n④ 使用管理后台进行登录，可以看到成功进入断点。如下图所示：\n\n",
            charsets: {
                cjk: !0
            }
        }, {
            title: "开发规范",
            frontmatter: {
                title: "开发规范",
                date: "2022-04-17T19:21:32.000Z",
                permalink: "/vue2/dev-spec"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/22.%E5%89%8D%E7%AB%AF%E6%89%8B%E5%86%8C%20Vue%202.x/01.%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83.html",
            relativePath: "01.开发指南/22.前端手册 Vue 2.x/01.开发规范.md",
            key: "v-19b9a873",
            path: "/vue2/dev-spec/",
            headers: [{
                level: 2,
                title: "1. view 页面",
                slug: "_1-view-页面",
                normalizedTitle: "1. view 页面",
                charIndex: 2
            }, {
                level: 2,
                title: "2. api 请求",
                slug: "_2-api-请求",
                normalizedTitle: "2. api 请求",
                charIndex: 90
            }, {
                level: 3,
                title: "2.1 请求封装",
                slug: "_2-1-请求封装",
                normalizedTitle: "2.1 请求封装",
                charIndex: 186
            }, {
                level: 3,
                title: "2.2 交互流程",
                slug: "_2-2-交互流程",
                normalizedTitle: "2.2 交互流程",
                charIndex: 4077
            }, {
                level: 3,
                title: "2.3 自定义 baseURL 基础路径",
                slug: "_2-3-自定义-baseurl-基础路径",
                normalizedTitle: "2.3 自定义 baseurl 基础路径",
                charIndex: 4714
            }, {
                level: 2,
                title: "3. component 组件",
                slug: "_3-component-组件",
                normalizedTitle: "3. component 组件",
                charIndex: 4983
            }, {
                level: 2,
                title: "4. style 样式",
                slug: "_4-style-样式",
                normalizedTitle: "4. style 样式",
                charIndex: 5189
            }],
            headersStr: "1. view 页面 2. api 请求 2.1 请求封装 2.2 交互流程 2.3 自定义 baseURL 基础路径 3. component 组件 4. style 样式",
            content: "# 1. view 页面\n\n在 @views 目录下，每个模块对应一个目录，它的所有功能的 .vue 都放在该目录里。\n\n\n\n一般来说，一个路由对应一个 .vue 文件。\n\n\n# 2. api 请求\n\n在 @/api 目录下，每个模块对应一个 .api 文件。\n\n\n\n每个 API 方法，会调用 request 方法，发起对后端 RESTful API 的调用。\n\n\n# 2.1 请求封装\n\n@/utils/request 基于 axios 封装，统一处理 GET、POST 方法的请求参数、请求头，以及错误提示信息等。\n\n# 2.1.1 创建 axios 实例\n\n * baseURL 基础路径\n * timeout 超时时间\n\n实现代码\n\nimport axios from 'axios'\n\n// 创建 axios 实例\nconst service = axios.create({\n    // axios 中请求配置有 baseURL 选项，表示请求 URL 公共部分\n    baseURL: process.env.VUE_APP_BASE_API + '/admin-api/', // 此处的 /admin-api/ 地址，原因是后端的基础路径为 /admin-api/\n    // 超时\n    timeout: 10000\n})\n\n\n# 2.1.2 Request 拦截器\n\n * Authorization、tenant-id 请求头\n * GET 请求参数的拼接\n\n实现代码\n\nimport { getToken } from '@/utils/auth'\nimport { getTenantEnable } from \"@/utils/ruoyi\";\nimport Cookies from \"js-cookie\";\n\nservice.interceptors.request.use(config => {\n    // 是否需要设置 token\n    const isToken = (config.headers || {}).isToken === false\n    if (getToken() && !isToken) {\n        config.headers['Authorization'] = 'Bearer ' + getToken() // 让每个请求携带自定义token 请根据实际情况自行修改\n    }\n    // 设置租户\n    if (getTenantEnable()) {\n        const tenantId = Cookies.get('tenantId');\n        if (tenantId) {\n            config.headers['tenant-id'] = tenantId;\n        }\n    }\n    // get 请求映射 params 参数\n    if (config.method === 'get' && config.params) {\n        let url = config.url + '?';\n        for (const propName of Object.keys(config.params)) {\n            const value = config.params[propName];\n            var part = encodeURIComponent(propName) + \"=\";\n            if (value !== null && typeof(value) !== \"undefined\") {\n                if (typeof value === 'object') {\n                    for (const key of Object.keys(value)) {\n                        let params = propName + '[' + key + ']';\n                        var subPart = encodeURIComponent(params) + \"=\";\n                        url += subPart + encodeURIComponent(value[key]) + \"&\";\n                    }\n                } else {\n                    url += part + encodeURIComponent(value) + \"&\";\n                }\n            }\n        }\n        url = url.slice(0, -1);\n        config.params = {};\n        config.url = url;\n    }\n    return config\n}, error => {\n    console.log(error)\n    Promise.reject(error)\n})\n\n\n# 2.1.3 Response 拦截器\n\n * Token 失效、登录过期时，跳回首页\n * 请求失败，Message 错误提示\n\n实现代码\n\nimport { Notification, MessageBox, Message } from 'element-ui'\nimport store from '@/store'\nimport errorCode from '@/utils/errorCode'\nimport Cookies from \"js-cookie\";\n\nexport let isRelogin = { show: false };\n\nservice.interceptors.response.use(res => {\n    // 未设置状态码则默认成功状态\n    const code = res.data.code || 200;\n    // 获取错误信息\n    const msg = errorCode[code] || res.data.msg || errorCode['default']\n    if (code === 401) {\n      if (!isRelogin.show) {\n        isRelogin.show = true;\n        MessageBox.confirm('登录状态已过期，您可以继续留在该页面，或者重新登录', '系统提示', {\n            confirmButtonText: '重新登录',\n            cancelButtonText: '取消',\n            type: 'warning'\n          }\n        ).then(() => {\n          isRelogin.show = false;\n          store.dispatch('LogOut').then(() => {\n            location.href = '/index';\n          })\n        }).catch(() => {\n          isRelogin.show = false;\n        });\n      }\n      return Promise.reject('无效的会话，或者会话已过期，请重新登录。')\n    } else if (code === 500) {\n      Message({\n        message: msg,\n        type: 'error'\n      })\n      return Promise.reject(new Error(msg))\n    } else if (code !== 200) {\n      Notification.error({\n        title: msg\n      })\n      return Promise.reject('error')\n    } else { // 请求成功！\n      return res.data\n    }\n  },\n  error => {\n    console.log('err' + error)\n    let { message } = error;\n    if (message === \"Network Error\") {\n      message = \"后端接口连接异常\";\n    }\n    else if (message.includes(\"timeout\")) {\n      message = \"系统接口请求超时\";\n    }\n    else if (message.includes(\"Request failed with status code\")) {\n      message = \"系统接口\" + message.substr(message.length - 3) + \"异常\";\n    }\n    Message({\n      message: message,\n      type: 'error',\n      duration: 5 * 1000\n    })\n    return Promise.reject(error)\n  }\n)\n\n\n\n# 2.2 交互流程\n\n一个完整的前端 UI 交互到服务端处理流程，如下图所示：\n\n\n\n以 [系统管理 -> 用户管理] 菜单为例，查看它是如何读取用户列表的。代码如下：\n\n// ① api/system/user.js\nimport request from '@/utils/request'\n\n// 查询用户列表\nexport function listUser(query) {\n    return request({\n        url: '/system/user/page',\n        method: 'get',\n        params: query\n    })\n}\n\n// ② views/system/user/index.vue\nimport { listUser } from \"@/api/system/user\";\n\nexport default {\n  data() {\n    userList: null,\n    loading: true\n  },\n  methods: {\n    getList() {\n      this.loading = true\n      listUser().then(response => {\n        this.userList = response.rows\n        this.loading = false\n      })\n    }\n  }\n}\n\n\n\n# 2.3 自定义 baseURL 基础路径\n\n如果想要自定义的 baseURL 基础路径，可以通过 baseURL 进行直接覆盖。示例如下：\n\nexport function listUser(query) {\n    return request({\n        url: '/system/user/page',\n        method: 'get',\n        params: query,\n        baseURL: 'https://www.iocoder.cn' // 自定义\n    })\n}\n\n\n\n# 3. component 组件\n\n① 在 @/components 目录下，实现全局组件，被所有模块所公用。例如说，富文本编辑器、各种各搜索组件、封装的分页组件等等。\n\n\n\n② 每个模块的业务组件，可实现在 views 目录下，自己模块的目录的 components 目录下，避免单个 .vue 文件过大，降低维护成功。例如说，@/views/pay/app/components/xxx.vue。\n\n\n\n\n# 4. style 样式\n\n① 在 @/styles 目录下，实现全局样式，被所有页面所公用。\n\n\n\n② 每个 .vue 页面，可在 <style /> 标签中添加样式，注意需要添加 scoped 表示只作用在当前页面里，避免造成全局的样式污染。\n\n",
            normalizedContent: "# 1. view 页面\n\n在 @views 目录下，每个模块对应一个目录，它的所有功能的 .vue 都放在该目录里。\n\n\n\n一般来说，一个路由对应一个 .vue 文件。\n\n\n# 2. api 请求\n\n在 @/api 目录下，每个模块对应一个 .api 文件。\n\n\n\n每个 api 方法，会调用 request 方法，发起对后端 restful api 的调用。\n\n\n# 2.1 请求封装\n\n@/utils/request 基于 axios 封装，统一处理 get、post 方法的请求参数、请求头，以及错误提示信息等。\n\n# 2.1.1 创建 axios 实例\n\n * baseurl 基础路径\n * timeout 超时时间\n\n实现代码\n\nimport axios from 'axios'\n\n// 创建 axios 实例\nconst service = axios.create({\n    // axios 中请求配置有 baseurl 选项，表示请求 url 公共部分\n    baseurl: process.env.vue_app_base_api + '/admin-api/', // 此处的 /admin-api/ 地址，原因是后端的基础路径为 /admin-api/\n    // 超时\n    timeout: 10000\n})\n\n\n# 2.1.2 request 拦截器\n\n * authorization、tenant-id 请求头\n * get 请求参数的拼接\n\n实现代码\n\nimport { gettoken } from '@/utils/auth'\nimport { gettenantenable } from \"@/utils/ruoyi\";\nimport cookies from \"js-cookie\";\n\nservice.interceptors.request.use(config => {\n    // 是否需要设置 token\n    const istoken = (config.headers || {}).istoken === false\n    if (gettoken() && !istoken) {\n        config.headers['authorization'] = 'bearer ' + gettoken() // 让每个请求携带自定义token 请根据实际情况自行修改\n    }\n    // 设置租户\n    if (gettenantenable()) {\n        const tenantid = cookies.get('tenantid');\n        if (tenantid) {\n            config.headers['tenant-id'] = tenantid;\n        }\n    }\n    // get 请求映射 params 参数\n    if (config.method === 'get' && config.params) {\n        let url = config.url + '?';\n        for (const propname of object.keys(config.params)) {\n            const value = config.params[propname];\n            var part = encodeuricomponent(propname) + \"=\";\n            if (value !== null && typeof(value) !== \"undefined\") {\n                if (typeof value === 'object') {\n                    for (const key of object.keys(value)) {\n                        let params = propname + '[' + key + ']';\n                        var subpart = encodeuricomponent(params) + \"=\";\n                        url += subpart + encodeuricomponent(value[key]) + \"&\";\n                    }\n                } else {\n                    url += part + encodeuricomponent(value) + \"&\";\n                }\n            }\n        }\n        url = url.slice(0, -1);\n        config.params = {};\n        config.url = url;\n    }\n    return config\n}, error => {\n    console.log(error)\n    promise.reject(error)\n})\n\n\n# 2.1.3 response 拦截器\n\n * token 失效、登录过期时，跳回首页\n * 请求失败，message 错误提示\n\n实现代码\n\nimport { notification, messagebox, message } from 'element-ui'\nimport store from '@/store'\nimport errorcode from '@/utils/errorcode'\nimport cookies from \"js-cookie\";\n\nexport let isrelogin = { show: false };\n\nservice.interceptors.response.use(res => {\n    // 未设置状态码则默认成功状态\n    const code = res.data.code || 200;\n    // 获取错误信息\n    const msg = errorcode[code] || res.data.msg || errorcode['default']\n    if (code === 401) {\n      if (!isrelogin.show) {\n        isrelogin.show = true;\n        messagebox.confirm('登录状态已过期，您可以继续留在该页面，或者重新登录', '系统提示', {\n            confirmbuttontext: '重新登录',\n            cancelbuttontext: '取消',\n            type: 'warning'\n          }\n        ).then(() => {\n          isrelogin.show = false;\n          store.dispatch('logout').then(() => {\n            location.href = '/index';\n          })\n        }).catch(() => {\n          isrelogin.show = false;\n        });\n      }\n      return promise.reject('无效的会话，或者会话已过期，请重新登录。')\n    } else if (code === 500) {\n      message({\n        message: msg,\n        type: 'error'\n      })\n      return promise.reject(new error(msg))\n    } else if (code !== 200) {\n      notification.error({\n        title: msg\n      })\n      return promise.reject('error')\n    } else { // 请求成功！\n      return res.data\n    }\n  },\n  error => {\n    console.log('err' + error)\n    let { message } = error;\n    if (message === \"network error\") {\n      message = \"后端接口连接异常\";\n    }\n    else if (message.includes(\"timeout\")) {\n      message = \"系统接口请求超时\";\n    }\n    else if (message.includes(\"request failed with status code\")) {\n      message = \"系统接口\" + message.substr(message.length - 3) + \"异常\";\n    }\n    message({\n      message: message,\n      type: 'error',\n      duration: 5 * 1000\n    })\n    return promise.reject(error)\n  }\n)\n\n\n\n# 2.2 交互流程\n\n一个完整的前端 ui 交互到服务端处理流程，如下图所示：\n\n\n\n以 [系统管理 -> 用户管理] 菜单为例，查看它是如何读取用户列表的。代码如下：\n\n// ① api/system/user.js\nimport request from '@/utils/request'\n\n// 查询用户列表\nexport function listuser(query) {\n    return request({\n        url: '/system/user/page',\n        method: 'get',\n        params: query\n    })\n}\n\n// ② views/system/user/index.vue\nimport { listuser } from \"@/api/system/user\";\n\nexport default {\n  data() {\n    userlist: null,\n    loading: true\n  },\n  methods: {\n    getlist() {\n      this.loading = true\n      listuser().then(response => {\n        this.userlist = response.rows\n        this.loading = false\n      })\n    }\n  }\n}\n\n\n\n# 2.3 自定义 baseurl 基础路径\n\n如果想要自定义的 baseurl 基础路径，可以通过 baseurl 进行直接覆盖。示例如下：\n\nexport function listuser(query) {\n    return request({\n        url: '/system/user/page',\n        method: 'get',\n        params: query,\n        baseurl: 'https://www.iocoder.cn' // 自定义\n    })\n}\n\n\n\n# 3. component 组件\n\n① 在 @/components 目录下，实现全局组件，被所有模块所公用。例如说，富文本编辑器、各种各搜索组件、封装的分页组件等等。\n\n\n\n② 每个模块的业务组件，可实现在 views 目录下，自己模块的目录的 components 目录下，避免单个 .vue 文件过大，降低维护成功。例如说，@/views/pay/app/components/xxx.vue。\n\n\n\n\n# 4. style 样式\n\n① 在 @/styles 目录下，实现全局样式，被所有页面所公用。\n\n\n\n② 每个 .vue 页面，可在 <style /> 标签中添加样式，注意需要添加 scoped 表示只作用在当前页面里，避免造成全局的样式污染。\n\n",
            charsets: {
                cjk: !0
            }
        }, {
            title: "Icon 图标",
            frontmatter: {
                title: "Icon 图标",
                date: "2022-04-17T21:52:05.000Z",
                permalink: "/vue2/icon"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/22.%E5%89%8D%E7%AB%AF%E6%89%8B%E5%86%8C%20Vue%202.x/03.Icon%20%E5%9B%BE%E6%A0%87.html",
            relativePath: "01.开发指南/22.前端手册 Vue 2.x/03.Icon 图标.md",
            key: "v-a2edb502",
            path: "/vue2/icon/",
            headers: [{
                level: 2,
                title: "1. 使用方式",
                slug: "_1-使用方式",
                normalizedTitle: "1. 使用方式",
                charIndex: 129
            }, {
                level: 2,
                title: "2. 自定义图标",
                slug: "_2-自定义图标",
                normalizedTitle: "2. 自定义图标",
                charIndex: 479
            }, {
                level: 2,
                title: "3. 改变颜色",
                slug: "_3-改变颜色",
                normalizedTitle: "3. 改变颜色",
                charIndex: 652
            }, {
                level: 2,
                title: "4. 离线 Icon 改造",
                slug: "_4-离线-icon-改造",
                normalizedTitle: "4. 离线 icon 改造",
                charIndex: 787
            }],
            headersStr: "1. 使用方式 2. 自定义图标 3. 改变颜色 4. 离线 Icon 改造",
            content: 'Element UI 内置多种 Icon 图标，可参考 Element Icon 图标 的文档。\n\n在项目的 /src/assets/icons/svg 目录下，自定义了 Icon 图标，默认注册到全局中，可以在项目中任意地方使用。如下图所示：\n\n\n\n\n# 1. 使用方式\n\n\x3c!-- 示例一：\n    icon-class 为 icon 的名字\n    class-name 为 icon 的自定义 class\n--\x3e\n<svg-icon icon-class="password" class-name=\'custom-class\' />\n\n\x3c!-- 示例二：\n    icon 为 Element UI 的图标\n--\x3e\n<el-button icon="el-icon-plus">新增</el-button>\n\n\x3c!-- 示例三：结合上述两示例 --\x3e\n<el-button>\n    <svg-icon icon-class="password" class-name=\'custom-class\' /> 新增\n</el-button>\n\n\n\n# 2. 自定义图标\n\n① 访问 https://www.iconfont.cn/ 地址，搜索你想要的图标，下载 SVG 格式。如下图所示：\n\n友情提示：其它 SVG 图标网站也可以。\n\n\n\n② 将 SVG 图标添加到 @/icons/svg 目录下，然后进行使用。\n\n<svg-icon icon-class="helpless" />\n\n\n\n# 3. 改变颜色\n\n<svg-icon /> 默认会读取其父级的 color fill: currentColor; 。\n\n你可以改变父级的 color ，或者直接改变 fill 的颜色即可。\n\n疑问：\n\n如果你遇到图标颜色不对，可以参照本 issue 进行修改\n\n\n# 4. 离线 Icon 改造\n\n参考 https://t.zsxq.com/gOKlQ 文档。',
            normalizedContent: 'element ui 内置多种 icon 图标，可参考 element icon 图标 的文档。\n\n在项目的 /src/assets/icons/svg 目录下，自定义了 icon 图标，默认注册到全局中，可以在项目中任意地方使用。如下图所示：\n\n\n\n\n# 1. 使用方式\n\n\x3c!-- 示例一：\n    icon-class 为 icon 的名字\n    class-name 为 icon 的自定义 class\n--\x3e\n<svg-icon icon-class="password" class-name=\'custom-class\' />\n\n\x3c!-- 示例二：\n    icon 为 element ui 的图标\n--\x3e\n<el-button icon="el-icon-plus">新增</el-button>\n\n\x3c!-- 示例三：结合上述两示例 --\x3e\n<el-button>\n    <svg-icon icon-class="password" class-name=\'custom-class\' /> 新增\n</el-button>\n\n\n\n# 2. 自定义图标\n\n① 访问 https://www.iconfont.cn/ 地址，搜索你想要的图标，下载 svg 格式。如下图所示：\n\n友情提示：其它 svg 图标网站也可以。\n\n\n\n② 将 svg 图标添加到 @/icons/svg 目录下，然后进行使用。\n\n<svg-icon icon-class="helpless" />\n\n\n\n# 3. 改变颜色\n\n<svg-icon /> 默认会读取其父级的 color fill: currentcolor; 。\n\n你可以改变父级的 color ，或者直接改变 fill 的颜色即可。\n\n疑问：\n\n如果你遇到图标颜色不对，可以参照本 issue 进行修改\n\n\n# 4. 离线 icon 改造\n\n参考 https://t.zsxq.com/goklq 文档。',
            charsets: {
                cjk: !0
            }
        }, {
            title: "系统组件",
            frontmatter: {
                title: "系统组件",
                date: "2022-04-18T01:10:07.000Z",
                permalink: "/vue2/components"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/22.%E5%89%8D%E7%AB%AF%E6%89%8B%E5%86%8C%20Vue%202.x/05.%E7%B3%BB%E7%BB%9F%E7%BB%84%E4%BB%B6.html",
            relativePath: "01.开发指南/22.前端手册 Vue 2.x/05.系统组件.md",
            key: "v-ba868b3a",
            path: "/vue2/components/",
            headers: [{
                level: 2,
                title: "1. 引入三方组件",
                slug: "_1-引入三方组件",
                normalizedTitle: "1. 引入三方组件",
                charIndex: 2
            }, {
                level: 3,
                title: "1.1 如何安装",
                slug: "_1-1-如何安装",
                normalizedTitle: "1.1 如何安装",
                charIndex: 60
            }, {
                level: 3,
                title: "1.2 如何注册",
                slug: "_1-2-如何注册",
                normalizedTitle: "1.2 如何注册",
                charIndex: 189
            }, {
                level: 2,
                title: "2. 系统组件",
                slug: "_2-系统组件",
                normalizedTitle: "2. 系统组件",
                charIndex: 827
            }, {
                level: 3,
                title: "2.1 基础框架组件",
                slug: "_2-1-基础框架组件",
                normalizedTitle: "2.1 基础框架组件",
                charIndex: 852
            }, {
                level: 3,
                title: "2.2 树形选择组件",
                slug: "_2-2-树形选择组件",
                normalizedTitle: "2.2 树形选择组件",
                charIndex: 898
            }, {
                level: 3,
                title: "2.3 表格分页组件",
                slug: "_2-3-表格分页组件",
                normalizedTitle: "2.3 表格分页组件",
                charIndex: 1144
            }, {
                level: 3,
                title: "2.4 工具栏右侧组件",
                slug: "_2-4-工具栏右侧组件",
                normalizedTitle: "2.4 工具栏右侧组件",
                charIndex: 1373
            }, {
                level: 3,
                title: "2.5 文件上传组件",
                slug: "_2-5-文件上传组件",
                normalizedTitle: "2.5 文件上传组件",
                charIndex: 1519
            }, {
                level: 3,
                title: "2.6 图片上传组件",
                slug: "_2-6-图片上传组件",
                normalizedTitle: "2.6 图片上传组件",
                charIndex: 1547
            }, {
                level: 3,
                title: "2.7 富文本编辑器",
                slug: "_2-7-富文本编辑器",
                normalizedTitle: "2.7 富文本编辑器",
                charIndex: 1605
            }, {
                level: 3,
                title: "2.8 表单设计组件",
                slug: "_2-8-表单设计组件",
                normalizedTitle: "2.8 表单设计组件",
                charIndex: 1770
            }, {
                level: 3,
                title: "2.9 工作流组件",
                slug: "_2-9-工作流组件",
                normalizedTitle: "2.9 工作流组件",
                charIndex: 2006
            }, {
                level: 3,
                title: "2.10 Cron 表达式组件",
                slug: "_2-10-cron-表达式组件",
                normalizedTitle: "2.10 cron 表达式组件",
                charIndex: 2766
            }, {
                level: 3,
                title: "2.11 内容复制组件",
                slug: "_2-11-内容复制组件",
                normalizedTitle: "2.11 内容复制组件",
                charIndex: 2933
            }, {
                level: 2,
                title: "3. 其它推荐组件",
                slug: "_3-其它推荐组件",
                normalizedTitle: "3. 其它推荐组件",
                charIndex: 3184
            }, {
                level: 2,
                title: "4. 自定义组件",
                slug: "_4-自定义组件",
                normalizedTitle: "4. 自定义组件",
                charIndex: 3347
            }, {
                level: 3,
                title: "4.1 创建使用",
                slug: "_4-1-创建使用",
                normalizedTitle: "4.1 创建使用",
                charIndex: 3414
            }, {
                level: 3,
                title: "4.2 组件通信",
                slug: "_4-2-组件通信",
                normalizedTitle: "4.2 组件通信",
                charIndex: 3845
            }],
            headersStr: "1. 引入三方组件 1.1 如何安装 1.2 如何注册 2. 系统组件 2.1 基础框架组件 2.2 树形选择组件 2.3 表格分页组件 2.4 工具栏右侧组件 2.5 文件上传组件 2.6 图片上传组件 2.7 富文本编辑器 2.8 表单设计组件 2.9 工作流组件 2.10 Cron 表达式组件 2.11 内容复制组件 3. 其它推荐组件 4. 自定义组件 4.1 创建使用 4.2 组件通信",
            content: '# 1. 引入三方组件\n\n除了 Element UI 组件以及项目内置的系统组件，有时还需要引入其它三方组件。\n\n\n# 1.1 如何安装\n\n这里，以引入 vue-count-to 为例。在终端输入下面的命令完成安装：\n\n## 加上 --save 参数，会自动添加依赖到 package.json 中去。\nnpm install vue-count-to --save\n\n\n\n# 1.2 如何注册\n\nVue 注册组件有两种方式：全局注册、局部注册。\n\n# 1.2.1 局部注册\n\n在对应的 Vue 页面中，使用 components 属性来注册组件。代码如下：\n\n<template>\n  <countTo :startVal=\'startVal\' :endVal=\'endVal\' :duration=\'3000\'></countTo>\n</template>\n\n<script>\nimport countTo from \'vue-count-to\';\nexport default {\n  components: { countTo }, // components 属性\n  data () {\n    return {\n      startVal: 0,\n      endVal: 2017\n    }\n  }\n}\n<\/script>\n\n\n# 1.2.2 全局注册\n\n① 在 main.js 中，全局注册组件。代码如下：\n\nimport countTo from \'vue-count-to\'\nVue.component(\'countTo\', countTo)\n\n\n② 在对应的 Vue 页面中，直接使用组件，无需注册。代码如下：\n\n<template>\n  <countTo :startVal=\'startVal\' :endVal=\'endVal\' :duration=\'3000\'></countTo>\n</template>\n\n\n\n# 2. 系统组件\n\n项目使用到的相关组件。\n\n\n# 2.1 基础框架组件\n\nelement-ui\n\nvue-element-admin\n\n\n# 2.2 树形选择组件\n\nvue-treeselect\n\n在 menu/index.vue 的使用案例：\n\n<el-form-item label="上级菜单">\n  <treeselect v-model="form.parentId" :options="menuOptions" :normalizer="normalizer" :show-count="true"\n              placeholder="选择上级菜单"/>\n</el-form-item>\n\n\n\n\n\n# 2.3 表格分页组件\n\nel-pagination，二次封装成 pagination 组件。\n\n在 notice/index.vue 的使用案例：\n\n<pagination v-show="total>0" :total="total" :page.sync="queryParams.pageNo" :limit.sync="queryParams.pageSize"\n            @pagination="getList"/>\n\n\n\n\n\n# 2.4 工具栏右侧组件\n\nright-toolbar\n\n在 notice/index.vue 的使用案例：\n\n<right-toolbar :showSearch.sync="showSearch" @queryTable="getList"></right-toolbar>\n\n\n\n\n\n# 2.5 文件上传组件\n\nfile-upload\n\n\n# 2.6 图片上传组件\n\n图片上传组件 image-upload\n\n图片预览组件 image-preview\n\n\n# 2.7 富文本编辑器\n\nquill，二次封装成 Editor 组件。\n\n在 notice/index.vue 的使用案例：\n\n<el-form-item label="内容">\n  <editor v-model="form.content" :min-height="192"/>\n</el-form-item>\n\n\n\n\n\n# 2.8 表单设计组件\n\n① 表单设计组件 form-generator\n\n在 build/index.vue 中使用，效果如下图：\n\n\n\n② 表单展示组件 parser，基于 form-generator 封装。\n\n在 processInstance/create.vue 的使用案例：\n\n<parser :key="new Date().getTime()" :form-conf="detailForm" @submit="submitForm" />\n\n\n\n\n\n# 2.9 工作流组件\n\nbpmn-process-designer，二次封装成 bpmnProcessDesigner 工作流设计组件\n\n① 工作流设计组件 my-process-designer，在 bpm/model/modelEditor.vue 中使用案例：\n\n\x3c!-- 流程设计器，负责绘制流程等 --\x3e\n<my-process-designer :key="`designer-${reloadIndex}`" v-model="xmlString" v-bind="controlForm"\n  keyboard ref="processDesigner" @init-finished="initModeler"\n  @save="save"/>\n\n\x3c!-- 流程属性器，负责编辑每个流程节点的属性 --\x3e\n<my-properties-panel :key="`penal-${reloadIndex}`" :bpmn-modeler="modeler" :prefix="controlForm.prefix" class="process-panel"\n  :model="model" />\n\n\n\n\n② 工作流展示组件 my-process-viewer，在 bpm/model/modelEditor.vue 中使用案例：\n\n<my-process-viewer key="designer" v-model="bpmnXML" v-bind="bpmnControlForm" :activityData="activityList"\n            :processInstanceData="processInstance" :taskData="tasks" />\n\n\n\n\n\n# 2.10 Cron 表达式组件\n\nvue-crontab，二次封装成 crontab 组件。\n\n在 job/index.vue 的使用案例：\n\n<crontab @hide="openCron=false" @fill="crontabFill" :expression="expression"></crontab>\n\n\n\n\n\n# 2.11 内容复制组件\n\nclipboard，使用可见 文档。\n\n在 codegen/index.vue 的使用案例：\n\n<el-link :underline="false" icon="el-icon-document-copy" style="float:right"\n         v-clipboard:copy="item.code" \n         v-clipboard:success="clipboardSuccess">\n    复制\n</el-link>\n\n\n\n\n\n# 3. 其它推荐组件\n\n推荐一些其它组件，可自己引入后使用。\n\n * Tree Table 树形表格：使用文档\n * Excel 前端直接导出：使用文档\n * CodeMirror 代码编辑器：使用文档\n * wangEditor 文本编辑器：使用文档\n * mavonEditor Markdown 编辑器：使用文档\n\n\n# 4. 自定义组件\n\n在 @/components 目录下，创建 .vue 文件，在通过 components 进行注册即可。\n\n\n# 4.1 创建使用\n\n新建一个简单的 a 组件来举例子。\n\n① 在 @/components/ 目录下，创建 test 文件，再创建 a.vue 文件。代码如下：\n\n\x3c!-- 子组件 --\x3e\n<template>\n  <div>这是a组件</div>\n</template>\n\n\n② 在其它 Vue 页面，导入并注册后使用。代码如下：\n\n\x3c!-- 父组件 --\x3e\n<template>\n  <div style="text-align: center; font-size: 20px">\n    测试页面\n    <testa></testa> \x3c!-- 3. 使用 --\x3e\n  </div>\n</template>\n\n<script>\nimport a from "@/components/a"; // 1. 引入\nexport default {\n  components: { testa: a } // 2. 注册\n};\n<\/script>\n\n\n\n# 4.2 组件通信\n\n基于上述的 a 示例组件，讲解父子组件如何通信。\n\n① 子组件通过 props 属性，来接收父组件传递的值。代码如下：\n\n\x3c!-- 子组件 --\x3e\n<template>\n    <div>这是a组件 name:{{ name }}</div>\n</template>\n\n<script>\n    export default {\n        props: { // 1. props 的 name 进行接收\n            name: {\n                type: String,\n                default: ""\n            },\n        }\n    };\n<\/script>\n\n\x3c!-- 父组件 --\x3e\n<template>\n  <div style="text-align: center; font-size: 20px">\n    测试页面\n    <testa :name="name"></testa> \x3c!-- 2. :name 传入 --\x3e\n  </div>\n</template>\n\n<script>\nimport a from "@/components/a";\n\nexport default {\n  components: { testa: a },\n  data() {\n    return {\n      name: "芋道"\n    };\n  },\n};\n<\/script>\n\n\n② 子组件通过 $emit 方法，让父组件监听到自定义事件。代码如下：\n\n\x3c!-- 子组件 --\x3e\n<template>\n  <div>\n    这是a组件 name:{{ name }}\n    <button @click="click">发送</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    name: {\n      type: String,\n      default: ""\n    },\n  },\n  data() {\n    return {\n      message: "我是来自子组件的消息"\n    };\n  },\n  methods: {\n    click() {\n      this.$emit("ok", this.message); // 1. $emit 方法，通知 ok 事件，message 是参数\n    },\n  },\n};\n<\/script>\n\n\x3c!-- 父组件 --\x3e\n<template>\n    <div style="text-align: center; font-size: 20px">\n        测试页面\n        <testa :name="name" @ok="ok"></testa>\n        子组件传来的值 : {{ message }}\n    </div>\n</template>\n\n<script>\nimport a from "@/components/a";\n\nexport default {\n    components: { testa: a },\n    data() {\n        return {\n            name: "芋道",\n            message: ""\n        };\n    },\n    methods: {\n        ok(message) { // 2. 声明 ok 方法，监听 ok 自定义事件\n            this.message = message;\n        },\n    },\n};\n<\/script>\n',
            normalizedContent: '# 1. 引入三方组件\n\n除了 element ui 组件以及项目内置的系统组件，有时还需要引入其它三方组件。\n\n\n# 1.1 如何安装\n\n这里，以引入 vue-count-to 为例。在终端输入下面的命令完成安装：\n\n## 加上 --save 参数，会自动添加依赖到 package.json 中去。\nnpm install vue-count-to --save\n\n\n\n# 1.2 如何注册\n\nvue 注册组件有两种方式：全局注册、局部注册。\n\n# 1.2.1 局部注册\n\n在对应的 vue 页面中，使用 components 属性来注册组件。代码如下：\n\n<template>\n  <countto :startval=\'startval\' :endval=\'endval\' :duration=\'3000\'></countto>\n</template>\n\n<script>\nimport countto from \'vue-count-to\';\nexport default {\n  components: { countto }, // components 属性\n  data () {\n    return {\n      startval: 0,\n      endval: 2017\n    }\n  }\n}\n<\/script>\n\n\n# 1.2.2 全局注册\n\n① 在 main.js 中，全局注册组件。代码如下：\n\nimport countto from \'vue-count-to\'\nvue.component(\'countto\', countto)\n\n\n② 在对应的 vue 页面中，直接使用组件，无需注册。代码如下：\n\n<template>\n  <countto :startval=\'startval\' :endval=\'endval\' :duration=\'3000\'></countto>\n</template>\n\n\n\n# 2. 系统组件\n\n项目使用到的相关组件。\n\n\n# 2.1 基础框架组件\n\nelement-ui\n\nvue-element-admin\n\n\n# 2.2 树形选择组件\n\nvue-treeselect\n\n在 menu/index.vue 的使用案例：\n\n<el-form-item label="上级菜单">\n  <treeselect v-model="form.parentid" :options="menuoptions" :normalizer="normalizer" :show-count="true"\n              placeholder="选择上级菜单"/>\n</el-form-item>\n\n\n\n\n\n# 2.3 表格分页组件\n\nel-pagination，二次封装成 pagination 组件。\n\n在 notice/index.vue 的使用案例：\n\n<pagination v-show="total>0" :total="total" :page.sync="queryparams.pageno" :limit.sync="queryparams.pagesize"\n            @pagination="getlist"/>\n\n\n\n\n\n# 2.4 工具栏右侧组件\n\nright-toolbar\n\n在 notice/index.vue 的使用案例：\n\n<right-toolbar :showsearch.sync="showsearch" @querytable="getlist"></right-toolbar>\n\n\n\n\n\n# 2.5 文件上传组件\n\nfile-upload\n\n\n# 2.6 图片上传组件\n\n图片上传组件 image-upload\n\n图片预览组件 image-preview\n\n\n# 2.7 富文本编辑器\n\nquill，二次封装成 editor 组件。\n\n在 notice/index.vue 的使用案例：\n\n<el-form-item label="内容">\n  <editor v-model="form.content" :min-height="192"/>\n</el-form-item>\n\n\n\n\n\n# 2.8 表单设计组件\n\n① 表单设计组件 form-generator\n\n在 build/index.vue 中使用，效果如下图：\n\n\n\n② 表单展示组件 parser，基于 form-generator 封装。\n\n在 processinstance/create.vue 的使用案例：\n\n<parser :key="new date().gettime()" :form-conf="detailform" @submit="submitform" />\n\n\n\n\n\n# 2.9 工作流组件\n\nbpmn-process-designer，二次封装成 bpmnprocessdesigner 工作流设计组件\n\n① 工作流设计组件 my-process-designer，在 bpm/model/modeleditor.vue 中使用案例：\n\n\x3c!-- 流程设计器，负责绘制流程等 --\x3e\n<my-process-designer :key="`designer-${reloadindex}`" v-model="xmlstring" v-bind="controlform"\n  keyboard ref="processdesigner" @init-finished="initmodeler"\n  @save="save"/>\n\n\x3c!-- 流程属性器，负责编辑每个流程节点的属性 --\x3e\n<my-properties-panel :key="`penal-${reloadindex}`" :bpmn-modeler="modeler" :prefix="controlform.prefix" class="process-panel"\n  :model="model" />\n\n\n\n\n② 工作流展示组件 my-process-viewer，在 bpm/model/modeleditor.vue 中使用案例：\n\n<my-process-viewer key="designer" v-model="bpmnxml" v-bind="bpmncontrolform" :activitydata="activitylist"\n            :processinstancedata="processinstance" :taskdata="tasks" />\n\n\n\n\n\n# 2.10 cron 表达式组件\n\nvue-crontab，二次封装成 crontab 组件。\n\n在 job/index.vue 的使用案例：\n\n<crontab @hide="opencron=false" @fill="crontabfill" :expression="expression"></crontab>\n\n\n\n\n\n# 2.11 内容复制组件\n\nclipboard，使用可见 文档。\n\n在 codegen/index.vue 的使用案例：\n\n<el-link :underline="false" icon="el-icon-document-copy" style="float:right"\n         v-clipboard:copy="item.code" \n         v-clipboard:success="clipboardsuccess">\n    复制\n</el-link>\n\n\n\n\n\n# 3. 其它推荐组件\n\n推荐一些其它组件，可自己引入后使用。\n\n * tree table 树形表格：使用文档\n * excel 前端直接导出：使用文档\n * codemirror 代码编辑器：使用文档\n * wangeditor 文本编辑器：使用文档\n * mavoneditor markdown 编辑器：使用文档\n\n\n# 4. 自定义组件\n\n在 @/components 目录下，创建 .vue 文件，在通过 components 进行注册即可。\n\n\n# 4.1 创建使用\n\n新建一个简单的 a 组件来举例子。\n\n① 在 @/components/ 目录下，创建 test 文件，再创建 a.vue 文件。代码如下：\n\n\x3c!-- 子组件 --\x3e\n<template>\n  <div>这是a组件</div>\n</template>\n\n\n② 在其它 vue 页面，导入并注册后使用。代码如下：\n\n\x3c!-- 父组件 --\x3e\n<template>\n  <div style="text-align: center; font-size: 20px">\n    测试页面\n    <testa></testa> \x3c!-- 3. 使用 --\x3e\n  </div>\n</template>\n\n<script>\nimport a from "@/components/a"; // 1. 引入\nexport default {\n  components: { testa: a } // 2. 注册\n};\n<\/script>\n\n\n\n# 4.2 组件通信\n\n基于上述的 a 示例组件，讲解父子组件如何通信。\n\n① 子组件通过 props 属性，来接收父组件传递的值。代码如下：\n\n\x3c!-- 子组件 --\x3e\n<template>\n    <div>这是a组件 name:{{ name }}</div>\n</template>\n\n<script>\n    export default {\n        props: { // 1. props 的 name 进行接收\n            name: {\n                type: string,\n                default: ""\n            },\n        }\n    };\n<\/script>\n\n\x3c!-- 父组件 --\x3e\n<template>\n  <div style="text-align: center; font-size: 20px">\n    测试页面\n    <testa :name="name"></testa> \x3c!-- 2. :name 传入 --\x3e\n  </div>\n</template>\n\n<script>\nimport a from "@/components/a";\n\nexport default {\n  components: { testa: a },\n  data() {\n    return {\n      name: "芋道"\n    };\n  },\n};\n<\/script>\n\n\n② 子组件通过 $emit 方法，让父组件监听到自定义事件。代码如下：\n\n\x3c!-- 子组件 --\x3e\n<template>\n  <div>\n    这是a组件 name:{{ name }}\n    <button @click="click">发送</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    name: {\n      type: string,\n      default: ""\n    },\n  },\n  data() {\n    return {\n      message: "我是来自子组件的消息"\n    };\n  },\n  methods: {\n    click() {\n      this.$emit("ok", this.message); // 1. $emit 方法，通知 ok 事件，message 是参数\n    },\n  },\n};\n<\/script>\n\n\x3c!-- 父组件 --\x3e\n<template>\n    <div style="text-align: center; font-size: 20px">\n        测试页面\n        <testa :name="name" @ok="ok"></testa>\n        子组件传来的值 : {{ message }}\n    </div>\n</template>\n\n<script>\nimport a from "@/components/a";\n\nexport default {\n    components: { testa: a },\n    data() {\n        return {\n            name: "芋道",\n            message: ""\n        };\n    },\n    methods: {\n        ok(message) { // 2. 声明 ok 方法，监听 ok 自定义事件\n            this.message = message;\n        },\n    },\n};\n<\/script>\n',
            charsets: {
                cjk: !0
            }
        }, {
            title: "菜单路由",
            frontmatter: {
                title: "菜单路由",
                date: "2022-04-17T21:50:06.000Z",
                permalink: "/vue2/route"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/22.%E5%89%8D%E7%AB%AF%E6%89%8B%E5%86%8C%20Vue%202.x/02.%E8%8F%9C%E5%8D%95%E8%B7%AF%E7%94%B1.html",
            relativePath: "01.开发指南/22.前端手册 Vue 2.x/02.菜单路由.md",
            key: "v-444a0f87",
            path: "/vue2/route/",
            headers: [{
                level: 2,
                title: "1. 路由配置",
                slug: "_1-路由配置",
                normalizedTitle: "1. 路由配置",
                charIndex: 169
            }, {
                level: 2,
                title: "2. 路由",
                slug: "_2-路由",
                normalizedTitle: "2. 路由",
                charIndex: 1589
            }, {
                level: 3,
                title: "2.1 静态路由",
                slug: "_2-1-静态路由",
                normalizedTitle: "2.1 静态路由",
                charIndex: 1621
            }, {
                level: 3,
                title: "2.2 动态路由",
                slug: "_2-2-动态路由",
                normalizedTitle: "2.2 动态路由",
                charIndex: 1736
            }, {
                level: 3,
                title: "2.3 路由跳转",
                slug: "_2-3-路由跳转",
                normalizedTitle: "2.3 路由跳转",
                charIndex: 2067
            }, {
                level: 2,
                title: "3. 菜单管理",
                slug: "_3-菜单管理",
                normalizedTitle: "3. 菜单管理",
                charIndex: 2273
            }, {
                level: 3,
                title: "3.1 新增目录",
                slug: "_3-1-新增目录",
                normalizedTitle: "3.1 新增目录",
                charIndex: 2381
            }, {
                level: 3,
                title: "3.2 新增菜单",
                slug: "_3-2-新增菜单",
                normalizedTitle: "3.2 新增菜单",
                charIndex: 2441
            }, {
                level: 3,
                title: "3.3 新增按钮",
                slug: "_3-3-新增按钮",
                normalizedTitle: "3.3 新增按钮",
                charIndex: 2456
            }, {
                level: 2,
                title: "4. 权限控制",
                slug: "_4-权限控制",
                normalizedTitle: "4. 权限控制",
                charIndex: 2471
            }, {
                level: 3,
                title: "4.1 v-hasPermi 指令",
                slug: "_4-1-v-haspermi-指令",
                normalizedTitle: "4.1 v-haspermi 指令",
                charIndex: 2579
            }, {
                level: 3,
                title: "4.2 v-hasRole 指令",
                slug: "_4-2-v-hasrole-指令",
                normalizedTitle: "4.2 v-hasrole 指令",
                charIndex: 2832
            }, {
                level: 3,
                title: "4.3 结合 v-if 指令",
                slug: "_4-3-结合-v-if-指令",
                normalizedTitle: "4.3 结合 v-if 指令",
                charIndex: 3034
            }, {
                level: 2,
                title: "5. 页面缓存",
                slug: "_5-页面缓存",
                normalizedTitle: "5. 页面缓存",
                charIndex: 3765
            }, {
                level: 3,
                title: "5.1 静态路由的示例",
                slug: "_5-1-静态路由的示例",
                normalizedTitle: "5.1 静态路由的示例",
                charIndex: 4098
            }, {
                level: 3,
                title: "5.2 动态路由的示例",
                slug: "_5-2-动态路由的示例",
                normalizedTitle: "5.2 动态路由的示例",
                charIndex: 4411
            }],
            headersStr: "1. 路由配置 2. 路由 2.1 静态路由 2.2 动态路由 2.3 路由跳转 3. 菜单管理 3.1 新增目录 3.2 新增菜单 3.3 新增按钮 4. 权限控制 4.1 v-hasPermi 指令 4.2 v-hasRole 指令 4.3 结合 v-if 指令 5. 页面缓存 5.1 静态路由的示例 5.2 动态路由的示例",
            content: "前端项目基于 element-ui-admin 实现，它的 路由和侧边栏 是组织起一个后台应用的关键骨架。\n\n侧边栏和路由是绑定在一起的，所以你只有在 @/router/index.js 下面配置对应的路由，侧边栏就能动态的生成了，大大减轻了手动重复编辑侧边栏的工作量。\n\n当然，这样就需要在配置路由的时候，遵循一些约定的规则。\n\n\n# 1. 路由配置\n\n首先，我们了解一下本项目配置路由时，提供了哪些配置项：\n\n// 当设置 true 的时候该路由不会在侧边栏出现 如 401，login 等页面，或者如一些编辑页面 /edit/1\nhidden: true // (默认 false)\n\n// 当设置 noRedirect 的时候该路由在面包屑导航中不可被点击\nredirect: 'noRedirect'\n\n// 1. 当你一个路由下面的 children 声明的路由大于 1 个时，自动会变成嵌套的模式。例如说，组件页面\n// 2. 只有一个时，会将那个子路由当做根路由显示在侧边栏。例如说，如引导页面\n// 若你想不管路由下面的 children 声明的个数都显示你的根路由，\n// 你可以设置 alwaysShow: true，这样它就会忽略之前定义的规则，一直显示根路由\nalwaysShow: true\n\nname: 'router-name' // 设定路由的名字，一定要填写不然使用 <keep-alive> 时会出现各种问题\nmeta: {\n  roles: ['admin', 'editor'] // 设置该路由进入的权限，支持多个权限叠加\n  title: 'title' // 设置该路由在侧边栏和面包屑中展示的名字\n  icon: 'svg-name' // 设置该路由的图标，支持 svg-class，也支持 el-icon-x element-ui 的 icon\n  noCache: true // 如果设置为 true，则不会被 <keep-alive> 缓存(默认 false)\n  breadcrumb: false //  如果设置为 false，则不会在breadcrumb面包屑中显示(默认 true)\n  affix: true // 如果设置为 true，它则会固定在 tags-view 中(默认 false)\n\n  // 当路由设置了该属性，则会高亮相对应的侧边栏。\n  // 这在某些场景非常有用，比如：一个文章的列表页路由为：/article/list\n  // 点击文章进入文章详情页，这时候路由为 /article/1，但你想在侧边栏高亮文章列表的路由，就可以进行如下设置\n  activeMenu: '/article/list'\n}\n\n\n普通示例\n\n{\n  path: '/system/test',\n  component: Layout,\n  redirect: 'noRedirect',\n  hidden: false,\n  alwaysShow: true,\n  meta: { title: '系统管理', icon : \"system\" },\n  children: [{\n    path: 'index',\n    component: (resolve) => require(['@/views/index'], resolve),\n    name: 'Test',\n    meta: {\n      title: '测试管理',\n      icon: 'user'\n    }\n  }]\n}\n\n\n外链示例\n\n{\n  path: 'https://www.iocoder.cn',\n  meta: { title: '芋道源码', icon : \"guide\" }\n}\n\n\n\n# 2. 路由\n\n项目的路由分为两种：静态路由、动态路由。\n\n\n# 2.1 静态路由\n\n静态路由，代表那些不需要动态判断权限的路由，如登录页、404、个人中心等通用页面。\n\n在 @/router/index.js 的 constantRoutes，就是配置对应的公共路由。如下图所示：\n\n\n\n\n# 2.2 动态路由\n\n动态路由，代表那些需要根据用户动态判断权限，并通过 addRoutes 动态添加的页面，如用户管理、角色管理等功能页面。\n\n在用户登录成功后，会触发 @/store/modules/permission.js 请求后端的菜单 RESTful API 接口，获取用户有权限的菜单列表，并转化添加到路由中。如下图所示：\n\n\n\n友情提示：\n\n 1. 动态路由可以在 [系统管理 -> 菜单管理] 进行新增和修改操作，请求的后端 RESTful API 接口是 /admin-api/system/auth/get-permission-info\n 2. 动态路由在生产环境下会默认使用路由懒加载，实现方式参考 loadView 方法的判断\n\n\n# 2.3 路由跳转\n\n使用 router.push 方法，可以实现跳转到不同的页面。\n\n// 简单跳转\nthis.$router.push({ path: \"/system/user\" });\n\n// 跳转页面并设置请求参数，使用 `query` 属性\nthis.$router.push({ path: \"/system/user\", query: {id: \"1\", name: \"芋道\"} });\n\n\n\n# 3. 菜单管理\n\n项目的菜单在 [系统管理 -> 菜单管理] 进行管理，支持无限层级，提供目录、菜单、按钮三种类型。如下图所示：\n\n\n\n菜单可在 [系统管理 -> 角色管理] 被分配给角色。如下图所示：\n\n\n\n\n# 3.1 新增目录\n\n① 大多数情况下，目录是作为菜单的【分类】：\n\n\n\n② 目录也提供实现【外链】的能力：\n\n\n\n\n# 3.2 新增菜单\n\n\n\n\n# 3.3 新增按钮\n\n\n\n\n# 4. 权限控制\n\n前端通过权限控制，隐藏用户没有权限的按钮等，实现功能级别的权限。\n\n友情提示：前端的权限控制，主要是提升用户体验，避免操作后发现没有权限。\n\n最终在请求到后端时，还是会进行一次权限的校验。\n\n\n# 4.1 v-hasPermi 指令\n\nv-hasPermi 指令，基于权限字符，进行权限的控制。\n\n\x3c!-- 单个 --\x3e\n<el-button v-hasPermi=\"['system:user:create']\">存在权限字符串才能看到</el-button>\n\n\x3c!-- 多个，满足任一一个即可 --\x3e\n<el-button v-hasPermi=\"['system:user:create', 'system:user:update']\">包含权限字符串才能看到</el-button>\n\n\n\n# 4.2 v-hasRole 指令\n\nv-hasRole 指令，基于角色标识，机进行的控制。\n\n\x3c!-- 单个 --\x3e\n<el-button v-hasRole=\"['admin']\">管理员才能看到</el-button>\n\n\x3c!-- 多个，满足任一一个即可 --\x3e\n<el-button v-hasRole=\"['role1', 'role2']\">包含角色才能看到</el-button>\n\n\n\n# 4.3 结合 v-if 指令\n\n在某些情况下，它是不适合使用 v-hasPermi 或 v-hasRole 指令，如元素标签组件。此时，只能通过手动设置 v-if，通过使用全局权限判断函数，用法是基本一致的。\n\n<template>\n  <el-tabs>\n    <el-tab-pane v-if=\"checkPermi(['system:user:create'])\" label=\"用户管理\" name=\"user\">用户管理</el-tab-pane>\n    <el-tab-pane v-if=\"checkPermi(['system:user:create', 'system:user:update'])\" label=\"参数管理\" name=\"menu\">参数管理</el-tab-pane>\n    <el-tab-pane v-if=\"checkRole(['admin'])\" label=\"角色管理\" name=\"role\">角色管理</el-tab-pane>\n    <el-tab-pane v-if=\"checkRole(['admin','common'])\" label=\"定时任务\" name=\"job\">定时任务</el-tab-pane>\n   </el-tabs>\n</template>\n\n<script>\nimport { checkPermi, checkRole } from \"@/utils/permission\"; // 权限判断函数\n\nexport default{\n   methods: {\n    checkPermi,\n    checkRole\n  }\n}\n<\/script>\n\n\n\n# 5. 页面缓存\n\n由于目前 keep-alive 和 router-view 是强耦合的，而且查看 Vue 的文档和源码不难发现 keep-alive 的 include 默认是优先匹配组件的 name ，所以在编写路由 router 和路由对应的 view component 的时候一定要确保两者的 name 是完全一致的。\n\n注意，切记 view component 的 name 命名时候尽量保证唯一性，切记不要和某些组件的命名重复了，不然会递归引用最后内存溢出等问题。\n\n友情提示：页面缓存是什么？\n\n简单来说，Tab 切换时，开启页面缓存的 Tab 保持原本的状态，不进行刷新（不请求数据）。\n\n详细可见 Vue 文档 —— KeepAlive\n\n\n# 5.1 静态路由的示例\n\n① router 路由的 name 声明如下：\n\n{\n  path: 'create-form',\n  component: ()=>import('@/views/form/create'),\n  name: 'createForm',\n  meta: { title: 'createForm', icon: 'table' }\n}\n\n\n② view component 的 name 声明如下：\n\nexport default {\n  name: 'createForm'\n}\n\n\n一定要保证两者的名字相同，切记写重或者写错。默认如果不写 name 就不会被缓存，详情见 issue。\n\n\n# 5.2 动态路由的示例\n\n",
            normalizedContent: "前端项目基于 element-ui-admin 实现，它的 路由和侧边栏 是组织起一个后台应用的关键骨架。\n\n侧边栏和路由是绑定在一起的，所以你只有在 @/router/index.js 下面配置对应的路由，侧边栏就能动态的生成了，大大减轻了手动重复编辑侧边栏的工作量。\n\n当然，这样就需要在配置路由的时候，遵循一些约定的规则。\n\n\n# 1. 路由配置\n\n首先，我们了解一下本项目配置路由时，提供了哪些配置项：\n\n// 当设置 true 的时候该路由不会在侧边栏出现 如 401，login 等页面，或者如一些编辑页面 /edit/1\nhidden: true // (默认 false)\n\n// 当设置 noredirect 的时候该路由在面包屑导航中不可被点击\nredirect: 'noredirect'\n\n// 1. 当你一个路由下面的 children 声明的路由大于 1 个时，自动会变成嵌套的模式。例如说，组件页面\n// 2. 只有一个时，会将那个子路由当做根路由显示在侧边栏。例如说，如引导页面\n// 若你想不管路由下面的 children 声明的个数都显示你的根路由，\n// 你可以设置 alwaysshow: true，这样它就会忽略之前定义的规则，一直显示根路由\nalwaysshow: true\n\nname: 'router-name' // 设定路由的名字，一定要填写不然使用 <keep-alive> 时会出现各种问题\nmeta: {\n  roles: ['admin', 'editor'] // 设置该路由进入的权限，支持多个权限叠加\n  title: 'title' // 设置该路由在侧边栏和面包屑中展示的名字\n  icon: 'svg-name' // 设置该路由的图标，支持 svg-class，也支持 el-icon-x element-ui 的 icon\n  nocache: true // 如果设置为 true，则不会被 <keep-alive> 缓存(默认 false)\n  breadcrumb: false //  如果设置为 false，则不会在breadcrumb面包屑中显示(默认 true)\n  affix: true // 如果设置为 true，它则会固定在 tags-view 中(默认 false)\n\n  // 当路由设置了该属性，则会高亮相对应的侧边栏。\n  // 这在某些场景非常有用，比如：一个文章的列表页路由为：/article/list\n  // 点击文章进入文章详情页，这时候路由为 /article/1，但你想在侧边栏高亮文章列表的路由，就可以进行如下设置\n  activemenu: '/article/list'\n}\n\n\n普通示例\n\n{\n  path: '/system/test',\n  component: layout,\n  redirect: 'noredirect',\n  hidden: false,\n  alwaysshow: true,\n  meta: { title: '系统管理', icon : \"system\" },\n  children: [{\n    path: 'index',\n    component: (resolve) => require(['@/views/index'], resolve),\n    name: 'test',\n    meta: {\n      title: '测试管理',\n      icon: 'user'\n    }\n  }]\n}\n\n\n外链示例\n\n{\n  path: 'https://www.iocoder.cn',\n  meta: { title: '芋道源码', icon : \"guide\" }\n}\n\n\n\n# 2. 路由\n\n项目的路由分为两种：静态路由、动态路由。\n\n\n# 2.1 静态路由\n\n静态路由，代表那些不需要动态判断权限的路由，如登录页、404、个人中心等通用页面。\n\n在 @/router/index.js 的 constantroutes，就是配置对应的公共路由。如下图所示：\n\n\n\n\n# 2.2 动态路由\n\n动态路由，代表那些需要根据用户动态判断权限，并通过 addroutes 动态添加的页面，如用户管理、角色管理等功能页面。\n\n在用户登录成功后，会触发 @/store/modules/permission.js 请求后端的菜单 restful api 接口，获取用户有权限的菜单列表，并转化添加到路由中。如下图所示：\n\n\n\n友情提示：\n\n 1. 动态路由可以在 [系统管理 -> 菜单管理] 进行新增和修改操作，请求的后端 restful api 接口是 /admin-api/system/auth/get-permission-info\n 2. 动态路由在生产环境下会默认使用路由懒加载，实现方式参考 loadview 方法的判断\n\n\n# 2.3 路由跳转\n\n使用 router.push 方法，可以实现跳转到不同的页面。\n\n// 简单跳转\nthis.$router.push({ path: \"/system/user\" });\n\n// 跳转页面并设置请求参数，使用 `query` 属性\nthis.$router.push({ path: \"/system/user\", query: {id: \"1\", name: \"芋道\"} });\n\n\n\n# 3. 菜单管理\n\n项目的菜单在 [系统管理 -> 菜单管理] 进行管理，支持无限层级，提供目录、菜单、按钮三种类型。如下图所示：\n\n\n\n菜单可在 [系统管理 -> 角色管理] 被分配给角色。如下图所示：\n\n\n\n\n# 3.1 新增目录\n\n① 大多数情况下，目录是作为菜单的【分类】：\n\n\n\n② 目录也提供实现【外链】的能力：\n\n\n\n\n# 3.2 新增菜单\n\n\n\n\n# 3.3 新增按钮\n\n\n\n\n# 4. 权限控制\n\n前端通过权限控制，隐藏用户没有权限的按钮等，实现功能级别的权限。\n\n友情提示：前端的权限控制，主要是提升用户体验，避免操作后发现没有权限。\n\n最终在请求到后端时，还是会进行一次权限的校验。\n\n\n# 4.1 v-haspermi 指令\n\nv-haspermi 指令，基于权限字符，进行权限的控制。\n\n\x3c!-- 单个 --\x3e\n<el-button v-haspermi=\"['system:user:create']\">存在权限字符串才能看到</el-button>\n\n\x3c!-- 多个，满足任一一个即可 --\x3e\n<el-button v-haspermi=\"['system:user:create', 'system:user:update']\">包含权限字符串才能看到</el-button>\n\n\n\n# 4.2 v-hasrole 指令\n\nv-hasrole 指令，基于角色标识，机进行的控制。\n\n\x3c!-- 单个 --\x3e\n<el-button v-hasrole=\"['admin']\">管理员才能看到</el-button>\n\n\x3c!-- 多个，满足任一一个即可 --\x3e\n<el-button v-hasrole=\"['role1', 'role2']\">包含角色才能看到</el-button>\n\n\n\n# 4.3 结合 v-if 指令\n\n在某些情况下，它是不适合使用 v-haspermi 或 v-hasrole 指令，如元素标签组件。此时，只能通过手动设置 v-if，通过使用全局权限判断函数，用法是基本一致的。\n\n<template>\n  <el-tabs>\n    <el-tab-pane v-if=\"checkpermi(['system:user:create'])\" label=\"用户管理\" name=\"user\">用户管理</el-tab-pane>\n    <el-tab-pane v-if=\"checkpermi(['system:user:create', 'system:user:update'])\" label=\"参数管理\" name=\"menu\">参数管理</el-tab-pane>\n    <el-tab-pane v-if=\"checkrole(['admin'])\" label=\"角色管理\" name=\"role\">角色管理</el-tab-pane>\n    <el-tab-pane v-if=\"checkrole(['admin','common'])\" label=\"定时任务\" name=\"job\">定时任务</el-tab-pane>\n   </el-tabs>\n</template>\n\n<script>\nimport { checkpermi, checkrole } from \"@/utils/permission\"; // 权限判断函数\n\nexport default{\n   methods: {\n    checkpermi,\n    checkrole\n  }\n}\n<\/script>\n\n\n\n# 5. 页面缓存\n\n由于目前 keep-alive 和 router-view 是强耦合的，而且查看 vue 的文档和源码不难发现 keep-alive 的 include 默认是优先匹配组件的 name ，所以在编写路由 router 和路由对应的 view component 的时候一定要确保两者的 name 是完全一致的。\n\n注意，切记 view component 的 name 命名时候尽量保证唯一性，切记不要和某些组件的命名重复了，不然会递归引用最后内存溢出等问题。\n\n友情提示：页面缓存是什么？\n\n简单来说，tab 切换时，开启页面缓存的 tab 保持原本的状态，不进行刷新（不请求数据）。\n\n详细可见 vue 文档 —— keepalive\n\n\n# 5.1 静态路由的示例\n\n① router 路由的 name 声明如下：\n\n{\n  path: 'create-form',\n  component: ()=>import('@/views/form/create'),\n  name: 'createform',\n  meta: { title: 'createform', icon: 'table' }\n}\n\n\n② view component 的 name 声明如下：\n\nexport default {\n  name: 'createform'\n}\n\n\n一定要保证两者的名字相同，切记写重或者写错。默认如果不写 name 就不会被缓存，详情见 issue。\n\n\n# 5.2 动态路由的示例\n\n",
            charsets: {
                cjk: !0
            }
        }, {
            title: "字典数据",
            frontmatter: {
                title: "字典数据",
                date: "2022-04-17T22:48:10.000Z",
                permalink: "/vue2/dict"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/22.%E5%89%8D%E7%AB%AF%E6%89%8B%E5%86%8C%20Vue%202.x/04.%E5%AD%97%E5%85%B8%E6%95%B0%E6%8D%AE.html",
            relativePath: "01.开发指南/22.前端手册 Vue 2.x/04.字典数据.md",
            key: "v-be4c250a",
            path: "/vue2/dict/",
            headers: [{
                level: 2,
                title: "1. 全局缓存",
                slug: "_1-全局缓存",
                normalizedTitle: "1. 全局缓存",
                charIndex: 72
            }, {
                level: 2,
                title: "2. DICT_TYPE",
                slug: "_2-dict-type",
                normalizedTitle: "2. dict_type",
                charIndex: 209
            }, {
                level: 2,
                title: "3. DictTag 字典标签",
                slug: "_3-dicttag-字典标签",
                normalizedTitle: "3. dicttag 字典标签",
                charIndex: 300
            }, {
                level: 2,
                title: "4. 字典工具类",
                slug: "_4-字典工具类",
                normalizedTitle: "4. 字典工具类",
                charIndex: 502
            }],
            headersStr: "1. 全局缓存 2. DICT_TYPE 3. DictTag 字典标签 4. 字典工具类",
            content: '本小节，讲解前端如何使用 [系统管理 -> 字典管理] 菜单的字典数据，例如说字典数据的下拉框、单选 / 多选按钮、高亮展示等等。\n\n\n\n\n# 1. 全局缓存\n\n用户登录成功后，前端会从后端获取到全量的字典数据，缓存在 store 中。如下图所示：\n\n\n\n这样，前端在使用到字典数据时，无需重复请求后端，提升用户体验。\n\n不过，缓存暂时未提供刷新，所以在字典数据发生变化时，需要用户刷新浏览器，进行重新加载。\n\n\n# 2. DICT_TYPE\n\n在 dict.js 文件中，使用 DICT_TYPE 枚举了字典的 KEY。如下图所示：\n\n\n\n后续如果有新的字典 KEY，需要你自己进行添加。\n\n\n# 3. DictTag 字典标签\n\n<dict-tag /> 组件，翻译字段对应的字典展示文本，并根据 colorType、cssClass 进行高亮。使用示例如下：\n\n\x3c!--\n    type: 字典 KEY\n    value: 字典值\n--\x3e\n<dict-tag :type="DICT_TYPE.SYSTEM_LOGIN_TYPE" :value="row.logType" />\n\n\n\n\n\n# 4. 字典工具类\n\n在 dict.js 文件中，提供了字典工具类，方法如下：\n\n// 获取 dictType 对应的数据字典数组\nexport function getDictDatas(dictType) { /** 省略代码 */ }\n\n// 获得 dictType + value 对应的字典展示文本\nexport function getDictDataLabel(dictType, value) { /** 省略代码 */ }\n\n\n结合 Element UI 的表单组件，使用示例如下：\n\n\x3c!-- radio 单选框 --\x3e\n<el-radio v-for="dict in this.getDictDatas(DICT_TYPE.COMMON_STATUS)"\n                      :key="dict.value" :label="parseInt(dict.value)">{{dict.label}}</el-radio>\n\n\x3c!-- select 下拉框 --\x3e\n<el-select v-model="form.code" placeholder="请选择渠道编码" clearable>\n    <el-option v-for="dict in this.getDictDatas(DICT_TYPE.SYSTEM_SMS_CHANNEL_CODE)"\n               :key="dict.value" :label="dict.label" :value="dict.value"/>\n</el-select>\n',
            normalizedContent: '本小节，讲解前端如何使用 [系统管理 -> 字典管理] 菜单的字典数据，例如说字典数据的下拉框、单选 / 多选按钮、高亮展示等等。\n\n\n\n\n# 1. 全局缓存\n\n用户登录成功后，前端会从后端获取到全量的字典数据，缓存在 store 中。如下图所示：\n\n\n\n这样，前端在使用到字典数据时，无需重复请求后端，提升用户体验。\n\n不过，缓存暂时未提供刷新，所以在字典数据发生变化时，需要用户刷新浏览器，进行重新加载。\n\n\n# 2. dict_type\n\n在 dict.js 文件中，使用 dict_type 枚举了字典的 key。如下图所示：\n\n\n\n后续如果有新的字典 key，需要你自己进行添加。\n\n\n# 3. dicttag 字典标签\n\n<dict-tag /> 组件，翻译字段对应的字典展示文本，并根据 colortype、cssclass 进行高亮。使用示例如下：\n\n\x3c!--\n    type: 字典 key\n    value: 字典值\n--\x3e\n<dict-tag :type="dict_type.system_login_type" :value="row.logtype" />\n\n\n\n\n\n# 4. 字典工具类\n\n在 dict.js 文件中，提供了字典工具类，方法如下：\n\n// 获取 dicttype 对应的数据字典数组\nexport function getdictdatas(dicttype) { /** 省略代码 */ }\n\n// 获得 dicttype + value 对应的字典展示文本\nexport function getdictdatalabel(dicttype, value) { /** 省略代码 */ }\n\n\n结合 element ui 的表单组件，使用示例如下：\n\n\x3c!-- radio 单选框 --\x3e\n<el-radio v-for="dict in this.getdictdatas(dict_type.common_status)"\n                      :key="dict.value" :label="parseint(dict.value)">{{dict.label}}</el-radio>\n\n\x3c!-- select 下拉框 --\x3e\n<el-select v-model="form.code" placeholder="请选择渠道编码" clearable>\n    <el-option v-for="dict in this.getdictdatas(dict_type.system_sms_channel_code)"\n               :key="dict.value" :label="dict.label" :value="dict.value"/>\n</el-select>\n',
            charsets: {
                cjk: !0
            }
        }, {
            title: "通用方法",
            frontmatter: {
                title: "通用方法",
                date: "2022-04-18T14:55:50.000Z",
                permalink: "/vue2/util"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/22.%E5%89%8D%E7%AB%AF%E6%89%8B%E5%86%8C%20Vue%202.x/06.%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95.html",
            relativePath: "01.开发指南/22.前端手册 Vue 2.x/06.通用方法.md",
            key: "v-43f4868f",
            path: "/vue2/util/",
            headers: [{
                level: 2,
                title: "1. $tab 对象",
                slug: "_1-tab-对象",
                normalizedTitle: "1. $tab 对象",
                charIndex: 21
            }, {
                level: 2,
                title: "2. $modal 对象",
                slug: "_2-modal-对象",
                normalizedTitle: "2. $modal 对象",
                charIndex: 1502
            }, {
                level: 2,
                title: "3. $auth 对象",
                slug: "_3-auth-对象",
                normalizedTitle: "3. $auth 对象",
                charIndex: 2244
            }, {
                level: 2,
                title: "4. $cache 对象",
                slug: "_4-cache-对象",
                normalizedTitle: "4. $cache 对象",
                charIndex: 2758
            }, {
                level: 2,
                title: "5. $download 对象",
                slug: "_5-download-对象",
                normalizedTitle: "5. $download 对象",
                charIndex: 3589
            }],
            headersStr: "1. $tab 对象 2. $modal 对象 3. $auth 对象 4. $cache 对象 5. $download 对象",
            content: '本小节，分享前端项目的常用方法。\n\n\n# 1. $tab 对象\n\n@tab 对象，由 plugins/tab.js 实现，用于 Tab 标签相关的操作。它有如下方法：\n\n① 打开页签\n\nthis.$tab.openPage("用户管理", "/system/user");\n\nthis.$tab.openPage("用户管理", "/system/user").then(() => {\n  // 执行结束的逻辑\n})\n\n\n② 修改页签\n\nconst obj = Object.assign({}, this.$route, { title: "自定义标题" })\nthis.$tab.updatePage(obj);\n\nthis.$tab.updatePage(obj).then(() => {\n    // 执行结束的逻辑\n})\n\n\n③ 关闭页签\n\n// 关闭当前 tab 页签，打开新页签\nconst obj = { path: "/system/user" };\nthis.$tab.closeOpenPage(obj);\n\n// 关闭当前页签，回到首页\nthis.$tab.closePage();\n\n// 关闭指定页签\nconst obj = { path: "/system/user", name: "User" };\nthis.$tab.closePage(obj);\n\nthis.$tab.closePage(obj).then(() => {\n    // 执行结束的逻辑\n})\n\n\n④ 刷新页签\n\n// 刷新当前页签\nthis.$tab.refreshPage();\n\n// 刷新指定页签\nconst obj = { path: "/system/user", name: "User" };\nthis.$tab.refreshPage(obj);\n\nthis.$tab.refreshPage(obj).then(() => {\n    // 执行结束的逻辑\n})\n\n\n⑤ 关闭所有页签\n\nthis.$tab.closeAllPage();\n\nthis.$tab.closeAllPage().then(() => {\n    // 执行结束的逻辑\n})\n\n\n⑥ 关闭左侧页签\n\nthis.$tab.closeLeftPage();\n\nconst obj = { path: "/system/user", name: "User" };\nthis.$tab.closeLeftPage(obj);\n\nthis.$tab.closeLeftPage(obj).then(() => {\n    // 执行结束的逻辑\n})\n\n\n⑦ 关闭右侧页签\n\nthis.$tab.closeRightPage();\n\nconst obj = { path: "/system/user", name: "User" };\nthis.$tab.closeRightPage(obj);\n\nthis.$tab.closeRightPage(obj).then(() => {\n    // 执行结束的逻辑\n})\n\n\n⑧ 关闭其它页签\n\nthis.$tab.closeOtherPage();\n\nconst obj = { path: "/system/user", name: "User" };\nthis.$tab.closeOtherPage(obj);\n\nthis.$tab.closeOtherPage(obj).then(() => {\n    // 执行结束的逻辑\n})\n\n\n\n# 2. $modal 对象\n\n@modal 对象，由 plugins/modal.js 实现，用于做消息提示、通知提示、对话框提醒、二次确认、遮罩等。它有如下方法：\n\n① 提供成功、警告和错误等反馈信息\n\nthis.$modal.msg("默认反馈");\nthis.$modal.msgError("错误反馈");\nthis.$modal.msgSuccess("成功反馈");\nthis.$modal.msgWarning("警告反馈");\n\n\n② 提供成功、警告和错误等提示信息\n\nthis.$modal.alert("默认提示");\nthis.$modal.alertError("错误提示");\nthis.$modal.alertSuccess("成功提示");\nthis.$modal.alertWarning("警告提示");\n\n\n③ 提供成功、警告和错误等通知信息\n\nthis.$modal.notify("默认通知");\nthis.$modal.notifyError("错误通知");\nthis.$modal.notifySuccess("成功通知");\nthis.$modal.notifyWarning("警告通知");\n\n\n④ 提供确认窗体信息\n\nthis.$modal.confirm(\'确认信息\').then(function() {\n    // ...\n}).then(() => {\n    // ...\n}).catch(() => {});\n\n\n⑤ 提供遮罩层信息\n\n// 打开遮罩层\nthis.$modal.loading("正在导出数据，请稍后...");\n\n// 关闭遮罩层\nthis.$modal.closeLoading();\n\n\n\n# 3. $auth 对象\n\n@auth 对象，由 plugins/auth.js 实现，用于验证用户是否拥有某（些）权限或角色。它有如下方法：\n\n① 验证用户权限\n\n// 验证用户是否具备某权限\nthis.$auth.hasPermi("system:user:add");\n// 验证用户是否含有指定权限，只需包含其中一个\nthis.$auth.hasPermiOr(["system:user:add", "system:user:update"]);\n// 验证用户是否含有指定权限，必须全部拥有\nthis.$auth.hasPermiAnd(["system:user:add", "system:user:update"]);\n\n\n② 验证用户角色\n\n// 验证用户是否具备某角色\nthis.$auth.hasRole("admin");\n// 验证用户是否含有指定角色，只需包含其中一个\nthis.$auth.hasRoleOr(["admin", "common"]);\n// 验证用户是否含有指定角色，必须全部拥有\nthis.$auth.hasRoleAnd(["admin", "common"]);\n\n\n\n# 4. $cache 对象\n\n@auth 对象，由 plugins/cache.js 实现，基于 session 或 local 实现不同级别的缓存。它有如下方法：\n\n对象名称      缓存类型\nsession   会话级缓存，通过 sessionStorage 实现\nlocal     本地级缓存，通过 localStorage 实现\n\n① 读写 String 缓存\n\n// local 普通值\nthis.$cache.local.set(\'key\', \'local value\')\nconsole.log(this.$cache.local.get(\'key\')) // 输出 \'local value\'\n\n// session 普通值\nthis.$cache.session.set(\'key\', \'session value\')\nconsole.log(this.$cache.session.get(\'key\')) // 输出 \'session value\'\n\n\n② 读写 JSON 缓存\n\n// local JSON值\n\nthis.$cache.local.setJSON(\'jsonKey\', { localProp: 1 })\nconsole.log(this.$cache.local.getJSON(\'jsonKey\')) // 输出 \'{localProp: 1}\'\n\n// session JSON值\nthis.$cache.session.setJSON(\'jsonKey\', { sessionProp: 1 })\nconsole.log(this.$cache.session.getJSON(\'jsonKey\')) // 输出 \'{sessionProp: 1}\'\n\n\n③ 删除缓存\n\nthis.$cache.local.remove(\'key\')\nthis.$cache.session.remove(\'key\')\n\n\n\n# 5. $download 对象\n\n$download 对象，由 plugins/download.js 实现，用于各种类型的文件下载。它有如下方法：\n\n方法列表\n\nthis.$download.excel(data, fileName);\nthis.$download.word(data, fileName);\nthis.$download.zip(data, fileName);\nthis.$download.html(data, fileName);\nthis.$download.markdown(data, fileName);\n\n\n在 user/index.vue 页面中，导出 Excel 文件的代码如下图：\n\n',
            normalizedContent: '本小节，分享前端项目的常用方法。\n\n\n# 1. $tab 对象\n\n@tab 对象，由 plugins/tab.js 实现，用于 tab 标签相关的操作。它有如下方法：\n\n① 打开页签\n\nthis.$tab.openpage("用户管理", "/system/user");\n\nthis.$tab.openpage("用户管理", "/system/user").then(() => {\n  // 执行结束的逻辑\n})\n\n\n② 修改页签\n\nconst obj = object.assign({}, this.$route, { title: "自定义标题" })\nthis.$tab.updatepage(obj);\n\nthis.$tab.updatepage(obj).then(() => {\n    // 执行结束的逻辑\n})\n\n\n③ 关闭页签\n\n// 关闭当前 tab 页签，打开新页签\nconst obj = { path: "/system/user" };\nthis.$tab.closeopenpage(obj);\n\n// 关闭当前页签，回到首页\nthis.$tab.closepage();\n\n// 关闭指定页签\nconst obj = { path: "/system/user", name: "user" };\nthis.$tab.closepage(obj);\n\nthis.$tab.closepage(obj).then(() => {\n    // 执行结束的逻辑\n})\n\n\n④ 刷新页签\n\n// 刷新当前页签\nthis.$tab.refreshpage();\n\n// 刷新指定页签\nconst obj = { path: "/system/user", name: "user" };\nthis.$tab.refreshpage(obj);\n\nthis.$tab.refreshpage(obj).then(() => {\n    // 执行结束的逻辑\n})\n\n\n⑤ 关闭所有页签\n\nthis.$tab.closeallpage();\n\nthis.$tab.closeallpage().then(() => {\n    // 执行结束的逻辑\n})\n\n\n⑥ 关闭左侧页签\n\nthis.$tab.closeleftpage();\n\nconst obj = { path: "/system/user", name: "user" };\nthis.$tab.closeleftpage(obj);\n\nthis.$tab.closeleftpage(obj).then(() => {\n    // 执行结束的逻辑\n})\n\n\n⑦ 关闭右侧页签\n\nthis.$tab.closerightpage();\n\nconst obj = { path: "/system/user", name: "user" };\nthis.$tab.closerightpage(obj);\n\nthis.$tab.closerightpage(obj).then(() => {\n    // 执行结束的逻辑\n})\n\n\n⑧ 关闭其它页签\n\nthis.$tab.closeotherpage();\n\nconst obj = { path: "/system/user", name: "user" };\nthis.$tab.closeotherpage(obj);\n\nthis.$tab.closeotherpage(obj).then(() => {\n    // 执行结束的逻辑\n})\n\n\n\n# 2. $modal 对象\n\n@modal 对象，由 plugins/modal.js 实现，用于做消息提示、通知提示、对话框提醒、二次确认、遮罩等。它有如下方法：\n\n① 提供成功、警告和错误等反馈信息\n\nthis.$modal.msg("默认反馈");\nthis.$modal.msgerror("错误反馈");\nthis.$modal.msgsuccess("成功反馈");\nthis.$modal.msgwarning("警告反馈");\n\n\n② 提供成功、警告和错误等提示信息\n\nthis.$modal.alert("默认提示");\nthis.$modal.alerterror("错误提示");\nthis.$modal.alertsuccess("成功提示");\nthis.$modal.alertwarning("警告提示");\n\n\n③ 提供成功、警告和错误等通知信息\n\nthis.$modal.notify("默认通知");\nthis.$modal.notifyerror("错误通知");\nthis.$modal.notifysuccess("成功通知");\nthis.$modal.notifywarning("警告通知");\n\n\n④ 提供确认窗体信息\n\nthis.$modal.confirm(\'确认信息\').then(function() {\n    // ...\n}).then(() => {\n    // ...\n}).catch(() => {});\n\n\n⑤ 提供遮罩层信息\n\n// 打开遮罩层\nthis.$modal.loading("正在导出数据，请稍后...");\n\n// 关闭遮罩层\nthis.$modal.closeloading();\n\n\n\n# 3. $auth 对象\n\n@auth 对象，由 plugins/auth.js 实现，用于验证用户是否拥有某（些）权限或角色。它有如下方法：\n\n① 验证用户权限\n\n// 验证用户是否具备某权限\nthis.$auth.haspermi("system:user:add");\n// 验证用户是否含有指定权限，只需包含其中一个\nthis.$auth.haspermior(["system:user:add", "system:user:update"]);\n// 验证用户是否含有指定权限，必须全部拥有\nthis.$auth.haspermiand(["system:user:add", "system:user:update"]);\n\n\n② 验证用户角色\n\n// 验证用户是否具备某角色\nthis.$auth.hasrole("admin");\n// 验证用户是否含有指定角色，只需包含其中一个\nthis.$auth.hasroleor(["admin", "common"]);\n// 验证用户是否含有指定角色，必须全部拥有\nthis.$auth.hasroleand(["admin", "common"]);\n\n\n\n# 4. $cache 对象\n\n@auth 对象，由 plugins/cache.js 实现，基于 session 或 local 实现不同级别的缓存。它有如下方法：\n\n对象名称      缓存类型\nsession   会话级缓存，通过 sessionstorage 实现\nlocal     本地级缓存，通过 localstorage 实现\n\n① 读写 string 缓存\n\n// local 普通值\nthis.$cache.local.set(\'key\', \'local value\')\nconsole.log(this.$cache.local.get(\'key\')) // 输出 \'local value\'\n\n// session 普通值\nthis.$cache.session.set(\'key\', \'session value\')\nconsole.log(this.$cache.session.get(\'key\')) // 输出 \'session value\'\n\n\n② 读写 json 缓存\n\n// local json值\n\nthis.$cache.local.setjson(\'jsonkey\', { localprop: 1 })\nconsole.log(this.$cache.local.getjson(\'jsonkey\')) // 输出 \'{localprop: 1}\'\n\n// session json值\nthis.$cache.session.setjson(\'jsonkey\', { sessionprop: 1 })\nconsole.log(this.$cache.session.getjson(\'jsonkey\')) // 输出 \'{sessionprop: 1}\'\n\n\n③ 删除缓存\n\nthis.$cache.local.remove(\'key\')\nthis.$cache.session.remove(\'key\')\n\n\n\n# 5. $download 对象\n\n$download 对象，由 plugins/download.js 实现，用于各种类型的文件下载。它有如下方法：\n\n方法列表\n\nthis.$download.excel(data, filename);\nthis.$download.word(data, filename);\nthis.$download.zip(data, filename);\nthis.$download.html(data, filename);\nthis.$download.markdown(data, filename);\n\n\n在 user/index.vue 页面中，导出 excel 文件的代码如下图：\n\n',
            charsets: {
                cjk: !0
            }
        }, {
            title: "配置读取",
            frontmatter: {
                title: "配置读取",
                date: "2022-04-18T20:06:23.000Z",
                permalink: "/vue2/config-center"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/22.%E5%89%8D%E7%AB%AF%E6%89%8B%E5%86%8C%20Vue%202.x/07.%E9%85%8D%E7%BD%AE%E8%AF%BB%E5%8F%96.html",
            relativePath: "01.开发指南/22.前端手册 Vue 2.x/07.配置读取.md",
            key: "v-788d69fa",
            path: "/vue2/config-center/",
            headers: [{
                level: 2,
                title: "1. 读取配置",
                slug: "_1-读取配置",
                normalizedTitle: "1. 读取配置",
                charIndex: 75
            }, {
                level: 2,
                title: "2. 实战案例",
                slug: "_2-实战案例",
                normalizedTitle: "2. 实战案例",
                charIndex: 313
            }],
            headersStr: "1. 读取配置 2. 实战案例",
            content: "在 [基础设施 -> 配置管理] 菜单，可以动态修改配置，无需重启服务器即可生效。\n\n\n\n提示\n\n对应 《后端手册 —— 配置中心》 文档。\n\n\n# 1. 读取配置\n\n前端调用 /@api/infra/config 的 #getConfigKey(configKey) 方法，获取指定 key 对应的配置的值。代码如下：\n\nexport function getConfigKey(configKey) {\n  return request({\n    url: '/infra/config/get-value-by-key?key=' + configKey,\n    method: 'get'\n  })\n}\n\n\n\n# 2. 实战案例\n\n在 src/views/infra/server/index.vue 页面中，获取 key 为 \"url.skywalking\" 的配置的值。代码如下：\n\n",
            normalizedContent: "在 [基础设施 -> 配置管理] 菜单，可以动态修改配置，无需重启服务器即可生效。\n\n\n\n提示\n\n对应 《后端手册 —— 配置中心》 文档。\n\n\n# 1. 读取配置\n\n前端调用 /@api/infra/config 的 #getconfigkey(configkey) 方法，获取指定 key 对应的配置的值。代码如下：\n\nexport function getconfigkey(configkey) {\n  return request({\n    url: '/infra/config/get-value-by-key?key=' + configkey,\n    method: 'get'\n  })\n}\n\n\n\n# 2. 实战案例\n\n在 src/views/infra/server/index.vue 页面中，获取 key 为 \"url.skywalking\" 的配置的值。代码如下：\n\n",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【v2.4.1】2025-02-09",
            frontmatter: {
                title: "【v2.4.1】2025-02-09",
                date: "2025-01-01T00:00:00.000Z",
                permalink: "/changelog/2.4.1/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/30.%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/70.%E3%80%90v2-4-1%E3%80%912025-02-09.html",
            relativePath: "01.开发指南/30.更新日志/70.【v2-4-1】2025-02-09.md",
            key: "v-4c301678",
            path: "/changelog/2.4.1/",
            headers: [{
                level: 2,
                title: "增加工作流更多功能，不限于签名、延迟器、触发器、路由分支等",
                slug: "增加工作流更多功能-不限于签名、延迟器、触发器、路由分支等",
                normalizedTitle: "增加工作流更多功能，不限于签名、延迟器、触发器、路由分支等",
                charIndex: 2
            }, {
                level: 3,
                title: "📈 Statistic",
                slug: "📈-statistic",
                normalizedTitle: "📈 statistic",
                charIndex: 36
            }, {
                level: 3,
                title: "⭐ New Features",
                slug: "⭐-new-features",
                normalizedTitle: "⭐ new features",
                charIndex: 117
            }, {
                level: 3,
                title: "🐞 Bug Fixes",
                slug: "🐞-bug-fixes",
                normalizedTitle: "🐞 bug fixes",
                charIndex: 1426
            }, {
                level: 3,
                title: "🔨 Dependency Upgrades",
                slug: "🔨-dependency-upgrades",
                normalizedTitle: "🔨 dependency upgrades",
                charIndex: 2494
            }],
            headersStr: "增加工作流更多功能，不限于签名、延迟器、触发器、路由分支等 📈 Statistic ⭐ New Features 🐞 Bug Fixes 🔨 Dependency Upgrades",
            content: "# 增加工作流更多功能，不限于签名、延迟器、触发器、路由分支等\n\n\n# 📈 Statistic\n\n * 总代码行数：238919\n * 源码代码行数：148065\n * 注释行数：54318\n * 单元测试用例数：1063\n\n\n# ⭐ New Features\n\nVue3 管理后台专区：\n\n * 【新增】文件列表: 添加复制链接功能，由 @jinmh 贡献 #631\n * 【新增】支持通过短信重置后台密码，由 @杨宇庆 贡献 #617、#1156\n * 【优化】菜单管理使用虚拟化树形控件实现，由 @puhui999、@Jason0z 贡献 #627、#678\n * 【优化】Vite CJS Node API deprecated waring，由 @崮生 贡献 #117\n * 【优化】InEnum 不必须指定 int 类型，通过泛型指定，由 由 @puhui999 贡献 #1212\n * 【优化】简化滑动脱敏处理器实现，由 @mcwindy 贡献 #745\n\nBPM 工作流专区：\n\n * 【新增】SIMPLE 设计器，增加延迟器，由 @Lesan 贡献 #1175、#645\n * 【新增】SIMPLE 设计器，增加触发器，由 @Jason 贡献 8a8dc67、b7329b0、53789d9、475385b、a23b0480f159eaad446b7b93b182b565f8c455de、e32fc81df6c2b8214d784cc1a01b1a3d274b1ca1\n * 【新增】SIMPLE 设计器，增加任务审批的监听器，由 @Lesan 贡献 #1186、#651、#1187、#652\n * 【新增】SIMPLE 设计器，增加路由分支，由 @Lesan 贡献 #1183、#648、#669、#1198\n * 【新增】SIMPLE/BPMN 设计器，增加签名，由 @Lesan 贡献 #654、#655、#1189、#1190、#1191、#659\n * 【新增】SIMPLE/BPMN 设计器，增加是否需要填写审批意见，由 @Lesan 贡献 #665、#1195\n * 【优化】流程模型的编辑，并增加“复制”功能，由 @zws-code 贡献 #121、#123\n * 【新增】BPMN 设计器，增加跳过表达式，由 @Lesan 贡献 #1192、#661\n * 【新增】基于模型清理流程实例，由 @Lesan 贡献 #1193、#661、#1194\n * 【新增】更多设置-提交人权限，由 @Lesan 贡献 #1197、#667\n * 【新增】更多设置-流程编码，由 @Lesan 贡献 #1199、#670、#1200、#671、#1217\n * 【新增】更多设置-自动去重，由 @Lesan 贡献 #1202、#673、1204、#674\n * 【新增】更多设置-自定义标题，由 @Lesan 贡献 #677、#1206\n * 【新增】更多设置-摘要设置，由 @Lesan 贡献 #681、#1210、#683\n * 【优化】流程模型列表的卡顿问题，由 @zws-code 贡献 #124\n * 【优化】优化流程模型分类组件性能和类型定义，由 @GoldenZqqq 贡献 #127\n * 【新增】流程实例的数据查看功能，由 @Lesan 贡献 #1215、#684、#1216、#685、#686\n\n\n# 🐞 Bug Fixes\n\nVue3 管理后台专区：\n\n * 【修复】菜单显示 Please set title 的问题，由 @chenting 贡献 #634\n * 【修复】菜单总是显示无效的问题，由 @chenting 贡献 #636\n * 【修复】升级 element-plus，修复 el-table-v2 滚动条 bug，由 @chenting 贡献 #637\n * 【修复】表单构建页面，json 显示和复制问题，调整 highlight 废弃的方法，由 @SamllNorth_Lee 贡献 #657\n * 【修复】修复角色更新时，记录的操作日志将更新前的数据记录为空的问题，由 @Dincat 贡献 #1196\n * 【修复】当显式声明@ApiAccessLog注解但未指定operateModule等属性时，系统未能正确获取默认属性值，导致日志记录中部分属性缺失，由 @ChengKe 贡献 #165\n * 【修复】雪花 ID 溢出了 update apierrorlog/ApiErrorLogRespVO.java，由 @山野羡民 贡献 #1214\n * 【修复】添加项目前缀，日志无法插入，由 @xiefangzhenz 贡献 #731\n * 【修复】重置密码接口错误导致管理员忘记密码功能异常，由 @Baron.Bai 贡献 #689\n * 【修复】定时任务模块，字段名称错误，由 @李恒 贡献 #687\n\nMALL 商城专区：\n\n * 【修复】商城 uniapp category 里右侧列表到底刷新功能，由 @壁虎在家 贡献 #133\n * 【修复】退款回收优惠券错误，由 @壁虎在家 贡献 #1181\n * 【修复】分销提现审批通过后，金额计算不对的问题，由 @puhui999 贡献 #1188\n * 【修复】客服中心页面，接收消息时 调用了很多次获取会话接口，由 @puhui999 贡献 #675\n * 【修复】uniapp 的一些展示问题，由 @puhui999 贡献 #135\n * 【修复】虚拟成团后所有成员添加虚拟成团标记，由 @puhui999 贡献 #1207\n * 【修复】修复积分不够还能兑换商品的 bug，由 @puhui999 贡献 #1207\n\nBPM 工作流专区：\n\n * 【修复】bpmn 流程模拟插件 bpmn-js-token-simulation，由 @半栈幼儿员 贡献 #647\n * 【修复】bpmn 服务任务无法启动，由 @Lesan 贡献 #682\n\n\n# 🔨 Dependency Upgrades",
            normalizedContent: "# 增加工作流更多功能，不限于签名、延迟器、触发器、路由分支等\n\n\n# 📈 statistic\n\n * 总代码行数：238919\n * 源码代码行数：148065\n * 注释行数：54318\n * 单元测试用例数：1063\n\n\n# ⭐ new features\n\nvue3 管理后台专区：\n\n * 【新增】文件列表: 添加复制链接功能，由 @jinmh 贡献 #631\n * 【新增】支持通过短信重置后台密码，由 @杨宇庆 贡献 #617、#1156\n * 【优化】菜单管理使用虚拟化树形控件实现，由 @puhui999、@jason0z 贡献 #627、#678\n * 【优化】vite cjs node api deprecated waring，由 @崮生 贡献 #117\n * 【优化】inenum 不必须指定 int 类型，通过泛型指定，由 由 @puhui999 贡献 #1212\n * 【优化】简化滑动脱敏处理器实现，由 @mcwindy 贡献 #745\n\nbpm 工作流专区：\n\n * 【新增】simple 设计器，增加延迟器，由 @lesan 贡献 #1175、#645\n * 【新增】simple 设计器，增加触发器，由 @jason 贡献 8a8dc67、b7329b0、53789d9、475385b、a23b0480f159eaad446b7b93b182b565f8c455de、e32fc81df6c2b8214d784cc1a01b1a3d274b1ca1\n * 【新增】simple 设计器，增加任务审批的监听器，由 @lesan 贡献 #1186、#651、#1187、#652\n * 【新增】simple 设计器，增加路由分支，由 @lesan 贡献 #1183、#648、#669、#1198\n * 【新增】simple/bpmn 设计器，增加签名，由 @lesan 贡献 #654、#655、#1189、#1190、#1191、#659\n * 【新增】simple/bpmn 设计器，增加是否需要填写审批意见，由 @lesan 贡献 #665、#1195\n * 【优化】流程模型的编辑，并增加“复制”功能，由 @zws-code 贡献 #121、#123\n * 【新增】bpmn 设计器，增加跳过表达式，由 @lesan 贡献 #1192、#661\n * 【新增】基于模型清理流程实例，由 @lesan 贡献 #1193、#661、#1194\n * 【新增】更多设置-提交人权限，由 @lesan 贡献 #1197、#667\n * 【新增】更多设置-流程编码，由 @lesan 贡献 #1199、#670、#1200、#671、#1217\n * 【新增】更多设置-自动去重，由 @lesan 贡献 #1202、#673、1204、#674\n * 【新增】更多设置-自定义标题，由 @lesan 贡献 #677、#1206\n * 【新增】更多设置-摘要设置，由 @lesan 贡献 #681、#1210、#683\n * 【优化】流程模型列表的卡顿问题，由 @zws-code 贡献 #124\n * 【优化】优化流程模型分类组件性能和类型定义，由 @goldenzqqq 贡献 #127\n * 【新增】流程实例的数据查看功能，由 @lesan 贡献 #1215、#684、#1216、#685、#686\n\n\n# 🐞 bug fixes\n\nvue3 管理后台专区：\n\n * 【修复】菜单显示 please set title 的问题，由 @chenting 贡献 #634\n * 【修复】菜单总是显示无效的问题，由 @chenting 贡献 #636\n * 【修复】升级 element-plus，修复 el-table-v2 滚动条 bug，由 @chenting 贡献 #637\n * 【修复】表单构建页面，json 显示和复制问题，调整 highlight 废弃的方法，由 @samllnorth_lee 贡献 #657\n * 【修复】修复角色更新时，记录的操作日志将更新前的数据记录为空的问题，由 @dincat 贡献 #1196\n * 【修复】当显式声明@apiaccesslog注解但未指定operatemodule等属性时，系统未能正确获取默认属性值，导致日志记录中部分属性缺失，由 @chengke 贡献 #165\n * 【修复】雪花 id 溢出了 update apierrorlog/apierrorlogrespvo.java，由 @山野羡民 贡献 #1214\n * 【修复】添加项目前缀，日志无法插入，由 @xiefangzhenz 贡献 #731\n * 【修复】重置密码接口错误导致管理员忘记密码功能异常，由 @baron.bai 贡献 #689\n * 【修复】定时任务模块，字段名称错误，由 @李恒 贡献 #687\n\nmall 商城专区：\n\n * 【修复】商城 uniapp category 里右侧列表到底刷新功能，由 @壁虎在家 贡献 #133\n * 【修复】退款回收优惠券错误，由 @壁虎在家 贡献 #1181\n * 【修复】分销提现审批通过后，金额计算不对的问题，由 @puhui999 贡献 #1188\n * 【修复】客服中心页面，接收消息时 调用了很多次获取会话接口，由 @puhui999 贡献 #675\n * 【修复】uniapp 的一些展示问题，由 @puhui999 贡献 #135\n * 【修复】虚拟成团后所有成员添加虚拟成团标记，由 @puhui999 贡献 #1207\n * 【修复】修复积分不够还能兑换商品的 bug，由 @puhui999 贡献 #1207\n\nbpm 工作流专区：\n\n * 【修复】bpmn 流程模拟插件 bpmn-js-token-simulation，由 @半栈幼儿员 贡献 #647\n * 【修复】bpmn 服务任务无法启动，由 @lesan 贡献 #682\n\n\n# 🔨 dependency upgrades",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【v2.4.2】开发中",
            frontmatter: {
                title: "【v2.4.2】开发中",
                date: "2025-01-01T00:00:00.000Z",
                permalink: "/changelog/2.4.2/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/30.%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/69.%E3%80%90v2-4-2%E3%80%91%E5%BC%80%E5%8F%91%E4%B8%AD.html",
            relativePath: "01.开发指南/30.更新日志/69.【v2-4-2】开发中.md",
            key: "v-08720438",
            path: "/changelog/2.4.2/",
            headers: [{
                level: 2,
                title: "",
                slug: "",
                normalizedTitle: "",
                charIndex: 0
            }, {
                level: 3,
                title: "📈 Statistic",
                slug: "📈-statistic",
                normalizedTitle: "📈 statistic",
                charIndex: 6
            }, {
                level: 3,
                title: "⭐ New Features",
                slug: "⭐-new-features",
                normalizedTitle: "⭐ new features",
                charIndex: 66
            }, {
                level: 3,
                title: "🐞 Bug Fixes",
                slug: "🐞-bug-fixes",
                normalizedTitle: "🐞 bug fixes",
                charIndex: 506
            }, {
                level: 3,
                title: "🔨 Dependency Upgrades",
                slug: "🔨-dependency-upgrades",
                normalizedTitle: "🔨 dependency upgrades",
                charIndex: 938
            }],
            headersStr: " 📈 Statistic ⭐ New Features 🐞 Bug Fixes 🔨 Dependency Upgrades",
            content: "#\n\n\n# 📈 Statistic\n\n * 总代码行数：\n * 源码代码行数：\n * 注释行数：\n * 单元测试用例数：\n\n\n# ⭐ New Features\n\nVue3 管理后台专区：\n\nBPM 工作流专区：\n\n * 【新增】SIMPLE 设计器，增加办理节点，由 @Lesan 贡献 #1228、#692、#695、#1234\n * 【新增】SIMPLE 设计器，增加触发器的数据修改，由 @Jason 贡献 9a4bb60、6be64a2dai\n * 【新增】SIMPLE 设计器，增加触发器的数据删除，由 @Jason 贡献 cbdc081、bfe4336\n * 【新增】SIMPLE 设计器，增加流程图的小手功能，由 @Lemon 贡献 #704\n * 【新增】SIMPLE 设计器，表单的字段权限，支持批量设置，由 @Lemon 贡献 #703\n * 【新增】SIMPLE 设计器，子流程，由 @Lemon 贡献 #1249\n\nMALL 商城专区：\n\n * 【优化】商城客服页面匹配暗黑模式，由 @卢越 贡献 #706\n * 【优化】优惠劵领取，减少查询，由 @山野羡民 贡献 #1246\n\n\n# 🐞 Bug Fixes\n\nVue3 管理后台专区：\n\nMALL 商城专区：\n\n * 【修复】管理后台，订单详情的物流信息展示不出来的问题，由 @爱宇阳 贡献 #690\n\nBPM 工作流专区：\n\n * 【修复】icon 不在强制填写，并修复少量 bug，由 @SamllNorth_Lee 贡献 #694、#1233\n * 【修复】审批节点自定义配置字段权限为空问题，由 @SamllNorth_Lee 贡献 #696\n * 【修复】工作流实例详情页面审批通过后，继续审批的 BUG 问题，由 @KAILIN 贡献 #698\n * 【修复】修复停用状态下的流程删除报错问题，由 @SamllNorth_Lee 贡献 #1235\n * 【修复】发起流程时，流程预测可能会随着表单变化的问题，由 @SamllNorth_Lee 贡献 #700、#1238\n * 【修复】Simple 模型，抄送节点在流程预测时未显示抄送人，由 @Lesan 贡献 #1240\n\n\n# 🔨 Dependency Upgrades",
            normalizedContent: "#\n\n\n# 📈 statistic\n\n * 总代码行数：\n * 源码代码行数：\n * 注释行数：\n * 单元测试用例数：\n\n\n# ⭐ new features\n\nvue3 管理后台专区：\n\nbpm 工作流专区：\n\n * 【新增】simple 设计器，增加办理节点，由 @lesan 贡献 #1228、#692、#695、#1234\n * 【新增】simple 设计器，增加触发器的数据修改，由 @jason 贡献 9a4bb60、6be64a2dai\n * 【新增】simple 设计器，增加触发器的数据删除，由 @jason 贡献 cbdc081、bfe4336\n * 【新增】simple 设计器，增加流程图的小手功能，由 @lemon 贡献 #704\n * 【新增】simple 设计器，表单的字段权限，支持批量设置，由 @lemon 贡献 #703\n * 【新增】simple 设计器，子流程，由 @lemon 贡献 #1249\n\nmall 商城专区：\n\n * 【优化】商城客服页面匹配暗黑模式，由 @卢越 贡献 #706\n * 【优化】优惠劵领取，减少查询，由 @山野羡民 贡献 #1246\n\n\n# 🐞 bug fixes\n\nvue3 管理后台专区：\n\nmall 商城专区：\n\n * 【修复】管理后台，订单详情的物流信息展示不出来的问题，由 @爱宇阳 贡献 #690\n\nbpm 工作流专区：\n\n * 【修复】icon 不在强制填写，并修复少量 bug，由 @samllnorth_lee 贡献 #694、#1233\n * 【修复】审批节点自定义配置字段权限为空问题，由 @samllnorth_lee 贡献 #696\n * 【修复】工作流实例详情页面审批通过后，继续审批的 bug 问题，由 @kailin 贡献 #698\n * 【修复】修复停用状态下的流程删除报错问题，由 @samllnorth_lee 贡献 #1235\n * 【修复】发起流程时，流程预测可能会随着表单变化的问题，由 @samllnorth_lee 贡献 #700、#1238\n * 【修复】simple 模型，抄送节点在流程预测时未显示抄送人，由 @lesan 贡献 #1240\n\n\n# 🔨 dependency upgrades",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【v2.4.0】2024-12-31",
            frontmatter: {
                title: "【v2.4.0】2024-12-31",
                date: "2024-08-02T00:00:00.000Z",
                permalink: "/changelog/2.4.0/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/30.%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/71.%E3%80%90v2-4-0%E3%80%912024-12-31.html",
            relativePath: "01.开发指南/30.更新日志/71.【v2-4-0】2024-12-31.md",
            key: "v-fa8c6850",
            path: "/changelog/2.4.0/",
            headers: [{
                level: 2,
                title: "增强工作流仿钉钉、飞书模式",
                slug: "增强工作流仿钉钉、飞书模式",
                normalizedTitle: "增强工作流仿钉钉、飞书模式",
                charIndex: 2
            }, {
                level: 2,
                title: "📈 Statistic",
                slug: "📈-statistic",
                normalizedTitle: "📈 statistic",
                charIndex: 20
            }, {
                level: 3,
                title: "⭐ New Features",
                slug: "⭐-new-features",
                normalizedTitle: "⭐ new features",
                charIndex: 101
            }, {
                level: 3,
                title: "🐞 Bug Fixes",
                slug: "🐞-bug-fixes",
                normalizedTitle: "🐞 bug fixes",
                charIndex: 2305
            }, {
                level: 3,
                title: "🔨 Dependency Upgrades",
                slug: "🔨-dependency-upgrades",
                normalizedTitle: "🔨 dependency upgrades",
                charIndex: 4170
            }],
            headersStr: "增强工作流仿钉钉、飞书模式 📈 Statistic ⭐ New Features 🐞 Bug Fixes 🔨 Dependency Upgrades",
            content: "# 增强工作流仿钉钉、飞书模式\n\n\n# 📈 Statistic\n\n * 总代码行数：237166\n * 源码代码行数：146852\n * 注释行数：54010\n * 单元测试用例数：1073\n\n\n# ⭐ New Features\n\n * 【优化】忽略多租户的表，兼容表名带有包裹符号的情况，由 @zoemak 贡献 #1101\n * 【优化】排序：字段驼峰改为下划线，由 @jinmh 贡献 #1108\n * 【新增】更新大屏相关的功能，由 @EarlySummer 贡献 #2、#3、#4\n * 【优化】s3 minio sdk 替换为 aws sdk，由 @留声机恶魔 贡献 #1117\n * 【新增】租户套餐名重名校验，由 @小新 贡献 #1152\n\nVue3 管理后台专区：\n\n * 【优化】升级 form-create 插件版本，更好的动态表单体验，由 @半栈幼儿员 贡献 #564\n * 【优化】@import 修改为 @use 以应对 sass 升级弃用 @import，由 @半栈幼儿员 贡献 #571\n * 【新增】TagsView 支持多个 path 相同但 fullPath 不相同情况，由 @半栈幼儿员 贡献 #570\n * 【优化】添加自定义指令消除 IDE 警告，由 @jinmh 贡献 #578\n * 【新增】uniapp 管理后台的双 token 刷新机制，整体布局，由 @Qiksy 贡献 #3\n * 【新增】uniapp 登录界面，由 @紫星 贡献 #5、#6、#7、#19、#22、#25\n * 【新增】uniapp 三方登录，由 @紫星 贡献 #17\n * 【新增】uniapp 用户管理，由 @紫星 贡献 #26、#27\n * 【新增】uniapp 个人信息，由 @dengbo 贡献 #7、#16\n * 【新增】uniapp 角色管理，由 @泽彦 贡献 #9、#18\n * 【新增】uniapp 我的界面，由 @runcarefully 贡献 #13、#14\n * 【新增】uniapp 工作流的列表，由 @alwayssuper 贡献 #11\n * 【新增】uniapp 工作流的详情，由 @andyzhang 贡献 #15\n * 【新增】uniapp 个人中心，由 @guanhaizhe 贡献 #23、#24\n * 【新增】uniapp 审批通过、不通过界面，由 @alwayssuper 贡献 #21\n * 【优化】uniapp 在 Android 打包的情况下，如果 dict 字典使用了 useDictStore()，会导致打包出来的应用白屏，由 @&wxr 贡献 #29\n\nMALL 商城专区：\n\n * 【新增】自提门店支持绑定店员，由 @痴货 贡献 #1098、#560\n * 【新增】添加微信转账到零钱提现功能，由 @痴货 贡献 #1099、#561、#109\n * 【新增】商城分销: 创建分销员，由 @puhui999 贡献 #607、#1142\n * 【优化】商城 uniapp 的各种分享，由 @puhui999 贡献 #126\n * 【优化】分销中心的样式，由 @FN 贡献 #112\n * 【优化】订单确认页，增加按照顺序自动选择物流方式，替代原有只选择“快递配送”的方式，由 @芋道源码 贡献 789ec69\n * 【优化】签到的界面，由 @Baron.Bai 贡献 f36b183\n * 【优化】商城客服: 消息获取改为游标查询，由 @puhui999 贡献 #1118、#1130\n * 【优化】商城客服：整体交互体验和界面，由 @puhui999 贡献 #579、#1126、#584、#124、#125、#598、#599\n * 【优化】订单支付后的异常情况，由 @puhui999 贡献 #1151、#129、#131\n\nBPM 工作流专区：\n\n * 【优化】SIMPLE 仿钉钉/飞书模式的完善，由 @Jason 贡献 #1133、#595\n * 【新增】SIMPLE 仿钉钉/飞书模式的高亮，由 @Jason 贡献\n * 【新增】BPMN ServiceTask 的支持，并进行优化，由 @Lesan 贡献 #605\n * 【优化】BPMN 流程图高亮的计算，切换到后端为主，由 @芋道源码 贡献 33f3bc0、41eec78\n * 【优化】流程模型列表 UI 重构，以及数组分类分组展示逻辑，由 @GoldenZqqq 贡献 #89、#92、#93、#94\n * 【优化】审批详情页面，由 @Zqqqqqq 贡献 #80、#102\n * 【优化】审批发起界面，由 @Zqqqqqq 贡献 #98、#99、#100\n * 【优化】流程模型的设计新界面，由 @Zqqqqqq 贡献 #111、#114、#115、#116\n * 【优化】审批中心的我的流程界面，由 @tuituji111 贡献 #583、#596、#602\n * 【优化】BPMN 设计器，增加 UserTask 自定义配置，由 @Lesan 贡献 #586、#594、#600、#603、#1137、#609、#610、#612、#614\n * 【新增】BPMN 设计器，增加 CallActivity 子流程，由 @Lesan 贡献 #616\n\nPAY 支付专区：\n\n * 【优化】微信支付退款时，日志记录发起微信支付异常信息，由 @杨宇庆 贡献 #1112\n * 【新增】微信转账到零钱：主动查询转账状态，由 @杨宇庆 贡献 #1113\n\n\n# 🐞 Bug Fixes\n\n * 【修复】菜单搜索点击输入框会折叠问题，由 @半栈幼儿员 贡献 #562\n * 【修复】商城订单的支付回调接口添加 @PermitAll 和部分 DO 缺少 @KeySequence 问题，由 @Lcp 贡献 #144\n * 【修复】滑动脱敏处理器禁用脱敏的判断，由 @杨宇庆 贡献 #1106\n * 【修复】Cloud 修复定时任务没有返回值导致的异常，由 @Lcp 贡献 #146\n * 【修复】由于多租户定时任务方法返回 void 导致的 xxlJob 任务执行失败的问题，由 @shanaiardor 贡献 #694\n * 【修复】解决编辑租户套餐时，菜单权限因缓存导致无法生效的问题，由 @杨宇庆 贡献 #1129\n * 【修复】XXL-JOB 和 @TenantJob 注解有冲突，导致传入参数可能为空，由 @芋道源码 贡献 ab5c790\n\nVue3 管理后台专区：\n\n * 【修复】外链有 hash 路由无法跳转的问题，由 @hecongyuan 贡献 #95\n * 【修复】退出登录后依旧在轮询消息未读数，导致反复弹窗，由 @半栈幼儿员 贡献 #573\n * 【修复】将超级管理员的角色 code 由 admin 改为 super_admin，由 @ZG4vin 贡献 #572\n * 【修复】开发模式下从“同时使用了用户信息和权限判断”的页面退出登录时异常问题，由 @半栈幼儿员 贡献 #574\n * 【修复】对 axios 的处理，由 @半栈幼儿员 贡献 #587、#588\n * 【修复】右侧设置按钮没有 z-index，导致表格滚动是会覆盖按钮，由 @熊猫大侠 贡献 #585\n * 【修复】Breadcrumb.vue 面包屑 css 处理，由 @Lei Chen 贡献 #104\n * 【修复】雪花算法 ID 精度丢失，由 @shixiaohe 贡献 #597\n * 【修复】优化路由是否为目录判断条件，由 @半栈幼儿员 贡献 #604\n * 【修复】修复引用表单设计器折叠面板和卡片组件，由 @aho 贡献 #606\n * 【修复】导出权限问题、支付应用选择问题：update src/views/pay/order/index.vue，由 @山野羡民 贡献 #592\n\nCRM 客户管理系统专区：\n\n * 【修复】待办列表和数据权限 BUG，由 @panjiabao 贡献 #1140\n * 【修复】解决商机、合同金额无法自动计算的问题，由 @杨宇庆 贡献 #615\n\nMALL 商城专区：\n\n * 【修复】分销记录只显示 1 条记录的问题，由 @痴货 贡献 #110\n * 【修复】当不存在优惠价格时，商城却显示优惠价格，由 @杨宇庆 贡献 #1107、#114\n * 【修复】当原价高于售价时，才显示划线价格，由 @杨宇庆 贡献 #113\n * 【修复】限时折扣活动的折扣校验不对，由 @卖瓜猹 贡献 #148\n * 【修复】uniapp 的微信小程序，前端直传时，真机环境下的图片上传问题，由 @卢越 贡献 #116\n * 【修复】uniapp 积分商城的商品列表加载更多异常，由 @Super Junior 贡献 #117\n * 【修复】uniapp 分佣的列表加载的 pageNo 不正确，由 @yuannuoxin 贡献 #118\n * 【修复】uniapp 分销中心的分销记录，由 @杨宇庆 贡献 #119\n * 【修复】uniapp 分享、分销的缺陷，由 @puhui999 贡献 #128\n * 【修复】积分商品的排序不正确，由 @puhui999 贡献 #1120\n * 【修复】活动选择商品时 sku 价格显示不正确的问题，由 @puhui999 贡献 #577\n * 【修复】会员取消售后接口中未校验用户 ID 的漏洞，由 @杨宇庆 贡献 #1124\n * 【修复】分佣商品界面预计佣金一直显示“计算中”的问题，由 @卢越 贡献 #123\n * 【修复】商城装修的一些缺陷，由 @puhui999 贡献 #611\n * 【修复】订单改价后退款时，退款金额异常问题，由 @RLgitee7311 贡献 #1150\n\nBPM 工作流专区：\n\n * 【修复】判断如果没有权限设置不进行可编辑表单过滤，避免表单变量被过滤，由 @shifeng1983 贡献 #590\n * 【修复】各种场景下的 bug，由 @Jason 贡献 #1161\n\n\n# 🔨 Dependency Upgrades\n\n * 【升级】spring boot from 3.3.4 to 3.4.1\n * 【升级】spring boot admin from 3.3.3 to 3.4.1\n * 【升级】redisson from 3.36.0 to 3.41.0\n * 【升级】knife4j from 4.5.0 to 4.6.0（社区版）\n * 【升级】mapstruct from 1.6.2 to 1.6.3\n * 【升级】hutool from 5.8.32 to 5.8.35\n * 【升级】netty from 4.1.113 to 4.1.116\n * 【升级】velocity from 2.4 to 2.4.1\n * 【升级】guava from 33.3.1 to 33.4.0\n * 【升级】mybatis-plus from 3.5.8 to 3.5.9\n * 【升级】jedis-mock from 1.1.4 to 1.1.8\n * 【升级】lombok from 1.18.34 to 1.18.36",
            normalizedContent: "# 增强工作流仿钉钉、飞书模式\n\n\n# 📈 statistic\n\n * 总代码行数：237166\n * 源码代码行数：146852\n * 注释行数：54010\n * 单元测试用例数：1073\n\n\n# ⭐ new features\n\n * 【优化】忽略多租户的表，兼容表名带有包裹符号的情况，由 @zoemak 贡献 #1101\n * 【优化】排序：字段驼峰改为下划线，由 @jinmh 贡献 #1108\n * 【新增】更新大屏相关的功能，由 @earlysummer 贡献 #2、#3、#4\n * 【优化】s3 minio sdk 替换为 aws sdk，由 @留声机恶魔 贡献 #1117\n * 【新增】租户套餐名重名校验，由 @小新 贡献 #1152\n\nvue3 管理后台专区：\n\n * 【优化】升级 form-create 插件版本，更好的动态表单体验，由 @半栈幼儿员 贡献 #564\n * 【优化】@import 修改为 @use 以应对 sass 升级弃用 @import，由 @半栈幼儿员 贡献 #571\n * 【新增】tagsview 支持多个 path 相同但 fullpath 不相同情况，由 @半栈幼儿员 贡献 #570\n * 【优化】添加自定义指令消除 ide 警告，由 @jinmh 贡献 #578\n * 【新增】uniapp 管理后台的双 token 刷新机制，整体布局，由 @qiksy 贡献 #3\n * 【新增】uniapp 登录界面，由 @紫星 贡献 #5、#6、#7、#19、#22、#25\n * 【新增】uniapp 三方登录，由 @紫星 贡献 #17\n * 【新增】uniapp 用户管理，由 @紫星 贡献 #26、#27\n * 【新增】uniapp 个人信息，由 @dengbo 贡献 #7、#16\n * 【新增】uniapp 角色管理，由 @泽彦 贡献 #9、#18\n * 【新增】uniapp 我的界面，由 @runcarefully 贡献 #13、#14\n * 【新增】uniapp 工作流的列表，由 @alwayssuper 贡献 #11\n * 【新增】uniapp 工作流的详情，由 @andyzhang 贡献 #15\n * 【新增】uniapp 个人中心，由 @guanhaizhe 贡献 #23、#24\n * 【新增】uniapp 审批通过、不通过界面，由 @alwayssuper 贡献 #21\n * 【优化】uniapp 在 android 打包的情况下，如果 dict 字典使用了 usedictstore()，会导致打包出来的应用白屏，由 @&wxr 贡献 #29\n\nmall 商城专区：\n\n * 【新增】自提门店支持绑定店员，由 @痴货 贡献 #1098、#560\n * 【新增】添加微信转账到零钱提现功能，由 @痴货 贡献 #1099、#561、#109\n * 【新增】商城分销: 创建分销员，由 @puhui999 贡献 #607、#1142\n * 【优化】商城 uniapp 的各种分享，由 @puhui999 贡献 #126\n * 【优化】分销中心的样式，由 @fn 贡献 #112\n * 【优化】订单确认页，增加按照顺序自动选择物流方式，替代原有只选择“快递配送”的方式，由 @芋道源码 贡献 789ec69\n * 【优化】签到的界面，由 @baron.bai 贡献 f36b183\n * 【优化】商城客服: 消息获取改为游标查询，由 @puhui999 贡献 #1118、#1130\n * 【优化】商城客服：整体交互体验和界面，由 @puhui999 贡献 #579、#1126、#584、#124、#125、#598、#599\n * 【优化】订单支付后的异常情况，由 @puhui999 贡献 #1151、#129、#131\n\nbpm 工作流专区：\n\n * 【优化】simple 仿钉钉/飞书模式的完善，由 @jason 贡献 #1133、#595\n * 【新增】simple 仿钉钉/飞书模式的高亮，由 @jason 贡献\n * 【新增】bpmn servicetask 的支持，并进行优化，由 @lesan 贡献 #605\n * 【优化】bpmn 流程图高亮的计算，切换到后端为主，由 @芋道源码 贡献 33f3bc0、41eec78\n * 【优化】流程模型列表 ui 重构，以及数组分类分组展示逻辑，由 @goldenzqqq 贡献 #89、#92、#93、#94\n * 【优化】审批详情页面，由 @zqqqqqq 贡献 #80、#102\n * 【优化】审批发起界面，由 @zqqqqqq 贡献 #98、#99、#100\n * 【优化】流程模型的设计新界面，由 @zqqqqqq 贡献 #111、#114、#115、#116\n * 【优化】审批中心的我的流程界面，由 @tuituji111 贡献 #583、#596、#602\n * 【优化】bpmn 设计器，增加 usertask 自定义配置，由 @lesan 贡献 #586、#594、#600、#603、#1137、#609、#610、#612、#614\n * 【新增】bpmn 设计器，增加 callactivity 子流程，由 @lesan 贡献 #616\n\npay 支付专区：\n\n * 【优化】微信支付退款时，日志记录发起微信支付异常信息，由 @杨宇庆 贡献 #1112\n * 【新增】微信转账到零钱：主动查询转账状态，由 @杨宇庆 贡献 #1113\n\n\n# 🐞 bug fixes\n\n * 【修复】菜单搜索点击输入框会折叠问题，由 @半栈幼儿员 贡献 #562\n * 【修复】商城订单的支付回调接口添加 @permitall 和部分 do 缺少 @keysequence 问题，由 @lcp 贡献 #144\n * 【修复】滑动脱敏处理器禁用脱敏的判断，由 @杨宇庆 贡献 #1106\n * 【修复】cloud 修复定时任务没有返回值导致的异常，由 @lcp 贡献 #146\n * 【修复】由于多租户定时任务方法返回 void 导致的 xxljob 任务执行失败的问题，由 @shanaiardor 贡献 #694\n * 【修复】解决编辑租户套餐时，菜单权限因缓存导致无法生效的问题，由 @杨宇庆 贡献 #1129\n * 【修复】xxl-job 和 @tenantjob 注解有冲突，导致传入参数可能为空，由 @芋道源码 贡献 ab5c790\n\nvue3 管理后台专区：\n\n * 【修复】外链有 hash 路由无法跳转的问题，由 @hecongyuan 贡献 #95\n * 【修复】退出登录后依旧在轮询消息未读数，导致反复弹窗，由 @半栈幼儿员 贡献 #573\n * 【修复】将超级管理员的角色 code 由 admin 改为 super_admin，由 @zg4vin 贡献 #572\n * 【修复】开发模式下从“同时使用了用户信息和权限判断”的页面退出登录时异常问题，由 @半栈幼儿员 贡献 #574\n * 【修复】对 axios 的处理，由 @半栈幼儿员 贡献 #587、#588\n * 【修复】右侧设置按钮没有 z-index，导致表格滚动是会覆盖按钮，由 @熊猫大侠 贡献 #585\n * 【修复】breadcrumb.vue 面包屑 css 处理，由 @lei chen 贡献 #104\n * 【修复】雪花算法 id 精度丢失，由 @shixiaohe 贡献 #597\n * 【修复】优化路由是否为目录判断条件，由 @半栈幼儿员 贡献 #604\n * 【修复】修复引用表单设计器折叠面板和卡片组件，由 @aho 贡献 #606\n * 【修复】导出权限问题、支付应用选择问题：update src/views/pay/order/index.vue，由 @山野羡民 贡献 #592\n\ncrm 客户管理系统专区：\n\n * 【修复】待办列表和数据权限 bug，由 @panjiabao 贡献 #1140\n * 【修复】解决商机、合同金额无法自动计算的问题，由 @杨宇庆 贡献 #615\n\nmall 商城专区：\n\n * 【修复】分销记录只显示 1 条记录的问题，由 @痴货 贡献 #110\n * 【修复】当不存在优惠价格时，商城却显示优惠价格，由 @杨宇庆 贡献 #1107、#114\n * 【修复】当原价高于售价时，才显示划线价格，由 @杨宇庆 贡献 #113\n * 【修复】限时折扣活动的折扣校验不对，由 @卖瓜猹 贡献 #148\n * 【修复】uniapp 的微信小程序，前端直传时，真机环境下的图片上传问题，由 @卢越 贡献 #116\n * 【修复】uniapp 积分商城的商品列表加载更多异常，由 @super junior 贡献 #117\n * 【修复】uniapp 分佣的列表加载的 pageno 不正确，由 @yuannuoxin 贡献 #118\n * 【修复】uniapp 分销中心的分销记录，由 @杨宇庆 贡献 #119\n * 【修复】uniapp 分享、分销的缺陷，由 @puhui999 贡献 #128\n * 【修复】积分商品的排序不正确，由 @puhui999 贡献 #1120\n * 【修复】活动选择商品时 sku 价格显示不正确的问题，由 @puhui999 贡献 #577\n * 【修复】会员取消售后接口中未校验用户 id 的漏洞，由 @杨宇庆 贡献 #1124\n * 【修复】分佣商品界面预计佣金一直显示“计算中”的问题，由 @卢越 贡献 #123\n * 【修复】商城装修的一些缺陷，由 @puhui999 贡献 #611\n * 【修复】订单改价后退款时，退款金额异常问题，由 @rlgitee7311 贡献 #1150\n\nbpm 工作流专区：\n\n * 【修复】判断如果没有权限设置不进行可编辑表单过滤，避免表单变量被过滤，由 @shifeng1983 贡献 #590\n * 【修复】各种场景下的 bug，由 @jason 贡献 #1161\n\n\n# 🔨 dependency upgrades\n\n * 【升级】spring boot from 3.3.4 to 3.4.1\n * 【升级】spring boot admin from 3.3.3 to 3.4.1\n * 【升级】redisson from 3.36.0 to 3.41.0\n * 【升级】knife4j from 4.5.0 to 4.6.0（社区版）\n * 【升级】mapstruct from 1.6.2 to 1.6.3\n * 【升级】hutool from 5.8.32 to 5.8.35\n * 【升级】netty from 4.1.113 to 4.1.116\n * 【升级】velocity from 2.4 to 2.4.1\n * 【升级】guava from 33.3.1 to 33.4.0\n * 【升级】mybatis-plus from 3.5.8 to 3.5.9\n * 【升级】jedis-mock from 1.1.4 to 1.1.8\n * 【升级】lombok from 1.18.34 to 1.18.36",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【v2.3.0】2024-10-07",
            frontmatter: {
                title: "【v2.3.0】2024-10-07",
                date: "2024-08-02T00:00:00.000Z",
                permalink: "/changelog/2.3.0/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/30.%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/72.%E3%80%90v2-3-0%E3%80%912024-10-07.html",
            relativePath: "01.开发指南/30.更新日志/72.【v2-3-0】2024-10-07.md",
            key: "v-23b6cc78",
            path: "/changelog/2.3.0/",
            headers: [{
                level: 2,
                title: "支持积分商城、优化工作流仿钉钉、飞书模式",
                slug: "支持积分商城、优化工作流仿钉钉、飞书模式",
                normalizedTitle: "支持积分商城、优化工作流仿钉钉、飞书模式",
                charIndex: 2
            }, {
                level: 2,
                title: "📈 Statistic",
                slug: "📈-statistic",
                normalizedTitle: "📈 statistic",
                charIndex: 27
            }, {
                level: 3,
                title: "⭐ New Features",
                slug: "⭐-new-features",
                normalizedTitle: "⭐ new features",
                charIndex: 108
            }, {
                level: 3,
                title: "🐞 Bug Fixes",
                slug: "🐞-bug-fixes",
                normalizedTitle: "🐞 bug fixes",
                charIndex: 2813
            }, {
                level: 3,
                title: "🔨 Dependency Upgrades",
                slug: "🔨-dependency-upgrades",
                normalizedTitle: "🔨 dependency upgrades",
                charIndex: 5440
            }],
            headersStr: "支持积分商城、优化工作流仿钉钉、飞书模式 📈 Statistic ⭐ New Features 🐞 Bug Fixes 🔨 Dependency Upgrades",
            content: "# 支持积分商城、优化工作流仿钉钉、飞书模式\n\n\n# 📈 Statistic\n\n * 总代码行数：234569\n * 源码代码行数：145178\n * 注释行数：53410\n * 单元测试用例数：1058\n\n\n# ⭐ New Features\n\n * 【新增】数据脱敏支持 disable 属性，可用于实现字段权限的功能，由 @craftsman4j 贡献 #605\n * 【优化】多租户 Job，日志记录租户 Job 错误信息，由 @杨宇庆 贡献 #1059\n * 【优化】使用 HttpUti 直接对接阿里云、华为云、腾讯云、七牛云等短信，减少 SDK 依赖、包大小，由 @scholarli 贡献 #1015、#1037、#1024、#1054\n * 【优化】增加 MyBatis Plus SQL 缓存、操作日志异步化记录、HTTP 签名增加 appId 隔离，由 @陈晨成 贡献 #130\n * 【新增】用户注册功能，由 @scholarli 贡献 #1074、#538\n\nVue3 管理后台专区：\n\n * 【优化】DictTag 支持多个属性，由 @Zqqqqqq 贡献 #68、#73、#72、#75\n * 【优化】优化 stylelint、优化登录页等等，由 @半栈幼儿员 贡献 #495\n * 【优化】标签页沉浸式效果，由 @半栈幼儿员 贡献 #499、#532\n * 【优化】element plus 从 2.7.0 升级到 2.8.0，由 @kuxiao 贡献 #496\n * 【优化】el-checkbox 的 label 优化成 value，由 @半栈幼儿员 贡献 #520、#511\n * 【优化】规范 Login 界面的 style 位置，由 @半栈幼儿员 贡献 #512\n * 【优化】IFrame 组件的封装，由 @半栈幼儿员 贡献 #508\n * 【优化】垂直菜单可用宽度，由 @半栈幼儿员 贡献 #519\n * 【优化】优化角色的数据权限、菜单权限的选择框，由 @半栈幼儿员 贡献 #509\n * 【优化】添加全局 box-sizing: border-box;（先等等、全局影响），由 @半栈幼儿员 贡献 #515、#518\n * 【新增】快速开关菜单的按钮，由 @邓超 贡献 #54\n\nMALL 商城专区：\n\n * 【新增】下单时，支持积分抵扣的选择，由 @puhui999 贡献 #68、#70\n * 【新增】积分商城，由 @puhui999 贡献 #1089、#1090、#1092、#555、#558、#1094、#105、#107、#1097\n * 【新增】uni-app 增加 terminal 终端类型的传递，由 @Ordinary 贡献 #66\n * 【优化】进入分类页的时候，自动勾选左侧一级分类（比如从首页进入），由 @卢越 贡献 #74\n * 【完善】uni-app 针对拼团邀请的处理，由 @puhui999 贡献 #79\n * 【新增】会员详情，增加售后、余额查看/修改的能力，由 @Zqqqqqq、@puhui999 贡献 #77、#78、#504、#1045、#1047\n * 【优化】商品结算页现在可展示优惠券是否可用的原因，由 @卢越 贡献 #84\n * 【优化】Vue3 管理后台：黑暗主题适配，涉及客服、售后详情，由 @卢越 贡献 #516、#524、#526\n * 【优化】满减送活动的前端 + 后端实现，由 @puhui999 贡献 #521、#525、#1050、#528、#1064、#1060、#1069、#1070、#1057、#1080、#546、#547、#1081\n * 【优化】限时折扣活动的前端 + 后端实现，由 @痴货、@puhui999 贡献 #529、#1055、#545、#552、#102\n * 【优化】商城客服聊天相关优化，由 @卢越 贡献 #527、#88\n * 【新增】uni-app 评论支持匿名、上传文件，由 @卢越 贡献 #89\n * 【优化】商城优惠券新增描述字段，由 @卢越 贡献 #530、#1056\n * 【优化】拼团、秒杀的店铺装修，由 @卢越 贡献 #1073、#537、#539、#96、#543、#1077、#1078\n * 【优化】分销提现时，支持下拉选择银行名字，由 @heyho 贡献 #1071、#92\n * 【优化】支付方式默认选中首个可用方式，由 @Lcp 贡献 #97\n * 【优化】查询订单详情接口，增加 sync 主动同步支付状态，由 @芋道源码 贡献 8850df1\n * 【优化】uni-app 端文件直传到OSS服务，由 @卢越 贡献 #1093、#103\n * 【优化】商城 Vue3 的一些优化，由 @卢越 贡献 #557、#104\n * 【优化】确认收货添加提示确认，提交售后信息后直接返回到订单详情，由 @Lcp 贡献 #106\n\nBPM 工作流专区：\n\n * 【新增】进一步完善仿钉钉/快搭模式，由 @Jason 贡献 #978、#452\n * 【优化】重构工作流审批页面，由 @Zqqqqqq 贡献 #80、#82、#84\n * 【优化】会签、或签分配人的时候，如果已经分配过，则不重复计算，由 @芋道源码 贡献 a6e5b28\n\nPAY 支付专区：\n\n * 【优化】支持支付宝接口内容加密，及修复支付宝渠道配置，由 @zhaoyu 贡献 #498\n * 【优化】钱包余额更新时，加锁避免并发更新，导致流水不连续的问题，由 @芋道源码 贡献 dbb674b\n * 【优化】优化支付宝、微信支付时，支付结果和异步回调结果的冲突，由 @芋道源码 贡献 dbb674b\n * 【新增】支付应用，增加 appKey 标识，用于不同接入方的标识，由 @陈玄礼 贡献 #1041\n * 【优化】更新支付单价格的检视意见，由 @杨宇庆 贡献 #1082\n * 【优化】查询支付订单时，增加 sync 主动轮询，解决支付宝、微信存在延迟的问题，由 @芋道源码 贡献 2c2e9fe、a1995c8、74e0427\n * 【优化】商城订单、钱包充值、示例订单的支付回调，增加“已支付”情况下的防重处理，由 @芋道源码 贡献 57a934a、3bde43b、567cbea\n * 【新增】《钱包充值、支付、退款》文档\n * 【新增】《模拟支付、退款》文档\n\nAI 大模型专区：\n\n * 【优化】AI 思维导图的界面，由 @hhhero 贡献 #489、#493\n * 【新增】知识库的后端实现，由 @小新 贡献 #16、#18、#19、#20、#21\n\nIoT 物联网专区：\n\n * 【新增】产品、设备、物模型的管理，由 @芋道源码 贡献 #542、#1076\n\n\n# 🐞 Bug Fixes\n\n * 【修复】insertOrUpdate 死循环问题，由 @bro0k 贡献 #619\n * 【修复】使用 MySQL 数据库，执行 mvn test 时多个 TestCase 失败，由 @George.Wei 贡献 #1051\n * 【修复】H5 子页面刷新点击回退，跳转至登录页问题，由 @kong 贡献 #2\n * 【修复】关闭菜单还是会显示的问题修复，由 @Vmo 贡献 #1063\n * 【修复】角色标识的提示不正确问题，由 @尹先生 贡献 #131\n * 【修复】nacos-client=2.0.4 控制台异常,升级 spring.cloud.alibaba.version=2021.0.5.0，由 @JuniorXu 贡献 #171\n * 【修复】修复字典选择器数据类型不生效问题，由 @OlyLis 贡献 #548\n * 【修复】Cloud 多租户下 XXL-Job 定时任务结果处理都为失败问题，由 @Lcp 贡献 #141\n * 【修复】完善对 SQLServer 2015 的兼容性，由 @芋道源码 贡献 af5520d\n * 【修复】代码生成时，同步数据库结构之后字段顺序混乱的问题，由 @supemeko 贡献 #1066\n\nVue3 管理后台专区：\n\n * 【修复】刷新令牌过期时，可能导致的白屏问题，由 @AhJindeg 贡献 #533、#535\n * 【修复】IconSelect 无法清理的问题，由 @AhJindeg 贡献 #522\n * 【修复】top 布局模式下主容器高度计算方式、工具栏多出 1px、页脚多出 1px，由 @半栈幼儿员 贡献 #513\n * 【修复】时间格式错误，由 @半栈幼儿员 贡献 #510\n * 【修复】标签栏高度（被 box-sizing 和 scrollbar__view 的 height: 99% 干扰），由 @半栈幼儿员 贡献 #517\n * 【修复】移动端模式下，浅色背景导致标题与背景融为一体，直接使用 Element UI 自带的颜色变量，由 @爱摸鱼的阿恒 贡献 #81\n * 【修复】新创建用户未上传头像时，头像不显示的bug；修复布局配置中标签页图标 key 错误的bug，由 @kuxiao 贡献 #540\n * 【修复】修复路由二级路径 VITE_BASE_PATH 支持，由 @半栈幼儿员 贡献 #544\n * 【修复】Vben 下载 Excel 文件时的异常处理问题，由 @kuxiao 贡献 #47\n * 【修复】菜单的路由地址为链接时不带参数的问题，由 @kuxiao 贡献 #550\n * 【修复】处理 vite-plugin-top-level-await 打包报错，由 @OlyLis 贡献 #556\n\nCRM 客户管理系统专区：\n\n * 【修复】查询中审批状态标识错误的问题，由 @Lcp 贡献 #139\n\nMALL 商城专区：\n\n * 【修复】切换 tabs 时，运营模块数据不实时更新的问题，由 @gitkmw 贡献 #69\n * 【修复】订单结算信息返回时，缺少积分相关信息，由 @puhui999 贡献 #1031\n * 【修复】修复抖音小程序无法启动问题，由 @heStudio_admin 贡献 #67\n * 【修复】获取 uni-app 订单可使用的优惠券时，少传递类型的问题，由 @卢越 贡献 #69、#1032\n * 【修复】优惠券回收之后，领取数量和剩余数量不更新的问题，由 @卢越 贡献 #1034\n * 【修复】拼团：未开启拼团的 SKU 需要禁用选择，由 @芋道源码 贡献 5feab41\n * 【修复】uni-app 部分店铺装修组件，没有 styles 样式传递，由 @卢越 贡献 #75、#76、#80、#81、#82\n * 【修复】uni-app 拼团、秒杀装修组件，没有正确展示价格，由 @卢越 贡献 #81、#501、#83\n * 【修复】uni-app 顶部导航栏装修无效的问题，由 @卢越 贡献 #87\n * 【修复】解决商品项图片为空串时，订单项没有使用SPU图片的问题，由 @Ordinary 贡献 #1035\n * 【修复】uni-app 购物车商品数量减为0时，删除错误，由 @邓飞鹏 贡献 #78\n * 【修复】会员统计可能存在的空指针，由 @卢越 贡献 #1048\n * 【修复】订单结算页没有优惠券但是提示优惠券不存在的问题，由 @卢越 贡献 #86\n * 【修复】修复快递鸟顺丰查询问题、订单退款问题、订单日志查询优化等，由 @卢越 贡献 #1049\n * 【修复】商城发货后订单日志无法显示快递公司名称的问题，由 @卢越 贡献 #1055\n * 【修复】分销：驳回佣金提现时,报'模板参数(reason)缺失'、让普通用户无需成为推广者也可以绑定成为推广者的下级以便让指定的推广者赚取佣金，由 @heyho 贡献 #1068\n * 【修复】uniapp 分销中心 => 我的团队 页面样式，布局优化、美化，由 @heyho 贡献 #95\n * 【修复】uniapp 授权登录成功后，每次都要填昵称和重新上传头像，由 @heyho 贡献 #93\n * 【修复】uniapp 在线客服页面的一些问题，由 @英狐 贡献 #90\n * 【修复】发送商品显示不全问题和打包后客服聊天表情缺失问题，由 @Lcp 贡献 #541\n * 【修复】批量优化或修改 BUG，由 @lrlyl 贡献 #1084、#553、#101\n * 【修复】发货后订单操作日志快递公司显示错误问题，由 @筱龙缘 贡献 #140\n * 【修复】物流信息、微信通知的缓存，因为 @Cacheable 错误使用 condition 导致无法缓存的问题，由 @芋道源码 贡献 4c09a55\n * 【修复】虚拟成团时，headId 未使用团长编号，由 @芋道源码 贡献 7849666\n\nBPM 工作流专区：\n\n * 【修复】流程模型分页数量查询不正确，由 @今晚打老虎 贡献 #135\n * 【修复】任务相关的分页查询，事件范围不对，由 @hoha 贡献 #167\n * 【修复】bpmnBytes 在非 UTF-8 环境下，可能存在乱码的问题，由 @SinyLi 贡献 #951\n\n\n# 🔨 Dependency Upgrades\n\n * 【升级】spring boot from 3.3.1 to 3.3.4\n * 【升级】spring boot admin from 3.3.2 to 3.3.3\n * 【升级】redisson from 3.32.0 to 3.36.0\n * 【升级】rocketmq-spring from 2.3.0 to 2.3.1\n * 【升级】netty from 4.1.111 to 4.1.113\n * 【升级】mapstruct from 1.5.5 to 1.6.2\n * 【升级】hutool from 5.8.29 to 5.8.32\n * 【升级】velocity from 2.3 to 2.4\n * 【升级】guava from 33.2.1 to 33.3.1\n * 【升级】jedis-mock from 1.1.2 to 1.1.4\n * 【升级】weixin-java from 4.6.0 to 4.6.5.B\n * 【升级】dm8 from 8.1.3.62 to 8.1.3.140\n * 【升级】opengauss from 5.0.2 to 5.1.0\n * 【升级】easy-trans from 3.0.5 to 3.0.6\n * 【升级】mybatis-plus from 3.5.7 to 3.5.8\n * 【升级】easyexcel from 3.3.4 to 4.0.3\n * 【移除】xercesImpl",
            normalizedContent: "# 支持积分商城、优化工作流仿钉钉、飞书模式\n\n\n# 📈 statistic\n\n * 总代码行数：234569\n * 源码代码行数：145178\n * 注释行数：53410\n * 单元测试用例数：1058\n\n\n# ⭐ new features\n\n * 【新增】数据脱敏支持 disable 属性，可用于实现字段权限的功能，由 @craftsman4j 贡献 #605\n * 【优化】多租户 job，日志记录租户 job 错误信息，由 @杨宇庆 贡献 #1059\n * 【优化】使用 httputi 直接对接阿里云、华为云、腾讯云、七牛云等短信，减少 sdk 依赖、包大小，由 @scholarli 贡献 #1015、#1037、#1024、#1054\n * 【优化】增加 mybatis plus sql 缓存、操作日志异步化记录、http 签名增加 appid 隔离，由 @陈晨成 贡献 #130\n * 【新增】用户注册功能，由 @scholarli 贡献 #1074、#538\n\nvue3 管理后台专区：\n\n * 【优化】dicttag 支持多个属性，由 @zqqqqqq 贡献 #68、#73、#72、#75\n * 【优化】优化 stylelint、优化登录页等等，由 @半栈幼儿员 贡献 #495\n * 【优化】标签页沉浸式效果，由 @半栈幼儿员 贡献 #499、#532\n * 【优化】element plus 从 2.7.0 升级到 2.8.0，由 @kuxiao 贡献 #496\n * 【优化】el-checkbox 的 label 优化成 value，由 @半栈幼儿员 贡献 #520、#511\n * 【优化】规范 login 界面的 style 位置，由 @半栈幼儿员 贡献 #512\n * 【优化】iframe 组件的封装，由 @半栈幼儿员 贡献 #508\n * 【优化】垂直菜单可用宽度，由 @半栈幼儿员 贡献 #519\n * 【优化】优化角色的数据权限、菜单权限的选择框，由 @半栈幼儿员 贡献 #509\n * 【优化】添加全局 box-sizing: border-box;（先等等、全局影响），由 @半栈幼儿员 贡献 #515、#518\n * 【新增】快速开关菜单的按钮，由 @邓超 贡献 #54\n\nmall 商城专区：\n\n * 【新增】下单时，支持积分抵扣的选择，由 @puhui999 贡献 #68、#70\n * 【新增】积分商城，由 @puhui999 贡献 #1089、#1090、#1092、#555、#558、#1094、#105、#107、#1097\n * 【新增】uni-app 增加 terminal 终端类型的传递，由 @ordinary 贡献 #66\n * 【优化】进入分类页的时候，自动勾选左侧一级分类（比如从首页进入），由 @卢越 贡献 #74\n * 【完善】uni-app 针对拼团邀请的处理，由 @puhui999 贡献 #79\n * 【新增】会员详情，增加售后、余额查看/修改的能力，由 @zqqqqqq、@puhui999 贡献 #77、#78、#504、#1045、#1047\n * 【优化】商品结算页现在可展示优惠券是否可用的原因，由 @卢越 贡献 #84\n * 【优化】vue3 管理后台：黑暗主题适配，涉及客服、售后详情，由 @卢越 贡献 #516、#524、#526\n * 【优化】满减送活动的前端 + 后端实现，由 @puhui999 贡献 #521、#525、#1050、#528、#1064、#1060、#1069、#1070、#1057、#1080、#546、#547、#1081\n * 【优化】限时折扣活动的前端 + 后端实现，由 @痴货、@puhui999 贡献 #529、#1055、#545、#552、#102\n * 【优化】商城客服聊天相关优化，由 @卢越 贡献 #527、#88\n * 【新增】uni-app 评论支持匿名、上传文件，由 @卢越 贡献 #89\n * 【优化】商城优惠券新增描述字段，由 @卢越 贡献 #530、#1056\n * 【优化】拼团、秒杀的店铺装修，由 @卢越 贡献 #1073、#537、#539、#96、#543、#1077、#1078\n * 【优化】分销提现时，支持下拉选择银行名字，由 @heyho 贡献 #1071、#92\n * 【优化】支付方式默认选中首个可用方式，由 @lcp 贡献 #97\n * 【优化】查询订单详情接口，增加 sync 主动同步支付状态，由 @芋道源码 贡献 8850df1\n * 【优化】uni-app 端文件直传到oss服务，由 @卢越 贡献 #1093、#103\n * 【优化】商城 vue3 的一些优化，由 @卢越 贡献 #557、#104\n * 【优化】确认收货添加提示确认，提交售后信息后直接返回到订单详情，由 @lcp 贡献 #106\n\nbpm 工作流专区：\n\n * 【新增】进一步完善仿钉钉/快搭模式，由 @jason 贡献 #978、#452\n * 【优化】重构工作流审批页面，由 @zqqqqqq 贡献 #80、#82、#84\n * 【优化】会签、或签分配人的时候，如果已经分配过，则不重复计算，由 @芋道源码 贡献 a6e5b28\n\npay 支付专区：\n\n * 【优化】支持支付宝接口内容加密，及修复支付宝渠道配置，由 @zhaoyu 贡献 #498\n * 【优化】钱包余额更新时，加锁避免并发更新，导致流水不连续的问题，由 @芋道源码 贡献 dbb674b\n * 【优化】优化支付宝、微信支付时，支付结果和异步回调结果的冲突，由 @芋道源码 贡献 dbb674b\n * 【新增】支付应用，增加 appkey 标识，用于不同接入方的标识，由 @陈玄礼 贡献 #1041\n * 【优化】更新支付单价格的检视意见，由 @杨宇庆 贡献 #1082\n * 【优化】查询支付订单时，增加 sync 主动轮询，解决支付宝、微信存在延迟的问题，由 @芋道源码 贡献 2c2e9fe、a1995c8、74e0427\n * 【优化】商城订单、钱包充值、示例订单的支付回调，增加“已支付”情况下的防重处理，由 @芋道源码 贡献 57a934a、3bde43b、567cbea\n * 【新增】《钱包充值、支付、退款》文档\n * 【新增】《模拟支付、退款》文档\n\nai 大模型专区：\n\n * 【优化】ai 思维导图的界面，由 @hhhero 贡献 #489、#493\n * 【新增】知识库的后端实现，由 @小新 贡献 #16、#18、#19、#20、#21\n\niot 物联网专区：\n\n * 【新增】产品、设备、物模型的管理，由 @芋道源码 贡献 #542、#1076\n\n\n# 🐞 bug fixes\n\n * 【修复】insertorupdate 死循环问题，由 @bro0k 贡献 #619\n * 【修复】使用 mysql 数据库，执行 mvn test 时多个 testcase 失败，由 @george.wei 贡献 #1051\n * 【修复】h5 子页面刷新点击回退，跳转至登录页问题，由 @kong 贡献 #2\n * 【修复】关闭菜单还是会显示的问题修复，由 @vmo 贡献 #1063\n * 【修复】角色标识的提示不正确问题，由 @尹先生 贡献 #131\n * 【修复】nacos-client=2.0.4 控制台异常,升级 spring.cloud.alibaba.version=2021.0.5.0，由 @juniorxu 贡献 #171\n * 【修复】修复字典选择器数据类型不生效问题，由 @olylis 贡献 #548\n * 【修复】cloud 多租户下 xxl-job 定时任务结果处理都为失败问题，由 @lcp 贡献 #141\n * 【修复】完善对 sqlserver 2015 的兼容性，由 @芋道源码 贡献 af5520d\n * 【修复】代码生成时，同步数据库结构之后字段顺序混乱的问题，由 @supemeko 贡献 #1066\n\nvue3 管理后台专区：\n\n * 【修复】刷新令牌过期时，可能导致的白屏问题，由 @ahjindeg 贡献 #533、#535\n * 【修复】iconselect 无法清理的问题，由 @ahjindeg 贡献 #522\n * 【修复】top 布局模式下主容器高度计算方式、工具栏多出 1px、页脚多出 1px，由 @半栈幼儿员 贡献 #513\n * 【修复】时间格式错误，由 @半栈幼儿员 贡献 #510\n * 【修复】标签栏高度（被 box-sizing 和 scrollbar__view 的 height: 99% 干扰），由 @半栈幼儿员 贡献 #517\n * 【修复】移动端模式下，浅色背景导致标题与背景融为一体，直接使用 element ui 自带的颜色变量，由 @爱摸鱼的阿恒 贡献 #81\n * 【修复】新创建用户未上传头像时，头像不显示的bug；修复布局配置中标签页图标 key 错误的bug，由 @kuxiao 贡献 #540\n * 【修复】修复路由二级路径 vite_base_path 支持，由 @半栈幼儿员 贡献 #544\n * 【修复】vben 下载 excel 文件时的异常处理问题，由 @kuxiao 贡献 #47\n * 【修复】菜单的路由地址为链接时不带参数的问题，由 @kuxiao 贡献 #550\n * 【修复】处理 vite-plugin-top-level-await 打包报错，由 @olylis 贡献 #556\n\ncrm 客户管理系统专区：\n\n * 【修复】查询中审批状态标识错误的问题，由 @lcp 贡献 #139\n\nmall 商城专区：\n\n * 【修复】切换 tabs 时，运营模块数据不实时更新的问题，由 @gitkmw 贡献 #69\n * 【修复】订单结算信息返回时，缺少积分相关信息，由 @puhui999 贡献 #1031\n * 【修复】修复抖音小程序无法启动问题，由 @hestudio_admin 贡献 #67\n * 【修复】获取 uni-app 订单可使用的优惠券时，少传递类型的问题，由 @卢越 贡献 #69、#1032\n * 【修复】优惠券回收之后，领取数量和剩余数量不更新的问题，由 @卢越 贡献 #1034\n * 【修复】拼团：未开启拼团的 sku 需要禁用选择，由 @芋道源码 贡献 5feab41\n * 【修复】uni-app 部分店铺装修组件，没有 styles 样式传递，由 @卢越 贡献 #75、#76、#80、#81、#82\n * 【修复】uni-app 拼团、秒杀装修组件，没有正确展示价格，由 @卢越 贡献 #81、#501、#83\n * 【修复】uni-app 顶部导航栏装修无效的问题，由 @卢越 贡献 #87\n * 【修复】解决商品项图片为空串时，订单项没有使用spu图片的问题，由 @ordinary 贡献 #1035\n * 【修复】uni-app 购物车商品数量减为0时，删除错误，由 @邓飞鹏 贡献 #78\n * 【修复】会员统计可能存在的空指针，由 @卢越 贡献 #1048\n * 【修复】订单结算页没有优惠券但是提示优惠券不存在的问题，由 @卢越 贡献 #86\n * 【修复】修复快递鸟顺丰查询问题、订单退款问题、订单日志查询优化等，由 @卢越 贡献 #1049\n * 【修复】商城发货后订单日志无法显示快递公司名称的问题，由 @卢越 贡献 #1055\n * 【修复】分销：驳回佣金提现时,报'模板参数(reason)缺失'、让普通用户无需成为推广者也可以绑定成为推广者的下级以便让指定的推广者赚取佣金，由 @heyho 贡献 #1068\n * 【修复】uniapp 分销中心 => 我的团队 页面样式，布局优化、美化，由 @heyho 贡献 #95\n * 【修复】uniapp 授权登录成功后，每次都要填昵称和重新上传头像，由 @heyho 贡献 #93\n * 【修复】uniapp 在线客服页面的一些问题，由 @英狐 贡献 #90\n * 【修复】发送商品显示不全问题和打包后客服聊天表情缺失问题，由 @lcp 贡献 #541\n * 【修复】批量优化或修改 bug，由 @lrlyl 贡献 #1084、#553、#101\n * 【修复】发货后订单操作日志快递公司显示错误问题，由 @筱龙缘 贡献 #140\n * 【修复】物流信息、微信通知的缓存，因为 @cacheable 错误使用 condition 导致无法缓存的问题，由 @芋道源码 贡献 4c09a55\n * 【修复】虚拟成团时，headid 未使用团长编号，由 @芋道源码 贡献 7849666\n\nbpm 工作流专区：\n\n * 【修复】流程模型分页数量查询不正确，由 @今晚打老虎 贡献 #135\n * 【修复】任务相关的分页查询，事件范围不对，由 @hoha 贡献 #167\n * 【修复】bpmnbytes 在非 utf-8 环境下，可能存在乱码的问题，由 @sinyli 贡献 #951\n\n\n# 🔨 dependency upgrades\n\n * 【升级】spring boot from 3.3.1 to 3.3.4\n * 【升级】spring boot admin from 3.3.2 to 3.3.3\n * 【升级】redisson from 3.32.0 to 3.36.0\n * 【升级】rocketmq-spring from 2.3.0 to 2.3.1\n * 【升级】netty from 4.1.111 to 4.1.113\n * 【升级】mapstruct from 1.5.5 to 1.6.2\n * 【升级】hutool from 5.8.29 to 5.8.32\n * 【升级】velocity from 2.3 to 2.4\n * 【升级】guava from 33.2.1 to 33.3.1\n * 【升级】jedis-mock from 1.1.2 to 1.1.4\n * 【升级】weixin-java from 4.6.0 to 4.6.5.b\n * 【升级】dm8 from 8.1.3.62 to 8.1.3.140\n * 【升级】opengauss from 5.0.2 to 5.1.0\n * 【升级】easy-trans from 3.0.5 to 3.0.6\n * 【升级】mybatis-plus from 3.5.7 to 3.5.8\n * 【升级】easyexcel from 3.3.4 to 4.0.3\n * 【移除】xercesimpl",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【v2.2.0】2024-08-02",
            frontmatter: {
                title: "【v2.2.0】2024-08-02",
                date: "2024-05-06T00:00:00.000Z",
                permalink: "/changelog/2.2.0/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/30.%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/73.%E3%80%90v2-2-0%E3%80%912024-08-02.html",
            relativePath: "01.开发指南/30.更新日志/73.【v2-2-0】2024-08-02.md",
            key: "v-4abee190",
            path: "/changelog/2.2.0/",
            headers: [{
                level: 2,
                title: "支持 AIGC 人工智能、商城在线客服",
                slug: "支持-aigc-人工智能、商城在线客服",
                normalizedTitle: "支持 aigc 人工智能、商城在线客服",
                charIndex: 2
            }, {
                level: 2,
                title: "📈 Statistic",
                slug: "📈-statistic",
                normalizedTitle: "📈 statistic",
                charIndex: 26
            }, {
                level: 3,
                title: "⭐ New Features",
                slug: "⭐-new-features",
                normalizedTitle: "⭐ new features",
                charIndex: 107
            }, {
                level: 3,
                title: "🐞 Bug Fixes",
                slug: "🐞-bug-fixes",
                normalizedTitle: "🐞 bug fixes",
                charIndex: 2068
            }, {
                level: 3,
                title: "🔨 Dependency Upgrades",
                slug: "🔨-dependency-upgrades",
                normalizedTitle: "🔨 dependency upgrades",
                charIndex: 6025
            }],
            headersStr: "支持 AIGC 人工智能、商城在线客服 📈 Statistic ⭐ New Features 🐞 Bug Fixes 🔨 Dependency Upgrades",
            content: "# 支持 AIGC 人工智能、商城在线客服\n\n\n# 📈 Statistic\n\n * 总代码行数：222554\n * 源码代码行数：137846\n * 注释行数：50515\n * 单元测试用例数：1043\n\n\n# ⭐ New Features\n\n * 【新增】支持人大金仓数 KingbaseES，由 @dhb52 贡献 #982\n * 【新增】find_in_set 函数的跨数据库实现，由 @dhb52 贡献 #994、#1000\n * 【新增】支持华为 openGauss，由 @dhb52 贡献 #985\n * 【新增】Vue3 管理后台：动态表单支持字典选择器分离，重新封装 API 选择器，扩展字体图标，由 @puhui999 贡献 #435、#441、#446、#449\n * 【新增】华为短信 Client 实现，由 @scholarli 贡献 #997\n * 【新增】protection 模块新增 signature 实现 API 签名，由 @slipper4j 贡献 #526、#531、#532、#541\n * 【优化】短信验证码前置补零对其 endCode 长度，由 @aqiangaqiang 贡献 #116\n * 【优化】优化记录 infra_api_access_log 方法，截取参数最长 8000 字符，由 @高高 贡献 #976、#977\n * 【新增】Vben 管理后台：新增《代码生成案例》，由 @JackLi 贡献 #42\n * 【优化】Vue3 管理后台：提取默认登录使用的租户与账号密码, 规避潜在的账户泄露问题，由 @邓超 贡献 #56\n * 【优化】Vue3 管理后台：Add StringDictDataType type by imitating getIntDictOptions，由 @AhJindeg 贡献 #453\n * 【优化】MyBatis 从 3.5.5 升级到 3.5.7，并简化数据权限的实现，由 @xl_niu 贡献 #1007\n * 【新增】Cloud：支持数据权限在 RPC 调用时，传递忽略数据权限的能力，由 @芋道源码 贡献 e18069d\n * 【新增】多租户缓存，增加忽略的 Spring Cache 配置，由 @芋道源码 贡献 1c95e12\n * 【新增】微信小程序的订阅消息，由 @puhui999 贡献 #1018、#61、#1019、#1021、#1023、#1024、#63、#1025、#63、#64、#1027\n * 【优化】文件存储 S3 兼容腾讯云、火山云的 VirtualStyle 模式，由 @芋道源码 贡献 4386c70\n * 【优化】Vben 管理后台：接入 V2 版本操作日志，接入访问日志的操作信息，由 @芋道源码 贡献 59d2baa、09d3fac\n * 【优化】Vue2 管理后台：接入 V2 版本操作日志，接入访问日志的操作信息，由 @芋道源码 贡献 06750bf、49dbfd0\n * 【优化】Area 在 IDEA debug 时 toString 方法报错StackOverflowError、指定 jackson 默认序列化时双向引用的前向、后向出口避免死循环报错，由 @常柯柯 贡献 #2、#1022\n\nCRM 客户管理系统专区：\n\n * 【新增】员工业绩统计，由 @scholarli 贡献 #966、#438、#971\n\nMALL 商城专区：\n\n * 【新增】获取小程序码相关接口，由 @puhui999 贡献 #972、#975、#53、#979、#54、#55\n * 【新增】客服功能的实现，由 @puhui999 贡献 #980、#993、#468、#1001、#470、#471、#1008、#474、#476、#1010、#469、#1014、#483、#56\n * 【新增】增加租户 ID 自定义配置支持，由 @downeyin 贡献 #62\n\nPAY 支付专区：\n\n * 【优化】微信支付使用 certSerialNo 替代 privateCertContent，由 @芋道源码 贡献 f0d680b、188b403\n\nAI 大模型专区：\n\n * 【新增】对话聊天的前后端实现，由 cherishsince 贡献 #469、#1006、#1013\n * 【新增】绘图创作的前后端实现，由 cherishsince 贡献 #469、#1006、#1013、#479\n * 【新增】音乐创作的后端实现，由 @小新 贡献 #1、#2、#3、#4、#5、#6、#7、#8\n * 【新增】音乐创作的前端实现，由 @紫星 贡献 #467\n * 【新增】写作助手的后端实现，由 @小新 贡献 #9、#11、#13、#14\n * 【新增】写作创作的前端实现，由 @hhhero 贡献 #473、#477、#482\n * 【新增】思维导图的前端实现，由 @hhhero 贡献 #484\n\n\n# 🐞 Bug Fixes\n\n * 【修复】SYSTEM：获取菜单精简信息列表接口没有排除父 ID 非 0 的节点，由 @dongdongxiang 贡献 #561\n * 【修复】Vue3 管理后台：菜单新增时，id=0 导致 SQLServer 新增菜单失败，由 @dhb52 贡献 #440\n * 【修复】Vue3 管理后台：由于 .env.local-dev 重命名导致的构建指令异常，由 @邓超 贡献 #39\n * 【修复】Vue3 管理后台：三方登录 SocialLogin.vue 的验证码开关取反，由 @天痕 贡献 #443、#442\n * 【修复】Vue3 管理后台：解决部门管理页面中，重置按钮失效问题，由 @刘岩Tony 贡献 #445\n * 【修复】MySQL 转 PostgreSQL、SQLServer 脚本，增加 dual 表需要一条数据，由 @dhb52 贡献 #968\n * 【修复】Vben 管理后台：mail regular 不正确，由 @Tech--man 贡献 #5\n * 【修复】更新角色时，记录修改内容，由 @syubun 贡献 #114\n * 【修复】Vue2 管理后台：导出 Excel 时，发生异常时，进行提示，由 @芋道源码 贡献 edc7293\n * 【修复】SYSTEM：id 获取不到用户引发的 NPE 异常，由 @g_l 贡献 #974\n * 【修复】上传文件测试时 pg 数据库字段与 FileContentDO 类型不一致报错修复，由 @orchidblessing 贡献 #534\n * 【修复】定时任务指定某一年执行时，只会执行一次，后台查看任务详细会报错，由 @高高 贡献 #987\n * 【修复】导入微信地址的时候无法获取areaId（只针对四个直辖市），由 @SuperHao、@hunao0221 贡献 #988、#585\n * 【修复】模块名称和表名称一样时，代码生成存在问题，如“shop”模块的“shop”表生成代码时shop都被移除了，由 @山野羡民 贡献 #990\n * 【修复】Vue3 管理后台：操作日志无法搜索操作人的问题，由 @杨宇庆 贡献 #457\n * 【修复】Vue3 管理后台：定时任务的列表中 点击“开启/关闭”按钮，弹窗点击取消，列表页状态已更改，由 @ms_think 贡献 #456\n * 【修复】修复主子表 ER P模式下代码自动生成不全问题，由 @jiushinakecai、@panjiabao 贡献 #583\n * 【修复】controller.vm 模版中的 export-excel 引用的 Vo 类没有加上 sceneEnum.prefixClass 前缀导致报错，由 @Syriana_Zh 贡献 #1004\n * 【修复】Vue3 管理后台：定时任务-调度日志 执行结果使用字段错误，由 @AhJindeg 贡献 #464\n * 【修复】Vue3 管理后台：刷新令牌过期后，未正确跳转登录页，由 @AhJindeg 贡献 #465\n * 【修复】请求租户不存在时，记录访问日志、操作日志异常的问题，由 @芋道源码 贡献 bbdf9e9\n * 【修复】Vben 管理后台：前端代码生成后列表页面是空的问题，由 @little-rex 贡献 #1020\n * 【修复】Vue2 管理后台：角色导出 URL 不正确的问题，由 @芋道源码 贡献 7e3f310\n * 【修复】代码生成 Vue2 版本导出 undefined 问题，由 @zhkwork 贡献 #125\n * 【修复】AI 模块的 Redis 配置错误、打包配置缺失、日志冲突的问题，由 @OnPeaceOfMind 贡献 #127、#128\n * 【修复】Vben 管理后台：升级 axios 版本，修复 token 过期刷新后，文件重传失败的问题，由 @芋道源码 贡献 a76b0ec\n * 【修复】Vben 管理后台：Excel 等导出时，如果发生异常，则不进行下载 Excel，而是错误提示，由 @芋道源码 贡献 941e95\n * 【修复】SYSTEM：导入系统用户时，增加注解校验过程，与界面添加和修改用户保持一致，由 @尹先生 贡献 #1017\n * 【修复】Vue3 管理后台：axios 请求拦截错误处理中 Promise.reject(error) 未返回，由 @perterHUAN 贡献 #488\n * 【修复】Vben 管理后台：处理表单设计器右侧属性配置面板表单不展示问题，由 @summer001-pd 贡献 #7\n\nCRM 客户管理系统专区：\n\n * 【修复】商品统计计数显示成价格了，由 @山野羡民 贡献 #439\n * 【修复】合同详情中团队成员未展示权限编辑的问题，由 @downeyin 贡献 #472\n * 【修复】回款管理导出报错的问题，由 @芋道源码 贡献 87126d8\n\nMALL 商城专区：\n\n * 【修复】性别未知时的枚举值与 member_user.sex 默认值不一致的问题，由 @邓超 贡献 #509\n * 【修复】商城首页销售额查询错误，由 @JJBoy1995 贡献 #518、#42\n * 【修复】MemberUserBaseVO 的 sex 与 SexEnum 不一致的问题重命名导致的构建指令异常，由 @邓超 贡献 #510\n * 【修复】秒杀时间段配置的 URL simple-list 不正确的问题，由 @芋道源码 贡献 e1a5302\n * 【修复】填写商品属性后按回车键导致页面刷新的问题，由 @邓超 贡献 #45\n * 【修复】radeOrderUpdateService 的单元测试，由 @邓超 贡献 #525\n * 【修复】后台获取商品 SPU 分页列表数据时，数据会出现错乱问题，由 @dongdongxiang 贡献 #565\n * 【修复】被禁用的账户可以通过短信验证码再次登录的问题，由 @邓超 贡献 #568\n * 【修复】会员签到记录 Bug，由 @随便v走走 贡献 #984\n * 【修复】分销用户绑定时判断是否为新用户逻辑错误问题，由 @孙南北 贡献 #124\n * 【修复】修复会员和售后退款中订和单明细查询传递参数错误，由 @OnPeaceOfMind 贡献 #466\n * 【修复】售后退货界面，加载物流公司失败的问题，由 @zhaowg 贡献 #59\n * 【修复】复制订单信息失败，字段错误，由 @WCH 贡献 #58\n * 【修复】订单项取消时，分销未取消所有推广员的推广记录问题，由 @芋道源码 贡献 cf6f3ea\n * 【修复】更新库存时，同时更新销量，和 taobao 保持一致的逻辑，由 @芋道源码 贡献 714f0be\n * 【修复】uni-app login.vue 微信登录绑定过慢，导致登录失败，由 @芋道源码 贡献 714f0be\n * 【修复】uni-app 在微信小程序下，切换手机 + 密码登录失败的问题，由 @芋道源码 贡献 d716bc4\n * 【修复】优惠劵的折扣计算不正确，由 @芋道源码 贡献 3d9ec19\n * 【修复】商城装修页面拖动组件时会异常选择所有文字的问题，由 @zhaoyu 贡献 #487\n\nBPM 工作流专区：\n\n * 【修复】Vue3 管理后台：OA 请假，修复列表展示的状态字段取值错误，由 @dhb52 贡献 #444\n * 【修复】多租户使用同一个流程标识 key 时查询报错，由 @今晚打老虎 贡献 #444\n * 【修复】Vue3 管理后台：流程详情的表单不显示数据问题，由 @OlyLis 贡献 #459\n * 【修复】Vue3 管理后台：OA 请假示例审批结果字段不正确的问题，由 @geekymv 贡献 #63\n * 【修复】Vue3 管理后台：流程设计器 bpmn 流转条件-流转类型选择默认流转路径，未正确显示 /，由 @最后的梦想 贡献 #463\n * 【修复】Cloud bpm 模块启动会失败的情况，由 @9527 贡献 #129\n * 【修复】Vue3 管理后台：流程设计器中，选择表达式时，不生效的情况，由 @芋道源码 贡献 46da7e2\n * 【修复】Vue3 管理后台：流程重新发起时，禁用业务表单的情况，避免报错，由 @芋道源码 贡献 5d91131\n * 【修复】发起用户可能没有部门，由 @今晚打老虎 贡献 #123\n\nPAY 支付专区：\n\n * 【修复】示例订单完成支付后跳转到 404 页面的问题，由 @邓超 贡献 #50\n * 【修复】无法配置微信原生支付与网站支付的问题，由 @邓超 贡献 #53\n * 【修复】微信扫码支付 v2 版本，缺少 product_id 的报错，由 @芋道源码 贡献 e02b95f\n\nERP 企业管理专区：\n\n * 【修复】采购订单菜单权限错误问题，由 @咖啡不苦 贡献 #113\n * 【修复】采购金额计算逻辑错误，由 @zhenxi-he 贡献 #563\n * 【修复】数据统计时，租户在 MyBatis XML 不生效的问题，由 @芋道源码 贡献 fe3f144\n\nMP 公众号专区：\n\n * 【修复】Vue3 管理后台：/mp/open/ -> /admin-api/mp/open/，由 @21克的爱情 贡献 #461\n\nREPORT 报表专区：\n\n * 【修复】修复积木在访问 jmreport/index 会报错的问题，由 @芋道源码 贡献 39bf9cf\n\n\n# 🔨 Dependency Upgrades\n\n * 【升级】spring boot from 3.2.2 to 3.3.1\n * 【升级】druid from 1.2.21 to 1.2.23\n * 【升级】dynamic-datasource from 4.3.0 to 4.3.1\n * 【升级】spring boot admin from 3.2.1 to 3.3.2\n * 【升级】podam from 8.0.1 to 8.0.2\n * 【升级】jedis-mock from 1.0.13 to 1.1.2\n * 【升级】lombok from 1.18.30 to 1.18.34\n * 【升级】jsoup from 1.17.2 to 1.18.1\n * 【升级】hutool-5 from 5.8.25 to 5.8.29\n * 【升级】hutool-6 from 6.0.0-M10 to 6.0.0-M14\n * 【升级】guava from 33.0.0-jre to 33.2.1-jre\n * 【升级】commons-net from 3.10.0 to 3.11.1\n * 【升级】tika-core from 2.9.1 to 2.9.2\n * 【升级】easy-excel from 3.3.3 to 3.3.4\n * 【升级】mybatis-plus from 3.5.5 to 3.5.7\n * 【升级】spring-cloud-alibaba from 2022.0.0.0 to 2023.0.1.2\n * 【升级】jimureport from 1.6.6 to 1.7.8\n * 【升级】easy-trans from 2.2.11 to 3.0.5\n * 【升级】redisson from 3.26.0 to 3.32.0\n * 【升级】knife4j from 4.3.0 to 4.5.0\n * 【升级】maven-compiler-plugin from 3.11.0 to 3.13.0\n * 【升级】flatten-maven-plugin from 1.5.0 to 1.6.0",
            normalizedContent: "# 支持 aigc 人工智能、商城在线客服\n\n\n# 📈 statistic\n\n * 总代码行数：222554\n * 源码代码行数：137846\n * 注释行数：50515\n * 单元测试用例数：1043\n\n\n# ⭐ new features\n\n * 【新增】支持人大金仓数 kingbasees，由 @dhb52 贡献 #982\n * 【新增】find_in_set 函数的跨数据库实现，由 @dhb52 贡献 #994、#1000\n * 【新增】支持华为 opengauss，由 @dhb52 贡献 #985\n * 【新增】vue3 管理后台：动态表单支持字典选择器分离，重新封装 api 选择器，扩展字体图标，由 @puhui999 贡献 #435、#441、#446、#449\n * 【新增】华为短信 client 实现，由 @scholarli 贡献 #997\n * 【新增】protection 模块新增 signature 实现 api 签名，由 @slipper4j 贡献 #526、#531、#532、#541\n * 【优化】短信验证码前置补零对其 endcode 长度，由 @aqiangaqiang 贡献 #116\n * 【优化】优化记录 infra_api_access_log 方法，截取参数最长 8000 字符，由 @高高 贡献 #976、#977\n * 【新增】vben 管理后台：新增《代码生成案例》，由 @jackli 贡献 #42\n * 【优化】vue3 管理后台：提取默认登录使用的租户与账号密码, 规避潜在的账户泄露问题，由 @邓超 贡献 #56\n * 【优化】vue3 管理后台：add stringdictdatatype type by imitating getintdictoptions，由 @ahjindeg 贡献 #453\n * 【优化】mybatis 从 3.5.5 升级到 3.5.7，并简化数据权限的实现，由 @xl_niu 贡献 #1007\n * 【新增】cloud：支持数据权限在 rpc 调用时，传递忽略数据权限的能力，由 @芋道源码 贡献 e18069d\n * 【新增】多租户缓存，增加忽略的 spring cache 配置，由 @芋道源码 贡献 1c95e12\n * 【新增】微信小程序的订阅消息，由 @puhui999 贡献 #1018、#61、#1019、#1021、#1023、#1024、#63、#1025、#63、#64、#1027\n * 【优化】文件存储 s3 兼容腾讯云、火山云的 virtualstyle 模式，由 @芋道源码 贡献 4386c70\n * 【优化】vben 管理后台：接入 v2 版本操作日志，接入访问日志的操作信息，由 @芋道源码 贡献 59d2baa、09d3fac\n * 【优化】vue2 管理后台：接入 v2 版本操作日志，接入访问日志的操作信息，由 @芋道源码 贡献 06750bf、49dbfd0\n * 【优化】area 在 idea debug 时 tostring 方法报错stackoverflowerror、指定 jackson 默认序列化时双向引用的前向、后向出口避免死循环报错，由 @常柯柯 贡献 #2、#1022\n\ncrm 客户管理系统专区：\n\n * 【新增】员工业绩统计，由 @scholarli 贡献 #966、#438、#971\n\nmall 商城专区：\n\n * 【新增】获取小程序码相关接口，由 @puhui999 贡献 #972、#975、#53、#979、#54、#55\n * 【新增】客服功能的实现，由 @puhui999 贡献 #980、#993、#468、#1001、#470、#471、#1008、#474、#476、#1010、#469、#1014、#483、#56\n * 【新增】增加租户 id 自定义配置支持，由 @downeyin 贡献 #62\n\npay 支付专区：\n\n * 【优化】微信支付使用 certserialno 替代 privatecertcontent，由 @芋道源码 贡献 f0d680b、188b403\n\nai 大模型专区：\n\n * 【新增】对话聊天的前后端实现，由 cherishsince 贡献 #469、#1006、#1013\n * 【新增】绘图创作的前后端实现，由 cherishsince 贡献 #469、#1006、#1013、#479\n * 【新增】音乐创作的后端实现，由 @小新 贡献 #1、#2、#3、#4、#5、#6、#7、#8\n * 【新增】音乐创作的前端实现，由 @紫星 贡献 #467\n * 【新增】写作助手的后端实现，由 @小新 贡献 #9、#11、#13、#14\n * 【新增】写作创作的前端实现，由 @hhhero 贡献 #473、#477、#482\n * 【新增】思维导图的前端实现，由 @hhhero 贡献 #484\n\n\n# 🐞 bug fixes\n\n * 【修复】system：获取菜单精简信息列表接口没有排除父 id 非 0 的节点，由 @dongdongxiang 贡献 #561\n * 【修复】vue3 管理后台：菜单新增时，id=0 导致 sqlserver 新增菜单失败，由 @dhb52 贡献 #440\n * 【修复】vue3 管理后台：由于 .env.local-dev 重命名导致的构建指令异常，由 @邓超 贡献 #39\n * 【修复】vue3 管理后台：三方登录 sociallogin.vue 的验证码开关取反，由 @天痕 贡献 #443、#442\n * 【修复】vue3 管理后台：解决部门管理页面中，重置按钮失效问题，由 @刘岩tony 贡献 #445\n * 【修复】mysql 转 postgresql、sqlserver 脚本，增加 dual 表需要一条数据，由 @dhb52 贡献 #968\n * 【修复】vben 管理后台：mail regular 不正确，由 @tech--man 贡献 #5\n * 【修复】更新角色时，记录修改内容，由 @syubun 贡献 #114\n * 【修复】vue2 管理后台：导出 excel 时，发生异常时，进行提示，由 @芋道源码 贡献 edc7293\n * 【修复】system：id 获取不到用户引发的 npe 异常，由 @g_l 贡献 #974\n * 【修复】上传文件测试时 pg 数据库字段与 filecontentdo 类型不一致报错修复，由 @orchidblessing 贡献 #534\n * 【修复】定时任务指定某一年执行时，只会执行一次，后台查看任务详细会报错，由 @高高 贡献 #987\n * 【修复】导入微信地址的时候无法获取areaid（只针对四个直辖市），由 @superhao、@hunao0221 贡献 #988、#585\n * 【修复】模块名称和表名称一样时，代码生成存在问题，如“shop”模块的“shop”表生成代码时shop都被移除了，由 @山野羡民 贡献 #990\n * 【修复】vue3 管理后台：操作日志无法搜索操作人的问题，由 @杨宇庆 贡献 #457\n * 【修复】vue3 管理后台：定时任务的列表中 点击“开启/关闭”按钮，弹窗点击取消，列表页状态已更改，由 @ms_think 贡献 #456\n * 【修复】修复主子表 er p模式下代码自动生成不全问题，由 @jiushinakecai、@panjiabao 贡献 #583\n * 【修复】controller.vm 模版中的 export-excel 引用的 vo 类没有加上 sceneenum.prefixclass 前缀导致报错，由 @syriana_zh 贡献 #1004\n * 【修复】vue3 管理后台：定时任务-调度日志 执行结果使用字段错误，由 @ahjindeg 贡献 #464\n * 【修复】vue3 管理后台：刷新令牌过期后，未正确跳转登录页，由 @ahjindeg 贡献 #465\n * 【修复】请求租户不存在时，记录访问日志、操作日志异常的问题，由 @芋道源码 贡献 bbdf9e9\n * 【修复】vben 管理后台：前端代码生成后列表页面是空的问题，由 @little-rex 贡献 #1020\n * 【修复】vue2 管理后台：角色导出 url 不正确的问题，由 @芋道源码 贡献 7e3f310\n * 【修复】代码生成 vue2 版本导出 undefined 问题，由 @zhkwork 贡献 #125\n * 【修复】ai 模块的 redis 配置错误、打包配置缺失、日志冲突的问题，由 @onpeaceofmind 贡献 #127、#128\n * 【修复】vben 管理后台：升级 axios 版本，修复 token 过期刷新后，文件重传失败的问题，由 @芋道源码 贡献 a76b0ec\n * 【修复】vben 管理后台：excel 等导出时，如果发生异常，则不进行下载 excel，而是错误提示，由 @芋道源码 贡献 941e95\n * 【修复】system：导入系统用户时，增加注解校验过程，与界面添加和修改用户保持一致，由 @尹先生 贡献 #1017\n * 【修复】vue3 管理后台：axios 请求拦截错误处理中 promise.reject(error) 未返回，由 @perterhuan 贡献 #488\n * 【修复】vben 管理后台：处理表单设计器右侧属性配置面板表单不展示问题，由 @summer001-pd 贡献 #7\n\ncrm 客户管理系统专区：\n\n * 【修复】商品统计计数显示成价格了，由 @山野羡民 贡献 #439\n * 【修复】合同详情中团队成员未展示权限编辑的问题，由 @downeyin 贡献 #472\n * 【修复】回款管理导出报错的问题，由 @芋道源码 贡献 87126d8\n\nmall 商城专区：\n\n * 【修复】性别未知时的枚举值与 member_user.sex 默认值不一致的问题，由 @邓超 贡献 #509\n * 【修复】商城首页销售额查询错误，由 @jjboy1995 贡献 #518、#42\n * 【修复】memberuserbasevo 的 sex 与 sexenum 不一致的问题重命名导致的构建指令异常，由 @邓超 贡献 #510\n * 【修复】秒杀时间段配置的 url simple-list 不正确的问题，由 @芋道源码 贡献 e1a5302\n * 【修复】填写商品属性后按回车键导致页面刷新的问题，由 @邓超 贡献 #45\n * 【修复】radeorderupdateservice 的单元测试，由 @邓超 贡献 #525\n * 【修复】后台获取商品 spu 分页列表数据时，数据会出现错乱问题，由 @dongdongxiang 贡献 #565\n * 【修复】被禁用的账户可以通过短信验证码再次登录的问题，由 @邓超 贡献 #568\n * 【修复】会员签到记录 bug，由 @随便v走走 贡献 #984\n * 【修复】分销用户绑定时判断是否为新用户逻辑错误问题，由 @孙南北 贡献 #124\n * 【修复】修复会员和售后退款中订和单明细查询传递参数错误，由 @onpeaceofmind 贡献 #466\n * 【修复】售后退货界面，加载物流公司失败的问题，由 @zhaowg 贡献 #59\n * 【修复】复制订单信息失败，字段错误，由 @wch 贡献 #58\n * 【修复】订单项取消时，分销未取消所有推广员的推广记录问题，由 @芋道源码 贡献 cf6f3ea\n * 【修复】更新库存时，同时更新销量，和 taobao 保持一致的逻辑，由 @芋道源码 贡献 714f0be\n * 【修复】uni-app login.vue 微信登录绑定过慢，导致登录失败，由 @芋道源码 贡献 714f0be\n * 【修复】uni-app 在微信小程序下，切换手机 + 密码登录失败的问题，由 @芋道源码 贡献 d716bc4\n * 【修复】优惠劵的折扣计算不正确，由 @芋道源码 贡献 3d9ec19\n * 【修复】商城装修页面拖动组件时会异常选择所有文字的问题，由 @zhaoyu 贡献 #487\n\nbpm 工作流专区：\n\n * 【修复】vue3 管理后台：oa 请假，修复列表展示的状态字段取值错误，由 @dhb52 贡献 #444\n * 【修复】多租户使用同一个流程标识 key 时查询报错，由 @今晚打老虎 贡献 #444\n * 【修复】vue3 管理后台：流程详情的表单不显示数据问题，由 @olylis 贡献 #459\n * 【修复】vue3 管理后台：oa 请假示例审批结果字段不正确的问题，由 @geekymv 贡献 #63\n * 【修复】vue3 管理后台：流程设计器 bpmn 流转条件-流转类型选择默认流转路径，未正确显示 /，由 @最后的梦想 贡献 #463\n * 【修复】cloud bpm 模块启动会失败的情况，由 @9527 贡献 #129\n * 【修复】vue3 管理后台：流程设计器中，选择表达式时，不生效的情况，由 @芋道源码 贡献 46da7e2\n * 【修复】vue3 管理后台：流程重新发起时，禁用业务表单的情况，避免报错，由 @芋道源码 贡献 5d91131\n * 【修复】发起用户可能没有部门，由 @今晚打老虎 贡献 #123\n\npay 支付专区：\n\n * 【修复】示例订单完成支付后跳转到 404 页面的问题，由 @邓超 贡献 #50\n * 【修复】无法配置微信原生支付与网站支付的问题，由 @邓超 贡献 #53\n * 【修复】微信扫码支付 v2 版本，缺少 product_id 的报错，由 @芋道源码 贡献 e02b95f\n\nerp 企业管理专区：\n\n * 【修复】采购订单菜单权限错误问题，由 @咖啡不苦 贡献 #113\n * 【修复】采购金额计算逻辑错误，由 @zhenxi-he 贡献 #563\n * 【修复】数据统计时，租户在 mybatis xml 不生效的问题，由 @芋道源码 贡献 fe3f144\n\nmp 公众号专区：\n\n * 【修复】vue3 管理后台：/mp/open/ -> /admin-api/mp/open/，由 @21克的爱情 贡献 #461\n\nreport 报表专区：\n\n * 【修复】修复积木在访问 jmreport/index 会报错的问题，由 @芋道源码 贡献 39bf9cf\n\n\n# 🔨 dependency upgrades\n\n * 【升级】spring boot from 3.2.2 to 3.3.1\n * 【升级】druid from 1.2.21 to 1.2.23\n * 【升级】dynamic-datasource from 4.3.0 to 4.3.1\n * 【升级】spring boot admin from 3.2.1 to 3.3.2\n * 【升级】podam from 8.0.1 to 8.0.2\n * 【升级】jedis-mock from 1.0.13 to 1.1.2\n * 【升级】lombok from 1.18.30 to 1.18.34\n * 【升级】jsoup from 1.17.2 to 1.18.1\n * 【升级】hutool-5 from 5.8.25 to 5.8.29\n * 【升级】hutool-6 from 6.0.0-m10 to 6.0.0-m14\n * 【升级】guava from 33.0.0-jre to 33.2.1-jre\n * 【升级】commons-net from 3.10.0 to 3.11.1\n * 【升级】tika-core from 2.9.1 to 2.9.2\n * 【升级】easy-excel from 3.3.3 to 3.3.4\n * 【升级】mybatis-plus from 3.5.5 to 3.5.7\n * 【升级】spring-cloud-alibaba from 2022.0.0.0 to 2023.0.1.2\n * 【升级】jimureport from 1.6.6 to 1.7.8\n * 【升级】easy-trans from 2.2.11 to 3.0.5\n * 【升级】redisson from 3.26.0 to 3.32.0\n * 【升级】knife4j from 4.3.0 to 4.5.0\n * 【升级】maven-compiler-plugin from 3.11.0 to 3.13.0\n * 【升级】flatten-maven-plugin from 1.5.0 to 1.6.0",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【v2.0.1】2024-03-01",
            frontmatter: {
                title: "【v2.0.1】2024-03-01",
                date: "2024-01-26T00:00:00.000Z",
                permalink: "/changelog/2.0.1/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/30.%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/75.%E3%80%90v2-0-1%E3%80%912024-03-01.html",
            relativePath: "01.开发指南/30.更新日志/75.【v2-0-1】2024-03-01.md",
            key: "v-c0868a50",
            path: "/changelog/2.0.1/",
            headers: [{
                level: 2,
                title: "支持 CRM、ERP 系统",
                slug: "支持-crm、erp-系统",
                normalizedTitle: "支持 crm、erp 系统",
                charIndex: 2
            }, {
                level: 3,
                title: "📈 Statistic",
                slug: "📈-statistic",
                normalizedTitle: "📈 statistic",
                charIndex: 20
            }, {
                level: 3,
                title: "⭐ New Features",
                slug: "⭐-new-features",
                normalizedTitle: "⭐ new features",
                charIndex: 101
            }, {
                level: 3,
                title: "🐞 Bug Fixes",
                slug: "🐞-bug-fixes",
                normalizedTitle: "🐞 bug fixes",
                charIndex: 1298
            }],
            headersStr: "支持 CRM、ERP 系统 📈 Statistic ⭐ New Features 🐞 Bug Fixes",
            content: "# 支持 CRM、ERP 系统\n\n\n# 📈 Statistic\n\n * 总代码行数：211059\n * 源码代码行数：131201\n * 注释行数：47856\n * 单元测试用例数：1071\n\n\n# ⭐ New Features\n\n * 【新增】支持前端直接上传阿里云、七牛、腾讯云、MinIO 等云存储，由 @疯狂的世界 贡献 #865、#382\n * 【新增】Vue3 管理后台：锁屏功能，由 @芋道源码 贡献\n * 【重构】将 banner、error-code、desensitize 组件，融合到 web 组件里，减少 starter，由 @芋道源码 贡献 44699ef\n * 【重构】将 sms 组件，融合到 system 模块里，减少 starter，由 @芋道源码 贡献 5acdd15\n * 【重构】将 file 组件，融合到 infra 模块里，减少 starter，由 @芋道源码 贡献 77d6340\n * 【重构】将 captcha 组件，融合到 system 模块里，减少 starter，由 @芋道源码 贡献 0317e42\n * 【重构】将 dict 组件，融合到 excel 组件里，减少 starter，由 @芋道源码 贡献 77d6340\n * 【优化】Vue3 管理后台：优化 utils/formatDate.ts 更好的 ts 类型，由 @dhb52 贡献 #391\n\nCRM 客户管理系统专区：\n\n * 【完善】CRM 的跟进记录，由 @puhui999 贡献 #853\n * 【新增】CRM 的客户导入，由 @puhui999 贡献 #858、#376、#876、#879\n * 【完善】CRM 的合同实现，由 @puhui999 贡献 #864、#381、#869\n * 【完善】CRM 的回款实现，由 @puhui999 贡献 #393、#880\n * 【完善】CRM 的线索实现，由 @Minh-X 贡献 #854\n * 【新增】CRM 商业智能的排行版实现，由 @安浩浩 贡献 #860、#378、#380、#861、#383、#866\n * 【完善】CRM 的待办事项，由 @dhb52 贡献 #377、#859、#384、#868、#870、#387、#871\n\nERP 企业资源计划系统专区：\n\n * 【新增】ERP 的首页统计，由 @芋道源码 贡献\n * 【新增】ERP 的产品信息、分类、单位，由 @芋道源码 贡献\n * 【新增】ERP 的仓库信息、库存、明细、出库、入库、调拨、盘点，由 @芋道源码 贡献\n * 【新增】ERP 的采购订单、入库、退货，由 @芋道源码 贡献\n * 【新增】ERP 的销售订单、出库、退货，由 @芋道源码 贡献\n * 【新增】ERP 的付款单、收款单、结算账户，由 @芋道源码 贡献\n\nBPM 工作流专区：\n\n * 【优化】BPMN 添加 assigne 处理器，由 @云开 贡献 #863\n\nPay 支付专区：\n\n * 【新增】支持微信 H5 网页支付，由 @杨宇庆 贡献 #895\n\n\n# 🐞 Bug Fixes\n\n * 【修复】“短信发送过于频率”的拼写错误，由 @杨宇庆 贡献 #855\n * 【修复】解决 deploy.sh 里停服务无法正常显示服务名的问题，由 @杨宇庆 贡献 #856\n * 【修复】JDK21 下，获取 redis 命令统计指令有误，由 @dhb52 贡献 #87\n * 【修复】Vue3 管理后台：验证码、文档开关不正确的问题，由 @dhb52 贡献 #311\n * 【修复】Vue3 管理后台：登录时，带参数的 URL 无法正常跳转的问题，由 @NiceShow 贡献 #379\n * 【修复】Vue3 管理后台：用户头像、昵称修改，同步更新 Layout/UserInfo，由 @dhb52 贡献 #385\n * 【修复】Vue3 管理后台：修复权限范围默认展开，deptExpand 却默认折叠的问题，由 @moon69 贡献 #375\n * 【修复】Vue3 管理后台：重写 el-upload httpRequest 文件上传成功会走成功的钩子，失败走失败的钩子，@puhui999 贡献 #395\n * 【修复】Vue3 管理后台：记住密码失效的问题，由 @芋道源码 贡献 1bc4eef\n * 【修复】Vue3 管理后台：修复子菜单选中时，父菜单也高亮的问题，由 @芋道源码 贡献 db10683\n * 【修复】Vue3 管理后台：修复第三种菜单风格“顶部”提前缩略了多个菜单，由 @芋道源码 贡献 ff0566b\n\nMALL 商城系统专区：\n\n * 【修复】商城统计，当某地区有人下单但无人支付时的空指针异常，由 @杨宇庆 贡献 #867\n * 【修复】评价查询的 queryWrapper 构建错误，由 @oah 贡献 #878\n * 【修复】会员退货接口中，未校验用户 ID 的问题，由 @杨宇庆 贡献 #891\n * 【修复】修复订单列表 tab 切换叠加问题，由 @DH 贡献 #42\n * 【修复】已过期的优惠劵，还显示可以使用，由 @芋道源码 贡献\n * 【修复】确认订单页面，不展示会员优惠信息，由 @芋道源码 贡献\n * 【修复】格式化订单状态不正确的问题，由 @cnyballk 贡献 #43\n * 【修复】购物车界面，金额展示不正确，由 @芋道源码 贡献\n * 【修复】商品卡片没有正确格式化数字的问题，由 @李占宏 贡献 #39\n\nCRM 客户管理系统专区：\n\n * 【修复】回款管理-编辑：不显示合同名称，由 @李占宏 贡献 #396\n * 【修复】更新回款报错、待办事项中即将到期的合同查询报错、新增商机产品不显示，由 @李占宏 贡献 #890\n * 【修复】跟进记录分页不显示商机，由 @杨宇庆 贡献 #867\n\nPay 支付专区：\n\n * 【修复】解决支付宝 Wap 创建的订单的超时时间无法生效的问题，由 @杨宇庆 贡献 #894\n * 【修复】解决订单同步任务引起的对已关闭的订单成功支付的问题，由 @杨宇庆 贡献 #893",
            normalizedContent: "# 支持 crm、erp 系统\n\n\n# 📈 statistic\n\n * 总代码行数：211059\n * 源码代码行数：131201\n * 注释行数：47856\n * 单元测试用例数：1071\n\n\n# ⭐ new features\n\n * 【新增】支持前端直接上传阿里云、七牛、腾讯云、minio 等云存储，由 @疯狂的世界 贡献 #865、#382\n * 【新增】vue3 管理后台：锁屏功能，由 @芋道源码 贡献\n * 【重构】将 banner、error-code、desensitize 组件，融合到 web 组件里，减少 starter，由 @芋道源码 贡献 44699ef\n * 【重构】将 sms 组件，融合到 system 模块里，减少 starter，由 @芋道源码 贡献 5acdd15\n * 【重构】将 file 组件，融合到 infra 模块里，减少 starter，由 @芋道源码 贡献 77d6340\n * 【重构】将 captcha 组件，融合到 system 模块里，减少 starter，由 @芋道源码 贡献 0317e42\n * 【重构】将 dict 组件，融合到 excel 组件里，减少 starter，由 @芋道源码 贡献 77d6340\n * 【优化】vue3 管理后台：优化 utils/formatdate.ts 更好的 ts 类型，由 @dhb52 贡献 #391\n\ncrm 客户管理系统专区：\n\n * 【完善】crm 的跟进记录，由 @puhui999 贡献 #853\n * 【新增】crm 的客户导入，由 @puhui999 贡献 #858、#376、#876、#879\n * 【完善】crm 的合同实现，由 @puhui999 贡献 #864、#381、#869\n * 【完善】crm 的回款实现，由 @puhui999 贡献 #393、#880\n * 【完善】crm 的线索实现，由 @minh-x 贡献 #854\n * 【新增】crm 商业智能的排行版实现，由 @安浩浩 贡献 #860、#378、#380、#861、#383、#866\n * 【完善】crm 的待办事项，由 @dhb52 贡献 #377、#859、#384、#868、#870、#387、#871\n\nerp 企业资源计划系统专区：\n\n * 【新增】erp 的首页统计，由 @芋道源码 贡献\n * 【新增】erp 的产品信息、分类、单位，由 @芋道源码 贡献\n * 【新增】erp 的仓库信息、库存、明细、出库、入库、调拨、盘点，由 @芋道源码 贡献\n * 【新增】erp 的采购订单、入库、退货，由 @芋道源码 贡献\n * 【新增】erp 的销售订单、出库、退货，由 @芋道源码 贡献\n * 【新增】erp 的付款单、收款单、结算账户，由 @芋道源码 贡献\n\nbpm 工作流专区：\n\n * 【优化】bpmn 添加 assigne 处理器，由 @云开 贡献 #863\n\npay 支付专区：\n\n * 【新增】支持微信 h5 网页支付，由 @杨宇庆 贡献 #895\n\n\n# 🐞 bug fixes\n\n * 【修复】“短信发送过于频率”的拼写错误，由 @杨宇庆 贡献 #855\n * 【修复】解决 deploy.sh 里停服务无法正常显示服务名的问题，由 @杨宇庆 贡献 #856\n * 【修复】jdk21 下，获取 redis 命令统计指令有误，由 @dhb52 贡献 #87\n * 【修复】vue3 管理后台：验证码、文档开关不正确的问题，由 @dhb52 贡献 #311\n * 【修复】vue3 管理后台：登录时，带参数的 url 无法正常跳转的问题，由 @niceshow 贡献 #379\n * 【修复】vue3 管理后台：用户头像、昵称修改，同步更新 layout/userinfo，由 @dhb52 贡献 #385\n * 【修复】vue3 管理后台：修复权限范围默认展开，deptexpand 却默认折叠的问题，由 @moon69 贡献 #375\n * 【修复】vue3 管理后台：重写 el-upload httprequest 文件上传成功会走成功的钩子，失败走失败的钩子，@puhui999 贡献 #395\n * 【修复】vue3 管理后台：记住密码失效的问题，由 @芋道源码 贡献 1bc4eef\n * 【修复】vue3 管理后台：修复子菜单选中时，父菜单也高亮的问题，由 @芋道源码 贡献 db10683\n * 【修复】vue3 管理后台：修复第三种菜单风格“顶部”提前缩略了多个菜单，由 @芋道源码 贡献 ff0566b\n\nmall 商城系统专区：\n\n * 【修复】商城统计，当某地区有人下单但无人支付时的空指针异常，由 @杨宇庆 贡献 #867\n * 【修复】评价查询的 querywrapper 构建错误，由 @oah 贡献 #878\n * 【修复】会员退货接口中，未校验用户 id 的问题，由 @杨宇庆 贡献 #891\n * 【修复】修复订单列表 tab 切换叠加问题，由 @dh 贡献 #42\n * 【修复】已过期的优惠劵，还显示可以使用，由 @芋道源码 贡献\n * 【修复】确认订单页面，不展示会员优惠信息，由 @芋道源码 贡献\n * 【修复】格式化订单状态不正确的问题，由 @cnyballk 贡献 #43\n * 【修复】购物车界面，金额展示不正确，由 @芋道源码 贡献\n * 【修复】商品卡片没有正确格式化数字的问题，由 @李占宏 贡献 #39\n\ncrm 客户管理系统专区：\n\n * 【修复】回款管理-编辑：不显示合同名称，由 @李占宏 贡献 #396\n * 【修复】更新回款报错、待办事项中即将到期的合同查询报错、新增商机产品不显示，由 @李占宏 贡献 #890\n * 【修复】跟进记录分页不显示商机，由 @杨宇庆 贡献 #867\n\npay 支付专区：\n\n * 【修复】解决支付宝 wap 创建的订单的超时时间无法生效的问题，由 @杨宇庆 贡献 #894\n * 【修复】解决订单同步任务引起的对已关闭的订单成功支付的问题，由 @杨宇庆 贡献 #893",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【v2.1.0】2024-05-05",
            frontmatter: {
                title: "【v2.1.0】2024-05-05",
                date: "2024-03-02T00:00:00.000Z",
                permalink: "/changelog/2.1.0/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/30.%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/74.%E3%80%90v2-1-0%E3%80%912024-05-05.html",
            relativePath: "01.开发指南/30.更新日志/74.【v2-1-0】2024-05-05.md",
            key: "v-5f5ee778",
            path: "/changelog/2.1.0/",
            headers: [{
                level: 2,
                title: "优化操作日志、多数据库的支持",
                slug: "优化操作日志、多数据库的支持",
                normalizedTitle: "优化操作日志、多数据库的支持",
                charIndex: 2
            }, {
                level: 2,
                title: "📈 Statistic",
                slug: "📈-statistic",
                normalizedTitle: "📈 statistic",
                charIndex: 21
            }, {
                level: 3,
                title: "⭐ New Features",
                slug: "⭐-new-features",
                normalizedTitle: "⭐ new features",
                charIndex: 102
            }, {
                level: 3,
                title: "🐞 Bug Fixes",
                slug: "🐞-bug-fixes",
                normalizedTitle: "🐞 bug fixes",
                charIndex: 2510
            }],
            headersStr: "优化操作日志、多数据库的支持 📈 Statistic ⭐ New Features 🐞 Bug Fixes",
            content: "# 优化操作日志、多数据库的支持\n\n\n# 📈 Statistic\n\n * 总代码行数：207512\n * 源码代码行数：129166\n * 注释行数：46828\n * 单元测试用例数：1024\n\n\n# ⭐ New Features\n\n * 【新增】MySQL 转 Oracle、PostgreSQL、SQLServer 脚本，更好的支持多 DB，由 @dhb52 贡献 #958、#959、#960、#961、#962、#963、#964、#965\n * 【重构】V2 操作日志转正，基于注解的可使用变量、可以自定义函数的通用操作日志组件，由 @芋道源码 贡献 132c1cc\n * 【优化】增强访问日志，支持是否记录、脱敏、操作信息等功能，由 @芋道源码 贡献 132c1cc\n * 【新增】ApiAccessLogInterceptor 拦截器，打印请求日志到 IDEA 控制台，由 @芋道源码 贡献 132c1cc\n * 【重构】Excel 导入时，增加 @ExcelSelect 注解，支持下拉选择数据，由 @puhui999 贡献 #900\n * 【新增】二次封装 form-create 组件，使用项目重新封装的文件上传组件，由 @puhui999 贡献 #3820710、#412\n * 【优化】支持登陆用户，直接读取昵称、部门等信息，也支持自定义字段，由 @芋道源码 贡献 909d330\n * 【新增】UserIdempotentKeyResolver 解析器，支持用户级别的幂等，由 @芋道源码 贡献 38db5fe\n * 【新增】RateLimiter 限流器，支持全局、用户、IP 等级别的限流，由 @芋道源码 贡献 cc50891\n * 【完善】代码生成对 DM 达梦数据的兼容性，由 @再见七月 贡献 #422、#108\n * 【移除】数据库文档，简化项目的复杂度，由 @芋道源码 贡献 ff0c12c、ff52769\n * 【移除】错误码的管理，简化项目的复杂度，由 @芋道源码 贡献 8093ef3、98bf5a1\n * 【移除】敏感词的管理，简化项目的复杂度，由 @芋道源码 贡献 9a31613、0925253\n * 【优化】新增 sslEnable 字段，支持 outlook 邮箱，由 @ZJY 贡献 #496、#19\n * 【增强】一键改包：支持 site、org 等包，由 @芋道源码 贡献 cd5e631\n * 【新增】Vue3 管理后台：在菜单管理中，可通过“路由地址”添加 ? 拼接参数，由 @芋道源码 贡献 f75e8d1\n\nCRM 客户管理系统专区：\n\n * 【完善】在客户添加团队成员时，可以同时添加到商机、合同，由 @puhui999 贡献 #900、#399、#907、#403\n * 【新增】员工客户分析，由 @dhb52 贡献 #902、#931、#415、#932、#419、#944、#947\n * 【新增】客户画像分析，由 @puhui999 贡献 #410、#923\n * 【新增】员工业绩统计，由 @scholarli 贡献 #916、#416、#952、#431\n * 【新增】员工客户分析，由 @dhb52 贡献 #902、#909、#934、#417\n * 【新增】销售漏斗分析，由 @puhui999 贡献 #426、#428、#946、#949\n\nMALL 商城专区：\n\n * 【新增】小程序的微信地址，导入成收货地址，由 @DH 贡献 #47\n * 【完善】适配顶部导航，由 @疯狂的世界 贡献 #406、#50\n * 【完善】兼容 HBuilder 最新版本 vite5，由 @芋道源码 贡献 c3f3c44\n\nBPM 工作流专区：\n\n * 【重构】审批人的分配规则实现，移除 bpm_task_assign_rule 表，使用 bpmn UserTask 自定义属性存储，由 @芋道源码 贡献 feadd02、797fddf\n * 【重构】流程分配人的实现，通过 BpmTaskCandidateStrategy 策略模式，并支持 Flowable Expression 流程表达式（替代 BpmTaskAssignScript 脚本），由 @芋道源码 贡献 797fddf、f5f73ad、960f27f、5f7ccd4\n * 【新增】顺序会签、或签的实现，由 @芋道源码 贡献 a1defeb、33d59c8\n * 【重构】流程实例的 status 状态实现，使用 Flowable 的 variables 存储，移除 bpm_process_instance_ext 表，由 @芋道源码 贡献 7967a2a、59c7c49\n * 【重构】流程任务的 status 状态实现，使用 Flowable 的 variables 存储，移除 bpm_task_ext 表，由 @芋道源码 贡献 7967a2a\n * 【完善】调整抄送逻辑的实现，改成审批通过、不通过时，可选择抄送，由 @芋道源码 贡献\n * 【重构】新增流程分类表，替代现有的 bpm_category 数据字典，由 @芋道源码 贡献 ed83b91、501a1c2\n * 【新增】支持多表单，每个流程任务都可以绑定流程表单，由 @芋道源码 贡献 08dd4ed、29a0fbf\n * 【移除】flowable starter 模块，融合到 bpm 模块中，由 @芋道源码 贡献 559bab5\n * 【新增】增加「发起人自选」的任务审批人的分配策略，由 @芋道源码 贡献 528a321、728cf15\n * 【新增】流程监听器，可配置 BPMN 任务监听器、执行监听器的模版，后续在 BPMN 选择使用，由 @芋道源码 贡献 7218e71\n\nMP 公众号专区：\n\n * 【新增】增加 unionid，由 @Fanjc 贡献 #104\n\nREPORT 报表专区：\n\n * 【完善】适配 jimu 报表的安全配置，由 @芋道源码 贡献 0222387\n\n\n# 🐞 Bug Fixes\n\n * 【修复】MapUtils.findAndThen，key 为 null 时，不处理，由 @dhb52 贡献 #904\n * 【修复】convertXxxByFlatMap, 当 map 后内容为 null 时，flatMap 会出现 NPE，由 @dhb52 贡献 #926\n * 【修复】Vue3 管理后台：取消社交登录时，登录按钮 loading 状态未取消，由 @AhJindeg 贡献 #400\n * 【修复】Vue3 管理后台：引入 prettier-eslint 依赖，修复 settings.json 文件中设置格式化插件 rvest.vs-code-prettier-eslint 未生效问题，由 @AhJindeg 贡献 #401\n * 【修复】角色在编辑数据权限时，无法回显的问题，由 @moon69 贡献 #402\n * 【修复】(crontab): add inputChange for crontab，由 @AhJindeg 贡献 #409\n * 【修复】【系统管理/岗位管理/新增按钮与导出按钮】权限 hasPermi 错误，由 @aqiangaqiang 贡献 #411\n * 【修复】中山市缺失，由 @cheng102e 贡献 #462\n * 【修复】Xss 开启时，忽略的 URL 针对 RequestBody 还是会 XSS 过滤的问题，由 @芋道源码 贡献 c943233\n * 【修复】jdk21 版本下 docker-compose 中 Redis Host 参数名称不正确的问题，由 E1 贡献 #901\n * 【修复】(role): add nextTick for open，由 @AhJindeg 贡献 #414\n * 【修复】Vue3 管理后台：导入用户的 UserImportForm 一些列 bug，由 @AhJindeg 贡献 #421\n * 【修复】获取登录用户的权限信息接口在没有授权角色时，没有菜单列表导致报错的问题，由 @a472159403 贡献 #945、#110\n * 【修复】Swagger 部分字段的注释不正确的问题，由 @moon69 贡献 #933\n * 【修复】Vue3 管理后台：修复第四个导航模式 hover 无法点开菜单的问题，由 @moon69 贡献 #427\n * 【修复】Vue3 管理后台：部分文件中 v-hasPermi 权限标识填写错误，由 @AhJindeg 贡献 #429\n * 【修复】非 json 请求（文件上传）时，token 过期时，错误读取 request body 问题，由 @芋道源码 贡献 fd832e2\n * 【修复】Vue3 管理后台：角色类型字段没有被字典翻译问题，由 @jnlimz 贡献 #430\n * 【修复】角色管理页面-查询未按照排序字段排序的问题，由 @jnlimz 贡献 #112\n * 【修复】短信模板中关于 type 字段的描述，由 @邓超 贡献 #496、#487\n * 【修复】Oracle 自带系统表，影响代码生成，由 @芋道源码 贡献 c6eed9a\n * 【修复】Vue3 管理后台：修复前端文件上传 Content-Type 异常问题，由 @Khalid 贡献 #436\n * 【修复】Vue3 管理后台：WebSocket 示例菜单，存在死循环的问题，由 @AhJindeg 贡献 #437\n * 【修复】代码生成：处理 SQLServer 数据库获取不到数据表结构注释，由 @ArlenBoy 贡献 #760\n * 【修复】移除 Druid 广告逻辑未按照期望执行，由 @芋道源码 贡献 290a981\n\nMALL 商城专区：\n\n * 【修复】小程序的 checkUpdate 未导出的问题，由 @cnyballk 贡献 #44、#45、#46\n * 【修复】登录后的移除 returnUrl 的使用不正确，由 @天痕 贡献 #49\n * 【修复】发货日志物流公司名称不显示问题，由 @山野羡民 贡献 #920\n * 【修复】取消订单时，取消分销订单不正确的问题，由 @wangxiaorui 贡献 #924\n * 【修复】解决查看未上架的商品时，报错缺少商品名称问题，由 @杨宇庆 贡献 #908\n * 【修复】添加加入购物车商品数量不可为 0 或更低数量的限制，由 @风狗 贡献 #915\n * 【修复】拼团详情错误传递 groupon_id 的问题，由 @芋道源码 贡献 a816582、5faa006\n * 【修复】营销的商品范围枚举不正确的问题，由 @芋道源码 贡献 427c2d5\n * 【修复】会员等级变更修复，由 @天痕 贡献 #93\n * 【修复】修改商品评论的可见性时，未正确更新评论的可见性的问题，由 @云扬四海 贡献 #939\n * 【修复】取消订单，返回优惠劵时，状态校验不正确的问题，由 @芋道源码 贡献 c1df35d\n * 【修复】秒杀时段点击编辑报错，由 @芋道源码 贡献 20a9780\n * 【修复】管理后台发放优惠劵时，只能发送未修改过有效期类型的优惠券，由 @芋道源码 贡献 dae4e64\n * 【修复】管理后台修改待支付订单，调整价格取值错误，由 @Evol郑天 贡献 #77\n * 【修复】管理后台的商城订单统计数据有问题，由 @芋道源码 贡献 e2fe047、3f7e99c\n * 【修复】订单详情，点击查看商品详情时应该跳转的是 spuId，由 @孙正涛 贡献 #51\n * 【修复】店铺装修时，商品列表组件返回的商品信息，按照选择的顺序返回，由 @芋道源码 贡献 bbfff1b\n * 【修复】拼团装修组件，跳转拼团商品界面的 id 不正确的问题，由 @芋道源码 贡献 68d2fc4\n * 【修复】优惠活动中的限时活动，添加活动报错系统异常，由 @bumianri 贡献 #733\n\nREPORT 报表专区：\n\n * 【修复】UReport 包冲突，导致积木报表导出 Excel 报错，由 @李占宏 贡献 #899\n * 【移除】Ureport 的实现，因为和 Spring Boot 兼容性较差，由 @芋道源码 贡献\n\nPAY 支付专区：\n\n * 【修复】微信支付时，无法保证父线程的 ThreadLocal 传入子线程，由 @芋道源码 贡献 d30700d\n * 【修复】解决退款失败时返回退款订单号错误的问题，由 @杨宇庆 贡献 #912\n\nCRM 客户管理专区：\n\n * 【修复】@RequestBody 和 Multipart 不能同时存在的异常和导入客户后序列化产生的异常，由 @芋道源码 贡献 a68abc4\n * 【修复】修复创建跟进记录操作日志的 id 不正确，由 @芋道源码 贡献 #938\n * 【修复】CRM 管理员数据权限，由 @puhui999 贡献 #957\n * 【修复】CRM 客户导入无效的问题，由 @puhui999 贡献 #433\n\nERP 企业管理专区：\n\n * 【修复】ERP 采购订单菜单权限错误问题，由 @zengheng 贡献 #922",
            normalizedContent: "# 优化操作日志、多数据库的支持\n\n\n# 📈 statistic\n\n * 总代码行数：207512\n * 源码代码行数：129166\n * 注释行数：46828\n * 单元测试用例数：1024\n\n\n# ⭐ new features\n\n * 【新增】mysql 转 oracle、postgresql、sqlserver 脚本，更好的支持多 db，由 @dhb52 贡献 #958、#959、#960、#961、#962、#963、#964、#965\n * 【重构】v2 操作日志转正，基于注解的可使用变量、可以自定义函数的通用操作日志组件，由 @芋道源码 贡献 132c1cc\n * 【优化】增强访问日志，支持是否记录、脱敏、操作信息等功能，由 @芋道源码 贡献 132c1cc\n * 【新增】apiaccessloginterceptor 拦截器，打印请求日志到 idea 控制台，由 @芋道源码 贡献 132c1cc\n * 【重构】excel 导入时，增加 @excelselect 注解，支持下拉选择数据，由 @puhui999 贡献 #900\n * 【新增】二次封装 form-create 组件，使用项目重新封装的文件上传组件，由 @puhui999 贡献 #3820710、#412\n * 【优化】支持登陆用户，直接读取昵称、部门等信息，也支持自定义字段，由 @芋道源码 贡献 909d330\n * 【新增】useridempotentkeyresolver 解析器，支持用户级别的幂等，由 @芋道源码 贡献 38db5fe\n * 【新增】ratelimiter 限流器，支持全局、用户、ip 等级别的限流，由 @芋道源码 贡献 cc50891\n * 【完善】代码生成对 dm 达梦数据的兼容性，由 @再见七月 贡献 #422、#108\n * 【移除】数据库文档，简化项目的复杂度，由 @芋道源码 贡献 ff0c12c、ff52769\n * 【移除】错误码的管理，简化项目的复杂度，由 @芋道源码 贡献 8093ef3、98bf5a1\n * 【移除】敏感词的管理，简化项目的复杂度，由 @芋道源码 贡献 9a31613、0925253\n * 【优化】新增 sslenable 字段，支持 outlook 邮箱，由 @zjy 贡献 #496、#19\n * 【增强】一键改包：支持 site、org 等包，由 @芋道源码 贡献 cd5e631\n * 【新增】vue3 管理后台：在菜单管理中，可通过“路由地址”添加 ? 拼接参数，由 @芋道源码 贡献 f75e8d1\n\ncrm 客户管理系统专区：\n\n * 【完善】在客户添加团队成员时，可以同时添加到商机、合同，由 @puhui999 贡献 #900、#399、#907、#403\n * 【新增】员工客户分析，由 @dhb52 贡献 #902、#931、#415、#932、#419、#944、#947\n * 【新增】客户画像分析，由 @puhui999 贡献 #410、#923\n * 【新增】员工业绩统计，由 @scholarli 贡献 #916、#416、#952、#431\n * 【新增】员工客户分析，由 @dhb52 贡献 #902、#909、#934、#417\n * 【新增】销售漏斗分析，由 @puhui999 贡献 #426、#428、#946、#949\n\nmall 商城专区：\n\n * 【新增】小程序的微信地址，导入成收货地址，由 @dh 贡献 #47\n * 【完善】适配顶部导航，由 @疯狂的世界 贡献 #406、#50\n * 【完善】兼容 hbuilder 最新版本 vite5，由 @芋道源码 贡献 c3f3c44\n\nbpm 工作流专区：\n\n * 【重构】审批人的分配规则实现，移除 bpm_task_assign_rule 表，使用 bpmn usertask 自定义属性存储，由 @芋道源码 贡献 feadd02、797fddf\n * 【重构】流程分配人的实现，通过 bpmtaskcandidatestrategy 策略模式，并支持 flowable expression 流程表达式（替代 bpmtaskassignscript 脚本），由 @芋道源码 贡献 797fddf、f5f73ad、960f27f、5f7ccd4\n * 【新增】顺序会签、或签的实现，由 @芋道源码 贡献 a1defeb、33d59c8\n * 【重构】流程实例的 status 状态实现，使用 flowable 的 variables 存储，移除 bpm_process_instance_ext 表，由 @芋道源码 贡献 7967a2a、59c7c49\n * 【重构】流程任务的 status 状态实现，使用 flowable 的 variables 存储，移除 bpm_task_ext 表，由 @芋道源码 贡献 7967a2a\n * 【完善】调整抄送逻辑的实现，改成审批通过、不通过时，可选择抄送，由 @芋道源码 贡献\n * 【重构】新增流程分类表，替代现有的 bpm_category 数据字典，由 @芋道源码 贡献 ed83b91、501a1c2\n * 【新增】支持多表单，每个流程任务都可以绑定流程表单，由 @芋道源码 贡献 08dd4ed、29a0fbf\n * 【移除】flowable starter 模块，融合到 bpm 模块中，由 @芋道源码 贡献 559bab5\n * 【新增】增加「发起人自选」的任务审批人的分配策略，由 @芋道源码 贡献 528a321、728cf15\n * 【新增】流程监听器，可配置 bpmn 任务监听器、执行监听器的模版，后续在 bpmn 选择使用，由 @芋道源码 贡献 7218e71\n\nmp 公众号专区：\n\n * 【新增】增加 unionid，由 @fanjc 贡献 #104\n\nreport 报表专区：\n\n * 【完善】适配 jimu 报表的安全配置，由 @芋道源码 贡献 0222387\n\n\n# 🐞 bug fixes\n\n * 【修复】maputils.findandthen，key 为 null 时，不处理，由 @dhb52 贡献 #904\n * 【修复】convertxxxbyflatmap, 当 map 后内容为 null 时，flatmap 会出现 npe，由 @dhb52 贡献 #926\n * 【修复】vue3 管理后台：取消社交登录时，登录按钮 loading 状态未取消，由 @ahjindeg 贡献 #400\n * 【修复】vue3 管理后台：引入 prettier-eslint 依赖，修复 settings.json 文件中设置格式化插件 rvest.vs-code-prettier-eslint 未生效问题，由 @ahjindeg 贡献 #401\n * 【修复】角色在编辑数据权限时，无法回显的问题，由 @moon69 贡献 #402\n * 【修复】(crontab): add inputchange for crontab，由 @ahjindeg 贡献 #409\n * 【修复】【系统管理/岗位管理/新增按钮与导出按钮】权限 haspermi 错误，由 @aqiangaqiang 贡献 #411\n * 【修复】中山市缺失，由 @cheng102e 贡献 #462\n * 【修复】xss 开启时，忽略的 url 针对 requestbody 还是会 xss 过滤的问题，由 @芋道源码 贡献 c943233\n * 【修复】jdk21 版本下 docker-compose 中 redis host 参数名称不正确的问题，由 e1 贡献 #901\n * 【修复】(role): add nexttick for open，由 @ahjindeg 贡献 #414\n * 【修复】vue3 管理后台：导入用户的 userimportform 一些列 bug，由 @ahjindeg 贡献 #421\n * 【修复】获取登录用户的权限信息接口在没有授权角色时，没有菜单列表导致报错的问题，由 @a472159403 贡献 #945、#110\n * 【修复】swagger 部分字段的注释不正确的问题，由 @moon69 贡献 #933\n * 【修复】vue3 管理后台：修复第四个导航模式 hover 无法点开菜单的问题，由 @moon69 贡献 #427\n * 【修复】vue3 管理后台：部分文件中 v-haspermi 权限标识填写错误，由 @ahjindeg 贡献 #429\n * 【修复】非 json 请求（文件上传）时，token 过期时，错误读取 request body 问题，由 @芋道源码 贡献 fd832e2\n * 【修复】vue3 管理后台：角色类型字段没有被字典翻译问题，由 @jnlimz 贡献 #430\n * 【修复】角色管理页面-查询未按照排序字段排序的问题，由 @jnlimz 贡献 #112\n * 【修复】短信模板中关于 type 字段的描述，由 @邓超 贡献 #496、#487\n * 【修复】oracle 自带系统表，影响代码生成，由 @芋道源码 贡献 c6eed9a\n * 【修复】vue3 管理后台：修复前端文件上传 content-type 异常问题，由 @khalid 贡献 #436\n * 【修复】vue3 管理后台：websocket 示例菜单，存在死循环的问题，由 @ahjindeg 贡献 #437\n * 【修复】代码生成：处理 sqlserver 数据库获取不到数据表结构注释，由 @arlenboy 贡献 #760\n * 【修复】移除 druid 广告逻辑未按照期望执行，由 @芋道源码 贡献 290a981\n\nmall 商城专区：\n\n * 【修复】小程序的 checkupdate 未导出的问题，由 @cnyballk 贡献 #44、#45、#46\n * 【修复】登录后的移除 returnurl 的使用不正确，由 @天痕 贡献 #49\n * 【修复】发货日志物流公司名称不显示问题，由 @山野羡民 贡献 #920\n * 【修复】取消订单时，取消分销订单不正确的问题，由 @wangxiaorui 贡献 #924\n * 【修复】解决查看未上架的商品时，报错缺少商品名称问题，由 @杨宇庆 贡献 #908\n * 【修复】添加加入购物车商品数量不可为 0 或更低数量的限制，由 @风狗 贡献 #915\n * 【修复】拼团详情错误传递 groupon_id 的问题，由 @芋道源码 贡献 a816582、5faa006\n * 【修复】营销的商品范围枚举不正确的问题，由 @芋道源码 贡献 427c2d5\n * 【修复】会员等级变更修复，由 @天痕 贡献 #93\n * 【修复】修改商品评论的可见性时，未正确更新评论的可见性的问题，由 @云扬四海 贡献 #939\n * 【修复】取消订单，返回优惠劵时，状态校验不正确的问题，由 @芋道源码 贡献 c1df35d\n * 【修复】秒杀时段点击编辑报错，由 @芋道源码 贡献 20a9780\n * 【修复】管理后台发放优惠劵时，只能发送未修改过有效期类型的优惠券，由 @芋道源码 贡献 dae4e64\n * 【修复】管理后台修改待支付订单，调整价格取值错误，由 @evol郑天 贡献 #77\n * 【修复】管理后台的商城订单统计数据有问题，由 @芋道源码 贡献 e2fe047、3f7e99c\n * 【修复】订单详情，点击查看商品详情时应该跳转的是 spuid，由 @孙正涛 贡献 #51\n * 【修复】店铺装修时，商品列表组件返回的商品信息，按照选择的顺序返回，由 @芋道源码 贡献 bbfff1b\n * 【修复】拼团装修组件，跳转拼团商品界面的 id 不正确的问题，由 @芋道源码 贡献 68d2fc4\n * 【修复】优惠活动中的限时活动，添加活动报错系统异常，由 @bumianri 贡献 #733\n\nreport 报表专区：\n\n * 【修复】ureport 包冲突，导致积木报表导出 excel 报错，由 @李占宏 贡献 #899\n * 【移除】ureport 的实现，因为和 spring boot 兼容性较差，由 @芋道源码 贡献\n\npay 支付专区：\n\n * 【修复】微信支付时，无法保证父线程的 threadlocal 传入子线程，由 @芋道源码 贡献 d30700d\n * 【修复】解决退款失败时返回退款订单号错误的问题，由 @杨宇庆 贡献 #912\n\ncrm 客户管理专区：\n\n * 【修复】@requestbody 和 multipart 不能同时存在的异常和导入客户后序列化产生的异常，由 @芋道源码 贡献 a68abc4\n * 【修复】修复创建跟进记录操作日志的 id 不正确，由 @芋道源码 贡献 #938\n * 【修复】crm 管理员数据权限，由 @puhui999 贡献 #957\n * 【修复】crm 客户导入无效的问题，由 @puhui999 贡献 #433\n\nerp 企业管理专区：\n\n * 【修复】erp 采购订单菜单权限错误问题，由 @zengheng 贡献 #922",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【v1.9.0】2023-12-01",
            frontmatter: {
                title: "【v1.9.0】2023-12-01",
                date: "2023-10-24T20:55:33.000Z",
                permalink: "/changelog/1.9.0/"
            },
            regularPath: "/99.%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/77.%E3%80%90v1-9-0%E3%80%912023-11-30.html",
            relativePath: "99.更新日志/77.【v1-9-0】2023-11-30.md",
            key: "v-3f295e87",
            path: "/changelog/1.9.0/",
            headers: [{
                level: 2,
                title: "支持 Spring Boot 3.2 版本，提供 WebSocket、主子表生成等功能",
                slug: "支持-spring-boot-3-2-版本-提供-websocket、主子表生成等功能",
                normalizedTitle: "支持 spring boot 3.2 版本，提供 websocket、主子表生成等功能",
                charIndex: 2
            }, {
                level: 3,
                title: "📈 Statistic",
                slug: "📈-statistic",
                normalizedTitle: "📈 statistic",
                charIndex: 50
            }, {
                level: 3,
                title: "⭐ New Features",
                slug: "⭐-new-features",
                normalizedTitle: "⭐ new features",
                charIndex: 131
            }, {
                level: 3,
                title: "🐞 Bug Fixes",
                slug: "🐞-bug-fixes",
                normalizedTitle: "🐞 bug fixes",
                charIndex: 1883
            }],
            headersStr: "支持 Spring Boot 3.2 版本，提供 WebSocket、主子表生成等功能 📈 Statistic ⭐ New Features 🐞 Bug Fixes",
            content: "# 支持 Spring Boot 3.2 版本，提供 WebSocket、主子表生成等功能\n\n\n# 📈 Statistic\n\n * 总代码行数：185740\n * 源码代码行数：114411\n * 注释行数：42259\n * 单元测试用例数：1073\n\n\n# ⭐ New Features\n\n * 【新增】RocketMQ、Kafka、RabbitMQ 消息队列的支持，由 @芋道源码 贡献 #711\n * 【优化】Vue 管理后台：新增用户时，归属部门赋默认值，由 @派森强哥 贡献 #707\n * 【新增】微信小程序、微信公众号、企业微信、钉钉等三方应用的管理，由 @puhui999 贡献 #696、#296\n * 【新增】Vue3 + Element Plus 代码生成器：主子表（ERP/标准/内嵌）、树表的支持，由 @芋道源码 贡献 #325、#736、#65\n * 【新增】Vue2 + Element UI 代码生成器：主子表（ERP/标准/内嵌）、树表的支持，由 @puhui999 贡献 #1、#734、#2、#761、#3、#769\n * 【完善】达梦数据库适配，由 @dhb52 贡献 #719\n * 【完善】SaaS 租户支持独立子域名，由 @芋道源码 贡献\n * 【优化】Vue3 管理后台：默认关闭 Prettier 格式化，避免影响开发效率，由 @芋道源码 贡献\n * 【优化】Vue3 管理后台：新增菜单搜索功能，由 @boide 贡献 #331\n * 【新增】WebSocket 组件，支持 Token 身份认证、Session 会话管理、Message 消息接收、Message 广播推送等，由 @芋道源码 贡献 #749\n * 【优化】使用 justauth 替代现有 yudao-spring-boot-starter-biz-social 依赖，减少 starter，由 @芋道源码 贡献 #752\n * 【优化】模块直接引入 wxjava starter，替代现有 yudao-spring-boot-starter-biz-weixin 依赖，减少 starter，由 @芋道源码 贡献\n\nBPM 工作流专区：\n\n * 【新增】创建流程实例指定审批人，由 @Youkehai 贡献 #717\n * 【新增】达梦数据库对工作流的适配，由 @dhb52 贡献 #723\n\nREPORT 报表专区：\n\n * 【新增】UReport2 的集成，由 @souvc 贡献 #744\n\nMALL 商城专区：\n\n * 【新增】商城 uniapp Vue3 版本，由 @Bluemark 贡献 #9、#13\n * 【新增】商城装修，由 @疯狂的世界 贡献 #703、#298、#709、#301、#712、#12、#14、#315、#319、#15、#735、#324、#16、#743、#18、#328\n * 【新增】商城 Vue3 管理后台：满减送活动，由 @Bluemark 贡献 #291\n * 【新增】商城 Vue3 管理后台：增加查询会员的商品收藏列表，由 @niou233 贡献 #724、#314\n\nCRM 客户管理系统专区：\n\n * 【新增】CRM 联系人的开发，由 @zyna 贡献 #691、#317、#727、#755、#335、#763、#337\n * 【新增】CRM 客户的开发，由 @wanwan 贡献 #695、#294、#701、#297、#715、#306\n * 【新增】CRM 商机、商机类型、商机状态的开发，由 @刘先生 贡献 #697、#747、#330\n * 【新增】CRM 客户、联系人、合同的转移操作，由 @puhui999 贡献 #702\n * 【新增】CRM 回款、回款计划的开发，由 @souvc 贡献 #706、#309\n * 【新增】CRM 全局的数据权限封装，由 @puhui999 贡献 #704、#710、#303、#725、#322、#745、#329、#758、#762\n * 【新增】CRM 客户的锁定、解锁，由 @Joey 共享 #713\n * 【新增】CRM 商品、商品分类的开发，由 @ZanGe丶 共享 #308、#716\n * 【新增】CRM 客户公海配置 + CRM 客户限制，由 @wanwan 贡献 #726、#316、#751、#334\n * 【新增】CRM 公海客户的领取和分配，由 @wanwan 贡献 #726、#316、#739\n\n\n# 🐞 Bug Fixes\n\n * 【修复】vben 代码生成错误，由 @xingyuv 贡献 #705\n * 【修复】Vue3 管理后台：unocss 导致 Login 登录界面的首次重定向问题，由 @芋道源码 贡献 de62a7a\n * 【修复】Vue3 管理后台：站内信内容过多回显问题，由 @lzy 贡献 #299\n * 【修复】Boot 3.X：分支启用 druid 的 stat-view-servlet 会导致服务启动失败，禁用又查看不到监控页面的问题，由 @OrionPax 贡献 #728\n * 【修复】Vue3 管理后台：滑块验证码无任何滑动直接点击验证时，x 坐标空，导致后端 NPE 的问题，由 @柯杨 贡献 #321\n * 【修复】Vue3 管理后台：社交绑定后，列表重复，由 @口口口 贡献 #323\n * 【修复】更新账号时岗位为空时发生的空指针异常，由 @oc 贡献 #69\n * 【修复】@PermitAll 注解在 @RequestMapping 未填写 method 无法免登录的问题，由 @胡庆春 贡献 #67\n * 【修复】mybatis plus 配置的 type-aliases-package 错误，由 @胡庆春 贡献 #68\n * 【修复】Cloud 未启动 system 模块，其他模块 【bpm\\report 等模块】，因依赖错误码组件无法启动服务，由 @陈晨成 贡献 #60\n\nMALL 商城专区：\n\n * 【修复】商城订单：解决列数据中的 table#header 数据不刷新的问题，由 @puhui999 贡献 #295\n * 【修复】商城 uniapp Vue2 版本，openid 解析不正确，由 @青椒麻不过花椒、@绾君心 贡献 #11、#19\n * 【修复】商城 Vue3 管理后台：运费模版的选择地区提示错误，由 @风狗 贡献 #302\n * 【修复】小程序模式下的一些异常，以及页面跳转错误，由 @云扬四海 贡献 #17\n * 【修复】返回使用过优惠券逻辑的状态字段取错了，由 @Ai3_刘小龙 贡献 #764\n\nPAY 支付专区：\n\n * 【修复】PayWalletRechargeCreate 参数校验不正确，由 @puhui999 贡献 #698\n\nMP 公众号专区：\n\n * 【修复】同步公众号粉丝接口调用错误，由 @Evol郑天 贡献 #336\n * 【修复】公众号-素材管理 上传时缺少 accountId 参数，由 @Evol郑天 贡献 #338",
            normalizedContent: "# 支持 spring boot 3.2 版本，提供 websocket、主子表生成等功能\n\n\n# 📈 statistic\n\n * 总代码行数：185740\n * 源码代码行数：114411\n * 注释行数：42259\n * 单元测试用例数：1073\n\n\n# ⭐ new features\n\n * 【新增】rocketmq、kafka、rabbitmq 消息队列的支持，由 @芋道源码 贡献 #711\n * 【优化】vue 管理后台：新增用户时，归属部门赋默认值，由 @派森强哥 贡献 #707\n * 【新增】微信小程序、微信公众号、企业微信、钉钉等三方应用的管理，由 @puhui999 贡献 #696、#296\n * 【新增】vue3 + element plus 代码生成器：主子表（erp/标准/内嵌）、树表的支持，由 @芋道源码 贡献 #325、#736、#65\n * 【新增】vue2 + element ui 代码生成器：主子表（erp/标准/内嵌）、树表的支持，由 @puhui999 贡献 #1、#734、#2、#761、#3、#769\n * 【完善】达梦数据库适配，由 @dhb52 贡献 #719\n * 【完善】saas 租户支持独立子域名，由 @芋道源码 贡献\n * 【优化】vue3 管理后台：默认关闭 prettier 格式化，避免影响开发效率，由 @芋道源码 贡献\n * 【优化】vue3 管理后台：新增菜单搜索功能，由 @boide 贡献 #331\n * 【新增】websocket 组件，支持 token 身份认证、session 会话管理、message 消息接收、message 广播推送等，由 @芋道源码 贡献 #749\n * 【优化】使用 justauth 替代现有 yudao-spring-boot-starter-biz-social 依赖，减少 starter，由 @芋道源码 贡献 #752\n * 【优化】模块直接引入 wxjava starter，替代现有 yudao-spring-boot-starter-biz-weixin 依赖，减少 starter，由 @芋道源码 贡献\n\nbpm 工作流专区：\n\n * 【新增】创建流程实例指定审批人，由 @youkehai 贡献 #717\n * 【新增】达梦数据库对工作流的适配，由 @dhb52 贡献 #723\n\nreport 报表专区：\n\n * 【新增】ureport2 的集成，由 @souvc 贡献 #744\n\nmall 商城专区：\n\n * 【新增】商城 uniapp vue3 版本，由 @bluemark 贡献 #9、#13\n * 【新增】商城装修，由 @疯狂的世界 贡献 #703、#298、#709、#301、#712、#12、#14、#315、#319、#15、#735、#324、#16、#743、#18、#328\n * 【新增】商城 vue3 管理后台：满减送活动，由 @bluemark 贡献 #291\n * 【新增】商城 vue3 管理后台：增加查询会员的商品收藏列表，由 @niou233 贡献 #724、#314\n\ncrm 客户管理系统专区：\n\n * 【新增】crm 联系人的开发，由 @zyna 贡献 #691、#317、#727、#755、#335、#763、#337\n * 【新增】crm 客户的开发，由 @wanwan 贡献 #695、#294、#701、#297、#715、#306\n * 【新增】crm 商机、商机类型、商机状态的开发，由 @刘先生 贡献 #697、#747、#330\n * 【新增】crm 客户、联系人、合同的转移操作，由 @puhui999 贡献 #702\n * 【新增】crm 回款、回款计划的开发，由 @souvc 贡献 #706、#309\n * 【新增】crm 全局的数据权限封装，由 @puhui999 贡献 #704、#710、#303、#725、#322、#745、#329、#758、#762\n * 【新增】crm 客户的锁定、解锁，由 @joey 共享 #713\n * 【新增】crm 商品、商品分类的开发，由 @zange丶 共享 #308、#716\n * 【新增】crm 客户公海配置 + crm 客户限制，由 @wanwan 贡献 #726、#316、#751、#334\n * 【新增】crm 公海客户的领取和分配，由 @wanwan 贡献 #726、#316、#739\n\n\n# 🐞 bug fixes\n\n * 【修复】vben 代码生成错误，由 @xingyuv 贡献 #705\n * 【修复】vue3 管理后台：unocss 导致 login 登录界面的首次重定向问题，由 @芋道源码 贡献 de62a7a\n * 【修复】vue3 管理后台：站内信内容过多回显问题，由 @lzy 贡献 #299\n * 【修复】boot 3.x：分支启用 druid 的 stat-view-servlet 会导致服务启动失败，禁用又查看不到监控页面的问题，由 @orionpax 贡献 #728\n * 【修复】vue3 管理后台：滑块验证码无任何滑动直接点击验证时，x 坐标空，导致后端 npe 的问题，由 @柯杨 贡献 #321\n * 【修复】vue3 管理后台：社交绑定后，列表重复，由 @口口口 贡献 #323\n * 【修复】更新账号时岗位为空时发生的空指针异常，由 @oc 贡献 #69\n * 【修复】@permitall 注解在 @requestmapping 未填写 method 无法免登录的问题，由 @胡庆春 贡献 #67\n * 【修复】mybatis plus 配置的 type-aliases-package 错误，由 @胡庆春 贡献 #68\n * 【修复】cloud 未启动 system 模块，其他模块 【bpm\\report 等模块】，因依赖错误码组件无法启动服务，由 @陈晨成 贡献 #60\n\nmall 商城专区：\n\n * 【修复】商城订单：解决列数据中的 table#header 数据不刷新的问题，由 @puhui999 贡献 #295\n * 【修复】商城 uniapp vue2 版本，openid 解析不正确，由 @青椒麻不过花椒、@绾君心 贡献 #11、#19\n * 【修复】商城 vue3 管理后台：运费模版的选择地区提示错误，由 @风狗 贡献 #302\n * 【修复】小程序模式下的一些异常，以及页面跳转错误，由 @云扬四海 贡献 #17\n * 【修复】返回使用过优惠券逻辑的状态字段取错了，由 @ai3_刘小龙 贡献 #764\n\npay 支付专区：\n\n * 【修复】paywalletrechargecreate 参数校验不正确，由 @puhui999 贡献 #698\n\nmp 公众号专区：\n\n * 【修复】同步公众号粉丝接口调用错误，由 @evol郑天 贡献 #336\n * 【修复】公众号-素材管理 上传时缺少 accountid 参数，由 @evol郑天 贡献 #338",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【v2.0.0】2024-01-26",
            frontmatter: {
                title: "【v2.0.0】2024-01-26",
                date: "2023-12-01T20:55:33.000Z",
                permalink: "/changelog/2.0.0/"
            },
            regularPath: "/01.%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/30.%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/76.%E3%80%90v2-0-0%E3%80%912024-01-26.html",
            relativePath: "01.开发指南/30.更新日志/76.【v2-0-0】2024-01-26.md",
            key: "v-7e58c238",
            path: "/changelog/2.0.0/",
            headers: [{
                level: 2,
                title: "支持商城 uni-app 支持 Vue3、店铺装修等功能",
                slug: "支持商城-uni-app-支持-vue3、店铺装修等功能",
                normalizedTitle: "支持商城 uni-app 支持 vue3、店铺装修等功能",
                charIndex: 2
            }, {
                level: 3,
                title: "📈 Statistic",
                slug: "📈-statistic",
                normalizedTitle: "📈 statistic",
                charIndex: 35
            }, {
                level: 3,
                title: "⭐ New Features",
                slug: "⭐-new-features",
                normalizedTitle: "⭐ new features",
                charIndex: 120
            }, {
                level: 3,
                title: "🐞 Bug Fixes",
                slug: "🐞-bug-fixes",
                normalizedTitle: "🐞 bug fixes",
                charIndex: 1681
            }],
            headersStr: "支持商城 uni-app 支持 Vue3、店铺装修等功能 📈 Statistic ⭐ New Features 🐞 Bug Fixes",
            content: '# 支持商城 uni-app 支持 Vue3、店铺装修等功能\n\n\n# 📈 Statistic\n\n * 总代码行数：190773\n * 源码代码行数：118129\n * 注释行数：43574\n * 单元测试用例数：1120\n * \n\n\n# ⭐ New Features\n\n * 【重构】简化 system 和 infra 大模块模块的 VO，由 @芋道源码 贡献 #774\n * 【新增】Vue3 管理后台：文件列表增加图片的展示和预览，由 @boide 贡献 #333\n * 【优化】Spring Cloud 的 feign 调用，使用 okhttp 替代 HttpURLConnection，由 @Henry 贡献 #72\n * 【优化】增加 system 和 infra 的代码覆盖率，提升稳定性，由 @芋道源码 贡献 #783\n * 【优化】增加 ip 东莞市下面的行政区信息，由 @芋道源码 贡献 #793\n * 【优化】操作日志实现，支持数据的变更记录，由 @puhui999 贡献 #805、#806、#346\n * 【优化】代码生成的表列表排序，按照更新时间倒序，由 @bunco 贡献 #828\n * 【优化】数据权限兼容性，由 @chenchenche 贡献 #90\n * 【优化】多图上传组件的 modalValue 回显，由 @puhui999 贡献 #366\n\nMALL 商城专区：\n\n * 【新增】完善商城装修的实现，由 @疯狂的世界 贡献 #339、#20、#24、#344、#345、#25、#347、#28、#360、#822\n * 【优化】商品库存为 0 时，商品列表商品封面显示已售罄，商品详情页用户无法下单，由 @奕泽云 贡献 #343、#777、#22\n * 【新增】实现 uniapp Vue3 版本，由 @Bluemark 贡献 #27、#26、#23、#31\n * 【新增】实现 uniapp Vue3 秒杀，由 @疯狂的世界 贡献 #32\n * 【新增】商品统计，由 @疯狂的世界 贡献 #791、#351\n * 【新增】完善满减送活动的前端界面，由 @落日晚风 贡献 #352\n\nCRM 客户管理系统专区：\n\n * 【新增】完善 CRM 的产品管理、产品分类的实现，由 @ZanGe丶 贡献 #776、#342\n * 【新增】完善 CRM 的客户管理的实现，由 @puhui999 贡献 #358、#810\n * 【新增】完善 CRM 的公海客户的实现，由 @puhui999 贡献 #363、#832\n * 【新增】完善 CRM 的联系人的实现，由 @zyna 贡献 #775、#341、#350、#803、#817、#359\n * 【新增】完善 CRM 的数据权限，由 @puhui999 贡献 #784、#789、#795\n * 【新增】完善 CRM 的商机，由 @lzxhqs 贡献 #830、#850\n * 【新增】完善 CRM 的线索实现，由 @Minh-X 贡献 #819、#820、#829、#845、#370\n * 【新增】完善 CRM 的产品、产品分类的操作日志，由 @安浩浩 贡献 #818、#826、#361、#833\n * 【新增】CRM 的跟进记录，由 @puhui999 贡献 #821、#840、#844、#846、#366、#847、#851\n * 【新增】CRM 的待办事项，由 @dhb52 贡献 #831、#364、#367\n * 【新增】完善 CRM 的客户锁定逻辑，由 @Joey 贡献 #790\n\nREPORT 报表专区：\n\n * 【新增】完善 UReport2 的集成，由 @souvc 贡献 #327、#773\n * 【优化】支持 SaaS 多租户，由 @Fanjc 贡献 #84\n\nBPM 工作流专区：\n\n * 【新增】工作流的抄送功能，由 @云开 贡献 #365、#839、#849\n * 【优化】工作流表单的文档提示，由 @水人 贡献 #357\n\n\n# 🐞 Bug Fixes\n\n * 【修复】Vue3 管理后台：IDEA 在 v-for="dict in getIntDictOptions(...)" 时，el-option 的 key 会告警的问题，由 @芋道源码 贡献 aecc9bb\n * 【修复】Vue3 管理后台：修改 UploadImg 组件预览图片的方式为 createImageViewer，解决列表预览图片层级出现错误，由 @puhui999 贡献 #340\n * 【修复】Spring Cloud 的 mp、member、mall 缺少 Maven build plugins，由 @WangSai 贡献 #73\n * 【修复】Spring Cache Redis 单冒号，而不是双 :: 冒号，避免 Redis Desktop Manager 多余空格，由 @晨曦伴读 贡献 #81\n * 【修复】Spring Cloud 在 JDK17 场景下无法编译启动的问题，由 @oc 贡献 #70\n * 【修复】修复 JDK21 代码生成模板文件中 import 的错误，由 @云开 贡献 #792\n * 【修复】Websocket 断开时，未删除会话缓存 bug，由 @陈晨成 贡献 #71\n * 【修复】JDK21 版本的 WebSocket 失效的问题，由 @oc 贡献 #87\n * 【修复】修改短信渠道事，缓存没有更新，由 @Evol郑天 贡献 #86\n * 【修复】导出 Excel:Long 类型 ID 会丢失精度，由 @moon69 贡献 #89\n * 【修复】文件路径 url 中文解码问题，由 @ccran 贡献 #807\n * 【修复】代码生成器 Vue2，Excel导出下载修复，由 @virtuecai 贡献 #804\n * 【修复】Vue2 管理后台：修改用户时，报密码长度不正确的问题，由 @芋道源码 贡献 7c8d340\n * 【修复】腾讯云上传 bug，由 @Breadswim 贡献 #123\n * 【修复】CacheUtils 异步缓存的 ThreadLocal 变量传递，由 @芋道源码 贡献 c98738d\n * 【修复】修复文件上传数据回显错误，由 @puhui999 贡献 #355\n * 【修复】Oracle limitN wrapper 条件修正，由 @Cool_Breeze 贡献 #843\n * 【修复】去除通知保存 VO 里的 Id 不为空验证，由 @smthhy 贡献 #841\n * 【修复】Vue3 管理后台：登录后，跳转不带参数的问题，由 @AKING 贡献 #373\n\nBPM 工作流专区：\n\n * 【修复】解决审批流自定义脚本无法获取流程变量，由 @xiuuuu 贡献 #799\n * 【修复】多租户的工作流隔离，由 @芋道源码 贡献 9a03f1a\n * 【修复】修复请假申请提交后页面不返回 的bug，由 @puhui999 贡献 #355\n\nMember 会员中心专区：\n\n * 【修复】修复微信小程序的一键登录时，缺少 state 参数，由 @Evol郑天 贡献 #74、#21\n * 【修复】会员当前有等级的时候下订单会把当前等级给清空了，由 @云扬四海 贡献 #809\n\nMALL 商城系统专区：\n\n * 【修复】微信小程序登录 openid 参数名不一致导致支付报错问题，由 @高靖 贡献 #33\n * 【修复】修复订单操作日志中快递公司名称模板与数据对不上的问题，由 @杨宇庆 贡献 #811\n\nPAY 支付中心专区：\n\n * 【修复】支付回调时，查询 PayOrderApi getOrder 需要登录的问题，由 @Fanjc 贡献 #88\n * 【修复】修改 pay 模块>支付订单的同步 Job，查询指定创建时间前的待支付订单，由 @骑士梦 贡献 #808\n * 【修复】支付 demo 退款单匹配错误问题，由 @lynfgn 贡献 #800',
            normalizedContent: '# 支持商城 uni-app 支持 vue3、店铺装修等功能\n\n\n# 📈 statistic\n\n * 总代码行数：190773\n * 源码代码行数：118129\n * 注释行数：43574\n * 单元测试用例数：1120\n * \n\n\n# ⭐ new features\n\n * 【重构】简化 system 和 infra 大模块模块的 vo，由 @芋道源码 贡献 #774\n * 【新增】vue3 管理后台：文件列表增加图片的展示和预览，由 @boide 贡献 #333\n * 【优化】spring cloud 的 feign 调用，使用 okhttp 替代 httpurlconnection，由 @henry 贡献 #72\n * 【优化】增加 system 和 infra 的代码覆盖率，提升稳定性，由 @芋道源码 贡献 #783\n * 【优化】增加 ip 东莞市下面的行政区信息，由 @芋道源码 贡献 #793\n * 【优化】操作日志实现，支持数据的变更记录，由 @puhui999 贡献 #805、#806、#346\n * 【优化】代码生成的表列表排序，按照更新时间倒序，由 @bunco 贡献 #828\n * 【优化】数据权限兼容性，由 @chenchenche 贡献 #90\n * 【优化】多图上传组件的 modalvalue 回显，由 @puhui999 贡献 #366\n\nmall 商城专区：\n\n * 【新增】完善商城装修的实现，由 @疯狂的世界 贡献 #339、#20、#24、#344、#345、#25、#347、#28、#360、#822\n * 【优化】商品库存为 0 时，商品列表商品封面显示已售罄，商品详情页用户无法下单，由 @奕泽云 贡献 #343、#777、#22\n * 【新增】实现 uniapp vue3 版本，由 @bluemark 贡献 #27、#26、#23、#31\n * 【新增】实现 uniapp vue3 秒杀，由 @疯狂的世界 贡献 #32\n * 【新增】商品统计，由 @疯狂的世界 贡献 #791、#351\n * 【新增】完善满减送活动的前端界面，由 @落日晚风 贡献 #352\n\ncrm 客户管理系统专区：\n\n * 【新增】完善 crm 的产品管理、产品分类的实现，由 @zange丶 贡献 #776、#342\n * 【新增】完善 crm 的客户管理的实现，由 @puhui999 贡献 #358、#810\n * 【新增】完善 crm 的公海客户的实现，由 @puhui999 贡献 #363、#832\n * 【新增】完善 crm 的联系人的实现，由 @zyna 贡献 #775、#341、#350、#803、#817、#359\n * 【新增】完善 crm 的数据权限，由 @puhui999 贡献 #784、#789、#795\n * 【新增】完善 crm 的商机，由 @lzxhqs 贡献 #830、#850\n * 【新增】完善 crm 的线索实现，由 @minh-x 贡献 #819、#820、#829、#845、#370\n * 【新增】完善 crm 的产品、产品分类的操作日志，由 @安浩浩 贡献 #818、#826、#361、#833\n * 【新增】crm 的跟进记录，由 @puhui999 贡献 #821、#840、#844、#846、#366、#847、#851\n * 【新增】crm 的待办事项，由 @dhb52 贡献 #831、#364、#367\n * 【新增】完善 crm 的客户锁定逻辑，由 @joey 贡献 #790\n\nreport 报表专区：\n\n * 【新增】完善 ureport2 的集成，由 @souvc 贡献 #327、#773\n * 【优化】支持 saas 多租户，由 @fanjc 贡献 #84\n\nbpm 工作流专区：\n\n * 【新增】工作流的抄送功能，由 @云开 贡献 #365、#839、#849\n * 【优化】工作流表单的文档提示，由 @水人 贡献 #357\n\n\n# 🐞 bug fixes\n\n * 【修复】vue3 管理后台：idea 在 v-for="dict in getintdictoptions(...)" 时，el-option 的 key 会告警的问题，由 @芋道源码 贡献 aecc9bb\n * 【修复】vue3 管理后台：修改 uploadimg 组件预览图片的方式为 createimageviewer，解决列表预览图片层级出现错误，由 @puhui999 贡献 #340\n * 【修复】spring cloud 的 mp、member、mall 缺少 maven build plugins，由 @wangsai 贡献 #73\n * 【修复】spring cache redis 单冒号，而不是双 :: 冒号，避免 redis desktop manager 多余空格，由 @晨曦伴读 贡献 #81\n * 【修复】spring cloud 在 jdk17 场景下无法编译启动的问题，由 @oc 贡献 #70\n * 【修复】修复 jdk21 代码生成模板文件中 import 的错误，由 @云开 贡献 #792\n * 【修复】websocket 断开时，未删除会话缓存 bug，由 @陈晨成 贡献 #71\n * 【修复】jdk21 版本的 websocket 失效的问题，由 @oc 贡献 #87\n * 【修复】修改短信渠道事，缓存没有更新，由 @evol郑天 贡献 #86\n * 【修复】导出 excel:long 类型 id 会丢失精度，由 @moon69 贡献 #89\n * 【修复】文件路径 url 中文解码问题，由 @ccran 贡献 #807\n * 【修复】代码生成器 vue2，excel导出下载修复，由 @virtuecai 贡献 #804\n * 【修复】vue2 管理后台：修改用户时，报密码长度不正确的问题，由 @芋道源码 贡献 7c8d340\n * 【修复】腾讯云上传 bug，由 @breadswim 贡献 #123\n * 【修复】cacheutils 异步缓存的 threadlocal 变量传递，由 @芋道源码 贡献 c98738d\n * 【修复】修复文件上传数据回显错误，由 @puhui999 贡献 #355\n * 【修复】oracle limitn wrapper 条件修正，由 @cool_breeze 贡献 #843\n * 【修复】去除通知保存 vo 里的 id 不为空验证，由 @smthhy 贡献 #841\n * 【修复】vue3 管理后台：登录后，跳转不带参数的问题，由 @aking 贡献 #373\n\nbpm 工作流专区：\n\n * 【修复】解决审批流自定义脚本无法获取流程变量，由 @xiuuuu 贡献 #799\n * 【修复】多租户的工作流隔离，由 @芋道源码 贡献 9a03f1a\n * 【修复】修复请假申请提交后页面不返回 的bug，由 @puhui999 贡献 #355\n\nmember 会员中心专区：\n\n * 【修复】修复微信小程序的一键登录时，缺少 state 参数，由 @evol郑天 贡献 #74、#21\n * 【修复】会员当前有等级的时候下订单会把当前等级给清空了，由 @云扬四海 贡献 #809\n\nmall 商城系统专区：\n\n * 【修复】微信小程序登录 openid 参数名不一致导致支付报错问题，由 @高靖 贡献 #33\n * 【修复】修复订单操作日志中快递公司名称模板与数据对不上的问题，由 @杨宇庆 贡献 #811\n\npay 支付中心专区：\n\n * 【修复】支付回调时，查询 payorderapi getorder 需要登录的问题，由 @fanjc 贡献 #88\n * 【修复】修改 pay 模块>支付订单的同步 job，查询指定创建时间前的待支付订单，由 @骑士梦 贡献 #808\n * 【修复】支付 demo 退款单匹配错误问题，由 @lynfgn 贡献 #800',
            charsets: {
                cjk: !0
            }
        }, {
            title: "【v1.8.3】2023-10-24",
            frontmatter: {
                title: "【v1.8.3】2023-10-24",
                date: "2023-10-24T20:55:33.000Z",
                permalink: "/changelog/1.8.3/"
            },
            regularPath: "/99.%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/78.%E3%80%90v1-8-3%E3%80%912023-10-24.html",
            relativePath: "99.更新日志/78.【v1-8-3】2023-10-24.md",
            key: "v-f21f67b2",
            path: "/changelog/1.8.3/",
            headers: [{
                level: 2,
                title: "优化商城代码，并支持 Spring Cloud 版本",
                slug: "优化商城代码-并支持-spring-cloud-版本",
                normalizedTitle: "优化商城代码，并支持 spring cloud 版本",
                charIndex: 2
            }, {
                level: 3,
                title: "📈 Statistic",
                slug: "📈-statistic",
                normalizedTitle: "📈 statistic",
                charIndex: 33
            }, {
                level: 3,
                title: "⭐ New Features",
                slug: "⭐-new-features",
                normalizedTitle: "⭐ new features",
                charIndex: 113
            }, {
                level: 3,
                title: "🐞 Bug Fixes",
                slug: "🐞-bug-fixes",
                normalizedTitle: "🐞 bug fixes",
                charIndex: 1501
            }, {
                level: 3,
                title: "🔨 Dependency Upgrades",
                slug: "🔨-dependency-upgrades",
                normalizedTitle: "🔨 dependency upgrades",
                charIndex: 2106
            }],
            headersStr: "优化商城代码，并支持 Spring Cloud 版本 📈 Statistic ⭐ New Features 🐞 Bug Fixes 🔨 Dependency Upgrades",
            content: "# 优化商城代码，并支持 Spring Cloud 版本\n\n\n# 📈 Statistic\n\n * 总代码行数：166511\n * 源码代码行数：102533\n * 注释行数：38384\n * 单元测试用例数：947\n\n\n# ⭐ New Features\n\n * 【新增】访问日志、错误日志、Job 执行日志的每日清理，由 @lanxindx 贡献 #646、#648\n * 【新增】测试站内信接口增加 Member 用户类型的支持，由 @风狗 贡献 #636、#255\n * 【新增】Vue3 管理后台：社交登录，由 @dhb52 贡献 #271\n * 【优化】优化 Vue3 + vben + ant-design-vue4.0 管理后台，由 @xingyu\n\nBPM 工作流专区：\n\n * 【新增】BPM 工作流增加委派操作，由 @Youkehai 贡献 #250、#631\n * 【新增】工作流的加签和减签，由 @Youkehai 贡献 #639、#659、#699、#290\n * 【新增】Vue2 管理后台：接入退回、委派的前端操作，由 @LiuMoffett 贡献 #662\n\nMember 会员专区：\n\n * 【新增】完善会员配置、签到配置、会员详情，由 @疯狂的世界 贡献 #642、#259\n * 【新增】商城订单的核销流程，由 @疯狂的世界 贡献 #262、#4、#676、#279\n * 【新增】Cloud 微服务：member 会员中心，提供会员账号、积分、等级、分组等功能，由 @芋道源码 贡献\n\nPay 支付专区：\n\n * 【新增】钱包充值套餐，由 @Jason 贡献\n * 【新增】支付转账，由 @Jason 贡献\n\nMALL 商城专区：\n\n * 【新增】商城的交易统计，由 @疯狂的世界 贡献 #258、#640、#650\n * 【新增】商城的会员统计，由 @疯狂的世界 贡献 #658、#268、#661\n * 【新增】商城的首页统计，由 @疯狂的世界 贡献 #273、#669、#5、#672、#275\n * 【新增】完善商城分佣功能，由 @疯狂的世界 贡献 #635、#2、#252、#649\n * 【新增】完善拼团、砍价、秒杀活动，由 @puhui999、@芋道源码 贡献 #634、#653、#654、#264、#655、#657、#269、#694\n * 【新增】完善商城优惠劵功能，由 @疯狂的世界 贡献 #637、#3\n * 【新增】完善交易日志、售后日志的记录，由 @芋道源码 贡献\n * 【优化】完善交易订单详情、退款售后详情，由 @芋道源码 贡献\n * 【新增】完善商城的限时折扣活动，由 @zxiaoxiu 贡献 #283、#683\n * 【新增】完善 SPU，订单列表：完善表头宽度自适应，由 @puhui999 贡献 #284、#685\n * 【新增】商城的文章管理、文章分类管理，由 @puhui999 贡献 #272、#668、#678\n\nCRM 客户管理系统专区：\n\n * 【新增】CRM 客户管理：合同流程的初始化，由 @dhb52 贡献 #671、#275\n * 【新增】CRM 客户管理：销售线索的初始化，由 @wanwan 贡献 #679、#688、#280、#286\n * 【新增】CRM 客户管理：商机的初始化，由 @刘先生 贡献 #682\n * 【新增】CRM 客户管理：回款的初始化，由 @souvc 贡献 #684、#285\n * 【新增】CRM 客户端管理：联系人的初始化，由 @zyna 贡献 #687\n\n\n# 🐞 Bug Fixes\n\n * 【修复】修改 Spring Doc 版本，解决 Swagger 文档都是 form 提交，由 @fangyuan 贡献 #637\n * 【修复】Vue3 管理后台：对齐面包屑的图标和文字，由 @疯狂的世界 贡献 #261\n * 【修复】Vue3 管理后台：解决处理顶级非目录路由的组件名称逻辑缺失的问题，由 @clockdotnet 贡献 #254\n * 【修复】解决未配置用户角色时无法加载页面问题，由 @刘少军 贡献 #647\n * 【修复】Vue2 管理后台：操作日志搜索参数名错误，由 @ligitee 贡献 #641\n * 【修复】Vue3 管理后台：刷新菜单缓存失效问题，由 @天痕 贡献 #265\n * 【修复】Vue3 管理后台：前端支付渠道配置权限错误，由 @小玩家 贡献 #277\n * 【修复】[文件管理->文件配置->更换主配置]，导致文件上传报错，由 @人生三两事 贡献 #675\n * 【修复】敏感词单字符检验失败问题，由 @摸鱼散人 贡献 #665\n * 【修复】基础设施：数据库文档未忽略前缀 FLW_ 的表，由 @疯狂的世界 贡献 #677\n * 【修复】审批信息页面引入 TaskDelegateForm.vue 不兼容 Linux，由 @陈晨成 贡献 #281\n * 【修复】短信模板无法修改问题，由 @Fanjc 贡献 #59\n\n\n# 🔨 Dependency Upgrades\n\n * 【升级】spring boot from 2.7.15 to 2.7.17",
            normalizedContent: "# 优化商城代码，并支持 spring cloud 版本\n\n\n# 📈 statistic\n\n * 总代码行数：166511\n * 源码代码行数：102533\n * 注释行数：38384\n * 单元测试用例数：947\n\n\n# ⭐ new features\n\n * 【新增】访问日志、错误日志、job 执行日志的每日清理，由 @lanxindx 贡献 #646、#648\n * 【新增】测试站内信接口增加 member 用户类型的支持，由 @风狗 贡献 #636、#255\n * 【新增】vue3 管理后台：社交登录，由 @dhb52 贡献 #271\n * 【优化】优化 vue3 + vben + ant-design-vue4.0 管理后台，由 @xingyu\n\nbpm 工作流专区：\n\n * 【新增】bpm 工作流增加委派操作，由 @youkehai 贡献 #250、#631\n * 【新增】工作流的加签和减签，由 @youkehai 贡献 #639、#659、#699、#290\n * 【新增】vue2 管理后台：接入退回、委派的前端操作，由 @liumoffett 贡献 #662\n\nmember 会员专区：\n\n * 【新增】完善会员配置、签到配置、会员详情，由 @疯狂的世界 贡献 #642、#259\n * 【新增】商城订单的核销流程，由 @疯狂的世界 贡献 #262、#4、#676、#279\n * 【新增】cloud 微服务：member 会员中心，提供会员账号、积分、等级、分组等功能，由 @芋道源码 贡献\n\npay 支付专区：\n\n * 【新增】钱包充值套餐，由 @jason 贡献\n * 【新增】支付转账，由 @jason 贡献\n\nmall 商城专区：\n\n * 【新增】商城的交易统计，由 @疯狂的世界 贡献 #258、#640、#650\n * 【新增】商城的会员统计，由 @疯狂的世界 贡献 #658、#268、#661\n * 【新增】商城的首页统计，由 @疯狂的世界 贡献 #273、#669、#5、#672、#275\n * 【新增】完善商城分佣功能，由 @疯狂的世界 贡献 #635、#2、#252、#649\n * 【新增】完善拼团、砍价、秒杀活动，由 @puhui999、@芋道源码 贡献 #634、#653、#654、#264、#655、#657、#269、#694\n * 【新增】完善商城优惠劵功能，由 @疯狂的世界 贡献 #637、#3\n * 【新增】完善交易日志、售后日志的记录，由 @芋道源码 贡献\n * 【优化】完善交易订单详情、退款售后详情，由 @芋道源码 贡献\n * 【新增】完善商城的限时折扣活动，由 @zxiaoxiu 贡献 #283、#683\n * 【新增】完善 spu，订单列表：完善表头宽度自适应，由 @puhui999 贡献 #284、#685\n * 【新增】商城的文章管理、文章分类管理，由 @puhui999 贡献 #272、#668、#678\n\ncrm 客户管理系统专区：\n\n * 【新增】crm 客户管理：合同流程的初始化，由 @dhb52 贡献 #671、#275\n * 【新增】crm 客户管理：销售线索的初始化，由 @wanwan 贡献 #679、#688、#280、#286\n * 【新增】crm 客户管理：商机的初始化，由 @刘先生 贡献 #682\n * 【新增】crm 客户管理：回款的初始化，由 @souvc 贡献 #684、#285\n * 【新增】crm 客户端管理：联系人的初始化，由 @zyna 贡献 #687\n\n\n# 🐞 bug fixes\n\n * 【修复】修改 spring doc 版本，解决 swagger 文档都是 form 提交，由 @fangyuan 贡献 #637\n * 【修复】vue3 管理后台：对齐面包屑的图标和文字，由 @疯狂的世界 贡献 #261\n * 【修复】vue3 管理后台：解决处理顶级非目录路由的组件名称逻辑缺失的问题，由 @clockdotnet 贡献 #254\n * 【修复】解决未配置用户角色时无法加载页面问题，由 @刘少军 贡献 #647\n * 【修复】vue2 管理后台：操作日志搜索参数名错误，由 @ligitee 贡献 #641\n * 【修复】vue3 管理后台：刷新菜单缓存失效问题，由 @天痕 贡献 #265\n * 【修复】vue3 管理后台：前端支付渠道配置权限错误，由 @小玩家 贡献 #277\n * 【修复】[文件管理->文件配置->更换主配置]，导致文件上传报错，由 @人生三两事 贡献 #675\n * 【修复】敏感词单字符检验失败问题，由 @摸鱼散人 贡献 #665\n * 【修复】基础设施：数据库文档未忽略前缀 flw_ 的表，由 @疯狂的世界 贡献 #677\n * 【修复】审批信息页面引入 taskdelegateform.vue 不兼容 linux，由 @陈晨成 贡献 #281\n * 【修复】短信模板无法修改问题，由 @fanjc 贡献 #59\n\n\n# 🔨 dependency upgrades\n\n * 【升级】spring boot from 2.7.15 to 2.7.17",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【v1.8.2】2023-09-24",
            frontmatter: {
                title: "【v1.8.2】2023-09-24",
                date: "2023-09-24T20:55:33.000Z",
                permalink: "/changelog/1.8.2/"
            },
            regularPath: "/99.%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/79.%E3%80%90v1-8-2%E3%80%912023-09-24.html",
            relativePath: "99.更新日志/79.【v1-8-2】2023-09-24.md",
            key: "v-aded8732",
            path: "/changelog/1.8.2/",
            headers: [{
                level: 2,
                title: "支持 Spring Boot 3.X，优化启动速度",
                slug: "支持-spring-boot-3-x-优化启动速度",
                normalizedTitle: "支持 spring boot 3.x，优化启动速度",
                charIndex: 2
            }, {
                level: 3,
                title: "📈 Statistic",
                slug: "📈-statistic",
                normalizedTitle: "📈 statistic",
                charIndex: 32
            }, {
                level: 3,
                title: "⭐ New Features",
                slug: "⭐-new-features",
                normalizedTitle: "⭐ new features",
                charIndex: 111
            }, {
                level: 3,
                title: "🐞 Bug Fixes",
                slug: "🐞-bug-fixes",
                normalizedTitle: "🐞 bug fixes",
                charIndex: 822
            }, {
                level: 3,
                title: "🔨 Dependency Upgrades",
                slug: "🔨-dependency-upgrades",
                normalizedTitle: "🔨 dependency upgrades",
                charIndex: 1143
            }],
            headersStr: "支持 Spring Boot 3.X，优化启动速度 📈 Statistic ⭐ New Features 🐞 Bug Fixes 🔨 Dependency Upgrades",
            content: "# 支持 Spring Boot 3.X，优化启动速度\n\n\n# 📈 Statistic\n\n * 总代码行数：148131\n * 源码代码行数：90985\n * 注释行数：34319\n * 单元测试用例数：940\n\n\n# ⭐ New Features\n\n * 【新增】Spring Boot 3.X + JDK17 的支持，对应 master-boot 分支，由 @xingyu 贡献\n * 【优化】项目的启动速度，MacBook 2018 从 23 秒降低到 14 秒，MacBook 2021 从 15 秒降低到 9 秒，由 @芋道源码 贡献 #08d39d4、#f0f5b52、#808ff6a、#6a371f0、#ebb3a04、#62c4838、#50371b3、#ab800aa\n * 【新增】完善商城分佣功能，由 @疯狂的世界 贡献 #607、#606、#235、#237、#611、#239、#616、#241、#622、#624、#244、#1、#247、#627\n * 【新增】完善商城订单列表、详情，售后列表、详情，由 @puhui999 贡献 #238、#610、#240、#615\n * 【完善】商城的砍价、秒杀活动的逻辑，由 @puhui999 贡献 #623、#625\n * 【新增】Vue3 管理后台：会员详情增加 [经验]、[订单] Tab 选项卡，由 @风狗 贡献 #234\n * 【优化】使用下划线分隔 ErrorCodeConstants 的 ErrorCode，由 @dhb52 贡献 #612\n * 【新增】钱包支付、退款，钱包充值，由 @Jason 贡献\n * 【完善】会员签到，由 @QingX 贡献 #621\n * 【优化】vben 代码生成器的模版，@xingyu 贡献 #618\n * 【新增】BPM 工作流增加驳回操作，由 @Youkehai 贡献 #251、#248、#629\n\n\n# 🐞 Bug Fixes\n\n * 【修复】revision 在 Maven install、deploy 时，不替换为版本号的问题，由 @chaining 贡献 #441\n * 【修复】部门树节点过滤不生效，由 @li_xinbin 贡献 #236\n * 【修复】描述错误, 社交类型的枚举为 SocialTypeEnum 而不是 SysUserSocialTypeEnum，由 @刁航 贡献 #342\n * 【修复】解决启用多租户时，使用 Redis 缓存，设置失效时间不生效的问题，由 @luodz 贡献 #53\n * 【修复】system_users.avatar 字段对于本地存储，长度不足，由 @dhb52 贡献 #614\n\n\n# 🔨 Dependency Upgrades\n\n * 【升级】springdoc from 1.6.15 to 1.7.0\n * 【升级】knife4j from 4.1.0 to 4.3.0\n * 【升级】spring boot from 2.7.14 to 2.7.15",
            normalizedContent: "# 支持 spring boot 3.x，优化启动速度\n\n\n# 📈 statistic\n\n * 总代码行数：148131\n * 源码代码行数：90985\n * 注释行数：34319\n * 单元测试用例数：940\n\n\n# ⭐ new features\n\n * 【新增】spring boot 3.x + jdk17 的支持，对应 master-boot 分支，由 @xingyu 贡献\n * 【优化】项目的启动速度，macbook 2018 从 23 秒降低到 14 秒，macbook 2021 从 15 秒降低到 9 秒，由 @芋道源码 贡献 #08d39d4、#f0f5b52、#808ff6a、#6a371f0、#ebb3a04、#62c4838、#50371b3、#ab800aa\n * 【新增】完善商城分佣功能，由 @疯狂的世界 贡献 #607、#606、#235、#237、#611、#239、#616、#241、#622、#624、#244、#1、#247、#627\n * 【新增】完善商城订单列表、详情，售后列表、详情，由 @puhui999 贡献 #238、#610、#240、#615\n * 【完善】商城的砍价、秒杀活动的逻辑，由 @puhui999 贡献 #623、#625\n * 【新增】vue3 管理后台：会员详情增加 [经验]、[订单] tab 选项卡，由 @风狗 贡献 #234\n * 【优化】使用下划线分隔 errorcodeconstants 的 errorcode，由 @dhb52 贡献 #612\n * 【新增】钱包支付、退款，钱包充值，由 @jason 贡献\n * 【完善】会员签到，由 @qingx 贡献 #621\n * 【优化】vben 代码生成器的模版，@xingyu 贡献 #618\n * 【新增】bpm 工作流增加驳回操作，由 @youkehai 贡献 #251、#248、#629\n\n\n# 🐞 bug fixes\n\n * 【修复】revision 在 maven install、deploy 时，不替换为版本号的问题，由 @chaining 贡献 #441\n * 【修复】部门树节点过滤不生效，由 @li_xinbin 贡献 #236\n * 【修复】描述错误, 社交类型的枚举为 socialtypeenum 而不是 sysusersocialtypeenum，由 @刁航 贡献 #342\n * 【修复】解决启用多租户时，使用 redis 缓存，设置失效时间不生效的问题，由 @luodz 贡献 #53\n * 【修复】system_users.avatar 字段对于本地存储，长度不足，由 @dhb52 贡献 #614\n\n\n# 🔨 dependency upgrades\n\n * 【升级】springdoc from 1.6.15 to 1.7.0\n * 【升级】knife4j from 4.1.0 to 4.3.0\n * 【升级】spring boot from 2.7.14 to 2.7.15",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【v1.7.3】2023-05-29",
            frontmatter: {
                title: "【v1.7.3】2023-05-29",
                date: "2023-04-22T16:21:33.000Z",
                permalink: "/changelog/1.7.3/"
            },
            regularPath: "/99.%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/82.%E3%80%90v1-7-3%E3%80%912023-05-29.html",
            relativePath: "99.更新日志/82.【v1-7-3】2023-05-29.md",
            key: "v-74173047",
            path: "/changelog/1.7.3/",
            headers: [{
                level: 2,
                title: "完善达梦数据库的兼容，新增 Vue3 商品管理",
                slug: "完善达梦数据库的兼容-新增-vue3-商品管理",
                normalizedTitle: "完善达梦数据库的兼容，新增 vue3 商品管理",
                charIndex: 2
            }, {
                level: 3,
                title: "📈 Statistic",
                slug: "📈-statistic",
                normalizedTitle: "📈 statistic",
                charIndex: 30
            }, {
                level: 3,
                title: "⭐ New Features",
                slug: "⭐-new-features",
                normalizedTitle: "⭐ new features",
                charIndex: 109
            }, {
                level: 3,
                title: "🐞 Bug Fixes",
                slug: "🐞-bug-fixes",
                normalizedTitle: "🐞 bug fixes",
                charIndex: 812
            }, {
                level: 3,
                title: "🔨 Dependency Upgrades",
                slug: "🔨-dependency-upgrades",
                normalizedTitle: "🔨 dependency upgrades",
                charIndex: 1865
            }],
            headersStr: "完善达梦数据库的兼容，新增 Vue3 商品管理 📈 Statistic ⭐ New Features 🐞 Bug Fixes 🔨 Dependency Upgrades",
            content: "# 完善达梦数据库的兼容，新增 Vue3 商品管理\n\n\n# 📈 Statistic\n\n * 总代码行数：122183\n * 源码代码行数：74826\n * 注释行数：28647\n * 单元测试用例数：790\n\n\n# ⭐ New Features\n\n * 【新增】达梦数据库的适配，并提供 SQL 文件，由 @changelzj 贡献 #474\n * 【新增】Vue3 管理后台：新增菜单搜索，由 @卡农ding 贡献 #156\n * 【新增】Vue3 管理后台：菜单管理：添加刷新菜单缓存按钮，由 @puhui999 贡献 #134\n * 【新增】Docker compose 的支持，可阅读 Docker-HOWTO.md 文档使用，由 @dhb52 贡献 #468\n * 【新增】Vue3 管理后台：[商品中心 -> 商品管理]，由 @puhui999 贡献\n * 【新增】Vue3 管理后台：[交易中心 -> 物流公司]，由 @Jason 贡献\n * 【新增】Vue3 管理后台：[交易中心 -> 配送模版]，由 @Jason 贡献\n * 【重构】Vue3 管理后台：公众号 MP 模块重构，功能增强，由 @dhb52 贡献 #135、#137\n * 【重构】Vue3 管理后台：[基础管理 -> Redis监控] 使用 EChart 组件实现，由 @Chika 贡献 #148\n * 【优化】Vue3 管理后台：升级 Vite 4.3.1，升级其它依赖，由 @xingyu4j 贡献 #53b6f0b\n * 【优化】_column.vm 中 required = true 提示已过期，改成使用：requiredMode = Schema.RequiredMode.REQUIRED，由 @baayso 贡献 #470\n * 【优化】发送邮件逻辑优化，邮件标题支持模版参数，由 @傲世孤尘 贡献 #485\n\n\n# 🐞 Bug Fixes\n\n * 【修复】代码生成：Vue3 标准模板缺少 baseURL 的格式化，由 @baayso 贡献 #462\n * 【修复】新建商品时商品分类状态判断错误，由 @LiZhongShi 贡献 #459\n * 【修复】缺少 ServletUtils 引用，由 @inypeacock 贡献 #461\n * 【修复】一键改包的”占位“文件影响改包工具运行，由 @anzhen-tech 贡献 #458\n * 【修复】尝试修复项目第一次打包失败报 Failed to execute goal org.apache.maven.plugins:maven-jar-plugin:3.3.0:jar，由 @芋道源码 贡献 #91f63ff\n * 【修复】Vue3 【站内信】测试模板消息发送，接口调用错误问题，由 @ZanGe丶 贡献 #145\n * 【修复】Vue3 表格内容超过表格总宽度后，横向滚动条前端顶不到表格边缘的问题，由 @AhJindeg 贡献 #139\n * 【修复】tika 库解析文件报错的问题，由 @灬霍霍 贡献 #481\n * 【修复】StrUtils.maxLength 会强制给后面加三个点，哪怕长度没有超过，优化长度不超过不加 ...，由 @重楼 贡献 #479\n * 【修复】修复 Vue3 代码生成 api 模版错误，由 @xingyu4j 贡献 #469\n * 【修复】easyexecl 3.3.0 bug 引起导出表格异常（java.lang.NoClassDefFoundError），由 @WalkerLee 贡献 #274\n * 【修复】不同模块错误码区间冲突、部分错误码重复错误，由 @Rundeepin 贡献 #484\n * 【修复】Vue2 管理后台：公众号粉丝同步 api 配置错误，由 @VT1996 贡献 #489\n * 【修复】Spring Cloud：网关 body 数据过大超过默认 256K 时，报错 DataBufferLimitException 异常，由 @杨寒寒 贡献 #34\n * 【修复】邮件日志 sendTime 类型不一致（应该是 LocalDateTime），@芋道源码 贡献 #cc04956\n * 【修复】Vue3 管理后台：公告内容不能为空，@cn3lfs 贡献 #9\n * 【修复】Vue3 管理后台：解决 vue 版本与 pinia 版本兼容问题，@qiuhuanran 贡献 #8\n\n\n# 🔨 Dependency Upgrades\n\n * 【升级】spring-boot from 2.7.10 to 2.7.11\n * 【升级】mapstruct from 1.5.3 to 1.5.5\n * 【升级】hutool from 5.8.15 to 5.8.18\n * 【升级】easyexcel from 3.2.1 to 3.3.1",
            normalizedContent: "# 完善达梦数据库的兼容，新增 vue3 商品管理\n\n\n# 📈 statistic\n\n * 总代码行数：122183\n * 源码代码行数：74826\n * 注释行数：28647\n * 单元测试用例数：790\n\n\n# ⭐ new features\n\n * 【新增】达梦数据库的适配，并提供 sql 文件，由 @changelzj 贡献 #474\n * 【新增】vue3 管理后台：新增菜单搜索，由 @卡农ding 贡献 #156\n * 【新增】vue3 管理后台：菜单管理：添加刷新菜单缓存按钮，由 @puhui999 贡献 #134\n * 【新增】docker compose 的支持，可阅读 docker-howto.md 文档使用，由 @dhb52 贡献 #468\n * 【新增】vue3 管理后台：[商品中心 -> 商品管理]，由 @puhui999 贡献\n * 【新增】vue3 管理后台：[交易中心 -> 物流公司]，由 @jason 贡献\n * 【新增】vue3 管理后台：[交易中心 -> 配送模版]，由 @jason 贡献\n * 【重构】vue3 管理后台：公众号 mp 模块重构，功能增强，由 @dhb52 贡献 #135、#137\n * 【重构】vue3 管理后台：[基础管理 -> redis监控] 使用 echart 组件实现，由 @chika 贡献 #148\n * 【优化】vue3 管理后台：升级 vite 4.3.1，升级其它依赖，由 @xingyu4j 贡献 #53b6f0b\n * 【优化】_column.vm 中 required = true 提示已过期，改成使用：requiredmode = schema.requiredmode.required，由 @baayso 贡献 #470\n * 【优化】发送邮件逻辑优化，邮件标题支持模版参数，由 @傲世孤尘 贡献 #485\n\n\n# 🐞 bug fixes\n\n * 【修复】代码生成：vue3 标准模板缺少 baseurl 的格式化，由 @baayso 贡献 #462\n * 【修复】新建商品时商品分类状态判断错误，由 @lizhongshi 贡献 #459\n * 【修复】缺少 servletutils 引用，由 @inypeacock 贡献 #461\n * 【修复】一键改包的”占位“文件影响改包工具运行，由 @anzhen-tech 贡献 #458\n * 【修复】尝试修复项目第一次打包失败报 failed to execute goal org.apache.maven.plugins:maven-jar-plugin:3.3.0:jar，由 @芋道源码 贡献 #91f63ff\n * 【修复】vue3 【站内信】测试模板消息发送，接口调用错误问题，由 @zange丶 贡献 #145\n * 【修复】vue3 表格内容超过表格总宽度后，横向滚动条前端顶不到表格边缘的问题，由 @ahjindeg 贡献 #139\n * 【修复】tika 库解析文件报错的问题，由 @灬霍霍 贡献 #481\n * 【修复】strutils.maxlength 会强制给后面加三个点，哪怕长度没有超过，优化长度不超过不加 ...，由 @重楼 贡献 #479\n * 【修复】修复 vue3 代码生成 api 模版错误，由 @xingyu4j 贡献 #469\n * 【修复】easyexecl 3.3.0 bug 引起导出表格异常（java.lang.noclassdeffounderror），由 @walkerlee 贡献 #274\n * 【修复】不同模块错误码区间冲突、部分错误码重复错误，由 @rundeepin 贡献 #484\n * 【修复】vue2 管理后台：公众号粉丝同步 api 配置错误，由 @vt1996 贡献 #489\n * 【修复】spring cloud：网关 body 数据过大超过默认 256k 时，报错 databufferlimitexception 异常，由 @杨寒寒 贡献 #34\n * 【修复】邮件日志 sendtime 类型不一致（应该是 localdatetime），@芋道源码 贡献 #cc04956\n * 【修复】vue3 管理后台：公告内容不能为空，@cn3lfs 贡献 #9\n * 【修复】vue3 管理后台：解决 vue 版本与 pinia 版本兼容问题，@qiuhuanran 贡献 #8\n\n\n# 🔨 dependency upgrades\n\n * 【升级】spring-boot from 2.7.10 to 2.7.11\n * 【升级】mapstruct from 1.5.3 to 1.5.5\n * 【升级】hutool from 5.8.15 to 5.8.18\n * 【升级】easyexcel from 3.2.1 to 3.3.1",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【v1.8.1】2023-09-04",
            frontmatter: {
                title: "【v1.8.1】2023-09-04",
                date: "2023-08-01T20:55:33.000Z",
                permalink: "/changelog/1.8.1/"
            },
            regularPath: "/99.%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/80.%E3%80%90v1-8-1%E3%80%912023-09-04.html",
            relativePath: "99.更新日志/80.【v1-8-1】2023-09-04.md",
            key: "v-a77a1c72",
            path: "/changelog/1.8.1/",
            headers: [{
                level: 2,
                title: "新增会员中心、商城系统",
                slug: "新增会员中心、商城系统",
                normalizedTitle: "新增会员中心、商城系统",
                charIndex: 2
            }, {
                level: 3,
                title: "📈 Statistic",
                slug: "📈-statistic",
                normalizedTitle: "📈 statistic",
                charIndex: 18
            }, {
                level: 3,
                title: "⭐ New Features",
                slug: "⭐-new-features",
                normalizedTitle: "⭐ new features",
                charIndex: 97
            }, {
                level: 3,
                title: "🐞 Bug Fixes",
                slug: "🐞-bug-fixes",
                normalizedTitle: "🐞 bug fixes",
                charIndex: 1507
            }, {
                level: 3,
                title: "🔨 Dependency Upgrades",
                slug: "🔨-dependency-upgrades",
                normalizedTitle: "🔨 dependency upgrades",
                charIndex: 2835
            }],
            headersStr: "新增会员中心、商城系统 📈 Statistic ⭐ New Features 🐞 Bug Fixes 🔨 Dependency Upgrades",
            content: "# 新增会员中心、商城系统\n\n\n# 📈 Statistic\n\n * 总代码行数：143844\n * 源码代码行数：88371\n * 注释行数：33292\n * 单元测试用例数：936\n\n\n# ⭐ New Features\n\n * 【新增】vben 版本，升级 ant-design-vue 4.0，由 @xingyu 贡献\n * 【优化】Redis 缓存替代本地缓存，降低学习成本，由 @圆梦巨人 贡献 #548\n * 【新增】yudao-cloud 的 《微服务调试（必读）》 文档，解决本地微服务调试时，会请求打到其他同学的本地服务实例\n * 【优化】yudao-cloud 移除 Dubbo 依赖，由 @芋道源码 贡献 7f7a3c5\n * 【优化】优化 docker-compose 功能，首次运行加载 sql/mysql/ruoyi-vue-pro.sql，由 @dhb52 贡献 #546\n * 【新增】会员标签管理，由 @疯狂的世界 贡献 #576、#207\n * 【新增】会员分组管理，由 @疯狂的世界 贡献 #580\n * 【新增】会员等级管理，由 @疯狂的世界 贡献 #209、#215、#585\n * 【新增】会员签到、积分，由 @QingX 贡献 #171、#178、#204、#575、#506\n * 【新增】订单列表管理重构完善，由 @puhui999 贡献 #210、#581、#600、#229\n * 【修复】mall、bpm 编译错误的问题，由 @wcz 贡献 #547\n * 【新增】会员详情，由 @风狗 贡献 #587、#583、#212、#218、#592、#221、#593、#222\n * 【新增】商品评论的后台新增、回复等功能，由 @疯狂的世界 贡献 #591、#220\n * 【新增】订单的取消操作 API，由 @疯狂的世界 贡献 #601、#603\n * 【新增】优惠劵发放，包括管理员发放、会员领取等，由 @疯狂的世界 贡献 #597、#225、#602、#230、#604、#231\n * 【新增】支付中心：增加模拟支付，方便开发调试，由 @Jason 贡献 #550\n * 【优化】基于 Redis 实现的 pubsub、stream 消息队列，支持开启或关闭。默认为关闭状态，项目启动更快，由 @芋道源码 贡献 68049b8\n * 【优化】Vue3 管理后台：request 支持传递 axios 原生参数，例如说 timeout 超时，由 @SupGiant 贡献 #18\n * 【优化】Vue3 管理后台：使用 unocss 替代 windcss，由 @xingyuv 贡献 #186\n * 【新增】Vue3 管理后台：支付管理 -> 应用信息，由 @dhb52 贡献 #188\n * 【新增】Vue3 管理后台：支付管理 -> 订单管理，由 @dhb52 贡献 #191\n * 【新增】Vue3 管理后台：支付管理 -> 退款管理，由 @dhb52 贡献 #196\n * 【新增】yudao-cloud：增加 docker-compose.yml，由 @jhaol 贡献 #48\n * 【优化】yudao-cloud：统一各模块日志彩色打印，由 @babylazsss 贡献 #47\n * 【优化】Redis Cache，支持 scan 扫描，支持过期单位，由 @wanwan 贡献 #562\n * 【优化】数据权限，使用 Parenthesis 使用 Parenthesis 为原有表达式添加括号，由 @oah1021 贡献 #332\n\n\n# 🐞 Bug Fixes\n\n * 【修复】yudao-cloud 操作日志存在无限递归的问题，由 @芋道源码 贡献 3930fd7\n * 【修复】Vue3 管理后台：分配角色菜单时，调用接口 404 问题，由 @芋道源码 贡献 0139443\n * 【修复】MailAccountService 更新/删除事，缓存未清空，由 @ZJY 贡献 #49\n * 【修复】Vue3 管理后台：登录后，通过登录页面无法再次登录的问题，由 @lehug 贡献 #195\n * 【修复】pgsql 新建租户时，由于 data_scope_dept_ids 为空值，产生的错误导致插入不成功，由 @天天写BUG 贡献 #561\n * 【修复】支付模块微信 App 统一下单时，返回值解析错误，由 @马铃薯头 贡献 #558\n * 【修复】创建菜单 permission 为空时，缓存 KEY 为 空 的 BUG，由 @杜继强 贡献 #557\n * 【修复】表格固定列不设置宽度时，布局错误问题，由 @BladeX 贡献 #556\n * 【修复】修复三方登录报错的问题，由 @xingyu 贡献 #549\n * 【修复】租户套餐修改时，查询角色报错问题，由 @芋道源码 贡献 ee53d2a\n * 【修复】Vue3 管理后台打包报错的问题，由 @爱之小枫 贡献 #200\n * 【修复】Vue3 关你后台的个人中心，修改密码校验失效的问题，由 @baayso 贡献 #201\n * 【修复】在调用 #selectList 的时候，如果 Collection 参数为空会报错 SQL 异常，由 @刁航 贡献 #326\n * 【修复】MapStruct 在 Date 和 LocalDateTime 转换的时区问题，由 @clockdotnet 贡献 #586\n * 【修复】Vue3 管理后台的 Pagination 当全局 size 为 small 的时候，分页组件样式太大的问题；当组件为 small 时，则会显示小的分页组件，由 @AKING 贡献 #216\n * 【修复】Vue3 管理后台的，单独使用 el-dialog 组件时，样式被篡改的问题，由 @AKING 贡献 #213\n * 【修复】兼容 Spring Web 配置上下文根路径的情况，由 @suyh 贡献 #594\n * 【修复】Vue2 管理后台：Crontab 组件 radio 的 label 类型不一致，由 @高小牛 贡献 #599\n * 【修复】微信支付初始化 client 客户端错误，导致发起支付报错，由 @52Lau 贡献 #319\n * 【修复】微信公众号菜单添加跳转小程序失败，由 @Krane 贡献 #335\n * 【修复】如果多个数据权限的规则合并的话，一个规则为 null，则 AndExpression(allExpression, oneExpress) 为空报错，由 @sodkwhy 贡献 #51\n * 【修复】Vue3 管理后台：CRUD Schema 解决了当使用默认的 dict 选项时，form 中事件不能触发的问题，由 @AKING 贡献 #226\n\n\n# 🔨 Dependency Upgrades\n\n * 【升级】spring-boot from 2.7.13 to 2.7.14\n * 【升级】mybatis-plus from 3.5.3.1 to 3.5.3.2",
            normalizedContent: "# 新增会员中心、商城系统\n\n\n# 📈 statistic\n\n * 总代码行数：143844\n * 源码代码行数：88371\n * 注释行数：33292\n * 单元测试用例数：936\n\n\n# ⭐ new features\n\n * 【新增】vben 版本，升级 ant-design-vue 4.0，由 @xingyu 贡献\n * 【优化】redis 缓存替代本地缓存，降低学习成本，由 @圆梦巨人 贡献 #548\n * 【新增】yudao-cloud 的 《微服务调试（必读）》 文档，解决本地微服务调试时，会请求打到其他同学的本地服务实例\n * 【优化】yudao-cloud 移除 dubbo 依赖，由 @芋道源码 贡献 7f7a3c5\n * 【优化】优化 docker-compose 功能，首次运行加载 sql/mysql/ruoyi-vue-pro.sql，由 @dhb52 贡献 #546\n * 【新增】会员标签管理，由 @疯狂的世界 贡献 #576、#207\n * 【新增】会员分组管理，由 @疯狂的世界 贡献 #580\n * 【新增】会员等级管理，由 @疯狂的世界 贡献 #209、#215、#585\n * 【新增】会员签到、积分，由 @qingx 贡献 #171、#178、#204、#575、#506\n * 【新增】订单列表管理重构完善，由 @puhui999 贡献 #210、#581、#600、#229\n * 【修复】mall、bpm 编译错误的问题，由 @wcz 贡献 #547\n * 【新增】会员详情，由 @风狗 贡献 #587、#583、#212、#218、#592、#221、#593、#222\n * 【新增】商品评论的后台新增、回复等功能，由 @疯狂的世界 贡献 #591、#220\n * 【新增】订单的取消操作 api，由 @疯狂的世界 贡献 #601、#603\n * 【新增】优惠劵发放，包括管理员发放、会员领取等，由 @疯狂的世界 贡献 #597、#225、#602、#230、#604、#231\n * 【新增】支付中心：增加模拟支付，方便开发调试，由 @jason 贡献 #550\n * 【优化】基于 redis 实现的 pubsub、stream 消息队列，支持开启或关闭。默认为关闭状态，项目启动更快，由 @芋道源码 贡献 68049b8\n * 【优化】vue3 管理后台：request 支持传递 axios 原生参数，例如说 timeout 超时，由 @supgiant 贡献 #18\n * 【优化】vue3 管理后台：使用 unocss 替代 windcss，由 @xingyuv 贡献 #186\n * 【新增】vue3 管理后台：支付管理 -> 应用信息，由 @dhb52 贡献 #188\n * 【新增】vue3 管理后台：支付管理 -> 订单管理，由 @dhb52 贡献 #191\n * 【新增】vue3 管理后台：支付管理 -> 退款管理，由 @dhb52 贡献 #196\n * 【新增】yudao-cloud：增加 docker-compose.yml，由 @jhaol 贡献 #48\n * 【优化】yudao-cloud：统一各模块日志彩色打印，由 @babylazsss 贡献 #47\n * 【优化】redis cache，支持 scan 扫描，支持过期单位，由 @wanwan 贡献 #562\n * 【优化】数据权限，使用 parenthesis 使用 parenthesis 为原有表达式添加括号，由 @oah1021 贡献 #332\n\n\n# 🐞 bug fixes\n\n * 【修复】yudao-cloud 操作日志存在无限递归的问题，由 @芋道源码 贡献 3930fd7\n * 【修复】vue3 管理后台：分配角色菜单时，调用接口 404 问题，由 @芋道源码 贡献 0139443\n * 【修复】mailaccountservice 更新/删除事，缓存未清空，由 @zjy 贡献 #49\n * 【修复】vue3 管理后台：登录后，通过登录页面无法再次登录的问题，由 @lehug 贡献 #195\n * 【修复】pgsql 新建租户时，由于 data_scope_dept_ids 为空值，产生的错误导致插入不成功，由 @天天写bug 贡献 #561\n * 【修复】支付模块微信 app 统一下单时，返回值解析错误，由 @马铃薯头 贡献 #558\n * 【修复】创建菜单 permission 为空时，缓存 key 为 空 的 bug，由 @杜继强 贡献 #557\n * 【修复】表格固定列不设置宽度时，布局错误问题，由 @bladex 贡献 #556\n * 【修复】修复三方登录报错的问题，由 @xingyu 贡献 #549\n * 【修复】租户套餐修改时，查询角色报错问题，由 @芋道源码 贡献 ee53d2a\n * 【修复】vue3 管理后台打包报错的问题，由 @爱之小枫 贡献 #200\n * 【修复】vue3 关你后台的个人中心，修改密码校验失效的问题，由 @baayso 贡献 #201\n * 【修复】在调用 #selectlist 的时候，如果 collection 参数为空会报错 sql 异常，由 @刁航 贡献 #326\n * 【修复】mapstruct 在 date 和 localdatetime 转换的时区问题，由 @clockdotnet 贡献 #586\n * 【修复】vue3 管理后台的 pagination 当全局 size 为 small 的时候，分页组件样式太大的问题；当组件为 small 时，则会显示小的分页组件，由 @aking 贡献 #216\n * 【修复】vue3 管理后台的，单独使用 el-dialog 组件时，样式被篡改的问题，由 @aking 贡献 #213\n * 【修复】兼容 spring web 配置上下文根路径的情况，由 @suyh 贡献 #594\n * 【修复】vue2 管理后台：crontab 组件 radio 的 label 类型不一致，由 @高小牛 贡献 #599\n * 【修复】微信支付初始化 client 客户端错误，导致发起支付报错，由 @52lau 贡献 #319\n * 【修复】微信公众号菜单添加跳转小程序失败，由 @krane 贡献 #335\n * 【修复】如果多个数据权限的规则合并的话，一个规则为 null，则 andexpression(allexpression, oneexpress) 为空报错，由 @sodkwhy 贡献 #51\n * 【修复】vue3 管理后台：crud schema 解决了当使用默认的 dict 选项时，form 中事件不能触发的问题，由 @aking 贡献 #226\n\n\n# 🔨 dependency upgrades\n\n * 【升级】spring-boot from 2.7.13 to 2.7.14\n * 【升级】mybatis-plus from 3.5.3.1 to 3.5.3.2",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【v1.7.1】2023-03-05",
            frontmatter: {
                title: "【v1.7.1】2023-03-05",
                date: "2023-01-30 08:00",
                permalink: "/changelog/1.7.1/"
            },
            regularPath: "/99.%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/84.%E3%80%90v1-7-1%E3%80%912023-03-05.html",
            relativePath: "99.更新日志/84.【v1-7-1】2023-03-05.md",
            key: "v-4994ee47",
            path: "/changelog/1.7.1/",
            headers: [{
                level: 2,
                title: "新增 Vue3 管理后台支持工作流、大屏设计器，升级 OpenAPI 3.0 接口文档",
                slug: "新增-vue3-管理后台支持工作流、大屏设计器-升级-openapi-3-0-接口文档",
                normalizedTitle: "新增 vue3 管理后台支持工作流、大屏设计器，升级 openapi 3.0 接口文档",
                charIndex: 2
            }, {
                level: 3,
                title: "📈 Statistic",
                slug: "📈-statistic",
                normalizedTitle: "📈 statistic",
                charIndex: 50
            }, {
                level: 3,
                title: "⭐ New Features",
                slug: "⭐-new-features",
                normalizedTitle: "⭐ new features",
                charIndex: 129
            }, {
                level: 3,
                title: "🐞 Bug Fixes",
                slug: "🐞-bug-fixes",
                normalizedTitle: "🐞 bug fixes",
                charIndex: 889
            }, {
                level: 3,
                title: "🔨 Dependency Upgrades",
                slug: "🔨-dependency-upgrades",
                normalizedTitle: "🔨 dependency upgrades",
                charIndex: 2092
            }],
            headersStr: "新增 Vue3 管理后台支持工作流、大屏设计器，升级 OpenAPI 3.0 接口文档 📈 Statistic ⭐ New Features 🐞 Bug Fixes 🔨 Dependency Upgrades",
            content: "# 新增 Vue3 管理后台支持工作流、大屏设计器，升级 OpenAPI 3.0 接口文档\n\n\n# 📈 Statistic\n\n * 总代码行数：126673\n * 源码代码行数：78532\n * 注释行数：28594\n * 单元测试用例数：782\n\n\n# ⭐ New Features\n\n * 【重构】Vue3 管理后台调整到 GitHub、Gitee 地址，逐步分离前端和后端仓库，保证 Git commit 日志的整洁！\n * 【新增】Vue3 工作流的，由 @周建、@xingyu4j 贡献 #397、#401、#407、#6、#7、#12、#14\n * 【新增】基于 Go-View 共建大屏设计器，支持 Vue2 和 Vue3 管理后台，由 @芋道源码 贡献 #403\n * 【新增】支付收银台，接入支付宝的 PC、Wap、二维码、条码、App 等支付方式，由 @芋道源码 贡献 #403\n * 【新增】接口文档使用 OpenAPI 3.0 实现，@xingyu4j 贡献 #380\n * 【优化】菜单新增 alwaysShow 总是展示、componentName 组件名，由 @芋道源码 贡献 #408\n * 【优化】system 模块的 Service 逻辑单元测试，单测数量 423，方法行覆盖率 95%，行覆盖率 93%，由 @芋道源码 贡献 #392\n * 【优化】infra 模块的 Service 逻辑单元测试，单测数量 81，方法行覆盖率 63%，行覆盖率 47%，由 @芋道源码 贡献 #393\n * 【优化】清理单元测试多余的 SQL 脚本，由 @niu_dehua 贡献 #345\n * 【优化】《后端手册 —— 快速启动》文档，由 @芋道源码 贡献\n * 【优化】解决 Vue2 管理后台，只有一个菜单时，不展父菜单/目录的情况，由 @zhang.xionghui 贡献 #394\n * 【优化】缓存部门的变量命名，由 @重楼 贡献 #421\n * 【新增】《萌新必读 —— 快速启动（我是前端）》 文档，适合前端同学启动前端项目\n\n\n# 🐞 Bug Fixes\n\n * 【修复】Vue3 管理后台的tagViews 左右两侧按钮不能垂直居中的问题，由 @AKING 贡献 #406\n * 【修复】项目启动，链接数据查询时控制台报错 SQLNonTransientConnectionException 异常，由 @zhang 贡献 #406\n * 【修复】Redis Pub/Sub 广播消费的容器，默认未启动的问题，由 @筱龙缘 贡献 #415\n * 【修复】MySQL 连接为 Asia/Shanghai 本地时区，由 @小桂子 贡献 #409 #410\n * 【修复】代码生成器的同步报错问题，由 @Rex 贡献 #413\n * 【修复】登录选择钉钉等第三方弹窗后，点击取消弹窗后恢复登录按钮 loading 状态，由 @thisliuyang 贡献 #217\n * 【修复】去掉 Swagger 自动配置类中的冗余配置，由 @zhangxingjia 贡献 #424\n * 【修复】用户详情不显示所属部门部门，由 @babylazsss 贡献 #424\n * 【修复】GitHub Action 自动 build 前端报错的问题，由 @六楼的雨 贡献 #424\n * 【修复】Vue3 管理后台：新增”字典类型“的时候，字典类型的必填校验不通过，由 @六楼的雨 贡献 #1\n * 【修复】Vue3 管理后台：字典点击表格红色报错修改；keepalive 缓存 toCamelCase 设置中去掉 ‘-’，保留驼峰命名；新增 Search 组件新增插槽传递；topActionSlots: false 报错修改；tagsView.ts 删除页面缓存优化；，由 @毕梅 贡献 #2\n * 【修复】Vue3 管理后台：部分逻辑的规范代码(eslint)，由 @孔思宇 贡献 #4\n * 【修复】Vue3 管理后台：build script 增加内存配置(解决 nodejs 默认配置内存溢出)，由 @孔思宇 贡献 #5\n * 【修复】Vue3 管理后台：分配角色的权限 el-tree 组件 setCheckedKeys 设置一旦选中父级子级也被选中，由 @当时明月在 贡献 #8\n * 【修复】Vue3 管理后台：XTable 中主题颜色不跟随项目主体一起切换，由 @毕梅 贡献 #12\n * 【修复】Vue3 管理后台：角色提交问题修改；XTable var 修改，由 @毕梅 贡献 #16\n * 【修复】Vue3 管理后台：Vite 由于 optimize.ts 缺少部门文件，导致二次 reload 的问题，由 @毕梅 贡献 #19\n * 【修复】Vue3 管理后台：系统管理中 id 显示序号bug，由 @周建 贡献 #18\n * 【修复】Vue3 管理后台：字典标签渲染问题不正确，由 @puhui999 贡献 #15\n\n\n# 🔨 Dependency Upgrades\n\n * 【升级】spring-boot from 2.7.7 to 2.7.8\n * 【升级】easy-excel from 3.1.5 to 3.2.0\n * 【升级】captcha-plus from 1.0.1 to 1.0.2\n * 【升级】jedis-mock from 1.0.5 to 1.0.6",
            normalizedContent: "# 新增 vue3 管理后台支持工作流、大屏设计器，升级 openapi 3.0 接口文档\n\n\n# 📈 statistic\n\n * 总代码行数：126673\n * 源码代码行数：78532\n * 注释行数：28594\n * 单元测试用例数：782\n\n\n# ⭐ new features\n\n * 【重构】vue3 管理后台调整到 github、gitee 地址，逐步分离前端和后端仓库，保证 git commit 日志的整洁！\n * 【新增】vue3 工作流的，由 @周建、@xingyu4j 贡献 #397、#401、#407、#6、#7、#12、#14\n * 【新增】基于 go-view 共建大屏设计器，支持 vue2 和 vue3 管理后台，由 @芋道源码 贡献 #403\n * 【新增】支付收银台，接入支付宝的 pc、wap、二维码、条码、app 等支付方式，由 @芋道源码 贡献 #403\n * 【新增】接口文档使用 openapi 3.0 实现，@xingyu4j 贡献 #380\n * 【优化】菜单新增 alwaysshow 总是展示、componentname 组件名，由 @芋道源码 贡献 #408\n * 【优化】system 模块的 service 逻辑单元测试，单测数量 423，方法行覆盖率 95%，行覆盖率 93%，由 @芋道源码 贡献 #392\n * 【优化】infra 模块的 service 逻辑单元测试，单测数量 81，方法行覆盖率 63%，行覆盖率 47%，由 @芋道源码 贡献 #393\n * 【优化】清理单元测试多余的 sql 脚本，由 @niu_dehua 贡献 #345\n * 【优化】《后端手册 —— 快速启动》文档，由 @芋道源码 贡献\n * 【优化】解决 vue2 管理后台，只有一个菜单时，不展父菜单/目录的情况，由 @zhang.xionghui 贡献 #394\n * 【优化】缓存部门的变量命名，由 @重楼 贡献 #421\n * 【新增】《萌新必读 —— 快速启动（我是前端）》 文档，适合前端同学启动前端项目\n\n\n# 🐞 bug fixes\n\n * 【修复】vue3 管理后台的tagviews 左右两侧按钮不能垂直居中的问题，由 @aking 贡献 #406\n * 【修复】项目启动，链接数据查询时控制台报错 sqlnontransientconnectionexception 异常，由 @zhang 贡献 #406\n * 【修复】redis pub/sub 广播消费的容器，默认未启动的问题，由 @筱龙缘 贡献 #415\n * 【修复】mysql 连接为 asia/shanghai 本地时区，由 @小桂子 贡献 #409 #410\n * 【修复】代码生成器的同步报错问题，由 @rex 贡献 #413\n * 【修复】登录选择钉钉等第三方弹窗后，点击取消弹窗后恢复登录按钮 loading 状态，由 @thisliuyang 贡献 #217\n * 【修复】去掉 swagger 自动配置类中的冗余配置，由 @zhangxingjia 贡献 #424\n * 【修复】用户详情不显示所属部门部门，由 @babylazsss 贡献 #424\n * 【修复】github action 自动 build 前端报错的问题，由 @六楼的雨 贡献 #424\n * 【修复】vue3 管理后台：新增”字典类型“的时候，字典类型的必填校验不通过，由 @六楼的雨 贡献 #1\n * 【修复】vue3 管理后台：字典点击表格红色报错修改；keepalive 缓存 tocamelcase 设置中去掉 ‘-’，保留驼峰命名；新增 search 组件新增插槽传递；topactionslots: false 报错修改；tagsview.ts 删除页面缓存优化；，由 @毕梅 贡献 #2\n * 【修复】vue3 管理后台：部分逻辑的规范代码(eslint)，由 @孔思宇 贡献 #4\n * 【修复】vue3 管理后台：build script 增加内存配置(解决 nodejs 默认配置内存溢出)，由 @孔思宇 贡献 #5\n * 【修复】vue3 管理后台：分配角色的权限 el-tree 组件 setcheckedkeys 设置一旦选中父级子级也被选中，由 @当时明月在 贡献 #8\n * 【修复】vue3 管理后台：xtable 中主题颜色不跟随项目主体一起切换，由 @毕梅 贡献 #12\n * 【修复】vue3 管理后台：角色提交问题修改；xtable var 修改，由 @毕梅 贡献 #16\n * 【修复】vue3 管理后台：vite 由于 optimize.ts 缺少部门文件，导致二次 reload 的问题，由 @毕梅 贡献 #19\n * 【修复】vue3 管理后台：系统管理中 id 显示序号bug，由 @周建 贡献 #18\n * 【修复】vue3 管理后台：字典标签渲染问题不正确，由 @puhui999 贡献 #15\n\n\n# 🔨 dependency upgrades\n\n * 【升级】spring-boot from 2.7.7 to 2.7.8\n * 【升级】easy-excel from 3.1.5 to 3.2.0\n * 【升级】captcha-plus from 1.0.1 to 1.0.2\n * 【升级】jedis-mock from 1.0.5 to 1.0.6",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【v1.8.0】2023-07-27",
            frontmatter: {
                title: "【v1.8.0】2023-07-27",
                date: "2023-06-03T20:55:33.000Z",
                permalink: "/changelog/1.8.0/"
            },
            regularPath: "/99.%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/81.%E3%80%90v1-8-0%E3%80%912023-07-27.html",
            relativePath: "99.更新日志/81.【v1-8-0】2023-07-27.md",
            key: "v-41bc0e67",
            path: "/changelog/1.8.0/",
            headers: [{
                level: 2,
                title: "重构支付中心，提供支付接入实战",
                slug: "重构支付中心-提供支付接入实战",
                normalizedTitle: "重构支付中心，提供支付接入实战",
                charIndex: 2
            }, {
                level: 3,
                title: "📈 Statistic",
                slug: "📈-statistic",
                normalizedTitle: "📈 statistic",
                charIndex: 22
            }, {
                level: 3,
                title: "⭐ New Features",
                slug: "⭐-new-features",
                normalizedTitle: "⭐ new features",
                charIndex: 101
            }, {
                level: 3,
                title: "🐞 Bug Fixes",
                slug: "🐞-bug-fixes",
                normalizedTitle: "🐞 bug fixes",
                charIndex: 729
            }, {
                level: 3,
                title: "🔨 Dependency Upgrades",
                slug: "🔨-dependency-upgrades",
                normalizedTitle: "🔨 dependency upgrades",
                charIndex: 2374
            }],
            headersStr: "重构支付中心，提供支付接入实战 📈 Statistic ⭐ New Features 🐞 Bug Fixes 🔨 Dependency Upgrades",
            content: "# 重构支付中心，提供支付接入实战\n\n\n# 📈 Statistic\n\n * 总代码行数：139152\n * 源码代码行数：85791\n * 注释行数：31891\n * 单元测试用例数：899\n\n\n# ⭐ New Features\n\n * 【优化】使用 docker compose -T 来执行数据导入，由 @dhb52 贡献 #508\n * 【重构】支付 PayClient 实现，优化对支付、退款异常的处理，由 @芋道源码 贡献\n * 【优化】支付与退款的表结构、回调支持幂等处理，由 @芋道源码 贡献\n * 【新增】PayOrderSyncJob 实现渠道支付结果的轮询，解决支付回调延迟的小概率延迟问题，由 @芋道源码 贡献\n * 【新增】PayRefundSyncJob 实现渠道退款结果的轮询，解决支付回调延迟的小概率延迟问题，由 @芋道源码 贡献\n * 【新增】微信公众号、小程序、扫码、条码支付与退款的接入，由 @芋道源码 贡献\n * 【新增】商城 uniapp 商品列表、详情的实现，支持拼团、秒杀、团购商品，由 @芋道源码 贡献\n * 【优化】商城订单的价格计算实现，基于责任链模式，支持配送、会员折扣、限时折扣、满减送、优惠劵等的多重计算，由 @芋道源码、@Jason 贡献\n * 【新增】Vue3 管理后台：[营销中心 -> 秒杀时段]、[营销中心 -> 秒杀活动]，由 @puhui999 贡献\n * 【新增】商城的售后日志，基于 AOP 实现，由 @陈賝 贡献\n * 【优化】完善商品评论的实现，由 @puhui999 贡献\n * 【优化】适配 postgres 数据库 sql 脚本，由 @御码滴汉子 贡献 #408\n\n\n# 🐞 Bug Fixes\n\n * 【修复】RedisPendingMessageResendJob 任务可能会导致消息重复的问题，由 @天气真好 贡献 #408\n * 【修复】Vue2 管理后台：富文本编辑器自动聚焦问题，由 @hellozbk 贡献 #492\n * 【修复】Vben 管理后台：代码生成器对 RadioButtonGroup 组件的支持，由 @xingyu 贡献 #513\n * 【修复】公众号标签修改提示报错，由 @再难也要坚持 贡献 #512\n * 【修复】Spring Boot 3.X 兼容性问题：启动 Mp 模块报错问题，由 @飞奔中 贡献 #507\n * 【修复】使用 PG 数据库时,站内信表、菜单权限表字段类型不一致问题，由 @呵呵大 贡献 #505\n * 【修复】PG 数据库部分字典数据缺失，由 @Zhang Yi 贡献 #292\n * 【修复】pg 数据库的脚本错误，由 @御码滴汉子 贡献 #497\n * 【修复】Set access token expire time to 0 报错问题，和邮件发送用户编号为空问题，由 @clockdotnet 贡献 #498\n * 【修复】Vue2 管理后台：生产环境打包压缩等配置未生效问题，由 @GuYu 贡献 #502\n * 【修复】Vue3 管理后台：短信渠道提交失败，由 @圆梦巨人 贡献 #166\n * 【修复】Vue3 管理后台：授权类型选项 bug，由 @wangzhaoqiang 贡献 #167\n * 【修复】Vue3 管理后台：修复 refreshToken 过期时间不正确，由 @呵呵大 贡献 #170\n * 【修复】Cloud 生成的时间类型为 Date 而不是 LocalDateTime 的错误问题，由 @jiaohongtao 贡献 #38\n * 【修复】Vue3 管理后台：useTable 在分页返回 total 为 0 时的 bug，由 @nullcache 贡献 #10\n * 【修复】Vue3 管理后台：BPMN 处理 window.bpmnInstances 有时候为 undefined 问题，由 @OlyLis 贡献 #155\n * 【修复】Vben 管理后台的代码生成模版，增加 resetSchema 调用，由 @xingyu 贡献 #540\n * 【修复】API 记录日志耗时单位修改为毫秒的问题，由 @kinlon92 贡献 #541\n * 【修复】Vue2 管理后台：VideoUpload 修改后再新增时的表单，无法清除还原到未选择视频文件状态的问题，由 @hellozbk 贡献 #536\n * 【修复】Vue3 管理后台的代码生成，Editor 属性修正为 v-model，由 @adely 贡献 #533\n * 【修复】application-local 配置文件，master 数据库 pg 连接串的数据库名由 slave 引用改为 master，由 @御码滴汉子 贡献 #525\n * 【修复】Cloud ErrorCodeApi 接收 LocalDateTime 参数不正确的问题，由 @我很幸福 贡献 #40\n * 【修复】Spring Cloud Bus RocketMQ 无法广播消费的问题，由 @Fanjc 贡献 #43\n * 【修复】去除 sql 中多余的在 jimu_report_data_source 表中设置 tenant_id 字段，由 @QSSSYH 贡献 #44\n * 【修复】yudao-ui-admin 前端 Cron 表达式-周选择第 4 项，# 号两边的值颠倒了，由 @Peter Nuding 贡献 #252\n * 【修复】Vue3 管理后台：定时任务，删除功能报错，由 @死歌 贡献 #180\n * 【修复】Vue3 管理后台：手机登录后，跳转不正确的问题，由 @water 贡献 #182\n\n\n# 🔨 Dependency Upgrades\n\n * 【升级】spring-boot from 2.7.11 to 2.7.13\n * 【升级】captcha-plus from 1.0.3 to 1.0.5\n * 【升级】druid from 1.2.16 to 1.2.18\n * 【升级】lombok from 1.18.26 to 1.18.28\n * 【升级】hutool from 5.8.18 to 5.8.20\n * 【升级】easyexcel from 3.3.1 to 3.3.2\n * 【升级】guava from 32.0.0-jre to 32.0.1-jre\n * 【升级】minio from 8.5.2 to 8.5.4\n * 【升级】jimureport from 1.5.6 to 1.5.8\n * 【升级】wx-java-mp from 4.3.0 to 4.5.0\n * 【升级】wx-java-pay from 4.3.0 to 4.5.0",
            normalizedContent: "# 重构支付中心，提供支付接入实战\n\n\n# 📈 statistic\n\n * 总代码行数：139152\n * 源码代码行数：85791\n * 注释行数：31891\n * 单元测试用例数：899\n\n\n# ⭐ new features\n\n * 【优化】使用 docker compose -t 来执行数据导入，由 @dhb52 贡献 #508\n * 【重构】支付 payclient 实现，优化对支付、退款异常的处理，由 @芋道源码 贡献\n * 【优化】支付与退款的表结构、回调支持幂等处理，由 @芋道源码 贡献\n * 【新增】payordersyncjob 实现渠道支付结果的轮询，解决支付回调延迟的小概率延迟问题，由 @芋道源码 贡献\n * 【新增】payrefundsyncjob 实现渠道退款结果的轮询，解决支付回调延迟的小概率延迟问题，由 @芋道源码 贡献\n * 【新增】微信公众号、小程序、扫码、条码支付与退款的接入，由 @芋道源码 贡献\n * 【新增】商城 uniapp 商品列表、详情的实现，支持拼团、秒杀、团购商品，由 @芋道源码 贡献\n * 【优化】商城订单的价格计算实现，基于责任链模式，支持配送、会员折扣、限时折扣、满减送、优惠劵等的多重计算，由 @芋道源码、@jason 贡献\n * 【新增】vue3 管理后台：[营销中心 -> 秒杀时段]、[营销中心 -> 秒杀活动]，由 @puhui999 贡献\n * 【新增】商城的售后日志，基于 aop 实现，由 @陈賝 贡献\n * 【优化】完善商品评论的实现，由 @puhui999 贡献\n * 【优化】适配 postgres 数据库 sql 脚本，由 @御码滴汉子 贡献 #408\n\n\n# 🐞 bug fixes\n\n * 【修复】redispendingmessageresendjob 任务可能会导致消息重复的问题，由 @天气真好 贡献 #408\n * 【修复】vue2 管理后台：富文本编辑器自动聚焦问题，由 @hellozbk 贡献 #492\n * 【修复】vben 管理后台：代码生成器对 radiobuttongroup 组件的支持，由 @xingyu 贡献 #513\n * 【修复】公众号标签修改提示报错，由 @再难也要坚持 贡献 #512\n * 【修复】spring boot 3.x 兼容性问题：启动 mp 模块报错问题，由 @飞奔中 贡献 #507\n * 【修复】使用 pg 数据库时,站内信表、菜单权限表字段类型不一致问题，由 @呵呵大 贡献 #505\n * 【修复】pg 数据库部分字典数据缺失，由 @zhang yi 贡献 #292\n * 【修复】pg 数据库的脚本错误，由 @御码滴汉子 贡献 #497\n * 【修复】set access token expire time to 0 报错问题，和邮件发送用户编号为空问题，由 @clockdotnet 贡献 #498\n * 【修复】vue2 管理后台：生产环境打包压缩等配置未生效问题，由 @guyu 贡献 #502\n * 【修复】vue3 管理后台：短信渠道提交失败，由 @圆梦巨人 贡献 #166\n * 【修复】vue3 管理后台：授权类型选项 bug，由 @wangzhaoqiang 贡献 #167\n * 【修复】vue3 管理后台：修复 refreshtoken 过期时间不正确，由 @呵呵大 贡献 #170\n * 【修复】cloud 生成的时间类型为 date 而不是 localdatetime 的错误问题，由 @jiaohongtao 贡献 #38\n * 【修复】vue3 管理后台：usetable 在分页返回 total 为 0 时的 bug，由 @nullcache 贡献 #10\n * 【修复】vue3 管理后台：bpmn 处理 window.bpmninstances 有时候为 undefined 问题，由 @olylis 贡献 #155\n * 【修复】vben 管理后台的代码生成模版，增加 resetschema 调用，由 @xingyu 贡献 #540\n * 【修复】api 记录日志耗时单位修改为毫秒的问题，由 @kinlon92 贡献 #541\n * 【修复】vue2 管理后台：videoupload 修改后再新增时的表单，无法清除还原到未选择视频文件状态的问题，由 @hellozbk 贡献 #536\n * 【修复】vue3 管理后台的代码生成，editor 属性修正为 v-model，由 @adely 贡献 #533\n * 【修复】application-local 配置文件，master 数据库 pg 连接串的数据库名由 slave 引用改为 master，由 @御码滴汉子 贡献 #525\n * 【修复】cloud errorcodeapi 接收 localdatetime 参数不正确的问题，由 @我很幸福 贡献 #40\n * 【修复】spring cloud bus rocketmq 无法广播消费的问题，由 @fanjc 贡献 #43\n * 【修复】去除 sql 中多余的在 jimu_report_data_source 表中设置 tenant_id 字段，由 @qsssyh 贡献 #44\n * 【修复】yudao-ui-admin 前端 cron 表达式-周选择第 4 项，# 号两边的值颠倒了，由 @peter nuding 贡献 #252\n * 【修复】vue3 管理后台：定时任务，删除功能报错，由 @死歌 贡献 #180\n * 【修复】vue3 管理后台：手机登录后，跳转不正确的问题，由 @water 贡献 #182\n\n\n# 🔨 dependency upgrades\n\n * 【升级】spring-boot from 2.7.11 to 2.7.13\n * 【升级】captcha-plus from 1.0.3 to 1.0.5\n * 【升级】druid from 1.2.16 to 1.2.18\n * 【升级】lombok from 1.18.26 to 1.18.28\n * 【升级】hutool from 5.8.18 to 5.8.20\n * 【升级】easyexcel from 3.3.1 to 3.3.2\n * 【升级】guava from 32.0.0-jre to 32.0.1-jre\n * 【升级】minio from 8.5.2 to 8.5.4\n * 【升级】jimureport from 1.5.6 to 1.5.8\n * 【升级】wx-java-mp from 4.3.0 to 4.5.0\n * 【升级】wx-java-pay from 4.3.0 to 4.5.0",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【v1.7.0】2023-01-30",
            frontmatter: {
                title: "【v1.7.0】2023-01-30",
                date: "2023-01-07 08:00",
                permalink: "/changelog/1.7.0/"
            },
            regularPath: "/99.%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/85.%E3%80%90v1-7-0%E3%80%912023-01-30.html",
            relativePath: "99.更新日志/85.【v1-7-0】2023-01-30.md",
            key: "v-171fe3f2",
            path: "/changelog/1.7.0/",
            headers: [{
                level: 2,
                title: "增加微信公众号的接入、邮箱、站内信、数据脱敏",
                slug: "增加微信公众号的接入、邮箱、站内信、数据脱敏",
                normalizedTitle: "增加微信公众号的接入、邮箱、站内信、数据脱敏",
                charIndex: 2
            }, {
                level: 3,
                title: "📈 Statistic",
                slug: "📈-statistic",
                normalizedTitle: "📈 statistic",
                charIndex: 29
            }, {
                level: 3,
                title: "⭐ New Features",
                slug: "⭐-new-features",
                normalizedTitle: "⭐ new features",
                charIndex: 108
            }, {
                level: 3,
                title: "🐞 Bug Fixes",
                slug: "🐞-bug-fixes",
                normalizedTitle: "🐞 bug fixes",
                charIndex: 860
            }, {
                level: 3,
                title: "🔨 Dependency Upgrades",
                slug: "🔨-dependency-upgrades",
                normalizedTitle: "🔨 dependency upgrades",
                charIndex: 1532
            }],
            headersStr: "增加微信公众号的接入、邮箱、站内信、数据脱敏 📈 Statistic ⭐ New Features 🐞 Bug Fixes 🔨 Dependency Upgrades",
            content: "# 增加微信公众号的接入、邮箱、站内信、数据脱敏\n\n\n# 📈 Statistic\n\n * 总代码行数：119925\n * 源码代码行数：73678\n * 注释行数：27769\n * 单元测试用例数：674\n\n\n# ⭐ New Features\n\n * 【新增】微信公众号功能，包括账号管理、数据统计、粉丝管理、消息管理、自动回复、标签管理、菜单管理、素材管理、图文草稿箱、图文发表记录，由 @芋道源码 贡献 #382\n * 【新增】RESTful API 返回数据时，支持数据脱敏，由 @与或非 贡献 #372\n * 【新增】邮箱功能：邮箱账号、邮件模版、邮件发送记录，由 @芋道源码 贡献 #385\n * 【新增】站内信功能：站内信模版、站内信消息，由 @圆梦巨人、@xrcoder 贡献 #385\n * 【新增】Vue3 管理后台新增 WebSocket 连接测试，由 @xingyu4j 贡献 #379\n * 【新增】配置 yaml 文件中自定义属性的提示，由 @与或非 贡献 #373\n * 【优化】重构 Vue3 管理后台的路由代码生成逻辑，优化性能，由 @xingyu4j 贡献 #375\n * 【优化】Vue3 管理后台的第一次进入加载速度，由 @xingyu4j 贡献 #381\n * 【新增】Vue3 管理后台基于 unplugin-auto-import 实现自动导入，由 @xingyu4j 贡献 #376\n * 【优化】重构滑块验证码 captcha 的实现，由 @xingyu4j 贡献 #374 #376\n * 【优化】简化本地缓存的实现，优化 《后端手册 —— 本地缓存》 文档，由 @芋道源码 贡献 #382\n * 【优化】代码生成列表的加载速度，由 @与或非 贡献 #378\n * 【新增】《后端手册 —— 验证码》 文档，由 @芋道源码 贡献\n * 【新增】《后端手册 —— 数据脱敏》 文档，由 @芋道源码 贡献\n * 【新增】《公众号手册》 文档，由 @芋道源码 贡献\n\n\n# 🐞 Bug Fixes\n\n * 【修复】积木报表：部分请求会报错：JmReportTokenServices 实现类 getUsername 方法返回值不允许为空，由 @与或非 贡献 #358\n * 【修复】积木报表：分享报错，由 @与或非 贡献 #357\n * 【修复】积木报表：API数据集解析时，提示数据为空，报表字段明细会被清空，由 @与或非 贡献 #359\n * 【修复】yudao-ui-appi 的 refreshToken is not a function 问题修复，由 @chaining 贡献 #356\n * 【修复】Vue2 管理后台 Redis 监控 echarts 图表不显示，由 @zy_2021 贡献 #354\n * 【修复】MyBatis Plus 升级导致 generatorTest 用例找不到对象爆红，由 @miozus 贡献 #365\n * 【修复】代码生成器读取不到 dataType 属性，导致无法正确生成代码，由 @与或非 贡献 #370\n * 【修复】Xss 启用后，编辑器上传图片错误，由 @与或非 贡献 #361 #383\n * 【修复】管理后台 uniapp 的令牌过期时，无法刷新令牌的 bug，由 @chaining 贡献 #360\n * 【修复】获取菜单返回了不可修改集合，导致无法排序的报错，由 @ambi 贡献 #371\n * 【修复】Vue2 管理后台的 tags 页签超过屏幕后，无法滚动导致无法选择后面的页签，由 @zhang.xionghui 贡献 #366\n\n\n# 🔨 Dependency Upgrades\n\n * 【升级】mybatis-plus from 3.5.3 to 3.5.3.1\n * 【升级】spring-security from 3.7.5 to 3.7.6\n * 【升级】spring-boot-admin from 2.7.9 to 2.7.10\n * 【升级】minio from 8.4.6 to 8.5.1\n * 【升级】knife4j from 3.0.3 to 4.0.0\n * 【升级】vxe-table from 4.3.7 to 4.3.9",
            normalizedContent: "# 增加微信公众号的接入、邮箱、站内信、数据脱敏\n\n\n# 📈 statistic\n\n * 总代码行数：119925\n * 源码代码行数：73678\n * 注释行数：27769\n * 单元测试用例数：674\n\n\n# ⭐ new features\n\n * 【新增】微信公众号功能，包括账号管理、数据统计、粉丝管理、消息管理、自动回复、标签管理、菜单管理、素材管理、图文草稿箱、图文发表记录，由 @芋道源码 贡献 #382\n * 【新增】restful api 返回数据时，支持数据脱敏，由 @与或非 贡献 #372\n * 【新增】邮箱功能：邮箱账号、邮件模版、邮件发送记录，由 @芋道源码 贡献 #385\n * 【新增】站内信功能：站内信模版、站内信消息，由 @圆梦巨人、@xrcoder 贡献 #385\n * 【新增】vue3 管理后台新增 websocket 连接测试，由 @xingyu4j 贡献 #379\n * 【新增】配置 yaml 文件中自定义属性的提示，由 @与或非 贡献 #373\n * 【优化】重构 vue3 管理后台的路由代码生成逻辑，优化性能，由 @xingyu4j 贡献 #375\n * 【优化】vue3 管理后台的第一次进入加载速度，由 @xingyu4j 贡献 #381\n * 【新增】vue3 管理后台基于 unplugin-auto-import 实现自动导入，由 @xingyu4j 贡献 #376\n * 【优化】重构滑块验证码 captcha 的实现，由 @xingyu4j 贡献 #374 #376\n * 【优化】简化本地缓存的实现，优化 《后端手册 —— 本地缓存》 文档，由 @芋道源码 贡献 #382\n * 【优化】代码生成列表的加载速度，由 @与或非 贡献 #378\n * 【新增】《后端手册 —— 验证码》 文档，由 @芋道源码 贡献\n * 【新增】《后端手册 —— 数据脱敏》 文档，由 @芋道源码 贡献\n * 【新增】《公众号手册》 文档，由 @芋道源码 贡献\n\n\n# 🐞 bug fixes\n\n * 【修复】积木报表：部分请求会报错：jmreporttokenservices 实现类 getusername 方法返回值不允许为空，由 @与或非 贡献 #358\n * 【修复】积木报表：分享报错，由 @与或非 贡献 #357\n * 【修复】积木报表：api数据集解析时，提示数据为空，报表字段明细会被清空，由 @与或非 贡献 #359\n * 【修复】yudao-ui-appi 的 refreshtoken is not a function 问题修复，由 @chaining 贡献 #356\n * 【修复】vue2 管理后台 redis 监控 echarts 图表不显示，由 @zy_2021 贡献 #354\n * 【修复】mybatis plus 升级导致 generatortest 用例找不到对象爆红，由 @miozus 贡献 #365\n * 【修复】代码生成器读取不到 datatype 属性，导致无法正确生成代码，由 @与或非 贡献 #370\n * 【修复】xss 启用后，编辑器上传图片错误，由 @与或非 贡献 #361 #383\n * 【修复】管理后台 uniapp 的令牌过期时，无法刷新令牌的 bug，由 @chaining 贡献 #360\n * 【修复】获取菜单返回了不可修改集合，导致无法排序的报错，由 @ambi 贡献 #371\n * 【修复】vue2 管理后台的 tags 页签超过屏幕后，无法滚动导致无法选择后面的页签，由 @zhang.xionghui 贡献 #366\n\n\n# 🔨 dependency upgrades\n\n * 【升级】mybatis-plus from 3.5.3 to 3.5.3.1\n * 【升级】spring-security from 3.7.5 to 3.7.6\n * 【升级】spring-boot-admin from 2.7.9 to 2.7.10\n * 【升级】minio from 8.4.6 to 8.5.1\n * 【升级】knife4j from 3.0.3 to 4.0.0\n * 【升级】vxe-table from 4.3.7 to 4.3.9",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【v1.7.2】2023-04-19",
            frontmatter: {
                title: "【v1.7.2】2023-04-19",
                date: "2023-03-06T01:33:33.000Z",
                permalink: "/changelog/1.7.2/"
            },
            regularPath: "/99.%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/83.%E3%80%90v1-7-2%E3%80%912023-04-19.html",
            relativePath: "99.更新日志/83.【v1-7-2】2023-04-19.md",
            key: "v-816439f2",
            path: "/changelog/1.7.2/",
            headers: [{
                level: 2,
                title: "重构 Vue3 管理后台，提升易用性、稳定性",
                slug: "重构-vue3-管理后台-提升易用性、稳定性",
                normalizedTitle: "重构 vue3 管理后台，提升易用性、稳定性",
                charIndex: 2
            }, {
                level: 3,
                title: "📈 Statistic",
                slug: "📈-statistic",
                normalizedTitle: "📈 statistic",
                charIndex: 29
            }, {
                level: 3,
                title: "⭐ New Features",
                slug: "⭐-new-features",
                normalizedTitle: "⭐ new features",
                charIndex: 108
            }, {
                level: 3,
                title: "🐞 Bug Fixes",
                slug: "🐞-bug-fixes",
                normalizedTitle: "🐞 bug fixes",
                charIndex: 3542
            }, {
                level: 3,
                title: "🔨 Dependency Upgrades",
                slug: "🔨-dependency-upgrades",
                normalizedTitle: "🔨 dependency upgrades",
                charIndex: 5201
            }],
            headersStr: "重构 Vue3 管理后台，提升易用性、稳定性 📈 Statistic ⭐ New Features 🐞 Bug Fixes 🔨 Dependency Upgrades",
            content: "# 重构 Vue3 管理后台，提升易用性、稳定性\n\n\n# 📈 Statistic\n\n * 总代码行数：125001\n * 源码代码行数：77128\n * 注释行数：28642\n * 单元测试用例数：789\n\n\n# ⭐ New Features\n\n * 【新增】《代码热加载》 文档，提升开发效率。\n * 【新增】Vue 管理后台：优化 VSCode 代码 Debugger 调试，使用 VSCode 自带的功能，由 @puhui999 贡献 #117\n * 【新增】代码生成时，增加 UI 类型的选择，可生成 Vue2、Vue3 多种管理后台的代码，支持 CRUD Schema 模式，由 @芋道源码 贡献 #453\n * 【新增】代码生成器，支持 VBEN 管理后台，由 @xingyu 贡献 #454\n * 【优化】Vue3 管理后台：去除 BPMNJS、FormCreate、Highlight 的全局引入，降低打包后的大小（6.6M -> 1.3M），由 @芋道源码 贡献 #128\n * 【重构】Vue3 管理后台：[基础设施 -> 配置管理] 由 @芋道源码 贡献 #24\n * 【重构】Vue3 管理后台：[SSO 登录] 由 @puhui999 贡献 #107\n * 【重构】Vue3 管理后台：[基础设施 -> 数据源配置] 由 @xiaowuye 贡献 #25\n * 【重构】Vue3 管理后台：[系统管理 -> 通知公告] 由 @babylazsss 贡献 #26\n * 【重构】Vue3 管理后台：[系统管理 -> 文件管理] 由 @xiaowuye 贡献 #29、#28\n * 【重构】Vue3 管理后台：[系统管理 -> 字典管理] 由 @Theo 贡献 #38\n * 【重构】Vue3 管理后台：[系统管理 -> 错误码管理] 由 @kinlon92 贡献 #39\n * 【重构】Vue3 管理后台：[系统管理 -> 岗位管理] 由 @Chika 贡献 #44\n * 【重构】Vue3 管理后台：[系统管理 -> 登录日志] 由 @lour6498 贡献 #41\n * 【重构】Vue3 管理后台：[系统管理 -> 客户端管理] 由 @yj441106 贡献 #60\n * 【重构】Vue3 管理后台：[基础设施 -> 错误日志] 由 @oldBaby 贡献 #43\n * 【重构】Vue3 管理后台：[基础设施 -> 访问日志] 由 @oldBaby 贡献 #48\n * 【重构】Vue3 管理后台：[基础设施 -> 代码生成] 由 @xiaowuye 贡献 #68\n * 【重构】Vue3 管理后台：[基础设施 -> 定时任务] 由 @孔思宇 贡献 #65\n * 【重构】Vue3 管理后台：[系统管理 -> 租户管理] 由 @东方白 贡献 #40\n * 【重构】Vue3 管理后台：[系统管理 -> 租户套餐] 由 @puhui999 贡献 #77、#75\n * 【重构】Vue3 管理后台：[系统管理 -> 短信管理] 由 @puhui999 贡献 #45\n * 【重构】Vue3 管理后台：[系统管理 -> 部门管理] 由 @凌太虚 贡献 #36\n * 【重构】Vue3 管理后台：[系统管理 -> 敏感词管理] 由 @syd 贡献 #55\n * 【重构】Vue3 管理后台：[系统管理 -> 菜单管理] 由 @Theo 贡献 #54\n * 【重构】Vue3 管理后台：[系统管理 -> 用户管理] 由 @fessor 贡献 #67、#76\n * 【重构】Vue3 管理后台：[系统管理 -> 角色管理] 由 @Chika 贡献 #63、#85\n * 【重构】Vue3 管理后台：[系统管理 -> 站内信消息] 由 @咱哥丶 贡献 #53\n * 【重构】Vue3 管理后台：[系统管理 -> 站内信消息] 由 @咱哥丶 贡献 #53\n * 【重构】Vue3 管理后台：[公众号 -> 账号管理] 由 @kinlon92 贡献 #49\n * 【重构】Vue3 管理后台：[公众号 -> 标签管理] 由 @矿泉水 贡献 #50\n * 【重构】Vue3 管理后台：[公众号 -> 数据统计] 由 @kinlon92 贡献 #69、#72\n * 【重构】Vue3 管理后台：[公众号 -> 粉丝管理] 由 @dhb52 贡献 #103\n * 【重构】Vue3 管理后台：[公众号 -> 消息管理] 由 @&wxr 贡献 #58、#70\n * 【重构】Vue3 管理后台：[公众号 -> 图文草稿箱] 由 @dhb52 贡献 #102\n * 【重构】Vue3 管理后台：[公众号 -> 素材管理] 由 @dhb52 贡献 #105\n * 【重构】Vue3 管理后台：[公众号 -> 自动回复] 由 @dhb52 贡献 #110\n * 【重构】Vue3 管理后台：[商品中心 -> 商品分类] 由 @孔思宇 贡献 #82\n * 【重构】Vue3 管理后台：[商品中心 -> 商品属性] 由 @孔思宇 贡献 #83\n * 【重构】Vue3 管理后台：[商品中心 -> 商品品牌] 由 @Aix 贡献 #104\n * 【重构】Vue3 管理后台：[支付管理 -> 商户信息] 由 @凌太虚 贡献 #81\n * 【重构】Vue3 管理后台：[支付管理 -> 应用信息] 由 @东方白 贡献 #116\n * 【重构】Vue3 管理后台：[支付管理 -> 支付订单] 由 @东方白 贡献 #116\n * 【重构】Vue3 管理后台：[支付管理 -> 退款订单] 由 @东方白 贡献 #116\n * 【重构】Vue3 管理后台：[工作流 -> 我的流程] 由 @Chika 贡献 #93\n * 【重构】Vue3 管理后台：[工作流 -> 已办任务] 由 @Chika 贡献 #90\n * 【重构】Vue3 管理后台：[工作流 -> 待办任务] 由 @Chika 贡献 #93\n * 【重构】Vue3 管理后台：[工作流 -> 请假查询] 由 @ZanGe丶 贡献 #108\n * 【新增】Vue3 管理后台：增加全局权限判断函数 checkPermi 和 checkRole，由 @LinkLi 贡献 #22\n * 【新增】字典数据 starter 模块单元测试，由 @与或非 贡献 #440\n * 【新增】多租住 Job 部分的单元测试，由 @与或非 贡献 #27\n * 【优化】校验手机号码是否正确的正则，由 @冰是睡着的水 贡献 #447\n * 【新增】PasswordEncoder 加密复杂度自定义，由 @Fanjc 贡献 #24\n * 【新增】Vue3 增加 @element-plus/icons-vue 依赖，由 @dhb52 贡献 #101\n * 【优化】Vue3 管理后台：增加 Mp 账号 Select 下拉框组件，由 @dhb52 贡献 #113、#118\n * 【优化】Vue3 管理后台：使用 Editor 替代 WxEditor，移除 @vueup/vue-quill 依赖，由 @dhb52 贡献 #121\n * 【优化】Vue3 管理后台：公众号消息独立 MessageTable 等组件，解决消息弹窗不重置的问题，由 @dhb52 贡献 #121\n * 【优化】Vue3 管理后台：公众号的素材管理，拆分多个独立组建，由 @dhb52 贡献 #126\n * 【优化】Vue3 管理后台：公众号的自动回复，拆分 ReplyTable 列表组件，由 @dhb52 贡献 #129\n * 【优化】Vue3 管理后台：公众号的消息回复组件，不同消息拆分不同表单，提升可维护性，由 @dhb52 贡献 #129\n * 【优化】Vue3 管理后台：公众号的草稿管理件，拆分多个独立组建，由 @dhb52 贡献 #129\n * 【优化】Vue3 管理后台：公众号的菜单管理，拆分多个独立组建，由 @dhb52 贡献 #129\n * 【优化】Vue2 管理后台：将工作流的业务表单做为动态组件，直接显示到审批页面，不再需要点击查看，由 @疯狂的世界 贡献 #432\n * 【优化】Vue3 管理后台：将工作流的业务表单做为动态组件，直接显示到审批页面，不再需要点击查看，由 @puhui999 贡献 #130\n * 【重构】Vue3 管理后台：给所有组件添加 name 属性预防未知 bug!!! 由 @puhui999 贡献 #125\n\n\n# 🐞 Bug Fixes\n\n * 【修复】Flowable 无法自动建表问题，由 @LinkLi 贡献 #427\n * 【修复】Vue3 管理后台：包含字典表的页面加载时报错，由 @毕梅 贡献 #21\n * 【修复】Vue3 管理后台：ProcessDesigner.vue 编译错误(eslint)，由 @孔思宇 贡献 #23\n * 【修复】积木报告建表语句错误，由 @疯狂的世界 贡献 #430\n * 【修复】基于 Spring Cloud Bus 实现的 Producer 抽象类，获取自己服务实例时获取不到，由 @Lee.J.Eric 贡献 #26\n * 【修复】修复某些情况下 ContextHolder 的 NPE 异常，由 @xuing 贡献 #225\n * 【修复】生成代码测试里面的时间问题（buildBetweenTime 方法），由 @xiaohe4966 贡献 #228\n * 【修复】Vue3 管你后台的各种验收 bug，由 @周建 贡献 #32、#51、#56、#71、#84\n * 【修复】PostgreSQLSQL 的 system_menu 表缺少 component_name、always_show 字段、缺少 system_mail_account、system_mail_log、system_mail_template、system_notify_message、system_notify_template 表，由 @libran 贡献 #435、#435、#436、#437\n * 【修复】订单的创建时间差 8 小时的问题，由 @chop 贡献 #442\n * 【修复】Vue2 短信验证码登录问题，由 @打听幸福的下落 贡献 #438\n * 【修复】工作流的审批任务列表的时间不正确的问题，由 @SuperHao 贡献 #426\n * 【修复】IP 查询时，因为空格导致异常问题，由 @chasel-jc 贡献 #31\n * 【修复】Spring Cloud 打包后，无法使用 java -jar 的问题，由 @lovezhike 贡献 #28\n * 【修复】点击遮罩层弹窗关闭后，页面就操作不了了会一直转圈的问题，由 @puhui999 贡献 #78\n * 【修复】设置 vite basePath 后，重新登录跳转路由错误，由 @mgzu 贡献 #89\n * 【修复】在 Vue3 + Vite4 模块中，使用顶层 await打 包的时候报错，由 @puhui999 贡献 #78\n * 【修复】Vue3 公众号素材选择时，获取 FreePublic 出错，以及分页溢出，由 @dhb52 贡献 #96\n * 【修复】Vue3 公众号图文显示有误，articles 为数组，由 @dhb52 贡献 #100\n * 【修复】xss 请求 Wrapper getAttribute 方法返回错误，由 @zhangxingjia 贡献 #451\n * 【修复】支付通知的通知 Transaction 不生效的问题，由 @kokoko 贡献 #450\n * 【修复】修复工作流创建流程时，流程名可能不存在的问题，由 @xushu 贡献 #439\n * 【修复】修复租户名的重复问题，由 @clockdotnet 贡献 #446\n * 【修复】Vue3 debugger 位置异常，由 @黄爱武 贡献 #114\n * 【修复】Vue3 新增或修改菜单时，无法选择菜单图标的 Bug，由 @chongyul 贡献 #2\n * 【修复】Vue2 管理后台新增租户时，未校验账号、密码是否为空，由 @LiZhongShi 贡献 #456\n * 【修复】敏感词导出和字典数据编辑保存的两个 BUG，由 @clockdotnet 贡献 #457\n * 【修复】Vue3 管理后台：用户管理查询入参错误、站内信模板删除 API 调用错误，由 @AhJindeg 贡献 #132\n\n\n# 🔨 Dependency Upgrades\n\n * 【升级】knife4j from 4.0.0 to 4.1.0\n * 【升级】spring-boot from 2.7.8 to 2.7.10\n * 【升级】spring-doc 1.6.14 to 1.6.15\n * 【升级】lombok from 1.18.24 to 1.18.26\n * 【升级】druid from 1.2.15 to 1.2.16\n * 【升级】jedis-mock from 1.0.6 to 1.0.7\n * 【升级】hutool from 1.15.3 to 1.15.4\n * 【升级】tika-core from 2.6.0 to 2.7.0\n * 【升级】netty-all from 4.1.86.Final to 4.1.90.Final\n * 【升级】minio from 8.5.1 to 8.5.2\n * 【升级】tencentcloud-sdk-java from 3.1.676 to 3.1.715\n * 【升级】alipay-sdk-java from 4.35.32.ALL to 4.35.79.ALL\n * 【升级】ip-region from 2.6.6 to 2.7.0",
            normalizedContent: "# 重构 vue3 管理后台，提升易用性、稳定性\n\n\n# 📈 statistic\n\n * 总代码行数：125001\n * 源码代码行数：77128\n * 注释行数：28642\n * 单元测试用例数：789\n\n\n# ⭐ new features\n\n * 【新增】《代码热加载》 文档，提升开发效率。\n * 【新增】vue 管理后台：优化 vscode 代码 debugger 调试，使用 vscode 自带的功能，由 @puhui999 贡献 #117\n * 【新增】代码生成时，增加 ui 类型的选择，可生成 vue2、vue3 多种管理后台的代码，支持 crud schema 模式，由 @芋道源码 贡献 #453\n * 【新增】代码生成器，支持 vben 管理后台，由 @xingyu 贡献 #454\n * 【优化】vue3 管理后台：去除 bpmnjs、formcreate、highlight 的全局引入，降低打包后的大小（6.6m -> 1.3m），由 @芋道源码 贡献 #128\n * 【重构】vue3 管理后台：[基础设施 -> 配置管理] 由 @芋道源码 贡献 #24\n * 【重构】vue3 管理后台：[sso 登录] 由 @puhui999 贡献 #107\n * 【重构】vue3 管理后台：[基础设施 -> 数据源配置] 由 @xiaowuye 贡献 #25\n * 【重构】vue3 管理后台：[系统管理 -> 通知公告] 由 @babylazsss 贡献 #26\n * 【重构】vue3 管理后台：[系统管理 -> 文件管理] 由 @xiaowuye 贡献 #29、#28\n * 【重构】vue3 管理后台：[系统管理 -> 字典管理] 由 @theo 贡献 #38\n * 【重构】vue3 管理后台：[系统管理 -> 错误码管理] 由 @kinlon92 贡献 #39\n * 【重构】vue3 管理后台：[系统管理 -> 岗位管理] 由 @chika 贡献 #44\n * 【重构】vue3 管理后台：[系统管理 -> 登录日志] 由 @lour6498 贡献 #41\n * 【重构】vue3 管理后台：[系统管理 -> 客户端管理] 由 @yj441106 贡献 #60\n * 【重构】vue3 管理后台：[基础设施 -> 错误日志] 由 @oldbaby 贡献 #43\n * 【重构】vue3 管理后台：[基础设施 -> 访问日志] 由 @oldbaby 贡献 #48\n * 【重构】vue3 管理后台：[基础设施 -> 代码生成] 由 @xiaowuye 贡献 #68\n * 【重构】vue3 管理后台：[基础设施 -> 定时任务] 由 @孔思宇 贡献 #65\n * 【重构】vue3 管理后台：[系统管理 -> 租户管理] 由 @东方白 贡献 #40\n * 【重构】vue3 管理后台：[系统管理 -> 租户套餐] 由 @puhui999 贡献 #77、#75\n * 【重构】vue3 管理后台：[系统管理 -> 短信管理] 由 @puhui999 贡献 #45\n * 【重构】vue3 管理后台：[系统管理 -> 部门管理] 由 @凌太虚 贡献 #36\n * 【重构】vue3 管理后台：[系统管理 -> 敏感词管理] 由 @syd 贡献 #55\n * 【重构】vue3 管理后台：[系统管理 -> 菜单管理] 由 @theo 贡献 #54\n * 【重构】vue3 管理后台：[系统管理 -> 用户管理] 由 @fessor 贡献 #67、#76\n * 【重构】vue3 管理后台：[系统管理 -> 角色管理] 由 @chika 贡献 #63、#85\n * 【重构】vue3 管理后台：[系统管理 -> 站内信消息] 由 @咱哥丶 贡献 #53\n * 【重构】vue3 管理后台：[系统管理 -> 站内信消息] 由 @咱哥丶 贡献 #53\n * 【重构】vue3 管理后台：[公众号 -> 账号管理] 由 @kinlon92 贡献 #49\n * 【重构】vue3 管理后台：[公众号 -> 标签管理] 由 @矿泉水 贡献 #50\n * 【重构】vue3 管理后台：[公众号 -> 数据统计] 由 @kinlon92 贡献 #69、#72\n * 【重构】vue3 管理后台：[公众号 -> 粉丝管理] 由 @dhb52 贡献 #103\n * 【重构】vue3 管理后台：[公众号 -> 消息管理] 由 @&wxr 贡献 #58、#70\n * 【重构】vue3 管理后台：[公众号 -> 图文草稿箱] 由 @dhb52 贡献 #102\n * 【重构】vue3 管理后台：[公众号 -> 素材管理] 由 @dhb52 贡献 #105\n * 【重构】vue3 管理后台：[公众号 -> 自动回复] 由 @dhb52 贡献 #110\n * 【重构】vue3 管理后台：[商品中心 -> 商品分类] 由 @孔思宇 贡献 #82\n * 【重构】vue3 管理后台：[商品中心 -> 商品属性] 由 @孔思宇 贡献 #83\n * 【重构】vue3 管理后台：[商品中心 -> 商品品牌] 由 @aix 贡献 #104\n * 【重构】vue3 管理后台：[支付管理 -> 商户信息] 由 @凌太虚 贡献 #81\n * 【重构】vue3 管理后台：[支付管理 -> 应用信息] 由 @东方白 贡献 #116\n * 【重构】vue3 管理后台：[支付管理 -> 支付订单] 由 @东方白 贡献 #116\n * 【重构】vue3 管理后台：[支付管理 -> 退款订单] 由 @东方白 贡献 #116\n * 【重构】vue3 管理后台：[工作流 -> 我的流程] 由 @chika 贡献 #93\n * 【重构】vue3 管理后台：[工作流 -> 已办任务] 由 @chika 贡献 #90\n * 【重构】vue3 管理后台：[工作流 -> 待办任务] 由 @chika 贡献 #93\n * 【重构】vue3 管理后台：[工作流 -> 请假查询] 由 @zange丶 贡献 #108\n * 【新增】vue3 管理后台：增加全局权限判断函数 checkpermi 和 checkrole，由 @linkli 贡献 #22\n * 【新增】字典数据 starter 模块单元测试，由 @与或非 贡献 #440\n * 【新增】多租住 job 部分的单元测试，由 @与或非 贡献 #27\n * 【优化】校验手机号码是否正确的正则，由 @冰是睡着的水 贡献 #447\n * 【新增】passwordencoder 加密复杂度自定义，由 @fanjc 贡献 #24\n * 【新增】vue3 增加 @element-plus/icons-vue 依赖，由 @dhb52 贡献 #101\n * 【优化】vue3 管理后台：增加 mp 账号 select 下拉框组件，由 @dhb52 贡献 #113、#118\n * 【优化】vue3 管理后台：使用 editor 替代 wxeditor，移除 @vueup/vue-quill 依赖，由 @dhb52 贡献 #121\n * 【优化】vue3 管理后台：公众号消息独立 messagetable 等组件，解决消息弹窗不重置的问题，由 @dhb52 贡献 #121\n * 【优化】vue3 管理后台：公众号的素材管理，拆分多个独立组建，由 @dhb52 贡献 #126\n * 【优化】vue3 管理后台：公众号的自动回复，拆分 replytable 列表组件，由 @dhb52 贡献 #129\n * 【优化】vue3 管理后台：公众号的消息回复组件，不同消息拆分不同表单，提升可维护性，由 @dhb52 贡献 #129\n * 【优化】vue3 管理后台：公众号的草稿管理件，拆分多个独立组建，由 @dhb52 贡献 #129\n * 【优化】vue3 管理后台：公众号的菜单管理，拆分多个独立组建，由 @dhb52 贡献 #129\n * 【优化】vue2 管理后台：将工作流的业务表单做为动态组件，直接显示到审批页面，不再需要点击查看，由 @疯狂的世界 贡献 #432\n * 【优化】vue3 管理后台：将工作流的业务表单做为动态组件，直接显示到审批页面，不再需要点击查看，由 @puhui999 贡献 #130\n * 【重构】vue3 管理后台：给所有组件添加 name 属性预防未知 bug!!! 由 @puhui999 贡献 #125\n\n\n# 🐞 bug fixes\n\n * 【修复】flowable 无法自动建表问题，由 @linkli 贡献 #427\n * 【修复】vue3 管理后台：包含字典表的页面加载时报错，由 @毕梅 贡献 #21\n * 【修复】vue3 管理后台：processdesigner.vue 编译错误(eslint)，由 @孔思宇 贡献 #23\n * 【修复】积木报告建表语句错误，由 @疯狂的世界 贡献 #430\n * 【修复】基于 spring cloud bus 实现的 producer 抽象类，获取自己服务实例时获取不到，由 @lee.j.eric 贡献 #26\n * 【修复】修复某些情况下 contextholder 的 npe 异常，由 @xuing 贡献 #225\n * 【修复】生成代码测试里面的时间问题（buildbetweentime 方法），由 @xiaohe4966 贡献 #228\n * 【修复】vue3 管你后台的各种验收 bug，由 @周建 贡献 #32、#51、#56、#71、#84\n * 【修复】postgresqlsql 的 system_menu 表缺少 component_name、always_show 字段、缺少 system_mail_account、system_mail_log、system_mail_template、system_notify_message、system_notify_template 表，由 @libran 贡献 #435、#435、#436、#437\n * 【修复】订单的创建时间差 8 小时的问题，由 @chop 贡献 #442\n * 【修复】vue2 短信验证码登录问题，由 @打听幸福的下落 贡献 #438\n * 【修复】工作流的审批任务列表的时间不正确的问题，由 @superhao 贡献 #426\n * 【修复】ip 查询时，因为空格导致异常问题，由 @chasel-jc 贡献 #31\n * 【修复】spring cloud 打包后，无法使用 java -jar 的问题，由 @lovezhike 贡献 #28\n * 【修复】点击遮罩层弹窗关闭后，页面就操作不了了会一直转圈的问题，由 @puhui999 贡献 #78\n * 【修复】设置 vite basepath 后，重新登录跳转路由错误，由 @mgzu 贡献 #89\n * 【修复】在 vue3 + vite4 模块中，使用顶层 await打 包的时候报错，由 @puhui999 贡献 #78\n * 【修复】vue3 公众号素材选择时，获取 freepublic 出错，以及分页溢出，由 @dhb52 贡献 #96\n * 【修复】vue3 公众号图文显示有误，articles 为数组，由 @dhb52 贡献 #100\n * 【修复】xss 请求 wrapper getattribute 方法返回错误，由 @zhangxingjia 贡献 #451\n * 【修复】支付通知的通知 transaction 不生效的问题，由 @kokoko 贡献 #450\n * 【修复】修复工作流创建流程时，流程名可能不存在的问题，由 @xushu 贡献 #439\n * 【修复】修复租户名的重复问题，由 @clockdotnet 贡献 #446\n * 【修复】vue3 debugger 位置异常，由 @黄爱武 贡献 #114\n * 【修复】vue3 新增或修改菜单时，无法选择菜单图标的 bug，由 @chongyul 贡献 #2\n * 【修复】vue2 管理后台新增租户时，未校验账号、密码是否为空，由 @lizhongshi 贡献 #456\n * 【修复】敏感词导出和字典数据编辑保存的两个 bug，由 @clockdotnet 贡献 #457\n * 【修复】vue3 管理后台：用户管理查询入参错误、站内信模板删除 api 调用错误，由 @ahjindeg 贡献 #132\n\n\n# 🔨 dependency upgrades\n\n * 【升级】knife4j from 4.0.0 to 4.1.0\n * 【升级】spring-boot from 2.7.8 to 2.7.10\n * 【升级】spring-doc 1.6.14 to 1.6.15\n * 【升级】lombok from 1.18.24 to 1.18.26\n * 【升级】druid from 1.2.15 to 1.2.16\n * 【升级】jedis-mock from 1.0.6 to 1.0.7\n * 【升级】hutool from 1.15.3 to 1.15.4\n * 【升级】tika-core from 2.6.0 to 2.7.0\n * 【升级】netty-all from 4.1.86.final to 4.1.90.final\n * 【升级】minio from 8.5.1 to 8.5.2\n * 【升级】tencentcloud-sdk-java from 3.1.676 to 3.1.715\n * 【升级】alipay-sdk-java from 4.35.32.all to 4.35.79.all\n * 【升级】ip-region from 2.6.6 to 2.7.0",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【v1.6.5】2022-12-01",
            frontmatter: {
                title: "【v1.6.5】2022-12-01",
                date: "2022-08-22 08:00",
                permalink: "/changelog/1.6.5/"
            },
            regularPath: "/99.%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/87.%E3%80%90v1-6-5%E3%80%912022-12-01.html",
            relativePath: "99.更新日志/87.【v1-6-5】2022-12-01.md",
            key: "v-99637f32",
            path: "/changelog/1.6.5/",
            headers: [{
                level: 2,
                title: "重构 Vue3 管理后台，优化稳定性",
                slug: "重构-vue3-管理后台-优化稳定性",
                normalizedTitle: "重构 vue3 管理后台，优化稳定性",
                charIndex: 2
            }, {
                level: 3,
                title: "📈 Statistic",
                slug: "📈-statistic",
                normalizedTitle: "📈 statistic",
                charIndex: 25
            }, {
                level: 3,
                title: "⭐ New Features",
                slug: "⭐-new-features",
                normalizedTitle: "⭐ new features",
                charIndex: 103
            }, {
                level: 3,
                title: "🐞 Bug Fixes",
                slug: "🐞-bug-fixes",
                normalizedTitle: "🐞 bug fixes",
                charIndex: 667
            }, {
                level: 3,
                title: "🔨 Dependency Upgrades",
                slug: "🔨-dependency-upgrades",
                normalizedTitle: "🔨 dependency upgrades",
                charIndex: 1515
            }],
            headersStr: "重构 Vue3 管理后台，优化稳定性 📈 Statistic ⭐ New Features 🐞 Bug Fixes 🔨 Dependency Upgrades",
            content: '# 重构 Vue3 管理后台，优化稳定性\n\n\n# 📈 Statistic\n\n * 总代码行数：98088\n * 源码代码行数：55926\n * 注释行数：23265\n * 单元测试用例数：671\n\n\n# ⭐ New Features\n\n * 【新增】管理后台登录时，使用滑块验证码，由 @xingyu4j 贡献 #238\n * 【新增】SSO 单点登录的示例，包括基于授权码模式、密码模式两种实现 #272\n * 【优化】提升 Vue3 实现管理后台的稳定性、兼容性，基于 vxe-table 解决 el-table 卡顿的问题，由 @xingyu4j 贡献 #271 #282 #283 #288 #291 #293 #299 #300 #314 #316\n * 【优化】使用 LocalDateTime 替换 Date，由 @xingyu4j 贡献 #292\n * 【新增】Spring Cache 在多租户下的支持，由 @whitedolphin 贡献 #257\n * 【新增】流程图 ServiceTask 的完成和 todo 高亮，增加 ServiceTask 节点的 hover 显示内容，由 @FinalFinancialFreedom 贡献 #260\n * 【移除】云片短信渠道，解决云片的安全风险 ea95115\n * 【移除】jasypt-spring-boot-starter 加密库使用 hutool AES 替代 ce3aefa\n * 【移除】Apollo 配置中心，简化学习成本 a8cdf74\n\n\n# 🐞 Bug Fixes\n\n * 【修复】WxMaService 的 null key in entry 报错，由 @rayyer 贡献 #259\n * 【修复】导入用户后编辑报错，由 @wangjun 贡献 #258\n * 【修复】编辑流程模型时，不退出模拟直接保存，导致后续分配规则报错，由 @wangjun 贡献 #258\n * 【修复】数据权限，不支持隐式内连接的问题\n * 【修复】"定时任务 -> 调度日志 -> 详细"里面，”执行时长“字段显示不正确的问题，由 @idevmo 贡献 #265\n * 【修复】Vue3 代码生成选择父菜单无效，生成的前端代码缺少字段以及格式错误，由 @jueyinghua 贡献 #286\n * 【修复】前端配置管理中参数分类显示错误，由 @guyuezb 贡献 #278\n * 【修复】短信接收报告回调时，设置 errorMsg 不正确，由 @Macro 贡献 #280\n * 【修复】当只修改模型并保存，再发布时，提示"流程定义部署失败，原因：信息未发生变化"，由 @SuperHao 贡献 #284\n * 【修复】WXLitePayClient.java 中 copy 应忽略的字段，由 @chenlei65368 贡献 #284\n * 【修复】阿里云 OSS 解析 region 时兼容带 https的 配置，由 @huangyemin 贡献 #276\n * 【修复】三级及以上菜单路由缓存失效问题，由 @咱哥丶 贡献 #290\n * 【修复】钉钉登录时，重定向后 type 丢失导致报错的问题 7093ed3\n * 【修复】无法自定义 Icon 图标的问题 e403684\n * 【修复】访问数据库存储的文件，path 多层级时，无法访问的问题 92ace03\n * 【修复】S3 上传七牛云无 mime type 的问题，由 @石溪 贡献 #313\n * 【修复】流程代办，日期时区转换错误，由 @zy_2021 贡献 #309\n\n\n# 🔨 Dependency Upgrades\n\n * 【升级】spring boot from 2.6.10 to 2.7.6\n * 【升级】flowable from 6.7.0 to 6.7.2\n * 【升级】hutool from 5.7.22 to 5.8.9\n * 【升级】velocity from 2.2 to 2.3\n * 【升级】druid from 1.2.11 to 1.2.14\n * 【升级】spring boot admin from 2.6.7 to 2.6.9\n * 【升级】mapstruct from 1.4.1 to 1.5.3.Final\n * 【升级】lombok from 1.16.14 to 1.18.24\n * 【升级】mockito from 4.0.0 to 4.8.0\n * 【升级】dynamic-datasource from 3.5.0 to 3.5.2\n * 【升级】redisson from 3.17.4 to 3.17.7\n * 【升级】easyexcel from 3.1.1 to 3.1.2\n * 【升级】vue from 2.7.0 to 2.7.14',
            normalizedContent: '# 重构 vue3 管理后台，优化稳定性\n\n\n# 📈 statistic\n\n * 总代码行数：98088\n * 源码代码行数：55926\n * 注释行数：23265\n * 单元测试用例数：671\n\n\n# ⭐ new features\n\n * 【新增】管理后台登录时，使用滑块验证码，由 @xingyu4j 贡献 #238\n * 【新增】sso 单点登录的示例，包括基于授权码模式、密码模式两种实现 #272\n * 【优化】提升 vue3 实现管理后台的稳定性、兼容性，基于 vxe-table 解决 el-table 卡顿的问题，由 @xingyu4j 贡献 #271 #282 #283 #288 #291 #293 #299 #300 #314 #316\n * 【优化】使用 localdatetime 替换 date，由 @xingyu4j 贡献 #292\n * 【新增】spring cache 在多租户下的支持，由 @whitedolphin 贡献 #257\n * 【新增】流程图 servicetask 的完成和 todo 高亮，增加 servicetask 节点的 hover 显示内容，由 @finalfinancialfreedom 贡献 #260\n * 【移除】云片短信渠道，解决云片的安全风险 ea95115\n * 【移除】jasypt-spring-boot-starter 加密库使用 hutool aes 替代 ce3aefa\n * 【移除】apollo 配置中心，简化学习成本 a8cdf74\n\n\n# 🐞 bug fixes\n\n * 【修复】wxmaservice 的 null key in entry 报错，由 @rayyer 贡献 #259\n * 【修复】导入用户后编辑报错，由 @wangjun 贡献 #258\n * 【修复】编辑流程模型时，不退出模拟直接保存，导致后续分配规则报错，由 @wangjun 贡献 #258\n * 【修复】数据权限，不支持隐式内连接的问题\n * 【修复】"定时任务 -> 调度日志 -> 详细"里面，”执行时长“字段显示不正确的问题，由 @idevmo 贡献 #265\n * 【修复】vue3 代码生成选择父菜单无效，生成的前端代码缺少字段以及格式错误，由 @jueyinghua 贡献 #286\n * 【修复】前端配置管理中参数分类显示错误，由 @guyuezb 贡献 #278\n * 【修复】短信接收报告回调时，设置 errormsg 不正确，由 @macro 贡献 #280\n * 【修复】当只修改模型并保存，再发布时，提示"流程定义部署失败，原因：信息未发生变化"，由 @superhao 贡献 #284\n * 【修复】wxlitepayclient.java 中 copy 应忽略的字段，由 @chenlei65368 贡献 #284\n * 【修复】阿里云 oss 解析 region 时兼容带 https的 配置，由 @huangyemin 贡献 #276\n * 【修复】三级及以上菜单路由缓存失效问题，由 @咱哥丶 贡献 #290\n * 【修复】钉钉登录时，重定向后 type 丢失导致报错的问题 7093ed3\n * 【修复】无法自定义 icon 图标的问题 e403684\n * 【修复】访问数据库存储的文件，path 多层级时，无法访问的问题 92ace03\n * 【修复】s3 上传七牛云无 mime type 的问题，由 @石溪 贡献 #313\n * 【修复】流程代办，日期时区转换错误，由 @zy_2021 贡献 #309\n\n\n# 🔨 dependency upgrades\n\n * 【升级】spring boot from 2.6.10 to 2.7.6\n * 【升级】flowable from 6.7.0 to 6.7.2\n * 【升级】hutool from 5.7.22 to 5.8.9\n * 【升级】velocity from 2.2 to 2.3\n * 【升级】druid from 1.2.11 to 1.2.14\n * 【升级】spring boot admin from 2.6.7 to 2.6.9\n * 【升级】mapstruct from 1.4.1 to 1.5.3.final\n * 【升级】lombok from 1.16.14 to 1.18.24\n * 【升级】mockito from 4.0.0 to 4.8.0\n * 【升级】dynamic-datasource from 3.5.0 to 3.5.2\n * 【升级】redisson from 3.17.4 to 3.17.7\n * 【升级】easyexcel from 3.1.1 to 3.1.2\n * 【升级】vue from 2.7.0 to 2.7.14',
            charsets: {
                cjk: !0
            }
        }, {
            title: "【v1.6.4】2022-08-22",
            frontmatter: {
                title: "【v1.6.4】2022-08-22",
                date: "2022-08-22 08:00",
                permalink: "/changelog/1.6.4/"
            },
            regularPath: "/99.%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/88.%E3%80%90v1-6-4%E3%80%912022-08-22.html",
            relativePath: "99.更新日志/88.【v1-6-4】2022-08-22.md",
            key: "v-0f85e067",
            path: "/changelog/1.6.4/",
            headers: [{
                level: 2,
                title: "新增 uniapp 管理后台、报表设计器",
                slug: "新增-uniapp-管理后台、报表设计器",
                normalizedTitle: "新增 uniapp 管理后台、报表设计器",
                charIndex: 2
            }, {
                level: 3,
                title: "📈 Statistic",
                slug: "📈-statistic",
                normalizedTitle: "📈 statistic",
                charIndex: 27
            }, {
                level: 3,
                title: "⭐ New Features",
                slug: "⭐-new-features",
                normalizedTitle: "⭐ new features",
                charIndex: 105
            }, {
                level: 3,
                title: "🐞 Bug Fixes",
                slug: "🐞-bug-fixes",
                normalizedTitle: "🐞 bug fixes",
                charIndex: 501
            }, {
                level: 3,
                title: "🔨 Dependency Upgrades",
                slug: "🔨-dependency-upgrades",
                normalizedTitle: "🔨 dependency upgrades",
                charIndex: 770
            }],
            headersStr: "新增 uniapp 管理后台、报表设计器 📈 Statistic ⭐ New Features 🐞 Bug Fixes 🔨 Dependency Upgrades",
            content: "# 新增 uniapp 管理后台、报表设计器\n\n\n# 📈 Statistic\n\n * 总代码行数：87565\n * 源码代码行数：54279\n * 注释行数：19868\n * 单元测试用例数：671\n\n\n# ⭐ New Features\n\n * 【新增】完善 Vue3 管理后台的工作流实现，由 @xingyu4j 贡献 #238\n * 【新增】管理后台的移动端 yudao-ui-admin-uniapp 项目，采用 uni-app 方案，一份代码多终端适配，同时支持 APP、小程序、H5！#247\n * 【新增】集成积木报表，提供低代码报表设计器，由 @jiangqiang1996 贡献 #237\n * 【新增】接入支付宝 PC 网站支付，由 @jiangqiang1996 贡献 #240\n * 【优化】项目的启动速度，控制在 30 秒左右，默认不启动 bpm、visualization 模块\n * 【优化】管理后台的弹窗支持滚动、拖拽，并点击背景布关闭，避免误操作，由 @颗粒 贡献 #253\n * 【优化】一键改包，如果目标目录已存在，则不进行生成，由 @C 贡献 #229\n\n\n# 🐞 Bug Fixes\n\n * 【修复】Redis 7.0 监控查询 calls 数值超过 Integer 范围的异常，由 @lanyue52011 贡献 #239\n * 【修复】前端表单设计器中动态数据，不能正常获取和更深层级的赋值错误的情况，由 @CorrectRoadH 贡献 #256\n * 【修复】代码生成功能中，点击同步，会清除已添加并存在的字段，由 @xrcoder 贡献 #249\n * 【修复】工作流与积木报表的依赖冲突，将 xercesImpl 升级到 2.12.0 版本，由 @shihy 贡献 #254\n\n\n# 🔨 Dependency Upgrades\n\n暂无",
            normalizedContent: "# 新增 uniapp 管理后台、报表设计器\n\n\n# 📈 statistic\n\n * 总代码行数：87565\n * 源码代码行数：54279\n * 注释行数：19868\n * 单元测试用例数：671\n\n\n# ⭐ new features\n\n * 【新增】完善 vue3 管理后台的工作流实现，由 @xingyu4j 贡献 #238\n * 【新增】管理后台的移动端 yudao-ui-admin-uniapp 项目，采用 uni-app 方案，一份代码多终端适配，同时支持 app、小程序、h5！#247\n * 【新增】集成积木报表，提供低代码报表设计器，由 @jiangqiang1996 贡献 #237\n * 【新增】接入支付宝 pc 网站支付，由 @jiangqiang1996 贡献 #240\n * 【优化】项目的启动速度，控制在 30 秒左右，默认不启动 bpm、visualization 模块\n * 【优化】管理后台的弹窗支持滚动、拖拽，并点击背景布关闭，避免误操作，由 @颗粒 贡献 #253\n * 【优化】一键改包，如果目标目录已存在，则不进行生成，由 @c 贡献 #229\n\n\n# 🐞 bug fixes\n\n * 【修复】redis 7.0 监控查询 calls 数值超过 integer 范围的异常，由 @lanyue52011 贡献 #239\n * 【修复】前端表单设计器中动态数据，不能正常获取和更深层级的赋值错误的情况，由 @correctroadh 贡献 #256\n * 【修复】代码生成功能中，点击同步，会清除已添加并存在的字段，由 @xrcoder 贡献 #249\n * 【修复】工作流与积木报表的依赖冲突，将 xercesimpl 升级到 2.12.0 版本，由 @shihy 贡献 #254\n\n\n# 🔨 dependency upgrades\n\n暂无",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【v1.6.6】2023-01-05",
            frontmatter: {
                title: "【v1.6.6】2023-01-05",
                date: "2023-01-01 08:00",
                permalink: "/changelog/1.6.6/"
            },
            regularPath: "/99.%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/86.%E3%80%90v-1-6-6%E3%80%912023-01-05.html",
            relativePath: "99.更新日志/86.【v-1-6-6】2023-01-05.md",
            key: "v-10452a93",
            path: "/changelog/1.6.6/",
            headers: [{
                level: 2,
                title: "完善 Vue3 管理后台，新增 IP & 地区库",
                slug: "完善-vue3-管理后台-新增-ip-地区库",
                normalizedTitle: "完善 vue3 管理后台，新增 ip &amp; 地区库",
                charIndex: null
            }, {
                level: 3,
                title: "📈 Statistic",
                slug: "📈-statistic",
                normalizedTitle: "📈 statistic",
                charIndex: 31
            }, {
                level: 3,
                title: "⭐ New Features",
                slug: "⭐-new-features",
                normalizedTitle: "⭐ new features",
                charIndex: 110
            }, {
                level: 3,
                title: "🐞 Bug Fixes",
                slug: "🐞-bug-fixes",
                normalizedTitle: "🐞 bug fixes",
                charIndex: 563
            }, {
                level: 3,
                title: "🔨 Dependency Upgrades",
                slug: "🔨-dependency-upgrades",
                normalizedTitle: "🔨 dependency upgrades",
                charIndex: 1424
            }],
            headersStr: "完善 Vue3 管理后台，新增 IP & 地区库 📈 Statistic ⭐ New Features 🐞 Bug Fixes 🔨 Dependency Upgrades",
            content: "# 完善 Vue3 管理后台，新增 IP & 地区库\n\n\n# 📈 Statistic\n\n * 总代码行数：104298\n * 源码代码行数：63656\n * 注释行数：24708\n * 单元测试用例数：602\n\n\n# ⭐ New Features\n\n * 【新增】yudao-spring-boot-starter-biz-ip 业务组件，提供地区 & IP 库的封装，由 @WangLH 贡献 0b5aa56\n * 【新增】《后端手册 —— 地区 & IP 库》 文档\n * 【新增】《后端手册 —— 敏感词》 文档\n * 【新增】《前端手册 Vue 3.x》 文档\n * 【优化】本地缓存的刷新实现，数据变更时，强制刷新，贡献 #3443aa6\n * 【新增】Vue3 XTable 组件，由 @xingyu4j 贡献 #349\n * 【优化】优化 Vue3 管理后台实现，由 @xingyu4j 贡献 #317 #322 #331 #335 #339 #343\n * 【优化】完善 Vue3 上传组件 && 提升打包速度，由 @xingyu4j 贡献 #337\n * 【重构】Vue3 头像上传，由 @xingyu4j 贡献 #338\n * 【新增】WebSocket 连接测试，由 @咱哥丶 贡献 #348\n\n\n# 🐞 Bug Fixes\n\n * 【修复】字典类型逻辑删除时，唯一索引冲突的问题，由 @tangkc123 贡献 #323\n * 【修复】pay 模块提交退款申请时，重复设置属性，由 @qshome 贡献 #325\n * 【修复】修改pay 模块创建支付单时，错误返回订单编号，由 @qshome 贡献 #324\n * 【修复】修改 pay 模块在微信支付时，支付过期时间格式化异常 （yyyy-MM-ddTHH:mm:ssXXX），由 @qshome 贡献 #329\n * 【修复】数据权限 SQL 存在多个表达式时，缺少括号问题，由 @与或非 贡献 #328\n * 【修复】yudao-ui-admin-vue3 面包屑导航图标和文字不在同一水平线，由 @supine-win 贡献 #333\n * 【修复】yudao-module-system-api 的 ErrorCodeConstants 中错误码重复的问题，由 @王添翼 贡献 #340\n * 【修复】DeptService 的 getDeptsByParentIdFromCache 在获取部门列表时，未处理多租户场景，贡献 #75b3a29\n * 【修复】前端 FileUpload 文件上传时，code 未使用 0 判断成功，由 @plimlips 贡献 #344\n * 【修复】Redis Stream 消息队列在重启 Java 进程时，由于 Consumer 未释放消息，导致消息丢失的问题，由 @与或非 贡献 #332\n * 【修复】腾讯 COS 异常，Region 必传，由 @与或非 贡献 #347\n * 【修复】DB 存储文件时，读取可能报错的问题，由 @与或非 贡献 #346\n * 【修复】没有数据权限时，添加/修改用户的唯一手机、账号等字段的校验不正确，贡献 7912a54\n * 【修复】配置管理，配置是否可见判断写反了，由 @kinlon92 贡献 #350\n * 【修复】上传视频无法预览，由 @与或非 贡献 #352\n\n\n# 🔨 Dependency Upgrades\n\n * 【升级】spring-boot from 2.7.6 to 2.7.7\n * 【升级】mybatis-plus from 3.5.2 to 3.5.3\n * 【升级】dynamic-datasource from 3.6.0 to 3.6.1\n * 【升级】flowable from 6.7.2 to 6.8.0\n * 【升级】lock4j from 2.2.2 to 2.2.3\n * 【升级】podam from 7.2.9 to 7.2.11\n * 【升级】jedis-mock from 1.0.4 to 1.0.5\n * 【升级】transmittable-thread-local from 2.14.0 to 2.14.2\n * 【升级】netty-all from 4.1.82 to 4.1.86\n * 【升级】aliyun-java-sdk-core from 4.6.2 to 4.6.3\n * 【升级】tencentcloud-sdk-java from 3.1.635 to 3.1.660\n * 【升级】spring-boot-admin from 2.7.7 to 2.7.9",
            normalizedContent: "# 完善 vue3 管理后台，新增 ip & 地区库\n\n\n# 📈 statistic\n\n * 总代码行数：104298\n * 源码代码行数：63656\n * 注释行数：24708\n * 单元测试用例数：602\n\n\n# ⭐ new features\n\n * 【新增】yudao-spring-boot-starter-biz-ip 业务组件，提供地区 & ip 库的封装，由 @wanglh 贡献 0b5aa56\n * 【新增】《后端手册 —— 地区 & ip 库》 文档\n * 【新增】《后端手册 —— 敏感词》 文档\n * 【新增】《前端手册 vue 3.x》 文档\n * 【优化】本地缓存的刷新实现，数据变更时，强制刷新，贡献 #3443aa6\n * 【新增】vue3 xtable 组件，由 @xingyu4j 贡献 #349\n * 【优化】优化 vue3 管理后台实现，由 @xingyu4j 贡献 #317 #322 #331 #335 #339 #343\n * 【优化】完善 vue3 上传组件 && 提升打包速度，由 @xingyu4j 贡献 #337\n * 【重构】vue3 头像上传，由 @xingyu4j 贡献 #338\n * 【新增】websocket 连接测试，由 @咱哥丶 贡献 #348\n\n\n# 🐞 bug fixes\n\n * 【修复】字典类型逻辑删除时，唯一索引冲突的问题，由 @tangkc123 贡献 #323\n * 【修复】pay 模块提交退款申请时，重复设置属性，由 @qshome 贡献 #325\n * 【修复】修改pay 模块创建支付单时，错误返回订单编号，由 @qshome 贡献 #324\n * 【修复】修改 pay 模块在微信支付时，支付过期时间格式化异常 （yyyy-mm-ddthh:mm:ssxxx），由 @qshome 贡献 #329\n * 【修复】数据权限 sql 存在多个表达式时，缺少括号问题，由 @与或非 贡献 #328\n * 【修复】yudao-ui-admin-vue3 面包屑导航图标和文字不在同一水平线，由 @supine-win 贡献 #333\n * 【修复】yudao-module-system-api 的 errorcodeconstants 中错误码重复的问题，由 @王添翼 贡献 #340\n * 【修复】deptservice 的 getdeptsbyparentidfromcache 在获取部门列表时，未处理多租户场景，贡献 #75b3a29\n * 【修复】前端 fileupload 文件上传时，code 未使用 0 判断成功，由 @plimlips 贡献 #344\n * 【修复】redis stream 消息队列在重启 java 进程时，由于 consumer 未释放消息，导致消息丢失的问题，由 @与或非 贡献 #332\n * 【修复】腾讯 cos 异常，region 必传，由 @与或非 贡献 #347\n * 【修复】db 存储文件时，读取可能报错的问题，由 @与或非 贡献 #346\n * 【修复】没有数据权限时，添加/修改用户的唯一手机、账号等字段的校验不正确，贡献 7912a54\n * 【修复】配置管理，配置是否可见判断写反了，由 @kinlon92 贡献 #350\n * 【修复】上传视频无法预览，由 @与或非 贡献 #352\n\n\n# 🔨 dependency upgrades\n\n * 【升级】spring-boot from 2.7.6 to 2.7.7\n * 【升级】mybatis-plus from 3.5.2 to 3.5.3\n * 【升级】dynamic-datasource from 3.6.0 to 3.6.1\n * 【升级】flowable from 6.7.2 to 6.8.0\n * 【升级】lock4j from 2.2.2 to 2.2.3\n * 【升级】podam from 7.2.9 to 7.2.11\n * 【升级】jedis-mock from 1.0.4 to 1.0.5\n * 【升级】transmittable-thread-local from 2.14.0 to 2.14.2\n * 【升级】netty-all from 4.1.82 to 4.1.86\n * 【升级】aliyun-java-sdk-core from 4.6.2 to 4.6.3\n * 【升级】tencentcloud-sdk-java from 3.1.635 to 3.1.660\n * 【升级】spring-boot-admin from 2.7.7 to 2.7.9",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【v1.6.3】2022-07-29",
            frontmatter: {
                title: "【v1.6.3】2022-07-29",
                date: "2022-07-29 08:00",
                permalink: "/changelog/1.6.3/"
            },
            regularPath: "/99.%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/89.%E3%80%90v1-6-3%E3%80%912022-07-29.html",
            relativePath: "99.更新日志/89.【v1-6-3】2022-07-29.md",
            key: "v-03a14a67",
            path: "/changelog/1.6.3/",
            headers: [{
                level: 2,
                title: "工作流支持会签或签、新增 Vue3 管理后台",
                slug: "工作流支持会签或签、新增-vue3-管理后台",
                normalizedTitle: "工作流支持会签或签、新增 vue3 管理后台",
                charIndex: 2
            }, {
                level: 3,
                title: "📈 Statistic",
                slug: "📈-statistic",
                normalizedTitle: "📈 statistic",
                charIndex: 29
            }, {
                level: 3,
                title: "⭐ New Features",
                slug: "⭐-new-features",
                normalizedTitle: "⭐ new features",
                charIndex: 107
            }, {
                level: 3,
                title: "🐞 Bug Fixes",
                slug: "🐞-bug-fixes",
                normalizedTitle: "🐞 bug fixes",
                charIndex: 995
            }, {
                level: 3,
                title: "🔨 Dependency Upgrades",
                slug: "🔨-dependency-upgrades",
                normalizedTitle: "🔨 dependency upgrades",
                charIndex: 1195
            }],
            headersStr: "工作流支持会签或签、新增 Vue3 管理后台 📈 Statistic ⭐ New Features 🐞 Bug Fixes 🔨 Dependency Upgrades",
            content: "# 工作流支持会签或签、新增 Vue3 管理后台\n\n\n# 📈 Statistic\n\n * 总代码行数：81410\n * 源码代码行数：50413\n * 注释行数：30977\n * 单元测试用例数：671\n\n\n# ⭐ New Features\n\n * 【新增】基于 Vue3 + ElementUI Plus 实现 yudao-ui-admin-vue3 管理后台项目，已完成系统管理 + 基础设施等功能，工作流正在实现中，主要由 @xingyu4j 贡献\n * 【新增】工作流支持会签、或签，可自定义任务分配方式 #212\n * 【新增】接口支持通过 @PermitAll 注解，允许匿名（未登录）进行访问 d9c2da7\n * 【新增】yudao.security.permit-all-urls 配置项，允许匿名（未登录）进行访问 d9c2da7\n * 【新增】Redis 缓存的查询与删除 由 @lwf_org 贡献 #211\n * 【优化】文件表增加 name 字段，记录上传的文件名，由 @manning233 贡献 #186\n * 【优化】基于 Guava 实现 dict 字典数据的本地缓存 d320091\n * 【优化】基于 Guava 实现 tenant 租户数据的本地缓存 992e205\n * 【重构】新增 yudao-spring-boot-starter-biz-error-code 错误码组件，用于错误码的自动创建与加载 7a86a61\n * 【重构】新增 yudao-spring-boot-starter-banner 组件，用于项目启动时打印开发文档、接口文档等 69a3a83\n * 【新增】yudao.access-log.enable 访问日志的开关，默认在 local 环境关闭记录访问日志 9040b17\n * 【新增】yudao.error-code.enable 错误码的开关，默认在 local 环境关闭自动生成错误码 cca8375\n * 【新增】集成 Prometheus 监控点 4dfa816\n * 【移除】去除 Activiti 工作流的支持，专注提供基于 Flowable 提供更强大的工作流能力\n * 【重构】时间区间的过滤条件，从开始和结束时间两个变量，修改为数组，由 @xingyu4j 贡献 dad10d8\n\n\n# 🐞 Bug Fixes\n\n * 【修复】流程审批不通过会报错的问题，由 @wzy_lc 贡献 #215\n * 【修复】Spring Boot Admin 的 prefer-ip 过期，由 @xingyu4j 贡献 63877cf\n * 【修复】环境 test、stage、stage、prod 不打印日志的问题 8a6c48f\n * 【修复】短信验证码的每日发送条数不正确 e5a7b84\n\n\n# 🔨 Dependency Upgrades\n\n * 【升级】spring-boot from 2.6.8 to 2.6.10\n * 【升级】hutool from 5.6.1 to 5.7.22\n * 【升级】druid from 1.2.8 to 1.2.11",
            normalizedContent: "# 工作流支持会签或签、新增 vue3 管理后台\n\n\n# 📈 statistic\n\n * 总代码行数：81410\n * 源码代码行数：50413\n * 注释行数：30977\n * 单元测试用例数：671\n\n\n# ⭐ new features\n\n * 【新增】基于 vue3 + elementui plus 实现 yudao-ui-admin-vue3 管理后台项目，已完成系统管理 + 基础设施等功能，工作流正在实现中，主要由 @xingyu4j 贡献\n * 【新增】工作流支持会签、或签，可自定义任务分配方式 #212\n * 【新增】接口支持通过 @permitall 注解，允许匿名（未登录）进行访问 d9c2da7\n * 【新增】yudao.security.permit-all-urls 配置项，允许匿名（未登录）进行访问 d9c2da7\n * 【新增】redis 缓存的查询与删除 由 @lwf_org 贡献 #211\n * 【优化】文件表增加 name 字段，记录上传的文件名，由 @manning233 贡献 #186\n * 【优化】基于 guava 实现 dict 字典数据的本地缓存 d320091\n * 【优化】基于 guava 实现 tenant 租户数据的本地缓存 992e205\n * 【重构】新增 yudao-spring-boot-starter-biz-error-code 错误码组件，用于错误码的自动创建与加载 7a86a61\n * 【重构】新增 yudao-spring-boot-starter-banner 组件，用于项目启动时打印开发文档、接口文档等 69a3a83\n * 【新增】yudao.access-log.enable 访问日志的开关，默认在 local 环境关闭记录访问日志 9040b17\n * 【新增】yudao.error-code.enable 错误码的开关，默认在 local 环境关闭自动生成错误码 cca8375\n * 【新增】集成 prometheus 监控点 4dfa816\n * 【移除】去除 activiti 工作流的支持，专注提供基于 flowable 提供更强大的工作流能力\n * 【重构】时间区间的过滤条件，从开始和结束时间两个变量，修改为数组，由 @xingyu4j 贡献 dad10d8\n\n\n# 🐞 bug fixes\n\n * 【修复】流程审批不通过会报错的问题，由 @wzy_lc 贡献 #215\n * 【修复】spring boot admin 的 prefer-ip 过期，由 @xingyu4j 贡献 63877cf\n * 【修复】环境 test、stage、stage、prod 不打印日志的问题 8a6c48f\n * 【修复】短信验证码的每日发送条数不正确 e5a7b84\n\n\n# 🔨 dependency upgrades\n\n * 【升级】spring-boot from 2.6.8 to 2.6.10\n * 【升级】hutool from 5.6.1 to 5.7.22\n * 【升级】druid from 1.2.8 to 1.2.11",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【v1.6.1】2022-03-21",
            frontmatter: {
                title: "【v1.6.1】2022-03-21",
                date: "2022-03-10T21:15:32.000Z",
                permalink: "/changelog/1.6.1/"
            },
            regularPath: "/99.%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/91.%E3%80%90v1-6-1%E3%80%912022-03-21.html",
            relativePath: "99.更新日志/91.【v1-6-1】2022-03-21.md",
            key: "v-31567b87",
            path: "/changelog/1.6.1/",
            headers: [{
                level: 2,
                title: "支持 OSS 云存储，优化代码生成",
                slug: "支持-oss-云存储-优化代码生成",
                normalizedTitle: "支持 oss 云存储，优化代码生成",
                charIndex: 2
            }, {
                level: 3,
                title: "📈 Statistic",
                slug: "📈-statistic",
                normalizedTitle: "📈 statistic",
                charIndex: 42
            }, {
                level: 3,
                title: "⭐ New Features",
                slug: "⭐-new-features",
                normalizedTitle: "⭐ new features",
                charIndex: 120
            }, {
                level: 3,
                title: "🐞 Bug Fixes",
                slug: "🐞-bug-fixes",
                normalizedTitle: "🐞 bug fixes",
                charIndex: 540
            }, {
                level: 3,
                title: "🔨 Dependency Upgrades",
                slug: "🔨-dependency-upgrades",
                normalizedTitle: "🔨 dependency upgrades",
                charIndex: 731
            }],
            headersStr: "支持 OSS 云存储，优化代码生成 📈 Statistic ⭐ New Features 🐞 Bug Fixes 🔨 Dependency Upgrades",
            content: "# 支持 OSS 云存储，优化代码生成\n\n对应 版本 1.6.1 功能列表\n\n\n# 📈 Statistic\n\n * 总代码行数：77279\n * 源码代码行数：47812\n * 注释行数：17676\n * 单元测试用例数：537\n\n\n# ⭐ New Features\n\n * 【优化】文件存储的功能，支持将文件存储到 S3（MinIO、阿里云、腾讯云、七牛云）、本地、FTP、SFTP、数据库等 #98\n * 【新增】《开发文档》的代码生成（新增功能）、功能权限、上传下载等小节完成，可访问 https://doc.iocoder.cn 地址\n * 【新增】开发环境下，管理后台每个菜单展示对应的《开发文档》的说明 code\n * 【新增】《开发文档》的工作流、代码生成（新增功能）、功能权限、数据权限等小节完成，可访问 https://doc.iocoder.cn 地址\n * 【优化】将 yudao-module-tool 合并到 yudao-module-infra 模块，统一基础设施 #94\n * 【优化】代码生成时，额外生成 MyBatis Mapper XML 文件 #96\n * 【新增】开启 TopNav 时，没有子菜单的情况下，隐藏侧边栏 code\n\n\n# 🐞 Bug Fixes\n\n * 【修复】仅本人数据权限时，个人中心会报错的问题 #97\n * 【修复】修改租户套餐的权限时，本地缓存刷新错误的问题 #99\n * 【修复】删除菜单、角色时，本地缓存未刷新的问题 code\n * 【修复】登录界面输入不存在的租户时，导致后续请求报错的问题 code\n * 【修复】登录超时刷新页面时，跳转登录页面还提示重新登录问题 code\n\n\n# 🔨 Dependency Upgrades\n\n * 【升级】apollo-client from 1.7.0 to 1.9.2\n * 【升级】guide from 4.1.0 to 5.1.0 ：解决 Apollo 在 JDK 17 无法启动的问题",
            normalizedContent: "# 支持 oss 云存储，优化代码生成\n\n对应 版本 1.6.1 功能列表\n\n\n# 📈 statistic\n\n * 总代码行数：77279\n * 源码代码行数：47812\n * 注释行数：17676\n * 单元测试用例数：537\n\n\n# ⭐ new features\n\n * 【优化】文件存储的功能，支持将文件存储到 s3（minio、阿里云、腾讯云、七牛云）、本地、ftp、sftp、数据库等 #98\n * 【新增】《开发文档》的代码生成（新增功能）、功能权限、上传下载等小节完成，可访问 https://doc.iocoder.cn 地址\n * 【新增】开发环境下，管理后台每个菜单展示对应的《开发文档》的说明 code\n * 【新增】《开发文档》的工作流、代码生成（新增功能）、功能权限、数据权限等小节完成，可访问 https://doc.iocoder.cn 地址\n * 【优化】将 yudao-module-tool 合并到 yudao-module-infra 模块，统一基础设施 #94\n * 【优化】代码生成时，额外生成 mybatis mapper xml 文件 #96\n * 【新增】开启 topnav 时，没有子菜单的情况下，隐藏侧边栏 code\n\n\n# 🐞 bug fixes\n\n * 【修复】仅本人数据权限时，个人中心会报错的问题 #97\n * 【修复】修改租户套餐的权限时，本地缓存刷新错误的问题 #99\n * 【修复】删除菜单、角色时，本地缓存未刷新的问题 code\n * 【修复】登录界面输入不存在的租户时，导致后续请求报错的问题 code\n * 【修复】登录超时刷新页面时，跳转登录页面还提示重新登录问题 code\n\n\n# 🔨 dependency upgrades\n\n * 【升级】apollo-client from 1.7.0 to 1.9.2\n * 【升级】guide from 4.1.0 to 5.1.0 ：解决 apollo 在 jdk 17 无法启动的问题",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【v1.6.2】2022-06-05",
            frontmatter: {
                title: "【v1.6.2】2022-06-05",
                date: "2022-03-26T21:15:32.000Z",
                permalink: "/changelog/1.6.2/"
            },
            regularPath: "/99.%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/90.%E3%80%90v1-6-2%E3%80%912022-06-05.html",
            relativePath: "99.更新日志/90.【v1-6-2】2022-06-05.md",
            key: "v-79b60e27",
            path: "/changelog/1.6.2/",
            headers: [{
                level: 2,
                title: "新增 OAuth 2.0、SSO 单点登录、多种数据库支持等功能",
                slug: "新增-oauth-2-0、sso-单点登录、多种数据库支持等功能",
                normalizedTitle: "新增 oauth 2.0、sso 单点登录、多种数据库支持等功能",
                charIndex: 2
            }, {
                level: 3,
                title: "📈 Statistic",
                slug: "📈-statistic",
                normalizedTitle: "📈 statistic",
                charIndex: 57
            }, {
                level: 3,
                title: "⭐ New Features",
                slug: "⭐-new-features",
                normalizedTitle: "⭐ new features",
                charIndex: 135
            }, {
                level: 3,
                title: "🐞 Bug Fixes",
                slug: "🐞-bug-fixes",
                normalizedTitle: "🐞 bug fixes",
                charIndex: 1473
            }, {
                level: 3,
                title: "🔨 Dependency Upgrades",
                slug: "🔨-dependency-upgrades",
                normalizedTitle: "🔨 dependency upgrades",
                charIndex: 2138
            }],
            headersStr: "新增 OAuth 2.0、SSO 单点登录、多种数据库支持等功能 📈 Statistic ⭐ New Features 🐞 Bug Fixes 🔨 Dependency Upgrades",
            content: "# 新增 OAuth 2.0、SSO 单点登录、多种数据库支持等功能\n\n对应 版本 1.6.2 功能列表\n\n\n# 📈 Statistic\n\n * 总代码行数：84846\n * 源码代码行数：52792\n * 注释行数：19234\n * 单元测试用例数：671\n\n\n# ⭐ New Features\n\n * 【新增】对 PostgreSQL 数据库的支持 #151 感谢这个过程中怪物的帮助！\n * 【新增】对 Oracle 数据库的支持 #152 感谢这个过程中 安贞、品霖的帮助！\n * 【新增】对 SQL Server 数据库的支持 #153 感谢这个过程中 Simon、蜉蝣无垠、牛希尧的帮助！\n * 【新增】《开发指南 —— 后端手册》的接口文档、三方登录、异常处理（错误码）、参数校验、分页实现、系统日志、数据库 MyBatis、多数据源、缓存 Redis、本地缓存、定时任务、消息队列、配置中心、单元测试、分布式锁、幂等性、限流熔断、数据库文档、短信配置、开发环境...\n * 【新增】《开发指南 —— 运维手册》的开发环境、Linux 部署、Docker 部署、Jenkins 部署、HTTPS 证书、服务监控...\n * 【新增】《开发指南 —— 前端手册》的开发规范、菜单路由、Icon 图标、字典数据、系统组件、通用方法、配置读取...\n * 【新增】手机验证码登录，美化登录界面，由 #155 贡献\n * 【新增】一键改包的程序，快速将项目的 Maven、包名等信息替换成你的 #110\n * 【新增】菜单新增是否缓存、是否隐藏的字段 #133 #172\n * 【新增】Spring Cache 声明式缓存，使用 Redis 存储 code\n * 【新增】腾讯云短信，由 swpthebest 贡献 #118\n * 【新增】敏感词，由 dachuan 贡献 #121\n * 【新增】数据源配置，为多租户、代码生成支持动态数据源做准备 #138\n * 【新增】用户 Token 采用 OAuth2.0 的 Access Token + Refresh Token，提升安全性 #166\n * 【新增】基于 OAuth2.0 实现 SSO 单点登录 #176\n * 【新增】用户与岗位的关联表，由 anzhen-tech 贡献 #113\n * 【新增】MyBatis 字段的加解密功能 code\n * 【新增】集成微信 Native、小程序的支付能力，支持 v2 和 v3 的回调数据处理 #142\n * 【优化】yudao-module-xx-impl 调整成 yudao-module-xx-biz，更加符合定位 code\n * 【优化】简化三方登录的实现，降低理解成本 #137\n * 【优化】去除 yudao-module-system、yudao-module-infra 对 yudao-module-member 的依赖 #122\n * 【优化】yudao-framework-test 测试组件的封装，内置 Redis、DB 等多种快速测试的基类 code\n * 【优化】配置指定默认的 npm 镜像源 #170\n * 【优化】字典管理、通知管理、岗位管理、角色管理、错误码管理的排序显示 #174\n * 【优化】前端 Token、账号、密码等信息，统一使用 LocalStorage 替代 Cookie 存储 code\n * 【优化】上传文件的类型识别，增加基于 filename 的读取 code\n\n\n# 🐞 Bug Fixes\n\n * 【修复】角色菜单集合复选框回显不正确 #107\n * 【修复】工作流 BPMN 图的 canvas 自适应，解决展示补全的问题 #104\n * 【修复】API 访问日志不记录的问题 code\n * 【修复】修复忽略租户的 URL，未带租户会报错的问题 code\n * 【修复】菜单无法使用外链的问题 code\n * 【修复】代码生成器的 vue 模板中，导出 Excel 文件时，文件名未格式化的问题 #133\n * 【修复】代码生成时，对话框的日期选择器，在编辑情况下不能回显 #135\n * 【修复】在 Windows 下 ftp 上传和下载存在报错的问题 #156\n * 【修复】图片上传组件 ImageUpload 上传报错的问题 code\n * 【修复】文件上传组件 FileUpload 上传报错的问题 code\n * 【修复】form generator 组件上传文件、图片报错的问题 code\n * 【修复】富文本编辑器的 Editor 的图片上传报错的问题 code\n * 【修复】DO 生成模板，当主键是 String 类型，模板有误 #167\n * 【修复】创建用户不分配角色的情况会存在空指针 #171\n * 【修复】yudao-ui-admin 启动告警 #173\n * 【修复】新建的用户未分配角色时，操作自己信息回报错的问题 code\n * 【修复】工作流的编辑无法撤回、crtl 选中的问题 code\n * 【修复】支付宝通知回调 BUG 修复 #142\n\n\n# 🔨 Dependency Upgrades\n\n * 【升级】spring-boot from 2.5.10 to 2.6.8 ：修复 RCE 漏洞，并且 2.5.X 结束声明周期\n * 【升级】redisson from 3.16.6 to 3.17.3 ：提升 Redisson 客户端的稳定性\n * 【升级】mysql-connector-java from 5.1.46 to 8.0.28 ：提升 MySQL 客户端的性能\n * 【升级】Knife4j from from 3.0.2 to 3.0.3\n * 【升级】swagger-annotations from 1.5.22 to 1.6.6\n * 【升级】spring-boot-admin from 2.6.2 to 2.6.7\n * 【升级】fastjson from 1.2.73 to 2.0.5\n * 【升级】resilience4j from 1.7.0 to 1.7.1\n * 【升级】jackson from 2.12.6 to 2.13.3\n * 【升级】spring-mvc from 5.3.16 to 5.3.20\n * 【升级】spring-security from 5.5.5 to 5.6.5\n * 【升级】hibernate-validator from 6.2.2 to 6.2.3\n * 【升级】junit from 5.7.2 to 5.8.2\n * 【升级】mockito from 3.9.0 to 4.0.0\n * 【升级】mybatis-plus from 3.4.3.4 to 3.5.2",
            normalizedContent: "# 新增 oauth 2.0、sso 单点登录、多种数据库支持等功能\n\n对应 版本 1.6.2 功能列表\n\n\n# 📈 statistic\n\n * 总代码行数：84846\n * 源码代码行数：52792\n * 注释行数：19234\n * 单元测试用例数：671\n\n\n# ⭐ new features\n\n * 【新增】对 postgresql 数据库的支持 #151 感谢这个过程中怪物的帮助！\n * 【新增】对 oracle 数据库的支持 #152 感谢这个过程中 安贞、品霖的帮助！\n * 【新增】对 sql server 数据库的支持 #153 感谢这个过程中 simon、蜉蝣无垠、牛希尧的帮助！\n * 【新增】《开发指南 —— 后端手册》的接口文档、三方登录、异常处理（错误码）、参数校验、分页实现、系统日志、数据库 mybatis、多数据源、缓存 redis、本地缓存、定时任务、消息队列、配置中心、单元测试、分布式锁、幂等性、限流熔断、数据库文档、短信配置、开发环境...\n * 【新增】《开发指南 —— 运维手册》的开发环境、linux 部署、docker 部署、jenkins 部署、https 证书、服务监控...\n * 【新增】《开发指南 —— 前端手册》的开发规范、菜单路由、icon 图标、字典数据、系统组件、通用方法、配置读取...\n * 【新增】手机验证码登录，美化登录界面，由 #155 贡献\n * 【新增】一键改包的程序，快速将项目的 maven、包名等信息替换成你的 #110\n * 【新增】菜单新增是否缓存、是否隐藏的字段 #133 #172\n * 【新增】spring cache 声明式缓存，使用 redis 存储 code\n * 【新增】腾讯云短信，由 swpthebest 贡献 #118\n * 【新增】敏感词，由 dachuan 贡献 #121\n * 【新增】数据源配置，为多租户、代码生成支持动态数据源做准备 #138\n * 【新增】用户 token 采用 oauth2.0 的 access token + refresh token，提升安全性 #166\n * 【新增】基于 oauth2.0 实现 sso 单点登录 #176\n * 【新增】用户与岗位的关联表，由 anzhen-tech 贡献 #113\n * 【新增】mybatis 字段的加解密功能 code\n * 【新增】集成微信 native、小程序的支付能力，支持 v2 和 v3 的回调数据处理 #142\n * 【优化】yudao-module-xx-impl 调整成 yudao-module-xx-biz，更加符合定位 code\n * 【优化】简化三方登录的实现，降低理解成本 #137\n * 【优化】去除 yudao-module-system、yudao-module-infra 对 yudao-module-member 的依赖 #122\n * 【优化】yudao-framework-test 测试组件的封装，内置 redis、db 等多种快速测试的基类 code\n * 【优化】配置指定默认的 npm 镜像源 #170\n * 【优化】字典管理、通知管理、岗位管理、角色管理、错误码管理的排序显示 #174\n * 【优化】前端 token、账号、密码等信息，统一使用 localstorage 替代 cookie 存储 code\n * 【优化】上传文件的类型识别，增加基于 filename 的读取 code\n\n\n# 🐞 bug fixes\n\n * 【修复】角色菜单集合复选框回显不正确 #107\n * 【修复】工作流 bpmn 图的 canvas 自适应，解决展示补全的问题 #104\n * 【修复】api 访问日志不记录的问题 code\n * 【修复】修复忽略租户的 url，未带租户会报错的问题 code\n * 【修复】菜单无法使用外链的问题 code\n * 【修复】代码生成器的 vue 模板中，导出 excel 文件时，文件名未格式化的问题 #133\n * 【修复】代码生成时，对话框的日期选择器，在编辑情况下不能回显 #135\n * 【修复】在 windows 下 ftp 上传和下载存在报错的问题 #156\n * 【修复】图片上传组件 imageupload 上传报错的问题 code\n * 【修复】文件上传组件 fileupload 上传报错的问题 code\n * 【修复】form generator 组件上传文件、图片报错的问题 code\n * 【修复】富文本编辑器的 editor 的图片上传报错的问题 code\n * 【修复】do 生成模板，当主键是 string 类型，模板有误 #167\n * 【修复】创建用户不分配角色的情况会存在空指针 #171\n * 【修复】yudao-ui-admin 启动告警 #173\n * 【修复】新建的用户未分配角色时，操作自己信息回报错的问题 code\n * 【修复】工作流的编辑无法撤回、crtl 选中的问题 code\n * 【修复】支付宝通知回调 bug 修复 #142\n\n\n# 🔨 dependency upgrades\n\n * 【升级】spring-boot from 2.5.10 to 2.6.8 ：修复 rce 漏洞，并且 2.5.x 结束声明周期\n * 【升级】redisson from 3.16.6 to 3.17.3 ：提升 redisson 客户端的稳定性\n * 【升级】mysql-connector-java from 5.1.46 to 8.0.28 ：提升 mysql 客户端的性能\n * 【升级】knife4j from from 3.0.2 to 3.0.3\n * 【升级】swagger-annotations from 1.5.22 to 1.6.6\n * 【升级】spring-boot-admin from 2.6.2 to 2.6.7\n * 【升级】fastjson from 1.2.73 to 2.0.5\n * 【升级】resilience4j from 1.7.0 to 1.7.1\n * 【升级】jackson from 2.12.6 to 2.13.3\n * 【升级】spring-mvc from 5.3.16 to 5.3.20\n * 【升级】spring-security from 5.5.5 to 5.6.5\n * 【升级】hibernate-validator from 6.2.2 to 6.2.3\n * 【升级】junit from 5.7.2 to 5.8.2\n * 【升级】mockito from 3.9.0 to 4.0.0\n * 【升级】mybatis-plus from 3.4.3.4 to 3.5.2",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【v1.5.1】2022-02-28",
            frontmatter: {
                title: "【v1.5.1】2022-02-28",
                date: "2022-03-10T12:48:42.000Z",
                permalink: "/changelog/1.5.1"
            },
            regularPath: "/99.%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/93.%E3%80%90v1-5-1%E3%80%912022-02-28.html",
            relativePath: "99.更新日志/93.【v1-5-1】2022-02-28.md",
            key: "v-790095a7",
            path: "/changelog/1.5.1/",
            headers: [{
                level: 2,
                title: "优化多租户功能，新增租户套餐，增强多租户封装",
                slug: "优化多租户功能-新增租户套餐-增强多租户封装",
                normalizedTitle: "优化多租户功能，新增租户套餐，增强多租户封装",
                charIndex: 2
            }, {
                level: 3,
                title: "📈 Statistic",
                slug: "📈-statistic",
                normalizedTitle: "📈 statistic",
                charIndex: 84
            }, {
                level: 3,
                title: "⭐ New Features",
                slug: "⭐-new-features",
                normalizedTitle: "⭐ new features",
                charIndex: 162
            }, {
                level: 3,
                title: "🐞 Bug Fixes",
                slug: "🐞-bug-fixes",
                normalizedTitle: "🐞 bug fixes",
                charIndex: 633
            }, {
                level: 3,
                title: "🔨 Dependency Upgrades",
                slug: "🔨-dependency-upgrades",
                normalizedTitle: "🔨 dependency upgrades",
                charIndex: 744
            }],
            headersStr: "优化多租户功能，新增租户套餐，增强多租户封装 📈 Statistic ⭐ New Features 🐞 Bug Fixes 🔨 Dependency Upgrades",
            content: "# 优化多租户功能，新增租户套餐，增强多租户封装\n\n * 创建租户时，自动创建用户、角色等信息\n * 支持租户套餐，自定义每个租户的菜单、操作、按钮等权限信息\n\n\n# 📈 Statistic\n\n * 总代码行数：71249\n * 源码代码行数：43921\n * 注释行数：16341\n * 单元测试用例数：341\n\n\n# ⭐ New Features\n\n * 【新增】后端 yudao.tenant.enable 配置项，前端 VUE_APP_TENANT_ENABLE 配置项，用于开关租户功能。 commit\n * 【优化】调整默认所有表开启多租户的特性，可通过 yudao.tenant.ignore-tables 配置项进行忽略，替代原本默认不开启的策略 commit\n * 【新增】通过 yudao.tenant.ignore-urls 配置忽略多租户的请求，例如说 ，例如说短信回调、支付回调等 Open API commit\n * 【新增】新增 @TenantIgnore 注解，标记指定方法，忽略多租户的自动过滤，适合实现跨租户的逻辑 commit\n * 【新增】租户套餐的管理，可配置每个租户的可使用的功能权限 commit\n * 【优化】新建租户时，自动创建对应的管理员账号、角色等基础信息 commit\n * 【优化】Redis 最低版本 5.0.0 检测，解决搭建环境过程中无法理解 XREADGROUP 指令的报错 commit\n\n\n# 🐞 Bug Fixes\n\n * 【修复】修复不支持根部门的问题 commit\n * 【修复】错误码存在重复的问题 commit\n * 【修复】角色的数据范围为仅本人时，登录后获取权限列表报错的问题 commit\n\n\n# 🔨 Dependency Upgrades\n\n * 【升级】spring-boot from 2.5.9 to 2.5.10\n * 【升级】mybatis-plus from 3.4.3.4 to 3.5.1",
            normalizedContent: "# 优化多租户功能，新增租户套餐，增强多租户封装\n\n * 创建租户时，自动创建用户、角色等信息\n * 支持租户套餐，自定义每个租户的菜单、操作、按钮等权限信息\n\n\n# 📈 statistic\n\n * 总代码行数：71249\n * 源码代码行数：43921\n * 注释行数：16341\n * 单元测试用例数：341\n\n\n# ⭐ new features\n\n * 【新增】后端 yudao.tenant.enable 配置项，前端 vue_app_tenant_enable 配置项，用于开关租户功能。 commit\n * 【优化】调整默认所有表开启多租户的特性，可通过 yudao.tenant.ignore-tables 配置项进行忽略，替代原本默认不开启的策略 commit\n * 【新增】通过 yudao.tenant.ignore-urls 配置忽略多租户的请求，例如说 ，例如说短信回调、支付回调等 open api commit\n * 【新增】新增 @tenantignore 注解，标记指定方法，忽略多租户的自动过滤，适合实现跨租户的逻辑 commit\n * 【新增】租户套餐的管理，可配置每个租户的可使用的功能权限 commit\n * 【优化】新建租户时，自动创建对应的管理员账号、角色等基础信息 commit\n * 【优化】redis 最低版本 5.0.0 检测，解决搭建环境过程中无法理解 xreadgroup 指令的报错 commit\n\n\n# 🐞 bug fixes\n\n * 【修复】修复不支持根部门的问题 commit\n * 【修复】错误码存在重复的问题 commit\n * 【修复】角色的数据范围为仅本人时，登录后获取权限列表报错的问题 commit\n\n\n# 🔨 dependency upgrades\n\n * 【升级】spring-boot from 2.5.9 to 2.5.10\n * 【升级】mybatis-plus from 3.4.3.4 to 3.5.1",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【v1.6.0】2022-03-10",
            frontmatter: {
                title: "【v1.6.0】2022-03-10",
                date: "2022-03-10T12:48:42.000Z",
                permalink: "/changelog/1.6.0"
            },
            regularPath: "/99.%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/92.%E3%80%90v1-6-0%E3%80%912022-03-10.html",
            relativePath: "99.更新日志/92.【v1-6-0】2022-03-10.md",
            key: "v-4ef2e2f2",
            path: "/changelog/1.6.0/",
            headers: [{
                level: 2,
                title: "支持 Flowable 工作流，发布开发文档",
                slug: "支持-flowable-工作流-发布开发文档",
                normalizedTitle: "支持 flowable 工作流，发布开发文档",
                charIndex: 2
            }, {
                level: 3,
                title: "📈 Statistic",
                slug: "📈-statistic",
                normalizedTitle: "📈 statistic",
                charIndex: 160
            }, {
                level: 3,
                title: "⭐ New Features",
                slug: "⭐-new-features",
                normalizedTitle: "⭐ new features",
                charIndex: 238
            }, {
                level: 3,
                title: "🐞 Bug Fixes",
                slug: "🐞-bug-fixes",
                normalizedTitle: "🐞 bug fixes",
                charIndex: 406
            }, {
                level: 3,
                title: "🔨 Dependency Upgrades",
                slug: "🔨-dependency-upgrades",
                normalizedTitle: "🔨 dependency upgrades",
                charIndex: 502
            }],
            headersStr: "支持 Flowable 工作流，发布开发文档 📈 Statistic ⭐ New Features 🐞 Bug Fixes 🔨 Dependency Upgrades",
            content: "# 支持 Flowable 工作流，发布开发文档\n\n * 基于 Flowable 实现工作流，可见 yudao-module-bpm-impl-flowable 模块。\n\n> 友情提示：原本 Activiti 实现的工作流，在 yudao-module-bpm-impl-activiti 模块，保持同步更新。\n\n\n# 📈 Statistic\n\n * 总代码行数：75008\n * 源码代码行数：46416\n * 注释行数：17132\n * 单元测试用例数：341\n\n\n# ⭐ New Features\n\n * 【新增】 yudao-module-bpm-impl-flowable 模块，实现 Flowable 工作流 #88\n * 【新增】《开发文档》的简介、功能列表、快速启动、技术选型、项目结构、新建模块、SaaS 多租户等小节完成，可访问 https://doc.iocoder.cn 地址\n\n\n# 🐞 Bug Fixes\n\n * 【修复】正常租户登录后退出，切换到过期租户时造成的 tenant.ignore-urls 配置失效的问题，比如无法获取验证码图片造成无法登录 #91\n\n\n# 🔨 Dependency Upgrades\n\n暂无，计划升级 Spring Boot 2.6.X",
            normalizedContent: "# 支持 flowable 工作流，发布开发文档\n\n * 基于 flowable 实现工作流，可见 yudao-module-bpm-impl-flowable 模块。\n\n> 友情提示：原本 activiti 实现的工作流，在 yudao-module-bpm-impl-activiti 模块，保持同步更新。\n\n\n# 📈 statistic\n\n * 总代码行数：75008\n * 源码代码行数：46416\n * 注释行数：17132\n * 单元测试用例数：341\n\n\n# ⭐ new features\n\n * 【新增】 yudao-module-bpm-impl-flowable 模块，实现 flowable 工作流 #88\n * 【新增】《开发文档》的简介、功能列表、快速启动、技术选型、项目结构、新建模块、saas 多租户等小节完成，可访问 https://doc.iocoder.cn 地址\n\n\n# 🐞 bug fixes\n\n * 【修复】正常租户登录后退出，切换到过期租户时造成的 tenant.ignore-urls 配置失效的问题，比如无法获取验证码图片造成无法登录 #91\n\n\n# 🔨 dependency upgrades\n\n暂无，计划升级 spring boot 2.6.x",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【v1.5.0】2022-02-17",
            frontmatter: {
                title: "【v1.5.0】2022-02-17",
                date: "2022-03-10T12:48:42.000Z",
                permalink: "/changelog/1.5.0"
            },
            regularPath: "/99.%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/94.%E3%80%90v1-5-0%E3%80%912022-02-17.html",
            relativePath: "99.更新日志/94.【v1-5-0】2022-02-17.md",
            key: "v-2030a8a7",
            path: "/changelog/1.5.0/",
            headers: [{
                level: 2,
                title: "重构成多 Maven Module 的代码结构",
                slug: "重构成多-maven-module-的代码结构",
                normalizedTitle: "重构成多 maven module 的代码结构",
                charIndex: 2
            }, {
                level: 3,
                title: "📈 Statistic",
                slug: "📈-statistic",
                normalizedTitle: "📈 statistic",
                charIndex: 124
            }, {
                level: 3,
                title: "⭐ New Features",
                slug: "⭐-new-features",
                normalizedTitle: "⭐ new features",
                charIndex: 202
            }, {
                level: 3,
                title: "🐞 Bug Fixes",
                slug: "🐞-bug-fixes",
                normalizedTitle: "🐞 bug fixes",
                charIndex: 672
            }, {
                level: 3,
                title: "🔨 Dependency Upgrades",
                slug: "🔨-dependency-upgrades",
                normalizedTitle: "🔨 dependency upgrades",
                charIndex: 1061
            }],
            headersStr: "重构成多 Maven Module 的代码结构 📈 Statistic ⭐ New Features 🐞 Bug Fixes 🔨 Dependency Upgrades",
            content: "# 重构成多 Maven Module 的代码结构\n\n * 修复各种多 Maven Module 重构带来的 Bug，感谢大量群友的 PR 支持！\n * 跟进 ruoyi-vue 3.4.0 ~ 3.8.1 版本，感谢这么优秀的开源项目！\n\n\n# 📈 Statistic\n\n * 总代码行数：69299\n * 源码代码行数：42687\n * 注释行数：15888\n * 单元测试用例数：278\n\n\n# ⭐ New Features\n\n * 【优化】使用 Lombok 简化 JsonUtils 工具类 #73\n * 【新增】兼容 Node 16 版本，通过升级 BPMN-JS 相关库 commit\n * 【新增】前端的表格右侧工具栏组件支持显隐列，具体可见【用户管理】功能 commit\n * 【新增】前端的菜单导航显示风格 TopNav（false 为 左侧导航菜单，true 为顶部导航菜单），支持布局的保存与重置 commit1 commit2\n * 【新增】前端的网页标题支持根据选择的菜单，动态展示标题 commit\n * 【新增】字典标签样式回显，例如说开启的状态展示为 primary 蓝色，禁用的状态为 info 灰色 commit\n * 【新增】前端的 iframe 组件，方便内嵌网页 commit\n * 【新增】在基础设施-配置管理菜单，可通过修改 yudao.captcha.enable 配置项，动态修改登录是否需要验证码 commit\n * 【新增】在代码生成的预览界面，支持一键复制代码 commit\n\n\n# 🐞 Bug Fixes\n\n * 【修复】数据权限的 DEPT_AND_CHILD 范围时，未设置自己所在的部门 #72\n * 【修复】Knife4j 接口文档 404 的问题，原因是 spring.mvc.static-path-pattern 配置项，影响了基础路径 commit\n * 【修复】修复文件访问地址错误 #68\n * 【修复】工作流程发起以及审批异常，由 @NotEmpty 校验、和 Long 类型异常导致 #73\n * 【修复】自定义 DefaultStreamMessageListenerContainerX 实现，解决 Redisson Stream 读取不到数据返回 null 导致 NPE 问题 commit\n * 【修复】部门更新后，本地缓存不刷新的问题 #77\n * 【修复】获取拥有指定的角色用户时，返回错误的 id 编号 #79\n\n\n# 🔨 Dependency Upgrades\n\n*【修复】Maven 构建的一些错误提示 #78",
            normalizedContent: "# 重构成多 maven module 的代码结构\n\n * 修复各种多 maven module 重构带来的 bug，感谢大量群友的 pr 支持！\n * 跟进 ruoyi-vue 3.4.0 ~ 3.8.1 版本，感谢这么优秀的开源项目！\n\n\n# 📈 statistic\n\n * 总代码行数：69299\n * 源码代码行数：42687\n * 注释行数：15888\n * 单元测试用例数：278\n\n\n# ⭐ new features\n\n * 【优化】使用 lombok 简化 jsonutils 工具类 #73\n * 【新增】兼容 node 16 版本，通过升级 bpmn-js 相关库 commit\n * 【新增】前端的表格右侧工具栏组件支持显隐列，具体可见【用户管理】功能 commit\n * 【新增】前端的菜单导航显示风格 topnav（false 为 左侧导航菜单，true 为顶部导航菜单），支持布局的保存与重置 commit1 commit2\n * 【新增】前端的网页标题支持根据选择的菜单，动态展示标题 commit\n * 【新增】字典标签样式回显，例如说开启的状态展示为 primary 蓝色，禁用的状态为 info 灰色 commit\n * 【新增】前端的 iframe 组件，方便内嵌网页 commit\n * 【新增】在基础设施-配置管理菜单，可通过修改 yudao.captcha.enable 配置项，动态修改登录是否需要验证码 commit\n * 【新增】在代码生成的预览界面，支持一键复制代码 commit\n\n\n# 🐞 bug fixes\n\n * 【修复】数据权限的 dept_and_child 范围时，未设置自己所在的部门 #72\n * 【修复】knife4j 接口文档 404 的问题，原因是 spring.mvc.static-path-pattern 配置项，影响了基础路径 commit\n * 【修复】修复文件访问地址错误 #68\n * 【修复】工作流程发起以及审批异常，由 @notempty 校验、和 long 类型异常导致 #73\n * 【修复】自定义 defaultstreammessagelistenercontainerx 实现，解决 redisson stream 读取不到数据返回 null 导致 npe 问题 commit\n * 【修复】部门更新后，本地缓存不刷新的问题 #77\n * 【修复】获取拥有指定的角色用户时，返回错误的 id 编号 #79\n\n\n# 🔨 dependency upgrades\n\n*【修复】maven 构建的一些错误提示 #78",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【v1.4.0】2022-02-04",
            frontmatter: {
                title: "【v1.4.0】2022-02-04",
                date: "2022-03-10T12:48:42.000Z",
                permalink: "/changelog/1.4.0"
            },
            regularPath: "/99.%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/95.%E3%80%90v1-4-0%E3%80%912022-02-04.html",
            relativePath: "99.更新日志/95.【v1-4-0】2022-02-04.md",
            key: "v-406aafe7",
            path: "/changelog/1.4.0/",
            headers: [{
                level: 2,
                title: "重构成多 Maven Module 的代码结构",
                slug: "重构成多-maven-module-的代码结构",
                normalizedTitle: "重构成多 maven module 的代码结构",
                charIndex: 2
            }, {
                level: 3,
                title: "📈 Statistic",
                slug: "📈-statistic",
                normalizedTitle: "📈 statistic",
                charIndex: 74
            }, {
                level: 3,
                title: "⭐ New Features",
                slug: "⭐-new-features",
                normalizedTitle: "⭐ new features",
                charIndex: 152
            }, {
                level: 3,
                title: "🐞 Bug Fixes",
                slug: "🐞-bug-fixes",
                normalizedTitle: "🐞 bug fixes",
                charIndex: 719
            }, {
                level: 3,
                title: "🔨 Dependency Upgrades",
                slug: "🔨-dependency-upgrades",
                normalizedTitle: "🔨 dependency upgrades",
                charIndex: 882
            }],
            headersStr: "重构成多 Maven Module 的代码结构 📈 Statistic ⭐ New Features 🐞 Bug Fixes 🔨 Dependency Upgrades",
            content: "# 重构成多 Maven Module 的代码结构\n\n大版本重构，基于 Maven Module 的方式拆分多模块，希望大家多多提点建议！\n\n\n# 📈 Statistic\n\n * 总代码行数：69118\n * 源码代码行数：42571\n * 注释行数：15847\n * 单元测试用例数：278\n\n\n# ⭐ New Features\n\n * 【重构】大模块按照多 Maven Module 的方式拆分，提升可维护性，为后续重构 yudao-cloud 提供基础\n * 【移除】将 yudao-core-service 模块移除，替换成每个 Maven Module 暴露对应的 yudao-module-***-api 模块\n * 【新增】Spring Security 支持读取多种用户类型，从不同的数据库表，从而实现单项目提供管理后台、用户 APP 的不同 RESTful API 接口\n * 【新增】Spring Security 新增 AuthorizeRequestsCustomizer 抽象类， 自定义每个 Maven Module 的 URL 的安全配置\n * 【新增】代码生成器支持多 Maven Module 的方式生成代码，支持管理后台、用户 APP 两种场景的 RESTful API 的生成，支持 H2 SQL 脚本的生成\n * 【新增】每次发布大版本时，将 yudao-ui-admin 编译后，放到 yudao-server 项目中，可以快速体验，无需搭建前端开发环境\n * 【重构】将数据库文档调整到 tool 模块，更加明确\n * 【优化】代码生成器的前端展示效果，例如说 Java 包路径合并\n\n\n# 🐞 Bug Fixes\n\n * 【修复】用户无权限访问 指定 API 时，未返回 FORBIDDEN 结果码\n * 【修复】定时任务刷新本地缓存时，无租户上线文，导致查询报错\n * 【修复】配置中心只加载了删除的配置\n * 【修复】管理后台 UI 超时登录后，返回登录界面时，由于未登录加载不到信息，导致报错的问题\n\n\n# 🔨 Dependency Upgrades\n\n * 【升级】spring-boot from 2.4.12 to 2.5.9，最新的 Spring Boot 2.6.X 在等更流行一些，稳定第一\n * 【升级】Spring Boot Admin from 2.3.2 to 2.6.2，提供更好的监控能力\n * 【移除】Apache FreeMarker 依赖，修改 Screw 使用 Velocity 作为模板引擎\n * 【升级】redisson from 3.16.6 to 3.16.8",
            normalizedContent: "# 重构成多 maven module 的代码结构\n\n大版本重构，基于 maven module 的方式拆分多模块，希望大家多多提点建议！\n\n\n# 📈 statistic\n\n * 总代码行数：69118\n * 源码代码行数：42571\n * 注释行数：15847\n * 单元测试用例数：278\n\n\n# ⭐ new features\n\n * 【重构】大模块按照多 maven module 的方式拆分，提升可维护性，为后续重构 yudao-cloud 提供基础\n * 【移除】将 yudao-core-service 模块移除，替换成每个 maven module 暴露对应的 yudao-module-***-api 模块\n * 【新增】spring security 支持读取多种用户类型，从不同的数据库表，从而实现单项目提供管理后台、用户 app 的不同 restful api 接口\n * 【新增】spring security 新增 authorizerequestscustomizer 抽象类， 自定义每个 maven module 的 url 的安全配置\n * 【新增】代码生成器支持多 maven module 的方式生成代码，支持管理后台、用户 app 两种场景的 restful api 的生成，支持 h2 sql 脚本的生成\n * 【新增】每次发布大版本时，将 yudao-ui-admin 编译后，放到 yudao-server 项目中，可以快速体验，无需搭建前端开发环境\n * 【重构】将数据库文档调整到 tool 模块，更加明确\n * 【优化】代码生成器的前端展示效果，例如说 java 包路径合并\n\n\n# 🐞 bug fixes\n\n * 【修复】用户无权限访问 指定 api 时，未返回 forbidden 结果码\n * 【修复】定时任务刷新本地缓存时，无租户上线文，导致查询报错\n * 【修复】配置中心只加载了删除的配置\n * 【修复】管理后台 ui 超时登录后，返回登录界面时，由于未登录加载不到信息，导致报错的问题\n\n\n# 🔨 dependency upgrades\n\n * 【升级】spring-boot from 2.4.12 to 2.5.9，最新的 spring boot 2.6.x 在等更流行一些，稳定第一\n * 【升级】spring boot admin from 2.3.2 to 2.6.2，提供更好的监控能力\n * 【移除】apache freemarker 依赖，修改 screw 使用 velocity 作为模板引擎\n * 【升级】redisson from 3.16.6 to 3.16.8",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【v1.1.0】2021.10.25",
            frontmatter: {
                title: "【v1.1.0】2021.10.25",
                date: "2022-03-10T12:42:12.000Z",
                permalink: "/changelog/1.1.0"
            },
            regularPath: "/99.%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/98.%E3%80%90v1-1-0%E3%80%912021-10-25.html",
            relativePath: "99.更新日志/98.【v1-1-0】2021-10-25.md",
            key: "v-2c62e6c7",
            path: "/changelog/1.1.0/",
            headers: [{
                level: 2,
                title: "增加管理后台的企业微信、钉钉等社交登录",
                slug: "增加管理后台的企业微信、钉钉等社交登录",
                normalizedTitle: "增加管理后台的企业微信、钉钉等社交登录",
                charIndex: 2
            }],
            headersStr: "增加管理后台的企业微信、钉钉等社交登录",
            content: "# 增加管理后台的企业微信、钉钉等社交登录\n\n * 新增管理后台的企业微信、钉钉等社交登录\n * 新增用户前台(例如说，用户使用的小程序)的后端项目 yudao-user-server\n * 新增公共服务 yudao-core-service 项目，通过 Jar 包的方式，提供 yudao-user-server 和 yudao-admin-server 的共享逻辑的复用\n * 新增用户前台的手机登录、验证码登录\n * 修复管理后台的用户头像上传 404 的问题，原因是请求路径不对\n * 修复用户导入失败的问题，原因是 Lombok 链式与 cglib 读取属性有冲突\n * 修复阿里云短信发送失败的问题，原因是 Opentracing 依赖的版本太低，调整成 0.31.0",
            normalizedContent: "# 增加管理后台的企业微信、钉钉等社交登录\n\n * 新增管理后台的企业微信、钉钉等社交登录\n * 新增用户前台(例如说，用户使用的小程序)的后端项目 yudao-user-server\n * 新增公共服务 yudao-core-service 项目，通过 jar 包的方式，提供 yudao-user-server 和 yudao-admin-server 的共享逻辑的复用\n * 新增用户前台的手机登录、验证码登录\n * 修复管理后台的用户头像上传 404 的问题，原因是请求路径不对\n * 修复用户导入失败的问题，原因是 lombok 链式与 cglib 读取属性有冲突\n * 修复阿里云短信发送失败的问题，原因是 opentracing 依赖的版本太低，调整成 0.31.0",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【v1.2.0】2021.12.15",
            frontmatter: {
                title: "【v1.2.0】2021.12.15",
                date: "2022-03-10T12:42:12.000Z",
                permalink: "/changelog/1.2.0"
            },
            regularPath: "/99.%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/97.%E3%80%90v1-2-0%E3%80%912021-12-15.html",
            relativePath: "99.更新日志/97.【v1-2-0】2021-12-15.md",
            key: "v-255d11e7",
            path: "/changelog/1.2.0/",
            headers: [{
                level: 2,
                title: "新增多租户、数据权限的功能",
                slug: "新增多租户、数据权限的功能",
                normalizedTitle: "新增多租户、数据权限的功能",
                charIndex: 2
            }, {
                level: 3,
                title: "⭐ New Features",
                slug: "⭐-new-features",
                normalizedTitle: "⭐ new features",
                charIndex: 60
            }, {
                level: 3,
                title: "🐞 Bug Fixes",
                slug: "🐞-bug-fixes",
                normalizedTitle: "🐞 bug fixes",
                charIndex: 325
            }, {
                level: 3,
                title: "🔨 Dependency Upgrades",
                slug: "🔨-dependency-upgrades",
                normalizedTitle: "🔨 dependency upgrades",
                charIndex: 460
            }],
            headersStr: "新增多租户、数据权限的功能 ⭐ New Features 🐞 Bug Fixes 🔨 Dependency Upgrades",
            content: "# 新增多租户、数据权限的功能\n\n这个版本新增了多租户与数据权限两个重量级的功能，建议花点时间进行了解与学习。\n\n\n# ⭐ New Features\n\n * 【新增】多租户，支持 Web、Security、Job、MQ、Async、DB、Redis 组件\n\n * 【新增】数据权限，内置基于部门过滤的规则\n\n * 【新增】用户前台的昵称、头像的修改\n\n * 【新增】用户前台的微信公众号、微信小程序的社交登录的 API 接口\n   \n   > 完整功能，需要等基于 Uniapp 实现的用户前台一起~ 努力 coding 中，胖友可以 star 持续关注一波！\n\n * 【优化】管理后台的登录成功后，LoginUser 使用统一方法补全信息\n\n\n# 🐞 Bug Fixes\n\n * 【修复】通知和字典查询接口的 @PreAuthorize 权限标识错误\n * 【修复】代码生成的 Java 类路径缺少 modules 目录\n * 【修复】代码生成的 Test 单元测试类的引入 Util 工具类的包路径不正确\n\n\n# 🔨 Dependency Upgrades\n\n * 【引入】mockito-inline 3.6.28：Mockito 提供对 final、static 的支持",
            normalizedContent: "# 新增多租户、数据权限的功能\n\n这个版本新增了多租户与数据权限两个重量级的功能，建议花点时间进行了解与学习。\n\n\n# ⭐ new features\n\n * 【新增】多租户，支持 web、security、job、mq、async、db、redis 组件\n\n * 【新增】数据权限，内置基于部门过滤的规则\n\n * 【新增】用户前台的昵称、头像的修改\n\n * 【新增】用户前台的微信公众号、微信小程序的社交登录的 api 接口\n   \n   > 完整功能，需要等基于 uniapp 实现的用户前台一起~ 努力 coding 中，胖友可以 star 持续关注一波！\n\n * 【优化】管理后台的登录成功后，loginuser 使用统一方法补全信息\n\n\n# 🐞 bug fixes\n\n * 【修复】通知和字典查询接口的 @preauthorize 权限标识错误\n * 【修复】代码生成的 java 类路径缺少 modules 目录\n * 【修复】代码生成的 test 单元测试类的引入 util 工具类的包路径不正确\n\n\n# 🔨 dependency upgrades\n\n * 【引入】mockito-inline 3.6.28：mockito 提供对 final、static 的支持",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【v1.3.0】2022.01.24",
            frontmatter: {
                title: "【v1.3.0】2022.01.24",
                date: "2022-03-10T12:42:12.000Z",
                permalink: "/changelog/1.3.0"
            },
            regularPath: "/99.%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/96.%E3%80%90v1-3-0%E3%80%912022-01-24.html",
            relativePath: "99.更新日志/96.【v1-3-0】2022-01-24.md",
            key: "v-aa31bdf2",
            path: "/changelog/1.3.0/",
            headers: [{
                level: 2,
                title: "新增工作流的功能",
                slug: "新增工作流的功能",
                normalizedTitle: "新增工作流的功能",
                charIndex: 2
            }, {
                level: 3,
                title: "📈 Statistic",
                slug: "📈-statistic",
                normalizedTitle: "📈 statistic",
                charIndex: 97
            }, {
                level: 3,
                title: "⭐ New Features",
                slug: "⭐-new-features",
                normalizedTitle: "⭐ new features",
                charIndex: 175
            }, {
                level: 3,
                title: "🐞 Bug Fixes",
                slug: "🐞-bug-fixes",
                normalizedTitle: "🐞 bug fixes",
                charIndex: 614
            }, {
                level: 3,
                title: "🔨 Dependency Upgrades",
                slug: "🔨-dependency-upgrades",
                normalizedTitle: "🔨 dependency upgrades",
                charIndex: 833
            }],
            headersStr: "新增工作流的功能 📈 Statistic ⭐ New Features 🐞 Bug Fixes 🔨 Dependency Upgrades",
            content: "# 新增工作流的功能\n\n基于 Activiti 7.X 版本实现工作流功能，支持可配置的动态表单、自定义的业务表单。\n\n下个版本会提供基于 Flowable 6.X 版本实现的工作流！\n\n\n# 📈 Statistic\n\n * 总代码行数：61594\n * 源码代码行数：37931\n * 注释行数：14225\n * 单元测试用例数：278\n\n\n# ⭐ New Features\n\n * 【优化】引入 form generator 0.2.0 版本，并重构相关代码\n * 【修改】修改部门负责人，从 String 字符串，调整成和后台用户的用户编号绑定\n * 【新增】流程表单，支持动态进行表单的配置\n * 【新增】工作组，用于支持指定工作组进行任务的审批\n * 【新增】流程模型的管理，支持新增、导入、编辑、删除、发布流程模型\n * 【新增】我的流程的管理，支持发起流程\n * 【新增】待办任务的管理，支持任务的审批通过与不通过\n * 【新增】已办任务的管理，支持详情的查看\n * 【新增】任务分配规则，可指定角色、部门成员、部门负责人、用户、用户组、自定义脚本等维度，进行任务的审批\n * 【新增】引入 bpmn-process-designer 0.0.1 版本，提供流程设计器的能力\n * 【优化】新增 LambdaQueryWrapperX 类，改成使用 Lambda 的方式选择字段，避免手写导致字段不正确\n\n\n# 🐞 Bug Fixes\n\n * 【修复】biz-data-permission 组件的缓存机制，导致部分 SQL 未进行数据过滤\n * 【修复】codegen 生成代码时，delete 接口补充 dataTypeClass 属性，避免 Swagger 打印 WARN 日志\n * 【修复】Swagger 文档由于写错 @ApiImplicitParam 注解的 name 和 dataTypeClass 属性，导致文档生成失败\n\n\n# 🔨 Dependency Upgrades\n\n * 【升级】redisson from 3.16.3 to 3.16.6，解决 Stream 在调试场景下会存在 NPE 的问题\n * 【升级】spring-boot from 2.4.5 to 2.4.12，最新的 Spring Boot 2.6.X 在等更流行一些，稳定第一\n * 【升级】druid from 1.2.4 to 1.2.8，提升数据库连接池的稳定性\n * 【升级】dynamic-datasource from 3.3.2 to 3.5.0，修复动态数据源切换的问题",
            normalizedContent: "# 新增工作流的功能\n\n基于 activiti 7.x 版本实现工作流功能，支持可配置的动态表单、自定义的业务表单。\n\n下个版本会提供基于 flowable 6.x 版本实现的工作流！\n\n\n# 📈 statistic\n\n * 总代码行数：61594\n * 源码代码行数：37931\n * 注释行数：14225\n * 单元测试用例数：278\n\n\n# ⭐ new features\n\n * 【优化】引入 form generator 0.2.0 版本，并重构相关代码\n * 【修改】修改部门负责人，从 string 字符串，调整成和后台用户的用户编号绑定\n * 【新增】流程表单，支持动态进行表单的配置\n * 【新增】工作组，用于支持指定工作组进行任务的审批\n * 【新增】流程模型的管理，支持新增、导入、编辑、删除、发布流程模型\n * 【新增】我的流程的管理，支持发起流程\n * 【新增】待办任务的管理，支持任务的审批通过与不通过\n * 【新增】已办任务的管理，支持详情的查看\n * 【新增】任务分配规则，可指定角色、部门成员、部门负责人、用户、用户组、自定义脚本等维度，进行任务的审批\n * 【新增】引入 bpmn-process-designer 0.0.1 版本，提供流程设计器的能力\n * 【优化】新增 lambdaquerywrapperx 类，改成使用 lambda 的方式选择字段，避免手写导致字段不正确\n\n\n# 🐞 bug fixes\n\n * 【修复】biz-data-permission 组件的缓存机制，导致部分 sql 未进行数据过滤\n * 【修复】codegen 生成代码时，delete 接口补充 datatypeclass 属性，避免 swagger 打印 warn 日志\n * 【修复】swagger 文档由于写错 @apiimplicitparam 注解的 name 和 datatypeclass 属性，导致文档生成失败\n\n\n# 🔨 dependency upgrades\n\n * 【升级】redisson from 3.16.3 to 3.16.6，解决 stream 在调试场景下会存在 npe 的问题\n * 【升级】spring-boot from 2.4.5 to 2.4.12，最新的 spring boot 2.6.x 在等更流行一些，稳定第一\n * 【升级】druid from 1.2.4 to 1.2.8，提升数据库连接池的稳定性\n * 【升级】dynamic-datasource from 3.3.2 to 3.5.0，修复动态数据源切换的问题",
            charsets: {
                cjk: !0
            }
        }, {
            title: "【v1.0.0】2021.05.03",
            frontmatter: {
                title: "【v1.0.0】2021.05.03",
                date: "2022-03-07T12:40:00.000Z",
                permalink: "/changelog/1.0.0"
            },
            regularPath: "/99.%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/99.%E3%80%90v1-0-0%E3%80%912021-05-03.html",
            relativePath: "99.更新日志/99.【v1-0-0】2021-05-03.md",
            key: "v-682dfe87",
            path: "/changelog/1.0.0/",
            headers: [{
                level: 2,
                title: "初始版本",
                slug: "初始版本",
                normalizedTitle: "初始版本",
                charIndex: 2
            }, {
                level: 3,
                title: "代码的重构",
                slug: "代码的重构",
                normalizedTitle: "代码的重构",
                charIndex: 43
            }, {
                level: 3,
                title: "后台功能的新增",
                slug: "后台功能的新增",
                normalizedTitle: "后台功能的新增",
                charIndex: 63
            }, {
                level: 3,
                title: "技术选型的调整",
                slug: "技术选型的调整",
                normalizedTitle: "技术选型的调整",
                charIndex: 52
            }],
            headersStr: "初始版本 代码的重构 后台功能的新增 技术选型的调整",
            content: "# 初始版本\n\n第一个版本，基于 RuoYi-Vue 重构，主要是三个方面：\n\n * 代码的重构\n * 技术选型的调整\n * 后台功能的新增\n\n因此，v1.0.0 的更新日志，分成这三方面来写。\n\n\n# 代码的重构\n\n * 调整整体代码结构，将多个 Maven Module 合并为单个，使用 Java package 进行拆分隔离，如 图 所示。原因是：随着业务逻辑的逐步复杂，多个 Maven Module 的依赖关系的管理，会是一个很大的问题。\n * 拆分 framework 为多个 Maven Module，按照 Web、Security、MyBatis、Redis 等不同组件，进行封装与拓展。\n * 基于 JUnit5 与 Mockito，实现单元测试，保证功能的正确性，与代码的可维护性。一直自动化，一直爽！\n * 增加 SpringBoot 多环境的配置文件，提供完善的 deploy.sh 部署脚本，以及 Jenkins 部署教程。\n * 优化 Spring Security 实现权限的代码，提升可读性和维护性。\n * 增加本地缓存（菜单、角色、数据字典等等），提升性能。通过 Redis 订阅发布，实现缓存的实时刷新。\n * 增加 VO 类，作为 API 接口的响应对象，避免数据库实体与前端的直接耦合。\n * 优化 操作日志，支持读取 Swagger 作为日志的内容。\n * 优化 定时任务，支持执行失败的重试，更完善的执行日志。\n * 优化 codegen 代码生成器，在原先生成 Controller、Service、Mapper、数据库实体、Vue 代码的基础上，额外生成 VO、单元测试的代码。\n * 调整文件改用 数据库 存储，而不是文件系统。原因是，项目在部署多个服务节点时，文件需要做同步。未来，会增加阿里云、七牛云等存储云服务。\n * 去除原有数据库的连表查询、递归查询，改为单表操作的方式，多次读取 + 内存拼接。\n * 优化 Java 代码的格式，解决 IDEA 代码告警的问题。\n\n\n# 后台功能的新增\n\n * 增加 API 访问与异常日志，方便排查线上 API 的问题。\n * 增加 全局错误码，统一业务异常的管理。管理后台会支持错误码的管理，支持提示文案的可配置化。\n * 增加 短信模块，提供短信渠道、短息模板、短信日志的管理，对接阿里云、云片等主流短信平台。\n * 增加 Redis Key 的管理，知道项目中使用到的 Redis Key 的格式、数据类型、过期时间、描述等等信息。\n\n\n# 技术选型的调整\n\n * 将 Spring Boot 版本，从 2.1.3 升级到 2.4.5 最新。\n * 增加 bom 文件，统一 Maven 的依赖管理。\n * 引入 MyBatis Plus 组件，简化 MyBatis 使用，提升开发效率。\n * 引入 Redisson 组件，作为 Redis 的客户端，提供更强大的 Redis 操作。\n * 基于 Redis 实现分布式消息队列的功能。接入 Redis Pub/Sub 实现广播消费，接入 Redis Stream 实现集群消费。\n * 去除 fastjson，统一使用 Jackson 作为 JSON 库，老爆安全漏洞的悲伤。\n * 引入 MapStruct 组件，实现数据库实体与 VO 类之间的转换。\n * 引入 Lombok 组件，生成 setter、getter 等常用方法，去除冗余代码。\n * 引入 Spring Async 功能，实现异步任务。例如说，异步记录 API 访问日志、管理员操作日志等等。\n * 魔改 Apollo 组件，接入本地数据库，实现内嵌的配置中心。通俗的说，我们可以将原本添加到 application.yaml 的配置项，改为添加到数据库中，项目启动会进行读取。\n * 引入 Hutool 组件，去除大量重复的工具类，也避免原本 Util 存在一些 bug 的问题。\n * 引入 Screw 组件，实现数据库文档的生成，虽然好像现在用途较少。\n * 引入 EasyExcel，提供 Excel 的导入与导出的功能。\n * 实现 Idempotent 组件，实现幂等的功能，可以用来解决 HTTP 重复请求的问题。\n * 引入 Lock4J，实现声明式的分布式锁的功能。虽然 Redisson 内置了分布式锁的功能，但是通过注解声明一个 @Lock4j 注解的使用方式，更加便利，且满足绝大多数场景。\n * 去除原有的服务监控，使用 SpringBoot Admin 替代，提供更完整的监控能力。\n * 引入 SkyWalking 组件，实现链路追踪和日志服务的功能。通过链路追踪，我们可以看到一个 API 请求涉及到的 MySQL、Redis 等操作；通过日志服务，我们可以方便的看到每个服务实例的日志。\n * 引入 Resilience4j 组件，实现限流、熔断等功能，保证服务的稳定性。\n * 引入 Knife4j，美化接口文档。原本所有 API 接口文档是缺失的，已经全部补全，可见 http://api-dashboard.yudao.iocoder.cn/doc.html 地址。",
            normalizedContent: "# 初始版本\n\n第一个版本，基于 ruoyi-vue 重构，主要是三个方面：\n\n * 代码的重构\n * 技术选型的调整\n * 后台功能的新增\n\n因此，v1.0.0 的更新日志，分成这三方面来写。\n\n\n# 代码的重构\n\n * 调整整体代码结构，将多个 maven module 合并为单个，使用 java package 进行拆分隔离，如 图 所示。原因是：随着业务逻辑的逐步复杂，多个 maven module 的依赖关系的管理，会是一个很大的问题。\n * 拆分 framework 为多个 maven module，按照 web、security、mybatis、redis 等不同组件，进行封装与拓展。\n * 基于 junit5 与 mockito，实现单元测试，保证功能的正确性，与代码的可维护性。一直自动化，一直爽！\n * 增加 springboot 多环境的配置文件，提供完善的 deploy.sh 部署脚本，以及 jenkins 部署教程。\n * 优化 spring security 实现权限的代码，提升可读性和维护性。\n * 增加本地缓存（菜单、角色、数据字典等等），提升性能。通过 redis 订阅发布，实现缓存的实时刷新。\n * 增加 vo 类，作为 api 接口的响应对象，避免数据库实体与前端的直接耦合。\n * 优化 操作日志，支持读取 swagger 作为日志的内容。\n * 优化 定时任务，支持执行失败的重试，更完善的执行日志。\n * 优化 codegen 代码生成器，在原先生成 controller、service、mapper、数据库实体、vue 代码的基础上，额外生成 vo、单元测试的代码。\n * 调整文件改用 数据库 存储，而不是文件系统。原因是，项目在部署多个服务节点时，文件需要做同步。未来，会增加阿里云、七牛云等存储云服务。\n * 去除原有数据库的连表查询、递归查询，改为单表操作的方式，多次读取 + 内存拼接。\n * 优化 java 代码的格式，解决 idea 代码告警的问题。\n\n\n# 后台功能的新增\n\n * 增加 api 访问与异常日志，方便排查线上 api 的问题。\n * 增加 全局错误码，统一业务异常的管理。管理后台会支持错误码的管理，支持提示文案的可配置化。\n * 增加 短信模块，提供短信渠道、短息模板、短信日志的管理，对接阿里云、云片等主流短信平台。\n * 增加 redis key 的管理，知道项目中使用到的 redis key 的格式、数据类型、过期时间、描述等等信息。\n\n\n# 技术选型的调整\n\n * 将 spring boot 版本，从 2.1.3 升级到 2.4.5 最新。\n * 增加 bom 文件，统一 maven 的依赖管理。\n * 引入 mybatis plus 组件，简化 mybatis 使用，提升开发效率。\n * 引入 redisson 组件，作为 redis 的客户端，提供更强大的 redis 操作。\n * 基于 redis 实现分布式消息队列的功能。接入 redis pub/sub 实现广播消费，接入 redis stream 实现集群消费。\n * 去除 fastjson，统一使用 jackson 作为 json 库，老爆安全漏洞的悲伤。\n * 引入 mapstruct 组件，实现数据库实体与 vo 类之间的转换。\n * 引入 lombok 组件，生成 setter、getter 等常用方法，去除冗余代码。\n * 引入 spring async 功能，实现异步任务。例如说，异步记录 api 访问日志、管理员操作日志等等。\n * 魔改 apollo 组件，接入本地数据库，实现内嵌的配置中心。通俗的说，我们可以将原本添加到 application.yaml 的配置项，改为添加到数据库中，项目启动会进行读取。\n * 引入 hutool 组件，去除大量重复的工具类，也避免原本 util 存在一些 bug 的问题。\n * 引入 screw 组件，实现数据库文档的生成，虽然好像现在用途较少。\n * 引入 easyexcel，提供 excel 的导入与导出的功能。\n * 实现 idempotent 组件，实现幂等的功能，可以用来解决 http 重复请求的问题。\n * 引入 lock4j，实现声明式的分布式锁的功能。虽然 redisson 内置了分布式锁的功能，但是通过注解声明一个 @lock4j 注解的使用方式，更加便利，且满足绝大多数场景。\n * 去除原有的服务监控，使用 springboot admin 替代，提供更完整的监控能力。\n * 引入 skywalking 组件，实现链路追踪和日志服务的功能。通过链路追踪，我们可以看到一个 api 请求涉及到的 mysql、redis 等操作；通过日志服务，我们可以方便的看到每个服务实例的日志。\n * 引入 resilience4j 组件，实现限流、熔断等功能，保证服务的稳定性。\n * 引入 knife4j，美化接口文档。原本所有 api 接口文档是缺失的，已经全部补全，可见 http://api-dashboard.yudao.iocoder.cn/doc.html 地址。",
            charsets: {
                cjk: !0
            }
        }, {
            title: "hello",
            frontmatter: {
                title: "hello",
                date: "2024-04-20T11:03:09.000Z",
                permalink: "/hello/"
            },
            regularPath: "/@pages/01.hello.html",
            relativePath: "@pages/01.hello.md",
            key: "v-81a0e9b8",
            path: "/hello/",
            headersStr: null,
            content: "正在发起认证中...",
            normalizedContent: "正在发起认证中...",
            charsets: {
                cjk: !0
            }
        }, {
            title: "Home",
            frontmatter: {
                home: !0,
                heroImage: "https://static.iocoder.cn/ruoyi-vue-pro-logo.png",
                heroText: "ruoyi-vue-pro 开发指南",
                tagline: "一个简单易上手的 Spring Boot 开发平台",
                actionText: "开始使用 →",
                actionLink: "/video/",
                bannerBg: "none",
                features: [{
                    title: "主流技术栈",
                    details: "互联网主流技术选型，Spring Boot、Spring Security、MyBatis Plus、Validator、Swagger 等技术栈"
                }, {
                    title: "模块化架构",
                    details: "后端采用模块化的架构，按照功能拆分成多个 Maven Module，单一职责，开发高效率，系统易维护"
                }, {
                    title: "前后端分离",
                    details: "前后端完全分离，前端基于 Vue + ElementUI 界面，后端基于 Spring MVC 提供 RESTful API 接口"
                }, {
                    title: "代码生成器",
                    details: "配置好表信息，一键生成前后端代码，包含增删改查、导出、权限控制、参数校验、接口文档、单元测试、Vue 等"
                }, {
                    title: "功能小而美",
                    details: "内置 RBAC 功能权限、数据权限、SaaS 多租户、工作流、操作日志、三方登录、支付退款、短信、商城等等"
                }, {
                    title: "多种数据库",
                    details: "数据库可使用 MySQL、Oracle、PostgreSQL、SQL Server、国产达梦 DM、大金、TiDB 等"
                }],
                postList: "none"
            },
            regularPath: "/",
            relativePath: "index.md",
            key: "v-8f722e46",
            path: "/",
            headersStr: null,
            content: "",
            normalizedContent: "",
            charsets: {}
        }, {
            title: "归档",
            frontmatter: {
                archivesPage: !0,
                title: "归档",
                permalink: "/archives/",
                article: !1
            },
            regularPath: "/@pages/archivesPage.html",
            relativePath: "@pages/archivesPage.md",
            key: "v-0d120b84",
            path: "/archives/",
            headersStr: null,
            content: "",
            normalizedContent: "",
            charsets: {}
        }, {
            title: "项目案例",
            frontmatter: {
                title: "项目案例",
                date: "2024-08-27T11:03:09.000Z",
                permalink: "/user-project/"
            },
            regularPath: "/@pages/02.%E9%A1%B9%E7%9B%AE%E6%A1%88%E4%BE%8B.html",
            relativePath: "@pages/02.项目案例.md",
            key: "v-126d25a2",
            path: "/user-project/",
            headers: [{
                level: 2,
                title: "惠质造（工业数智化运营平台）",
                slug: "惠质造-工业数智化运营平台",
                normalizedTitle: "惠质造（工业数智化运营平台）",
                charIndex: 378
            }],
            headersStr: "惠质造（工业数智化运营平台）",
            content: "芋道，以开发者为中心，打造中国第一流的快速开发平台，全部开源，个人与企业可 100% 免费使用（无需授权）：\n\n * 单体多模块架构：https://github.com/YunaiV/ruoyi-vue-pro\n * 微服务分布式架构：https://github.com/YunaiV/yudao-cloud\n\n系统内置多种多种业务功能，可以用于快速你的业务系统：\n\n\n\n * 通用模块（必选）：系统功能、基础设施\n * 通用模块（可选）：工作流程、支付系统、数据报表、会员中心\n * 业务系统（按需）：ERP 系统、CRM 系统、商城系统、微信公众号、AI 大模型\n\n截止目前，用户群已破 100000+ 人，使用企业至少 10000+ 家，涵盖了各个行业，包括但不限于：互联网、金融、电商、教育、医疗、制造、政府等等。如下是部分企业案例：\n\n\n# 惠质造（工业数智化运营平台）\n\n\n\n * 公司名称：杭州惠质造科技有限公司\n * 官网地址：https://www.huizhizao.vip\n * 使用场景：商城、工作流、ERP、CRM、MES、QMS、OA、PLM、HRS、SCM、PDA\n\n产品界面（后台首页 + 手机端）\n\n\n\n\n\n",
            normalizedContent: "芋道，以开发者为中心，打造中国第一流的快速开发平台，全部开源，个人与企业可 100% 免费使用（无需授权）：\n\n * 单体多模块架构：https://github.com/yunaiv/ruoyi-vue-pro\n * 微服务分布式架构：https://github.com/yunaiv/yudao-cloud\n\n系统内置多种多种业务功能，可以用于快速你的业务系统：\n\n\n\n * 通用模块（必选）：系统功能、基础设施\n * 通用模块（可选）：工作流程、支付系统、数据报表、会员中心\n * 业务系统（按需）：erp 系统、crm 系统、商城系统、微信公众号、ai 大模型\n\n截止目前，用户群已破 100000+ 人，使用企业至少 10000+ 家，涵盖了各个行业，包括但不限于：互联网、金融、电商、教育、医疗、制造、政府等等。如下是部分企业案例：\n\n\n# 惠质造（工业数智化运营平台）\n\n\n\n * 公司名称：杭州惠质造科技有限公司\n * 官网地址：https://www.huizhizao.vip\n * 使用场景：商城、工作流、erp、crm、mes、qms、oa、plm、hrs、scm、pda\n\n产品界面（后台首页 + 手机端）\n\n\n\n\n\n",
            charsets: {
                cjk: !0
            }
        }],
        themeConfig: {
            nav: [{
                text: "开发指南",
                link: "/intro/",
                items: [{
                    text: "萌新必读",
                    link: "/intro/"
                }, {
                    text: "后端手册",
                    link: "/module-new/"
                }, {
                    text: "中间件手册",
                    link: "/message-queue/event/"
                }, {
                    text: "工作流手册",
                    link: "/bpm-preview/"
                }, {
                    text: "大屏手册",
                    link: "/report/"
                }, {
                    text: "支付手册",
                    link: "/pay/build/"
                }, {
                    text: "会员手册",
                    link: "/member/build/"
                }, {
                    text: "商城手册",
                    link: "/mall/build/"
                }, {
                    text: "ERP 手册",
                    link: "/erp/build/"
                }, {
                    text: "CRM 手册",
                    link: "/crm/build/"
                }, {
                    text: "AI 大模型手册",
                    link: "/ai-preview/"
                }, {
                    text: "公众号手册",
                    link: "/mp/build/"
                }, {
                    text: "系统手册",
                    link: "/sms/"
                }, {
                    text: "运维手册",
                    link: "/dev-env/"
                }, {
                    text: "前端手册 Vue 2.x",
                    link: "/vue2/dev-spec/"
                }, {
                    text: "前端手册 Vue 3.x",
                    link: "/vue3/dev-spec/"
                }]
            }, {
                text: "项目实战",
                link: "/bpm/",
                items: [{
                    text: "工作流手册",
                    link: "/bpm-preview/"
                }, {
                    text: "大屏手册",
                    link: "/report/"
                }, {
                    text: "支付手册",
                    link: "/pay/build/"
                }, {
                    text: "会员手册",
                    link: "/member/build/"
                }, {
                    text: "商城手册",
                    link: "/mall/build/"
                }, {
                    text: "ERP 手册",
                    link: "/erp/build/"
                }, {
                    text: "CRM 手册",
                    link: "/crm/build/"
                }, {
                    text: "AI 大模型手册",
                    link: "/ai-preview/"
                }, {
                    text: "公众号手册",
                    link: "/mp/build/"
                }, {
                    text: "系统手册",
                    link: "/sms/"
                }]
            }, {
                text: "视频教程",
                link: "/video/"
            }, {
                text: "在线体验",
                items: [{
                    text: "Vue3 + element-plus",
                    link: "http://dashboard-vue3.yudao.iocoder.cn/"
                }, {
                    text: "Vue3 + vben(ant-design-vue)",
                    link: "http://dashboard-vben.yudao.iocoder.cn/"
                }, {
                    text: "Vue2 + element-ui",
                    link: "http://dashboard.yudao.iocoder.cn/"
                }]
            }, {
                text: "微服务版",
                link: "https://github.com/YunaiV/yudao-cloud"
            }, {
                text: "作者博客",
                link: "https://www.iocoder.cn/"
            }],
            sidebarDepth: 2,
            logo: "https://static.iocoder.cn/ruoyi-vue-pro-logo.png",
            repo: "YunaiV/ruoyi-vue-pro",
            searchMaxSuggestions: 20,
            lastUpdated: "上次更新",
            sidebar: {
                "/01.开发指南/": [{
                    title: "萌新必读",
                    collapsable: !1,
                    children: [["01.萌新必读/01.简介.md", "简介", "/intro"], ["01.萌新必读/02.交流群.md", "交流群", "/qun"], ["01.萌新必读/03.视频教程.md", "视频教程", "/video"], ["01.萌新必读/04.功能列表.md", "功能列表", "/feature"], ["01.萌新必读/05.快速启动【后端】.md", "快速启动（后端项目）", "/quick-start"], ["01.萌新必读/06.快速启动【前端】.md", "快速启动（前端项目）", "/quick-start-front"], ["01.萌新必读/07.接口文档.md", "接口文档", "/api-doc"], ["01.萌新必读/08.技术选型.md", "技术选型", "/technology"], ["01.萌新必读/09.项目结构.md", "项目结构", "/project-intro"], ["01.萌新必读/10.代码热加载.md", "代码热加载", "/dev-hot-swap/"], ["01.萌新必读/11.一键改包.md", "一键改包", "/project-rename"], ["01.萌新必读/12.迁移模块.md", "迁移模块（适合新项目）", "/migrate-module/"], ["01.萌新必读/13.删除功能.md", "删除功能（以租户为例）", "/delete-code"], ["01.萌新必读/14.表结构变更.md", "表结构变更（版本升级）", "/sql-update"], ["01.萌新必读/15.国产信创数据库.md", "国产信创数据库（DM 达梦、大金、OpenGauss）", "/xinchuang-db"], ["01.萌新必读/16.如何去除 Redis 依赖.md", "如何去除 Redis 缓存", "/remove-redis"], ["01.萌新必读/98.内网穿透.md", "内网穿透", "/natapp"], ["01.萌新必读/99.面试题&简历.md", "面试题、简历模版、简历优化", "/interview"]]
                }, {
                    title: "后端手册",
                    collapsable: !1,
                    children: [["02.后端手册/01.新建模块.md", "新建模块", "/module-new/"], ["02.后端手册/02.代码生成（单表）.md", "代码生成【单表】（新增功能）", "/new-feature"], ["02.后端手册/03.代码生成（主子表）.md", "代码生成【主子表】", "/new-feature/master-sub"], ["02.后端手册/04.代码生成（树表）.md", "代码生成（树表）", "/new-feature/tree"], ["02.后端手册/07.功能权限.md", "功能权限", "/resource-permission"], ["02.后端手册/08.数据权限.md", "数据权限", "/data-permission"], ["02.后端手册/09.用户体系.md", "用户体系", "/user-center"], ["02.后端手册/10.三方登录.md", "三方登录", "/social-user"], ["02.后端手册/11.OAuth2x0.md", "OAuth 2.0（SSO 单点登录)", "/oauth2"], ["02.后端手册/12.SaaS 多租户（字段隔离）.md", "SaaS 多租户【字段隔离】", "/saas-tenant"], ["02.后端手册/13.SaaS 多租户（数据库隔离）.md", "SaaS 多租户【数据库隔离】", "/saas-tenant/dynamic"], ["02.后端手册/14.WebSocket.md", "WebSocket 实时通信", "/websocket/"], ["02.后端手册/15.异常处理.md", "异常处理（错误码）", "/exception"], ["02.后端手册/16.参数校验.md", "参数校验、时间传参", "/validator"], ["02.后端手册/17.分页实现.md", "分页实现", "/page-feature"], ["02.后端手册/18.VO 对象转换、数据翻译.md", "VO 对象转换、数据翻译", "/vo/"], ["02.后端手册/19.上传下载.md", "文件存储（上传下载）", "/file"], ["02.后端手册/20.Excel 导入导出.md", "Excel 导入导出", "/excel-import-and-export"], ["02.后端手册/21.系统日志.md", "操作日志、访问日志、异常日志", "/system-log"], ["02.后端手册/25.MyBatis 数据库.md", "MyBatis 数据库", "/mybatis"], ["02.后端手册/26.MyBatis 联表x分页.md", "MyBatis 联表&分页查询", "/mybatis-pro/"], ["02.后端手册/27.多数据源.md", "多数据源（读写分离）、事务", "/dynamic-datasource"], ["02.后端手册/28.Redis 缓存.md", "Redis 缓存", "/redis-cache"], ["02.后端手册/29.本地缓存.md", "本地缓存", "/local-cache"], ["02.后端手册/30.异步任务.md", "异步任务", "/async-task"], ["02.后端手册/31.分布式锁.md", "分布式锁", "/distributed-lock"], ["02.后端手册/32.幂等性.md", "幂等性（防重复提交）", "/idempotent"], ["02.后端手册/33.请求限流.md", "请求限流（RateLimiter）", "/rate-limiter/"], ["02.后端手册/34.HTTP 签名.md", "HTTP 接口签名（防篡改）", "/http-sign/"], ["02.后端手册/40.单元测试.md", "单元测试", "/unit-test"], ["02.后端手册/41.验证码.md", "验证码", "/captcha"], ["02.后端手册/42.工具类 Util.md", "工具类 Util", "/util"], ["02.后端手册/43.配置管理.md", "配置管理", "/config-center"], ["02.后端手册/44.数据库文档.md", "数据库文档", "/db-doc"]]
                }, {
                    title: "中间件手册",
                    collapsable: !1,
                    children: [["03.中间件手册/06.定时任务.md", "定时任务", "/job"], ["03.中间件手册/11.消息队列（内存）.md", "消息队列（内存）", "/message-queue/event"], ["03.中间件手册/12.消息队列（Redis）.md", "消息队列（Redis）", "/message-queue/redis"], ["03.中间件手册/13.消息队列（RocketMQ）.md", "消息队列（RocketMQ）", "/message-queue/rocketmq"], ["03.中间件手册/14.消息队列（RabbitMQ）.md", "消息队列（RabbitMQ）", "/message-queue/rabbitmq"], ["03.中间件手册/15.消息队列（Kafka）.md", "消息队列（Kafka）", "/message-queue/kafka"], ["03.中间件手册/22.限流熔断.md", "限流熔断", "/server-protection"]]
                }, {
                    title: "工作流手册",
                    collapsable: !1,
                    children: [["10.工作流手册/01.工作流演示.md", "工作流演示", "/bpm-preview"], ["10.工作流手册/02.功能开启.md", "功能开启", "/bpm/"], ["10.工作流手册/03.工作流（达梦适配）.md", "工作流（达梦适配）", "/bpm/dameng/"], ["10.工作流手册/04.审批接入（流程表单）.md", "审批接入（流程表单）", "/bpm/use-bpm-form/"], ["10.工作流手册/05.审批接入（业务表单）.md", "审批接入（业务表单）", "/bpm/use-business-form/"], ["10.工作流手册/11.流程设计器（BPMN）.md", "流程设计器（BPMN）", "/bpm/model-designer-bpmn"], ["10.工作流手册/12.流程设计器（钉钉、飞书）.md", "流程设计器（钉钉、飞书）", "/bpm/model-designer-dingding"], ["10.工作流手册/20.选择审批人、发起人自选.md", "选择审批人、发起人自选", "/bpm/assignee"], ["10.工作流手册/21.会签、或签、依次审批.md", "会签、或签、依次审批", "/bpm/multi-instance"], ["10.工作流手册/22.流程发起、取消、重新发起.md", "流程发起、取消、重新发起", "/bpm/process-instance/"], ["10.工作流手册/23.审批通过、不通过、驳回.md", "审批通过、不通过、驳回", "/bpm/task-todo-done"], ["10.工作流手册/24.审批加签、减签.md", "审批加签、减签", "/bpm/sign/"], ["10.工作流手册/25.审批转办、委派、抄送.md", "审批转办、委派、抄送", "/bpm/task-delegation-and-cc"], ["10.工作流手册/30.执行监听器、任务监听器.md", "执行监听器、任务监听器", "/bpm/listener"], ["10.工作流手册/31.流程表达式.md", "流程表达式", "/bpm/expression"], ["10.工作流手册/41.流程审批通知.md", "流程审批通知", "/bpm/message/"]]
                }, {
                    title: "大屏手册",
                    collapsable: !1,
                    children: [["11.大屏手册/01.报表设计器.md", "报表设计器", "/report/"], ["11.大屏手册/02.大屏设计器.md", "大屏设计器", "/report/screen"]]
                }, {
                    title: "支付手册",
                    collapsable: !1,
                    children: [["12.支付手册/01.功能开启.md", "功能开启", "/pay/build"], ["12.支付手册/11.支付宝支付接入.md", "支付宝支付接入", "/pay/alipay-pay-demo"], ["12.支付手册/12.微信公众号支付接入.md", "微信公众号支付接入", "/pay/wx-pub-pay-demo/"], ["12.支付手册/13.微信小程序支付接入.md", "微信小程序支付接入", "/pay/wx-lite-pay-demo/"], ["12.支付手册/21.支付宝、微信退款接入.md", "支付宝、微信退款接入", "/pay/refund-demo"], ["12.支付手册/30.钱包充值、支付、退款.md", "钱包充值、支付、退款", "/pay/wallet"], ["12.支付手册/31.模拟支付、退款.md", "模拟支付、退款", "/pay/mock"]]
                }, {
                    title: "会员手册",
                    collapsable: !1,
                    children: [["13.会员手册/01.功能开启.md", "功能开启", "/member/build/"], ["13.会员手册/02.微信公众号登录.md", "微信公众号登录", "/member/weixin-mp-login/"], ["13.会员手册/03.微信小程序登录.md", "微信小程序登录", "/member/weixin-lite-login/"], ["13.会员手册/04.微信小程序订阅消息.md", "微信小程序订阅消息", "/member/weixin-lite-subscribe-message/"], ["13.会员手册/05.微信小程序码.md", "微信小程序码", "/member/weixin-lite-qrcode/"], ["13.会员手册/11.会员用户、标签、分组.md", "会员用户、标签、分组", "/member/user"], ["13.会员手册/12.会员等级、积分、签到.md", "会员等级、积分、签到", "/member/level"]]
                }, {
                    title: "商城手册",
                    collapsable: !1,
                    children: [["14.商城手册/01.商城演示.md", "商城演示", "/mall-preview"], ["14.商城手册/02.功能开启.md", "功能开启", "/mall/build"], ["14.商城手册/03.店铺装修.md", "商城装修", "/mall/diy"], ["14.商城手册/04.在线客服.md", "在线客服", "/mall/kefu"], ["14.商城手册/10.【商品】商品分类.md", "【商品】商品分类", "/mall/product-category/"], ["14.商城手册/11.【商品】商品属性.md", "【商品】商品属性", "/mall/product-property/"], ["14.商城手册/12.【商品】商品 SPU 与 SKU.md", "【商品】商品 SPU 与 SKU", "/mall/product-spu-sku/"], ["14.商城手册/13.【商品】商品评价.md", "【商品】商品评价", "/mall/product-comment/"], ["14.商城手册/21.【交易】购物车.md", "【交易】购物车", "/mall/trade-cart/"], ["14.商城手册/22.【交易】交易订单.md", "【交易】交易订单", "/mall/trade-order/"], ["14.商城手册/23.【交易】售后退款.md", "【交易】售后退款", "/mall/trade-aftersale/"], ["14.商城手册/24.【交易】快递发货.md", "【交易】快递发货", "/mall/trade-delivery-express"], ["14.商城手册/25.【交易】门店自提.md", "【交易】门店自提", "/mall/trade-delivery-pickup"], ["14.商城手册/26.【交易】分销返佣.md", "【交易】分销返佣", "/mall/trade-brokerage"], ["14.商城手册/30.【营销】优惠劵.md", "【营销】优惠劵", "/mall/promotion-coupon"], ["14.商城手册/31.【营销】积分商城.md", "【营销】积分商城", "/mall/point-activity"], ["14.商城手册/32.【营销】拼团活动.md", "【营销】拼团活动", "/mall/promotion-combination"], ["14.商城手册/33.【营销】秒杀活动.md", "【营销】秒杀活动", "/mall/promotion-seckill/"], ["14.商城手册/34.【营销】砍价活动.md", "【营销】砍价活动", "/mall/promotion-bargain/"], ["14.商城手册/35.【营销】满减送活动.md", "【营销】满减送活动", "/mall/promotion-record/"], ["14.商城手册/36.【营销】限时折扣.md", "【营销】限时折扣", "/mall/promotion-discount/"], ["14.商城手册/37.【营销】内容管理.md", "【营销】内容管理", "/mall/promotion-content/"], ["14.商城手册/40.【统计】会员、商品、交易统计.md", "【统计】会员、商品、交易统计", "/mall/statistics/"]]
                }, {
                    title: "ERP手册",
                    collapsable: !1,
                    children: [["15.ERP手册/01.ERP 演示.md", "ERP 演示", "/erp-preview"], ["15.ERP手册/02.功能开启.md", "功能开启", "/erp/build"], ["15.ERP手册/10.【产品】产品信息、分类、单位.md", "【产品】产品信息、分类、单位", "/erp/product/"], ["15.ERP手册/20.【库存】产品库存、库存明细.md", "【库存】产品库存、库存明细", "/erp/stock/"], ["15.ERP手册/21.【库存】其它入库、其它出库.md", "【库存】其它入库、其它出库", "/erp/stock-in-out"], ["15.ERP手册/22.【库存】库存调拨、库存盘点.md", "【库存】库存调拨、库存盘点", "/erp/stock-move-check"], ["15.ERP手册/30.【采购】采购订单、入库、退货.md", "【采购】采购订单、入库、退货", "/erp/purchase/"], ["15.ERP手册/40.【销售】销售订单、出库、退货.md", "【销售】销售订单、出库、退货", "/erp/sale/"], ["15.ERP手册/50.【财务】采购付款、销售收款.md", "【财务】采购付款、销售收款", "/sale/finance-payment-receipt"]]
                }, {
                    title: "CRM手册",
                    collapsable: !1,
                    children: [["16.CRM手册/01.CRM 演示.md", "CRM 演示", "/crm-preview"], ["16.CRM手册/02.功能开启.md", "功能开启", "/crm/build/"], ["16.CRM手册/10.【线索】线索管理.md", "【线索】线索管理", "/crm/clue"], ["16.CRM手册/20.【客户】客户管理、公海客户.md", "【客户】客户管理、公海客户", "/crm/customer/"], ["16.CRM手册/30.【商机】商机管理、商机状态.md", "【商机】商机管理、商机状态", "/crm/business/"], ["16.CRM手册/40.【合同】合同管理、合同提醒.md", "【合同】合同管理、合同提醒", "/crm/contract"], ["16.CRM手册/50.【回款】回款管理、回款计划.md", "【回款】回款管理、回款计划", "/crm/receivable/"], ["16.CRM手册/60.【产品】产品管理、产品分类.md", "【产品】产品管理、产品分类", "/crm/product/"], ["16.CRM手册/90.【通用】数据权限.md", "【通用】数据权限", "/crm/permission/"], ["16.CRM手册/91.【通用】跟进记录、待办事项.md", "【通用】跟进记录、待办事项", "/crm/follow-up/"]]
                }, {
                    title: "AI大模型手册",
                    collapsable: !1,
                    children: [["17.AI大模型手册/01.AI 大模型演示.md", "AI 大模型演示", "/ai-preview"], ["17.AI大模型手册/02.功能开启.md", "功能开启", "/ai/build/"], ["17.AI大模型手册/11.AI 对话聊天.md", "AI 聊天对话", "/ai/chat/"], ["17.AI大模型手册/12.AI 绘画创作.md", "AI 绘画创作", "/ai/image"], ["17.AI大模型手册/13.AI 音乐创作.md", "AI 音乐创作", "/ai/music/"], ["17.AI大模型手册/14.AI 写作助手.md", "AI 写作助手", "/ai/write/"], ["17.AI大模型手册/15.AI 思维导图.md", "AI 思维导图", "/ai/mindmap/"], ["17.AI大模型手册/80.【模型接入】OpenAI.md", "【模型接入】OpenAI", "/ai/openai"], ["17.AI大模型手册/81.【模型接入】通义千问.md", "【模型接入】通义千问", "/ai/tongyi"], ["17.AI大模型手册/82.【模型接入】DeepSeek.md", "【模型接入】DeepSeek", "/ai/deep-seek"], ["17.AI大模型手册/83.【模型接入】字节豆包.md", "【模型接入】字节豆包", "/ai/doubao"], ["17.AI大模型手册/84.【模型接入】腾讯混元.md", "【模型接入】腾讯混元", "/ai/hunyuan"], ["17.AI大模型手册/85.【模型接入】硅基流动.md", "【模型接入】硅基流动", "/ai/siliconflow"], ["17.AI大模型手册/89.【模型接入】文心一言.md", "【模型接入】文心一言", "/ai/yiyan"], ["17.AI大模型手册/90.【模型接入】LLAMA.md", "【模型接入】LLAMA", "/ai/llama"], ["17.AI大模型手册/91.【模型接入】智谱 GLM.md", "【模型接入】智谱 GLM", "/ai/glm"], ["17.AI大模型手册/92.【模型接入】讯飞星火.md", "【模型接入】讯飞星火", "/ai/xinghuo"], ["17.AI大模型手册/93.【模型接入】微软 OpenAI.md", "【模型接入】微软 OpenAI", "/ai/azure-openai"], ["17.AI大模型手册/94.【模型接入】谷歌 Gemini.md", "【模型接入】谷歌 Gemini", "/ai/gemini"], ["17.AI大模型手册/95.【模型接入】Stable Diffusion.md", "【模型接入】Stable Diffusion", "/ai/stable-diffusion"], ["17.AI大模型手册/96.【模型接入】Midjourney.md", "【模型接入】Midjourney", "/ai/midjourney/"], ["17.AI大模型手册/97.【模型接入】Suno.md", "【模型接入】Suno", "/ai/suno/"]]
                }, {
                    title: "公众号手册",
                    collapsable: !1,
                    children: [["18.公众号手册/01.功能开启.md", "功能开启", "/mp/build"], ["18.公众号手册/02.公众号接入.md", "公众号接入", "/mp/account"], ["18.公众号手册/03.公众号粉丝.md", "公众号粉丝", "/mp/user"], ["18.公众号手册/04.公众号标签.md", "公众号标签", "/mp/tag"], ["18.公众号手册/05.公众号消息.md", "公众号消息", "/mp/message"], ["18.公众号手册/06.自动回复.md", "自动回复", "/mp/auto-reply"], ["18.公众号手册/07.公众号菜单.md", "公众号菜单", "/mp/menu"], ["18.公众号手册/08.公众号素材.md", "公众号素材", "/mp/material/"], ["18.公众号手册/09.公众号图文.md", "公众号图文", "/mp/article/"], ["18.公众号手册/10.公众号统计.md", "公众号统计", "/mp/statistics/"]]
                }, {
                    title: "系统手册",
                    collapsable: !1,
                    children: [["19.系统手册/40.短信配置.md", "短信配置", "/sms"], ["19.系统手册/41.邮件配置.md", "邮件配置", "/mail"], ["19.系统手册/42.站内信配置.md", "站内信配置", "/notify"], ["19.系统手册/45.数据脱敏.md", "数据脱敏、字段权限", "/desensitize"], ["19.系统手册/46.敏感词.md", "敏感词", "/sensitive-word"], ["19.系统手册/48.地区 & IP.md", "地区 & IP 库", "/area-and-ip/"]]
                }, {
                    title: "运维手册",
                    collapsable: !1,
                    children: [["20.运维手册/01.开发环境.md", "开发环境", "/dev-env"], ["20.运维手册/02.Linux 部署.md", "Linux 部署", "/deployment-linux"], ["20.运维手册/03.Docker 部署.md", "Docker 部署", "/deployment-docker"], ["20.运维手册/04.Jenkins 部署.md", "Jenkins 部署", "/deployment-jenkins"], ["20.运维手册/05.宝塔部署.md", "宝塔部署", "/deployment-baota"], ["20.运维手册/10.HTTPS 证书.md", "HTTPS 证书", "/https"], ["20.运维手册/11.服务监控.md", "服务监控", "/server-monitor"]]
                }, {
                    title: "前端手册 Vue 3.x",
                    collapsable: !1,
                    children: [["21.前端手册 Vue 3.x/01.开发规范.md", "开发规范", "/vue3/dev-spec"], ["21.前端手册 Vue 3.x/02.菜单路由.md", "菜单路由", "/vue3/route"], ["21.前端手册 Vue 3.x/03.Icon 图标.md", "Icon 图标", "/vue3/icon"], ["21.前端手册 Vue 3.x/04.字典数据.md", "字典数据", "/vue3/dict"], ["21.前端手册 Vue 3.x/05.系统组件.md", "系统组件", "/vue3/components"], ["21.前端手册 Vue 3.x/06.通用方法.md", "通用方法", "/vue3/util"], ["21.前端手册 Vue 3.x/07.配置读取.md", "配置读取", "/vue3/config-center"], ["21.前端手册 Vue 3.x/08.CRUD 组件.md", "CRUD 组件", "/vue3/crud-schema"], ["21.前端手册 Vue 3.x/09.国际化.md", "国际化", "/vue3/i18n"], ["21.前端手册 Vue 3.x/10.IDE 调试.md", "IDE 调试", "/vue3/debugger"], ["21.前端手册 Vue 3.x/11.代码格式化.md", "代码格式化", "/vue3/format"]]
                }, {
                    title: "前端手册 Vue 2.x",
                    collapsable: !1,
                    children: [["22.前端手册 Vue 2.x/01.开发规范.md", "开发规范", "/vue2/dev-spec"], ["22.前端手册 Vue 2.x/02.菜单路由.md", "菜单路由", "/vue2/route"], ["22.前端手册 Vue 2.x/03.Icon 图标.md", "Icon 图标", "/vue2/icon"], ["22.前端手册 Vue 2.x/04.字典数据.md", "字典数据", "/vue2/dict"], ["22.前端手册 Vue 2.x/05.系统组件.md", "系统组件", "/vue2/components"], ["22.前端手册 Vue 2.x/06.通用方法.md", "通用方法", "/vue2/util"], ["22.前端手册 Vue 2.x/07.配置读取.md", "配置读取", "/vue2/config-center"]]
                }, {
                    title: "更新日志",
                    collapsable: !1,
                    children: [["30.更新日志/69.【v2-4-2】开发中.md", "【v2.4.2】开发中", "/changelog/2.4.2/"], ["30.更新日志/70.【v2-4-1】2025-02-09.md", "【v2.4.1】2025-02-09", "/changelog/2.4.1/"], ["30.更新日志/71.【v2-4-0】2024-12-31.md", "【v2.4.0】2024-12-31", "/changelog/2.4.0/"], ["30.更新日志/72.【v2-3-0】2024-10-07.md", "【v2.3.0】2024-10-07", "/changelog/2.3.0/"], ["30.更新日志/73.【v2-2-0】2024-08-02.md", "【v2.2.0】2024-08-02", "/changelog/2.2.0/"], ["30.更新日志/74.【v2-1-0】2024-05-05.md", "【v2.1.0】2024-05-05", "/changelog/2.1.0/"], ["30.更新日志/75.【v2-0-1】2024-03-01.md", "【v2.0.1】2024-03-01", "/changelog/2.0.1/"], ["30.更新日志/76.【v2-0-0】2024-01-26.md", "【v2.0.0】2024-01-26", "/changelog/2.0.0/"]]
                }],
                catalogue: {},
                "/99.更新日志/": [["77.【v1-9-0】2023-11-30.md", "【v1.9.0】2023-12-01", "/changelog/1.9.0/"], ["78.【v1-8-3】2023-10-24.md", "【v1.8.3】2023-10-24", "/changelog/1.8.3/"], ["79.【v1-8-2】2023-09-24.md", "【v1.8.2】2023-09-24", "/changelog/1.8.2/"], ["80.【v1-8-1】2023-09-04.md", "【v1.8.1】2023-09-04", "/changelog/1.8.1/"], ["81.【v1-8-0】2023-07-27.md", "【v1.8.0】2023-07-27", "/changelog/1.8.0/"], ["82.【v1-7-3】2023-05-29.md", "【v1.7.3】2023-05-29", "/changelog/1.7.3/"], ["83.【v1-7-2】2023-04-19.md", "【v1.7.2】2023-04-19", "/changelog/1.7.2/"], ["84.【v1-7-1】2023-03-05.md", "【v1.7.1】2023-03-05", "/changelog/1.7.1/"], ["85.【v1-7-0】2023-01-30.md", "【v1.7.0】2023-01-30", "/changelog/1.7.0/"], ["86.【v-1-6-6】2023-01-05.md", "【v1.6.6】2023-01-05", "/changelog/1.6.6/"], ["87.【v1-6-5】2022-12-01.md", "【v1.6.5】2022-12-01", "/changelog/1.6.5/"], ["88.【v1-6-4】2022-08-22.md", "【v1.6.4】2022-08-22", "/changelog/1.6.4/"], ["89.【v1-6-3】2022-07-29.md", "【v1.6.3】2022-07-29", "/changelog/1.6.3/"], ["90.【v1-6-2】2022-06-05.md", "【v1.6.2】2022-06-05", "/changelog/1.6.2/"], ["91.【v1-6-1】2022-03-21.md", "【v1.6.1】2022-03-21", "/changelog/1.6.1/"], ["92.【v1-6-0】2022-03-10.md", "【v1.6.0】2022-03-10", "/changelog/1.6.0"], ["93.【v1-5-1】2022-02-28.md", "【v1.5.1】2022-02-28", "/changelog/1.5.1"], ["94.【v1-5-0】2022-02-17.md", "【v1.5.0】2022-02-17", "/changelog/1.5.0"], ["95.【v1-4-0】2022-02-04.md", "【v1.4.0】2022-02-04", "/changelog/1.4.0"], ["96.【v1-3-0】2022-01-24.md", "【v1.3.0】2022.01.24", "/changelog/1.3.0"], ["97.【v1-2-0】2021-12-15.md", "【v1.2.0】2021.12.15", "/changelog/1.2.0"], ["98.【v1-1-0】2021-10-25.md", "【v1.1.0】2021.10.25", "/changelog/1.1.0"], ["99.【v1-0-0】2021-05-03.md", "【v1.0.0】2021.05.03", "/changelog/1.0.0"]]
            },
            updateBar: {
                showToArticle: !1
            },
            category: !1,
            tag: !1,
            author: {
                name: "芋道源码",
                href: "https://www.iocoder.cn"
            },
            social: {
                icons: [{
                    iconClass: "icon-youjian",
                    title: "发邮件",
                    link: "mailto:7685413@qq.com"
                }, {
                    iconClass: "icon-github",
                    title: "GitHub",
                    link: "https://github.com/YunaiV"
                }, {
                    iconClass: "icon-erji",
                    title: "博客",
                    link: "https://www.iocoder.cn/?yudao"
                }]
            },
            footer: {
                createYear: 2019,
                copyrightInfo: "芋道源码 | MIT License"
            },
            htmlModules: {
                pageB: '\n  <div class="wwads-cn wwads-horizontal pageB" data-id="136" style="width:100%;max-height:80px;min-height:auto;"></div>\n  <style>\n    .pageB img{width:80px!important;}\n    .wwads-horizontal .wwads-text, .wwads-content .wwads-text{line-height:1;}\n  </style>\n  ',
                windowRB: '\n    <div class="wwads-cn wwads-vertical windowRB" data-id="136" style="max-width:160px;\n    min-width: auto;min-height:auto;"></div>\n    <style>\n      .windowRB{ padding: 0;}\n      .windowRB .wwads-img{margin-top: 10px;}\n      .windowRB .wwads-content{margin: 0 10px 10px 10px;}\n      .custom-html-window-rb .close-but{\n        display: none;\n      }\n    </style>\n  '
            }
        }
    };
    var Ts = t(94)
      , As = t(95)
      , xs = t(11);
    var Cs = {
        computed: {
            $filterPosts() {
                return this.$site.pages.filter(n => {
                    const {frontmatter: {pageComponent: e, article: t, home: a}} = n;
                    return !(e || !1 === t || !0 === a)
                }
                )
            },
            $sortPosts() {
                return (n = this.$filterPosts).sort( (n, e) => {
                    const t = n.frontmatter.sticky
                      , a = e.frontmatter.sticky;
                    return t && a ? t == a ? Object(xs.a)(n, e) : t - a : t && !a ? -1 : !t && a ? 1 : Object(xs.a)(n, e)
                }
                ),
                n;
                var n
            },
            $sortPostsByDate() {
                return (n = this.$filterPosts).sort( (n, e) => Object(xs.a)(n, e)),
                n;
                var n
            },
            $groupPosts() {
                return function(n) {
                    const e = {}
                      , t = {};
                    for (let a = 0, i = n.length; a < i; a++) {
                        const {frontmatter: {categories: i, tags: r}} = n[a];
                        "array" === Object(xs.n)(i) && i.forEach(t => {
                            t && (e[t] || (e[t] = []),
                            e[t].push(n[a]))
                        }
                        ),
                        "array" === Object(xs.n)(r) && r.forEach(e => {
                            e && (t[e] || (t[e] = []),
                            t[e].push(n[a]))
                        }
                        )
                    }
                    return {
                        categories: e,
                        tags: t
                    }
                }(this.$sortPosts)
            },
            $categoriesAndTags() {
                return function(n) {
                    const e = []
                      , t = [];
                    for (let t in n.categories)
                        e.push({
                            key: t,
                            length: n.categories[t].length
                        });
                    for (let e in n.tags)
                        t.push({
                            key: e,
                            length: n.tags[e].length
                        });
                    return {
                        categories: e,
                        tags: t
                    }
                }(this.$groupPosts)
            }
        }
    };
    Gt.component(Ts.default),
    Gt.component(As.default);
    function Ls(n) {
        return n.toString().padStart(2, "0")
    }
    t(243);
    Gt.component("Badge", () => Promise.all([t.e(0), t.e(3)]).then(t.bind(null, 565))),
    Gt.component("CodeBlock", () => Promise.resolve().then(t.bind(null, 94))),
    Gt.component("CodeGroup", () => Promise.resolve().then(t.bind(null, 95)));
    t(244);
    var Ns = [ ({Vue: n, options: e, router: t, siteData: a, isServer: i}) => {
        let r = "http://127.0.0.1:8080"
          , o = "http://127.0.0.1:9999";
        if (r = "https://cloud.iocoder.cn",
        o = "https://svip.iocoder.cn",
        !i) {
            (function() {
                const n = ["https://gitee.com/zhijiantianya/yudao-cloud", "https://gitee.com/zhijiantianya/ruoyi-vue-pro"]
                  , e = l();
                if (!e)
                    return n[0];
                const t = Cookies.get("repository");
                if (t)
                    return t;
                try {} finally {
                    $.get(o + "/app-api/monster/git-star/get", {
                        username: e,
                        repository: n[0],
                        t: (new Date).getTime()
                    }, (function(t) {
                        0 !== t.code || t.data ? $.get(o + "/app-api/monster/git-star/get", {
                            username: e,
                            repository: n[1],
                            t: (new Date).getTime()
                        }, (function(e) {
                            0 !== e.code || e.data ? Cookies.set("repository", n[0], {
                                expires: 1
                            }) : Cookies.set("repository", n[1], {
                                expires: 1
                            })
                        }
                        )) : Cookies.set("repository", n[0], {
                            expires: 1
                        })
                    }
                    ))
                }
            }
            )();
            if (setTimeout( () => {
                const n = new Date;
                $(".site-name").append(`（文档更新时间：${n.getFullYear()}-${n.getMonth() + 1}-${n.getDate()}）`)
            }
            , 1e3),
            -1 === location.host.indexOf("doc.iocoder.cn") && -1 === location.host.indexOf("localhost") && -1 === location.host.indexOf("127.0.0.1"))
                return void (location.href = "https://doc.iocoder.cn?origin=" + location.origin);
            function l() {
                return Cookies.get("username")
            }
            function s(n) {
                for (var e = window.location.search.substring(1).split("&"), t = 0; t < e.length; t++) {
                    var a = e[t].split("=");
                    if (a[0] == n)
                        return a[1]
                }
                return null
            }
             t.afterEach( () => {
            //     var e;
            //     e = function() {
            //         !function() {
            //             if (document.location.pathname.indexOf("/hello") >= 0)
            //                 return void $.get(o + "/zsxq/auth-url", {
            //                     host: document.location.host
            //                 }, (function(n) {
            //                     location.href = n
            //                 }
            //                 ));
            //             const e = s("app_id")
            //               , t = s("expire_time")
            //               , a = s("group_number")
            //               , i = s("join_time")
            //               , r = s("timestamp")
            //               , l = s("user_icon")
            //               , c = s("signature")
            //               , d = s("user_id")
            //               , u = s("user_name")
            //               , m = s("user_number")
            //               , p = s("user_role");
            //             c && $.get(o + "/zsxq/auth-callback", {
            //                 host: document.location.host,
            //                 appId: e,
            //                 expireTime: t,
            //                 groupNumber: a,
            //                 joinTime: i,
            //                 timestamp: r,
            //                 userIcon: decodeURIComponent(l),
            //                 signature: c,
            //                 userId: d,
            //                 userName: decodeURIComponent(u),
            //                 userNumber: m,
            //                 userRole: p
            //             }, (function(e) {
            //                 e ? (Cookies.set(n, c + "." + d, {
            //                     expires: 7,
            //                     path: "/"
            //                 }),
            //                 alert("验证通过，可阅读所有文档！建议抽空花 5 分钟认真阅读 https://articles.zsxq.com/id_c4fvndpw79uv.html 文档，了解更多 VIP 信息！")) : Cookies.remove(n)
            //             }
            //             ))
            //         }(),
            //         -1 !== location.host.indexOf("doc.iocoder.cn") || -1 !== location.host.indexOf("localhost") || -1 !== location.host.indexOf("127.0.0.1") ? function() {
            //             const n = location.pathname
            //               , e = ["/bpm/", "/user-center/", "/social-user/", "/oauth2/", "/saas-tenant/", "/sms/", "/mail/", "/notify/", "/mybatis-pro/", "/dynamic-datasource/", "/report/", "/Spring-Boot", "/Spring-Cloud", "/api-doc/", "/module-new/", "/new-feature/", "/dev-hot-swap/", "/file/", "/message-queue/", "/job/", "/idempotent/", "/distributed-lock/", "/rate-limiter/", "/http-sign/", "/project-rename/", "/delete-code/", "/resource-permission/", "/data-permission/", "/deployment-linux/", "/deployment-docker/", "/deployment-baota", "/mp/", "/mall/", "/pay/", "/crm/", "/member/", "/erp/", "/ai/", "/websocket/", "/vo/", "/system-log/"];
            //             for (const t of e)
            //                 if (n.indexOf(t) >= 0)
            //                     return !0;
            //             return e.indexOf(n) >= 0
            //         }() && function() {
            //             if (c())
            //                 return void function() {
            //                     const e = Cookies.get(n) || "";
            //                     e && $.get(o + "/zsxq/auth", {
            //                         host: document.location.host,
            //                         vip: e
            //                     }, (function(e) {
            //                         e || (Cookies.remove(n),
            //                         location.reload())
            //                     }
            //                     ))
            //                 }();
            //             try {
            //                 $(".content-wrapper").html('<div style="color: red;">仅 VIP 可见！</div>');
            //                 for (let n = 0; n < 2e3; n += 100)
            //                     setTimeout( () => {
            //                         $(".content-wrapper").html('<div style="color: red;">仅 VIP 可见！</div>')
            //                     }
            //                     , n)
            //             } catch (n) {
            //                 return void (location.href = "https://articles.zsxq.com/id_c4fvndpw79uv.html")
            //             }
            //             const e = (window.innerWidth - 640 - 10) / 2;
            //             let t = jqueryAlert({
            //                 title: "🚀 该文档仅「芋道快速开发平台 Boot + Cloud」星球 VIP 用户可见 🚀",
            //                 width: "640",
            //                 height: "640",
            //                 modal: !0,
            //                 bodyScroll: "true",
            //                 content: '<p style="text-align:left;font-size:15px">知识星球包括 ruoyi-vue-pro 和 yudao-cloud 两个项目:（详细介绍见右侧) </p>\n<p style="text-align:left;font-size:15px;"><strong style="color: #E9405A;">1. 视频教程</strong>: 用户认证、工作流、Web 组件、SaaS 多租户、数据权限等功能的教程\n\n<p style="text-align:left;font-size:15px;"><strong style="color: #E9405A;">2. 付费文档</strong>: 包括 RBAC 功能权限、数据权限、SaaS 多租户、SSO 单点登录、工作流、支付中心、商城中心、大屏报表、微信公众号、通知（短信、邮件、站内信）等数 100 篇的使用与设计文档\n\n<p style="text-align:left;font-size:15px;"><strong style="color: #E9405A;">3. 技术解答</strong>: 沉淀 12000+ 关于项目的技术问答与讨论，6 小时获得作者认真解答\n\n<p style="text-align:left;font-size:15px;"><strong style="color: #E9405A;">4. 技术专栏</strong>: 70 篇 Spring Boot、30 篇 Spring Cloud Alibaba 系统学习\n\n<img style="margin-top: 10px;" width="480" src="/img/视频教程/zsxq_win.png" />\n<p style="text-align:left;font-size:15px;margin-bottom:5px;"><strong>步骤 ①</strong>: [ 打开微信 ] -&gt; [ 扫描上方二维码 ] -&gt; [ <span style="color: #E9405A; ">加入知识星球</span> ]\n\n<p style="text-align:left;font-size:15px;margin-bottom:15px;"><strong>步骤 ②</strong>: [ 访问 <a href="https://articles.zsxq.com/id_c4fvndpw79uv.html" target="_blank">https://articles.zsxq.com/id_c4fvndpw79uv.html</a> 地址 ] -&gt; [ 搜索<span style="color: #E9405A; ">“文档码”</span> ]，点击后自动激活\n                </p>\n <div style="position: fixed; right: 0; bottom: 0; height: 100%; width: ' + e + 'px;">\n    <div style="overflow: hidden;">\n    </div>\n    <img src="/img/视频教程/视频大纲-竖.png" style="height: 100%; width: 100%; border: 0 none;" />\n    </div>\n    </div>',
            //                 buttons: {
            //                     "参考上述步骤操作！加入星球后，也可以点击【此处】激活": function() {
            //                         window.open(location.origin + "/hello/", "_blank")
            //                     }
            //                 }
            //             });
            //             const a = setInterval( () => {
            //                 c() && t && (t.close(),
            //                 location.reload(),
            //                 clearInterval(a))
            //             }
            //             , 1e3)
            //         }() : location.href = "https://doc.iocoder.cn?origin=" + location.origin
            //     }
            //     ,
                "complete" === document.readyState || "interactive" === document.readyState ? setTimeout(e, 1) : document.addEventListener("DOMContentLoaded", e),
                setTimeout( () => {
                    const n = document.querySelector(".pageB");
                    if (!n)
                        return;
                    const e = n.querySelector(".wwads-hide");
                    e && (e.onclick = () => {
                        n.style.display = "none"
                    }
                    ),
                    n.style.display = "flex"
                }
                 , 0)
             }
            );
            const n = "88974ed8-6aff-48ab-a7d1-4af5ffea88bb";
            function c() {
                const e = Cookies.get(n) || "";
                return e && e.length > 0
            }
        }
    }
    , ({Vue: n, options: e, router: t, siteData: a}) => {
        a.pages.map(n => {
            const {frontmatter: {date: e, author: t}} = n;
            "string" == typeof e && "Z" === e.charAt(e.length - 1) && (n.frontmatter.date = function(n) {
                n instanceof Date || (n = new Date(n));
                return `${n.getUTCFullYear()}-${Ls(n.getUTCMonth() + 1)}-${Ls(n.getUTCDate())} ${Ls(n.getUTCHours())}:${Ls(n.getUTCMinutes())}:${Ls(n.getUTCSeconds())}`
            }(e)),
            t ? n.author = t : a.themeConfig.author && (n.author = a.themeConfig.author)
        }
        ),
        n.mixin(Cs)
    }
    , {}, ({Vue: n}) => {
        n.mixin({
            computed: {
                $dataBlock() {
                    return this.$options.__data__block__
                }
            }
        })
    }
    , {}, {}, ({router: n}) => {
        "undefined" != typeof window && (window._hmt = window._hmt || [],
        function() {
            var n = document.createElement("script");
            n.src = "https://hm.baidu.com/hm.js?4d9f9fa20dc17ceda35728278660ac7b";
            var e = document.getElementsByTagName("script")[0];
            e.parentNode.insertBefore(n, e)
        }(),
        n.afterEach((function(n) {
            _hmt.push(["_trackPageview", n.fullPath])
        }
        )))
    }
    ]
      , Ms = [];
    class ks extends class {
        constructor() {
            this.store = new Gt({
                data: {
                    state: {}
                }
            })
        }
        $get(n) {
            return this.store.state[n]
        }
        $set(n, e) {
            Gt.set(this.store.state, n, e)
        }
        $emit(...n) {
            this.store.$emit(...n)
        }
        $on(...n) {
            this.store.$on(...n)
        }
    }
    {
    }
    Object.assign(ks.prototype, {
        getPageAsyncComponent: ll,
        getLayoutAsyncComponent: sl,
        getAsyncComponent: cl,
        getVueComponent: dl
    });
    var Os = {
        install(n) {
            const e = new ks;
            n.$vuepress = e,
            n.prototype.$vuepress = e
        }
    };
    function Is(n, e) {
        const t = e.toLowerCase();
        return n.options.routes.some(n => n.path.toLowerCase() === t)
    }
    var Ss = {
        props: {
            pageKey: String,
            slotKey: {
                type: String,
                default: "default"
            }
        },
        render(n) {
            const e = this.pageKey || this.$parent.$page.key;
            return ml("pageKey", e),
            Gt.component(e) || Gt.component(e, ll(e)),
            Gt.component(e) ? n(e) : n("")
        }
    }
      , Rs = {
        functional: !0,
        props: {
            slotKey: String,
            required: !0
        },
        render: (n, {props: e, slots: t}) => n("div", {
            class: ["content__" + e.slotKey]
        }, t()[e.slotKey])
    }
      , ws = {
        computed: {
            openInNewWindowTitle() {
                return this.$themeLocaleConfig.openNewWindowText || "(opens new window)"
            }
        }
    }
      , Us = (t(245),
    t(246),
    Object(bs.a)(ws, (function() {
        var n = this._self._c;
        return n("span", [n("svg", {
            staticClass: "icon outbound",
            attrs: {
                xmlns: "http://www.w3.org/2000/svg",
                "aria-hidden": "true",
                focusable: "false",
                x: "0px",
                y: "0px",
                viewBox: "0 0 100 100",
                width: "15",
                height: "15"
            }
        }, [n("path", {
            attrs: {
                fill: "currentColor",
                d: "M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"
            }
        }), this._v(" "), n("polygon", {
            attrs: {
                fill: "currentColor",
                points: "45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"
            }
        })]), this._v(" "), n("span", {
            staticClass: "sr-only"
        }, [this._v(this._s(this.openInNewWindowTitle))])])
    }
    ), [], !1, null, null, null).exports)
      , zs = {
        functional: !0,
        render(n, {parent: e, children: t}) {
            if (e._isMounted)
                return t;
            e.$once("hook:mounted", () => {
                e.$forceUpdate()
            }
            )
        }
    };
    Gt.config.productionTip = !1,
    Gt.use($o),
    Gt.use(Os),
    Gt.mixin(function(n, e, t=Gt) {
        !function(n) {
            n.locales && Object.keys(n.locales).forEach(e => {
                n.locales[e].path = e
            }
            );
            Object.freeze(n)
        }(e),
        t.$vuepress.$set("siteData", e);
        const a = new (n(t.$vuepress.$get("siteData")))
          , i = Object.getOwnPropertyDescriptors(Object.getPrototypeOf(a))
          , r = {};
        return Object.keys(i).reduce( (n, e) => (e.startsWith("$") && (n[e] = i[e].get),
        n), r),
        {
            computed: r
        }
    }(n => class {
        setPage(n) {
            this.__page = n
        }
        get $site() {
            return n
        }
        get $themeConfig() {
            return this.$site.themeConfig
        }
        get $frontmatter() {
            return this.$page.frontmatter
        }
        get $localeConfig() {
            const {locales: n={}} = this.$site;
            let e, t;
            for (const a in n)
                "/" === a ? t = n[a] : 0 === this.$page.path.indexOf(a) && (e = n[a]);
            return e || t || {}
        }
        get $siteTitle() {
            return this.$localeConfig.title || this.$site.title || ""
        }
        get $canonicalUrl() {
            const {canonicalUrl: n} = this.$page.frontmatter;
            return "string" == typeof n && n
        }
        get $title() {
            const n = this.$page
              , {metaTitle: e} = this.$page.frontmatter;
            if ("string" == typeof e)
                return e;
            const t = this.$siteTitle
              , a = n.frontmatter.home ? null : n.frontmatter.title || n.title;
            return t ? a ? a + " | " + t : t : a || "VuePress"
        }
        get $description() {
            const n = function(n) {
                if (n) {
                    const e = n.filter(n => "description" === n.name)[0];
                    if (e)
                        return e.content
                }
            }(this.$page.frontmatter.meta);
            return n || (this.$page.frontmatter.description || this.$localeConfig.description || this.$site.description || "")
        }
        get $lang() {
            return this.$page.frontmatter.lang || this.$localeConfig.lang || "en-US"
        }
        get $localePath() {
            return this.$localeConfig.path || "/"
        }
        get $themeLocaleConfig() {
            return (this.$site.themeConfig.locales || {})[this.$localePath] || {}
        }
        get $page() {
            return this.__page ? this.__page : function(n, e) {
                for (let t = 0; t < n.length; t++) {
                    const a = n[t];
                    if (a.path.toLowerCase() === e.toLowerCase())
                        return a
                }
                return {
                    path: "",
                    frontmatter: {}
                }
            }(this.$site.pages, this.$route.path)
        }
    }
    , ys)),
    Gt.component("Content", Ss),
    Gt.component("ContentSlotsDistributor", Rs),
    Gt.component("OutboundLink", Us),
    Gt.component("ClientOnly", zs),
    Gt.component("Layout", sl("Layout")),
    Gt.component("NotFound", sl("NotFound")),
    Gt.prototype.$withBase = function(n) {
        const e = this.$site.base;
        return "/" === n.charAt(0) ? e + n.slice(1) : n
    }
    ,
    window.__VUEPRESS__ = {
        version: "1.9.2",
        hash: ""
    },
    async function(n) {
        const e = "undefined" != typeof window && window.__VUEPRESS_ROUTER_BASE__ ? window.__VUEPRESS_ROUTER_BASE__ : ys.routerBase || ys.base
          , t = new $o({
            base: e,
            mode: "history",
            fallback: !1,
            routes: Es,
            scrollBehavior: (n, e, t) => t || (n.hash ? !Gt.$vuepress.$get("disableScrollBehavior") && {
                selector: decodeURIComponent(n.hash)
            } : {
                x: 0,
                y: 0
            })
        });
        !function(n) {
            n.beforeEach( (e, t, a) => {
                if (Is(n, e.path))
                    a();
                else if (/(\/|\.html)$/.test(e.path))
                    if (/\/$/.test(e.path)) {
                        const t = e.path.replace(/\/$/, "") + ".html";
                        Is(n, t) ? a(t) : a()
                    } else
                        a();
                else {
                    const t = e.path + "/"
                      , i = e.path + ".html";
                    Is(n, i) ? a(i) : Is(n, t) ? a(t) : a()
                }
            }
            )
        }(t);
        const a = {};
        try {
            await Promise.all(Ns.filter(n => "function" == typeof n).map(e => e({
                Vue: Gt,
                options: a,
                router: t,
                siteData: ys,
                isServer: n
            })))
        } catch (n) {
            console.error(n)
        }
        return {
            app: new Gt(Object.assign(a, {
                router: t,
                render: n => n("div", {
                    attrs: {
                        id: "app"
                    }
                }, [n("RouterView", {
                    ref: "layout"
                }), n("div", {
                    class: "global-ui"
                }, Ms.map(e => n(e)))])
            })),
            router: t
        }
    }(!1).then( ({app: n, router: e}) => {
        e.onReady( () => {
            n.$mount("#app")
        }
        )
    }
    )
}
]);
